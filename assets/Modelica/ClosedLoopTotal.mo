package Buildings "Library with models for building energy and control systems"

  package Airflow
  "Package to compute airflow and contaminant transport between rooms"
    extends Modelica.Icons.Package;

    package Multizone
    "Package with models for multizone airflow and contaminant transport"
      extends Modelica.Icons.VariantsPackage;

      model DoorDiscretizedOpen
      "Door model using discretization along height coordinate"
        extends Buildings.Airflow.Multizone.BaseClasses.DoorDiscretized;

    protected
        constant Real mFixed = 0.5 "Fixed value for flow coefficient";
        constant Real gamma(min=1) = 1.5
        "Normalized flow rate where dphi(0)/dpi intersects phi(1)";
        constant Real a = gamma
        "Polynomial coefficient for regularized implementation of flow resistance";
        constant Real b = 1/8*mFixed^2 - 3*gamma - 3/2*mFixed + 35.0/8
        "Polynomial coefficient for regularized implementation of flow resistance";
        constant Real c = -1/4*mFixed^2 + 3*gamma + 5/2*mFixed - 21.0/4
        "Polynomial coefficient for regularized implementation of flow resistance";
        constant Real d = 1/8*mFixed^2 - gamma - mFixed + 15.0/8
        "Polynomial coefficient for regularized implementation of flow resistance";
      equation
        m=mFixed;
        A = wOpe*hOpe;
        kVal = CD*dA*sqrt(2/rho_nominal);
        // orifice equation
        for i in 1:nCom loop
          dV_flow[i] = Buildings.Airflow.Multizone.BaseClasses.powerLawFixedM(
            k=kVal,
            dp=dpAB[i],
            m=mFixed,
            a=a,
            b=b,
            c=c,
            d=d,
            dp_turbulent=dp_turbulent);
        end for;

        annotation (Diagram(graphics),
                             Icon(graphics),
      defaultComponentName="doo",
      Documentation(info="<html>
<p>
This model describes the bi-directional air flow through an open door.
</p>
<p>
To compute the bi-directional flow, 
the door is discretize along the height coordinate. 
An orifice equation is used to compute the flow for each compartment.
</p>
<p>
In this model, the door is always open.
Use the model 
<a href=\"modelica://Buildings.Airflow.Multizone.DoorDiscretizedOperable\">
Buildings.Airflow.Multizone.DoorDiscretizedOperable</a>
for a door that can either be open or closed.
</p>
</html>",
      revisions="<html>
<ul>
<li><i>December 6, 2011</i> by Michael Wetter:<br>
       Changed the computation of the discharge coefficient to use the 
       nominal density instead of the actual density. 
       Computing <code>sqrt(2/rho)</code> sometimes causes warnings from the solver,
       as it seems to try negative values for the density during iterative solutions.
</li>
<li><i>August 12, 2011</i> by Michael Wetter:<br>
       Changed model to use the new function 
       <a href=\"modelica://Buildings.Airflow.Multizone.BaseClasses.powerLawFixedM\">
       Buildings.Airflow.Multizone.BaseClasses.powerLawFixedM</a>.
</li>
<li><i>July 20, 2010</i> by Michael Wetter:<br>
       Migrated model to Modelica 3.1 and integrated it into the Buildings library.
</li>
<li><i>February 10, 2005</i> by Michael Wetter:<br>
       Released first version.
</ul>
</html>"));
      end DoorDiscretizedOpen;

      model Orifice "Orifice"
        extends Buildings.Airflow.Multizone.BaseClasses.PowerLawResistance(m=0.5,
          k = CD * A * sqrt(2.0/rho_nominal));

        parameter Real CD=0.65 "|Orifice characteristics|Discharge coefficient";

        annotation (Diagram(graphics),
                             Icon(graphics={
              Rectangle(
                extent={{-100,8},{100,-8}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,127,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-20,100},{20,20}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-20,-20},{20,-100}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{24,-24},{96,-100}},
                lineColor={0,0,255},
                fillColor={0,127,0},
                fillPattern=FillPattern.Solid,
                textString="A=%A")}),
      defaultComponentName="ori",
      Documentation(info="<html>
<p>
This model describes the mass flow rate and pressure difference relation
of an orifice in the form
<PRE>
    V_flow = k * dp^m,
</PRE>
where <code>k</code> is a variable and
<code>m</code> a parameter. For turbulent flow, set <code>m=1/2</code> and
for laminar flow, set <code>m=1</code>. 
Large openings are characterized by values close to <code>0.5</code>,
while values near <code>0.65</code> have been found for small
crack-like openings (Dols and Walton, 2002).

<h4>References</h4>
<UL>
<LI>
W. Stuart Dols and George N. Walton, <I>CONTAMW 2.0 User Manual,
Multizone Airflow and Contaminant Transport Analysis Software</I>,
Building and Fire Research Laboratory,
National Institute of Standards and Technology,
Tech. Report NISTIR 6921,
November, 2002.
</UL>
</html>",
      revisions="<html>
<ul>
<li><i>December 6, 2011</i> by Michael Wetter:<br>
       Replaced <code>rho</code> with <code>rho_nominal</code> because
       <code>rho</code> is computed in an <code>equation</code> section and not
       in the <code>initial equation</code> section.
</li>
<li><i>July 20, 2010</i> by Michael Wetter:<br>
       Migrated model to Modelica 3.1 and integrated it into the Buildings library.
</li>
<li><i>February 4, 2005</i> by Michael Wetter:<br>
       Released first version.
</ul>
</html>"));
      end Orifice;

      package BaseClasses
      "Package with base classes for Buildings.Airflow.Multizone"
        extends Modelica.Icons.BasesPackage;

        partial model DoorDiscretized
        "Door model using discretization along height coordinate"
          extends
          Buildings.Airflow.Multizone.BaseClasses.TwoWayFlowElementBuoyancy;

          parameter Integer nCom=10
          "Number of compartments for the discretization";

          parameter Modelica.SIunits.Pressure dp_turbulent(min=0) = 0.01
          "Pressure difference where laminar and turbulent flow relation coincide. Recommended: 0.01";
          parameter Real CD=0.65
          "|Orifice characteristics|Discharge coefficient";

          Modelica.SIunits.Pressure dpAB[nCom](nominal=1)
          "Pressure difference between compartments";
          Modelica.SIunits.Velocity v[nCom](nominal=0.01)
          "Velocity in compartment from A to B";
          Modelica.SIunits.Velocity vTop
          "Velocity at top of opening from A to B";
          Modelica.SIunits.Velocity vBot
          "Velocity at bottom of opening from A to B";

      protected
          parameter Modelica.SIunits.Length dh=hOpe/nCom
          "Height of each compartment";
          Modelica.SIunits.AbsolutePressure pA[nCom](nominal=101325)
          "Pressure in compartments of room A";
          Modelica.SIunits.AbsolutePressure pB[nCom](nominal=101325)
          "Pressure in compartments of room B";

          Modelica.SIunits.VolumeFlowRate dV_flow[nCom]
          "Volume flow rate through compartment from A to B";
          Modelica.SIunits.VolumeFlowRate dVAB_flow[nCom]
          "Volume flow rate through compartment from A to B if positive";
          Modelica.SIunits.VolumeFlowRate dVBA_flow[nCom]
          "Volume flow rate through compartment from B to A if positive";

          Real m(min=0.5, max=1)
          "Flow exponent, m=0.5 for turbulent, m=1 for laminar";
          Real kVal "Flow coefficient for each compartment, k = V_flow/ dp^m";
          Modelica.SIunits.Area dA "Compartment area";

        //  Modelica.SIunits.Density rhoAve "Average air density";
          parameter Medium.ThermodynamicState sta0=Medium.setState_pTX(
              T=Medium.T_default,
              p=Medium.p_default,
              X=Medium.X_default);
          parameter Modelica.SIunits.Density rho_nominal=Medium.density(sta0)
          "Density, used to compute fluid volume";
        equation
          dA = A/nCom;
        //  rhoAve = (rho_a1_inflow + rho_a2_inflow)/2;

          for i in 1:nCom loop
            // pressure drop in each compartment
            pA[i] = port_a1.p + rho_a1_inflow*Modelica.Constants.g_n*(hA - (i - 0.5)*dh);
            pB[i] = port_a2.p + rho_a2_inflow*Modelica.Constants.g_n*(hB - (i - 0.5)*dh);
            dpAB[i] = pA[i] - pB[i];
            v[i] = dV_flow[i]/dA;
            // assignment of net volume flows
            dVAB_flow[i] = dV_flow[i]*
              Buildings.Utilities.Math.Functions.smoothHeaviside(x=dV_flow[i], delta=
              VZer_flow/nCom) + VZer_flow/nCom;
            dVBA_flow[i] = -dV_flow[i] + dVAB_flow[i] + 2*VZer_flow/nCom;
          end for;
          // add positive and negative flows
          VAB_flow = ones(nCom)*dVAB_flow;
          VBA_flow = ones(nCom)*dVBA_flow;
          vTop = v[nCom];
          vBot = v[1];
          annotation (
            Diagram(graphics),
            Icon(graphics={
                Rectangle(
                  extent={{-60,80},{60,-84}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={85,75,55},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-54,72},{56,-84}},
                  lineColor={0,0,0},
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{56,72},{-36,66},{-36,-90},{56,-84},{56,72}},
                  lineColor={0,0,0},
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-30,-10},{-16,-8},{-16,-14},{-30,-16},{-30,-10}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid)}),
            Documentation(info="<html>
<p>
This is a partial model for the bi-directional air flow through a door.
</p>
<p>
To compute the bi-directional flow, 
the door is discretize along the height coordinate, and uses
an orifice equation to compute the flow for each compartment.
</p>
<p>
The compartment area <code>dA</code> is a variable, which allows
using the model for a door that can be open or closed.
</p>
</html>",
        revisions="<html>
<ul>
<li><i>December 6, 2011</i> by Michael Wetter:<br>
       Removed protected variable <code>rhoAve</code>.
</li>
<li><i>August 12, 2011</i> by Michael Wetter:<br>
       Changed model to use the new function 
       <a href=\"modelica://Buildings.Airflow.Multizone.BaseClasses.powerLawFixedM\">
       Buildings.Airflow.Multizone.BaseClasses.powerLawFixedM</a>.
</li>
<li><i>July 20, 2010</i> by Michael Wetter:<br>
       Migrated model to Modelica 3.1 and integrated it into the Buildings library.
</li>
<li><i>February 8, 2005</i> by Michael Wetter:<br>
       Released first version.
</ul>
</html>"));
        end DoorDiscretized;

        partial model PowerLawResistance
        "Flow resistance that uses the power law"
          extends Buildings.Fluid.Interfaces.PartialTwoPortInterface(final
              m_flow_nominal=rho_nominal*k*dp_turbulent, final show_V_flow=true,
              final show_T=true);
          extends Buildings.Airflow.Multizone.BaseClasses.ErrorControl;

          parameter Modelica.SIunits.Area A
          "|Orifice characteristics|Area of orifice";

          parameter Real m(min=0.5, max=1)
          "Flow exponent, m=0.5 for turbulent, m=1 for laminar";
          parameter Boolean useConstantDensity=true
          "Set to false to use density based on state (as implemented by the Medium model)"
            annotation (Evaluate=true);
          Modelica.SIunits.Density rho "Fluid density at port_a";
          parameter Modelica.SIunits.Pressure dp_turbulent(min=0, displayUnit="Pa") = 0.1
          "Pressure difference where laminar and turbulent flow relation coincide. Recommended = 0.1";
          Modelica.SIunits.Velocity v(nominal=1) "Average velocity";
          parameter Modelica.SIunits.Length lWet=sqrt(A)
          "Wetted perimeter used for Reynolds number calculation";
          Real Re "Reynolds number";

      protected
          parameter Real k "Flow coefficient, k = V_flow/ dp^m";

          parameter Medium.ThermodynamicState sta0=Medium.setState_pTX(
              T=Medium.T_default,
              p=Medium.p_default,
              X=Medium.X_default);
          parameter Modelica.SIunits.Density rho_nominal=Medium.density(sta0)
          "Density, used to compute fluid volume";

          constant Real gamma(min=1) = 1.5
          "Normalized flow rate where dphi(0)/dpi intersects phi(1)";
          parameter Real a = gamma
          "Polynomial coefficient for regularized implementation of flow resistance";
          parameter Real b = 1/8*m^2 - 3*gamma - 3/2*m + 35.0/8
          "Polynomial coefficient for regularized implementation of flow resistance";
          parameter Real c = -1/4*m^2 + 3*gamma + 5/2*m - 21.0/4
          "Polynomial coefficient for regularized implementation of flow resistance";
          parameter Real d = 1/8*m^2 - gamma - m + 15.0/8
          "Polynomial coefficient for regularized implementation of flow resistance";

          Modelica.SIunits.DynamicViscosity dynVis "Dynamic viscosity";

          Modelica.SIunits.Mass mExc(start=0)
          "Air mass exchanged (for purpose of error control only)";

        equation
          if forceErrorControlOnFlow then
            der(mExc) = port_a.m_flow;
          else
            der(mExc) = 0;
          end if;

          rho = if useConstantDensity then rho_nominal else Medium.density(sta_a);
          dynVis = Medium.dynamicViscosity(sta_a);
          port_a.m_flow = rho*Buildings.Airflow.Multizone.BaseClasses.powerLawFixedM(
            k=k,
            dp=dp,
            m=m,
            a=a,
            b=b,
            c=c,
            d=d,
            dp_turbulent=dp_turbulent);
          v = V_flow/A;
          Re = v*lWet*rho/dynVis;

          // Isenthalpic state transformation (no storage and no loss of energy)
          port_a.h_outflow = inStream(port_b.h_outflow);
          port_b.h_outflow = inStream(port_a.h_outflow);

          // Mass balance (no storage)
          port_a.m_flow + port_b.m_flow = 0;

          // Transport of substances
          port_a.Xi_outflow = inStream(port_b.Xi_outflow);
          port_b.Xi_outflow = inStream(port_a.Xi_outflow);

          port_a.C_outflow = inStream(port_b.C_outflow);
          port_b.C_outflow = inStream(port_a.C_outflow);
          annotation (
            Diagram(graphics),
            Icon(graphics),
            Documentation(info="<html>
<p>
This model describes the mass flow rate and pressure difference relation
of an orifice in the form
<PRE>
    V_flow = k * dp^m,
</PRE>
where <code>k</code> is a variable and
<code>m</code> a parameter.
For turbulent flow, set <code>m=1/2</code> and
for laminar flow, set <code>m=1</code>. 
<P>
The model is used as a base for the interzonal air flow models.
</html>",
        revisions="<html>
<ul>
<li><i>December 6, 2011</i> by Michael Wetter:<br>
       Removed <code>fixed=false</code> attribute of protected parameter
       <code>k</code>.
</li>
<li><i>July 20, 2010</i> by Michael Wetter:<br>
       Migrated model to Modelica 3.1 and integrated it into the Buildings library.
</li>
<li><i>February 4, 2005</i> by Michael Wetter:<br>
       Released first version.
</ul>
</html>"));
        end PowerLawResistance;

        partial model TwoWayFlowElement
        "Flow resistance that uses the power law"
          extends Buildings.Fluid.Interfaces.PartialFourPortInterface(
            redeclare final package Medium1 = Medium,
            redeclare final package Medium2 = Medium,
            final allowFlowReversal1=false,
            final allowFlowReversal2=false,
            final m1_flow_nominal=10/3600*1.2,
            final m2_flow_nominal=m1_flow_nominal);
          extends Buildings.Airflow.Multizone.BaseClasses.ErrorControl;

          replaceable package Medium = Modelica.Media.Interfaces.PartialMedium
            annotation (choicesAllMatching=true);

          Modelica.SIunits.VolumeFlowRate VAB_flow(nominal=0.001)
          "Volume flow rate from A to B if positive";
          Modelica.SIunits.VolumeFlowRate VBA_flow(nominal=0.001)
          "Volume flow rate from B to A if positive";
          Modelica.SIunits.MassFlowRate mAB_flow(nominal=0.001)
          "Mass flow rate from A to B if positive";
          Modelica.SIunits.MassFlowRate mBA_flow(nominal=0.001)
          "Mass flow rate from B to A if positive";

          Modelica.SIunits.Velocity vAB(nominal=0.01)
          "Average velocity from A to B";
          Modelica.SIunits.Velocity vBA(nominal=0.01)
          "Average velocity from B to A";

          Modelica.SIunits.Density rho_a1_inflow(start=1.2)
          "Density of air flowing in from port_a1";
          Modelica.SIunits.Density rho_a2_inflow(start=1.2)
          "Density of air flowing in from port_a2";

          Modelica.SIunits.Area A "Face area";

          parameter Modelica.SIunits.Velocity vZer=0.001
          "Minimum velocity to prevent zero flow. Recommended: 0.001";
      protected
          Modelica.SIunits.VolumeFlowRate VZer_flow(fixed=false)
          "Minimum net volume flow rate to prevent zero flow";
      protected
          Modelica.SIunits.Mass mExcAB(start=0)
          "Air mass exchanged (for purpose of error control only)";
          Modelica.SIunits.Mass mExcBA(start=0)
          "Air mass exchanged (for purpose of error control only)";

        equation
          // enforcing error control on both direction rather than on the sum only
          // gives higher robustness. The reason may be that for bi-directional flow,
          // (VAB_flow - VBA_flow) may be close to zero.
          if forceErrorControlOnFlow then
            der(mExcAB) = mAB_flow;
            der(mExcBA) = mBA_flow;
          else
            der(mExcAB) = 0;
            der(mExcBA) = 0;
          end if;
          rho_a1_inflow = Medium.density(state_a1_inflow);
          rho_a2_inflow = Medium.density(state_a2_inflow);
          VZer_flow = vZer*A;

          mAB_flow = rho_a1_inflow*VAB_flow;
          mBA_flow = rho_a2_inflow*VBA_flow;
          // Average velocity (using the whole orifice area)
          vAB = VAB_flow/A;
          vBA = VBA_flow/A;

          port_a1.m_flow = mAB_flow;
          port_a2.m_flow = mBA_flow;

          // Energy balance (no storage, no heat loss/gain)
          port_a1.h_outflow = inStream(port_b1.h_outflow);
          port_b1.h_outflow = inStream(port_a1.h_outflow);
          port_a2.h_outflow = inStream(port_b2.h_outflow);
          port_b2.h_outflow = inStream(port_a2.h_outflow);

          // Mass balance (no storage)
          port_a1.m_flow = -port_b1.m_flow;
          port_a2.m_flow = -port_b2.m_flow;

          port_a1.Xi_outflow = inStream(port_b1.Xi_outflow);
          port_b1.Xi_outflow = inStream(port_a1.Xi_outflow);
          port_a2.Xi_outflow = inStream(port_b2.Xi_outflow);
          port_b2.Xi_outflow = inStream(port_a2.Xi_outflow);

          // Transport of trace substances
          port_a1.C_outflow = inStream(port_b1.C_outflow);
          port_b1.C_outflow = inStream(port_a1.C_outflow);
          port_a2.C_outflow = inStream(port_b2.C_outflow);
          port_b2.C_outflow = inStream(port_a2.C_outflow);

          annotation (
            Diagram(graphics),
            Icon(graphics={Rectangle(
                  extent={{-100,100},{100,-100}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None)}),
            Documentation(info="<html>
<p>
This is a partial model for models that describe the bi-directional
air flow through large openings.
<P>
Models that extend this model need to compute 
<code>mAB_flow</code> and <code>mBA_flow</code>,
or alternatively <code>VAB_flow</code> and <code>VBA_flow</code>,
and the face area <code>area</code>.
The face area is a variable to allow this partial model to be used
for doors that can be open or closed as a function of an input signal.
</html>",
        revisions="<html>
<ul>
<li><i>July 20, 2010</i> by Michael Wetter:<br>
       Migrated model to Modelica 3.1 and integrated it into the Buildings library.
</li>
<li><i>February 4, 2005</i> by Michael Wetter:<br>
       Released first version.
</ul>
</html>"));
        end TwoWayFlowElement;

        partial model TwoWayFlowElementBuoyancy
        "Flow resistance that uses the power law"
          extends Buildings.Airflow.Multizone.BaseClasses.TwoWayFlowElement;

          parameter Modelica.SIunits.Length wOpe=0.9
          "|Geometry|Width of opening";
          parameter Modelica.SIunits.Length hOpe=2.1
          "|Geometry|Height of opening";

          parameter Modelica.SIunits.Length hA=2.7/2
          "|Geometry|Height of reference pressure zone A";
          parameter Modelica.SIunits.Length hB=2.7/2
          "|Geometry|Height of reference pressure zone B";

          annotation (Diagram(graphics),
                               Icon(graphics),
        Documentation(info="<html>
<p>
This is a partial model for models that describe the bi-directional
air flow through large openings.
<P>
Models that extend this model need to compute 
<code>mAB_flow</code> and <code>mBA_flow</code>,
or alternatively <code>VAB_flow</code> and <code>VBA_flow</code>,
and the face area <code>area</code>.
The face area is a variable to allow this partial model to be used
for doors that can be open or closed as a function of an input signal.
</html>",
        revisions="<html>
<ul>
<li><i>July 20, 2010</i> by Michael Wetter:<br>
       Migrated model to Modelica 3.1 and integrated it into the Buildings library.
</li>
<li><i>February 4, 2005</i> by Michael Wetter:<br>
       Released first version.
</ul>
</html>"));
        end TwoWayFlowElementBuoyancy;

        model ErrorControl
        "Interface that defines parameters for error control"
          parameter Boolean forceErrorControlOnFlow = true
          "Flag to force error control on m_flow. Set to true if interested in flow rate";
          annotation (Diagram(graphics),
                               Icon(graphics),
        Documentation(info="<html>
<p>
This is an interface that defines parameters used for error control.
<p>
Dymola does error control on state variables, such as temperature, pressure and 
species concentration.
Flow variables such as <code>m_flow</code> are typically not checked during the error control. 
This can give large errors in flow variables, as long as the error on the volume's state variables
that are coupled to the flow variables is small. 
Obtaining accurate flow variables can be achieved by imposing an error control
on the exchanged mass, which can be defined as 
<pre>
  dm/dt = m_flow.
</pre>
By setting <code>enforceErrorControlOnFlow = true</code>, such an equation is imposed
by models that extend this class.
</html>",
        revisions="<html>
<ul>
<li><i>July 20, 2010</i> by Michael Wetter:<br>
       Integrated model into the Buildings library.
</li>
<li><i>November 1, 2005</i> by Michael Wetter:<br>
       Released first version.
</ul>
</html>"));
        end ErrorControl;

        function powerLawFixedM
        "Power law used in orifice equations when m is constant"
          input Real k "Flow coefficient, k = V_flow/ dp^m";
          input Modelica.SIunits.Pressure dp "Pressure difference";
          input Real m(min=0.5, max=1)
          "Flow exponent, m=0.5 for turbulent, m=1 for laminar";
          input Real a "Polynomial coefficient";
          input Real b "Polynomial coefficient";
          input Real c "Polynomial coefficient";
          input Real d "Polynomial coefficient";
          input Modelica.SIunits.Pressure dp_turbulent(min=0)=0.001
          "Pressure difference where regularization starts";
          output Modelica.SIunits.VolumeFlowRate V_flow "Volume flow rate";
      protected
          constant Real gamma(min=1) = 1.5
          "Normalized flow rate where dphi(0)/dpi intersects phi(1)";
          Real pi "Normalized pressure";
          Real pi2 "Square of normalized pressure";
        algorithm
         if (dp >= dp_turbulent) then
           V_flow := k*dp^m;
         elseif (dp <= -dp_turbulent) then
           V_flow :=-k*(-dp)^m;
         else
           pi  := dp/dp_turbulent;
           pi2 := pi*pi;
           V_flow := k*dp_turbulent^m * pi * ( a + pi2 * ( b + pi2 * ( c + pi2 * d)));
         end if;

          annotation (smoothOrder=2,
        Documentation(info="<html>
<p>
This model describes the mass flow rate and pressure difference relation
of an orifice in the form
<p align=\"center\" style=\"font-style:italic;\">
  V = k sign(&Delta;p) |&Delta;p|<sup>m</sup>
</p>
where 
<i>V</i> is the volume flow rate,
<i>k &gt; 0</i> is a flow coefficient
<i>&Delta; p</i> is the pressure drop and
<i>m &isin; [0.5, 1]</i> is a flow coefficient.
The equation is regularized for 
<i>|&Delta;p| &lt; &Delta;p<sub>t</sub></i>, where
<i>&Delta;p<sub>t</sub></i> is a parameter.
For turbulent flow, set <i>m=1 &frasl; 2</i> and
for laminar flow, set <i>m=1</i>. 
</p>
<p>
The model is used for the interzonal air flow models.
It is identical to
<a href=\"modelica://Buildings.Airflow.Multizone.BaseClasses.powerLaw\">
Buildings.Airflow.Multizone.BaseClasses.powerLaw</a> but it
requires the polynomial coefficients as an input.
This allows a more efficient simulation if <i>m</i> and therefore also
<i>a</i>, <i>b</i>, <i>c</i> and <i>d</i> are constant.
</p>
<h4>Implementation</h4>
<p>
For <i>|&Delta;p| &lt; &Delta;p<sub>t</sub></i>, the equation is regularized
so that it is twice continuously differentiable in <i>&Delta;p</i>, and that it
has an infinite number of continuous derivatives in <i>m</i> and in <i>k</i>.
</p>
<p>
If <i>m</i>, and therefore also
<i>a</i>, <i>b</i>, <i>c</i> and <i>d</i>, change with time, then
it is more convenient and efficient to use
<a href=\"modelica://Buildings.Airflow.Multizone.BaseClasses.powerLaw\">
Buildings.Airflow.Multizone.BaseClasses.powerLaw</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
<i>August 12, 2011</i> by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end powerLawFixedM;

        function windPressureLowRise
        "Wind pressure coefficient for low-rise buildings"
          input Real Cp0(min=0)
          "Wind pressure coefficient for normal wind incidence angle";
          input Modelica.SIunits.Angle incAng
          "Wind incidence angle (0: normal to wall)";
          input Real G "Natural logarithm of side ratio";
          output Real Cp "Wind pressure coefficient";
      protected
          Modelica.SIunits.Angle aR "alpha, restricted to 0...pi";
          Modelica.SIunits.Angle incAng2 "0.5*wind incidence angle";
          Real sinA2 "=sin(alpha/2)";
          Real cosA2 "=cos(alpha/2)";
          Real a "Attenuation factor";
          constant Modelica.SIunits.Angle pi2 = 2*Modelica.Constants.pi;
          constant Modelica.SIunits.Angle aRDel = 5*Modelica.Constants.pi/180
          "Lower bound where transition occurs";
          constant Modelica.SIunits.Angle aRDel2 = aRDel/2
          "Half-width of transition interval";
          constant Modelica.SIunits.Angle aRMax = 175*Modelica.Constants.pi/180
          "Upper bound where transition occurs";
          constant Real a180 = Modelica.Math.log(1.248 - 0.703 +
              0.131*Modelica.Math.sin(2*Modelica.Constants.pi*G)^3
              + 0.071*G^2) "Attenuation factor at 180 degree incidence angle";
        algorithm
          // Restrict incAng to [0...pi]

          // Change sign to positive
          aR := if incAng < 0 then -incAng else incAng;
          // Constrain to [0...2*pi]
          if aR > pi2 then
            aR := aR - integer(aR/pi2)*pi2;
          end if;
          // Constrain to [0...pi]
          if aR > Modelica.Constants.pi then
            aR := pi2-aR;
          end if;

          // Evaluate eqn. 2-1 from FSEC-CR-163-86
          incAng2 :=aR/2;
          sinA2 :=Modelica.Math.sin(incAng2);
          cosA2 :=Modelica.Math.cos(incAng2);
          // Implementation of the wind pressure coefficient that is once
          // continuously differentiable for all incidence angles
          if aR < aRDel then
            Cp :=Cp0*Buildings.Utilities.Math.Functions.spliceFunction(
                pos=  Modelica.Math.log(1.248 - 0.703*sinA2 - 1.175*Modelica.Math.sin(aR)^2 +
                0.131*Modelica.Math.sin(2*aR*G)^3 + 0.769*cosA2 + 0.071*G^2*sinA2^2 + 0.717*cosA2^2),
                neg=1,
                x=aR-aRDel2,
                deltax=aRDel2);
          elseif aR > aRMax then
            Cp := Cp0*Buildings.Utilities.Math.Functions.spliceFunction(
                pos=  a180,
                neg=Modelica.Math.log(1.248 - 0.703*sinA2 - 1.175*Modelica.Math.sin(aR)^2 +
                0.131*Modelica.Math.sin(2*aR*G)^3 + 0.769*cosA2 + 0.071*G^2*sinA2^2 + 0.717*cosA2^2),
                x=aR+aRDel2-Modelica.Constants.pi,
                deltax=aRDel2);
          else
            Cp :=Cp0*Modelica.Math.log(1.248 - 0.703*sinA2 - 1.175*Modelica.Math.sin(aR)^2 +
              0.131*Modelica.Math.sin(2*aR*G)^3 + 0.769*cosA2 + 0.071*G^2*sinA2^2 + 0.717*cosA2^2);
          end if;
        annotation (
        smoothOrder=1,
        Documentation(info="<html>
<p>
This function computes the wind pressure coefficient for
low-rise buildings with rectangular shape.
The correlation is the data fit from Swami and Chandra (1987),
who fitted a function to various wind pressure coefficients from the literature.
The same correlation is also implemented in CONTAM (Persily and Ivy, 2001).
</p>
<p>
The wind pressure coefficient is computed based on the 
natural logarithm of the side ratio of the walls, which is defined as
</p>
<p align=\"center\" style=\"font-style:italic;\">
G = ln(x &frasl; y)
</p>
<p>
where <i>x</i> is the length of the wall that will be connected to 
this model, and <i>y</i> is the length of the adjacent wall as shown
in the figure below.
</p>
<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Airflow/Multizone/BaseClasses/windPressureLowRise.png\" border=\"1\">
</p>
<p>
Based on the wind incidence angle <i>&alpha;</i> and the side ratio
of the walls, the model computes how much the wind pressure
is attenuated compared to the reference wind pressure <code>Cp0</code>.
The reference wind pressure <code>Cp0</code> is a user-defined parameter,
and must be equal to the wind pressure at zero wind incidence angle, i.e., 
<i>&alpha; = 0</i>.
Swami and Chandra (1987) recommend <i>C<sub>p0</sub> = 0.6</i> for
all low-rise buildings as this represents the average of 
various values reported in the literature.
The attenuation factor is
<p align=\"center\" style=\"font-style:italic;\">
C<sub>p</sub> &frasl; C<sub>p0</sub> = ln(1.248 - 0.703 sin(&alpha; &frasl; 2)
      - 1.175 sin<sup>2</sup>(&alpha;)
      - 0.131 sin<sup>3</sup>(2 &alpha; G)
      + 0.769 cos(&alpha; &frasl; 2)
       +0.071 G<sup>2</sup> * sin<sup>2</sup>(&alpha; &frasl; 2)
       + 0.717 cos<sup>2</sup>(&alpha; &frasl; 2)),
</p>
where 
<i>C<sub>p</sub></i> is the wind pressure coefficient for
the current angle of incidence.
<p>
This function is used in
<a href=\"modelica://Buildings.Fluid.Sources.Outside_CpLowRise\">
Buildings.Fluid.Sources.Outside_CpLowRise</a>
which can be used directly with components of this package.
</p>
<p>
<h4>References</h4>
<p>
<ul>
<li>
Muthusamy V. Swami and
Subrato Chandra.
<i>
<a href=\"http://www.fsec.ucf.edu/en/publications/pdf/FSEC-CR-163-86.pdf\">
Procedures for
Calculating Natural
Ventilation Airflow
Rates in Buildings.</a></i>
Florida Solar Energy Center, FSEC-CR-163-86. March, 1987.
Cape Canaveral, Florida.
</li>
<li>
Andrew K. Persily and Elizabeth M. Ivy.
<i>
<a href=\"www.bfrl.nist.gov/IAQanalysis/docs/NISTIR6585.pdf\">
Input Data for Multizone Airflow and IAQ Analysis.</a></i>
NIST, NISTIR 6585.
January, 2001.
Gaithersburg, MD.
</li>
</ul>
</p>
<h4>Implementation</h4>
<p>
Symmetry requires that the first derivative of the wind pressure coefficient
with respect to the incidence angle is zero for incidence angles of zero and &pi;.
However, the correlation of Swami and Chandra has non-zero derivatives at these values.
In this implementation, the original function is therefore slightly modified for incidence angles
between 0 and 5 degree, and between 175 and 180 degree.
This leads to a model that is differentiable in the incidence angle,
which generally leads to better numeric performance.
</p>
</html>",         revisions="<html>
<ul>
<li>
October 27, 2011 by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end windPressureLowRise;
      annotation (preferedView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Airflow.Multizone\">Buildings.Airflow.Multizone</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferedView="info", Documentation(info="<html>
This package provides
models to compute the airflow and contaminant transport between different rooms and between
a room and the exterior environment.
See the <a href=\"Modelica:Buildings.Airflow.Multizone.UsersGuide\">
User's Guide</a> for more information.
</html>"));
    end Multizone;
  annotation (
    preferedView="info",
    Documentation(info="<html>
This package provides
models to compute the air flow between different rooms and between
a room and the exterior environment.
For models that compute airflow in duct networks, see
<a href=\"modelica://Buildings.Fluid\">
Buildings.Fluid</a>.
</html>"));
  end Airflow;

  package BoundaryConditions "Package with models for boundary conditions"
    extends Modelica.Icons.Package;

    package SkyTemperature "Package with models to compute the sky temperature"
      extends Modelica.Icons.VariantsPackage;

      block BlackBody "Calculate black body sky temperature"
        extends Modelica.Blocks.Interfaces.BlockIcon;
        import Buildings.BoundaryConditions.Types.SkyTemperatureCalculation;

        parameter Buildings.BoundaryConditions.Types.SkyTemperatureCalculation calTSky=
          SkyTemperatureCalculation.TemperaturesAndSkyCover
        "Computation of black-body sky temperature"
          annotation(choicesAllMatching=true,
                     Evaluate=true);

        Modelica.Blocks.Interfaces.RealInput TDryBul(
          final quantity="Temperature",
          final unit="K",
          displayUnit="degC") "Dry bulb temperature at ground level"
          annotation (Placement(transformation(extent={{-140,60},{-100,100}})));
        Modelica.Blocks.Interfaces.RealInput TDewPoi(
          final quantity="Temperature",
          final unit="K",
          displayUnit="degC") "Dew point temperature"
          annotation (Placement(transformation(extent={{-140,10},{-100,50}})));
        Modelica.Blocks.Interfaces.RealInput nOpa "Opaque sky cover"
          annotation (Placement(transformation(extent={{-140,-50},{-100,-10}})));
        Modelica.Blocks.Interfaces.RealOutput TBlaSky(
          final quantity="Temperature",
          displayUnit="degC",
          final unit="K") "Black-body sky temperature"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        Modelica.Blocks.Interfaces.RealInput radHor(unit="W/m2", min=0, nominal=100)
        "Horizontal infrared irradiation"
          annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));
    protected
        Modelica.SIunits.Temperature TDewPoiK "Dewpoint temperature";
        Modelica.SIunits.Emissivity epsSky "Black-body absorptivity of sky";
        Real nOpa10(min=0, max=10) "Opaque sky cover";
      algorithm
        if calTSky == Buildings.BoundaryConditions.Types.SkyTemperatureCalculation.TemperaturesAndSkyCover then
          TDewPoiK := Buildings.Utilities.Math.Functions.smoothMin(TDryBul, TDewPoi, 0.1);
          nOpa10 := 10*nOpa "Input nOpa is scaled to [0,1] instead of [0,10]";
          epsSky := (0.787 + 0.764*Modelica.Math.log(-TDewPoiK/Modelica.Constants.T_zero))*(1 + 0.0224*nOpa10 -
            0.0035*(nOpa10^2) + 0.00028*(nOpa10^3));
          TBlaSky := TDryBul*(epsSky^0.25);
        else
          TBlaSky := (radHor/Modelica.Constants.sigma)^0.25;
        end if;
        annotation (
          defaultComponentName="TBlaSky",
          Documentation(info="<html>
<p>
This component computes the black-body sky temperature.
</p>
<p>
For <code>calTSky = 0</code>, the model uses horizontal infrared irradiation. 
Otherwise, it uses dry buld temperature, dew point temperature and opaque sky cover.
</p>
</html>
",       revisions="<html>
<ul>
<li>
October 3, 2011, by Michael Wetter:<br>
Used enumeration to set the sky temperature computation.
Fixed error in <code>if-then</code> statement that led to
a selection of the wrong branch to compute the sky temperature.
</li>
<li>
March 16, 2011, by Michael Wetter:<br>
Added types for parameters and attributes for variables. 
Removed default parameter value.
</li>
<li>
March 15, 2011, by Wangda Zuo:<br>
Use <code>smoothMin()</code> instead of <code>min()</code>. 
</li>
<li>
June 1, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"),Diagram(coordinateSystem(preserveAspectRatio=true,extent={{-100,-100},{100,100}}),
                          graphics),
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={
              Text(
                extent={{-150,110},{150,150}},
                textString="%name",
                lineColor={0,0,255}),
              Text(
                extent={{-50,44},{56,-40}},
                lineColor={0,0,255},
                textString="T"),
              Text(
                extent={{-96,84},{-66,74}},
                lineColor={0,0,127},
                textString="TDry"),
              Text(
                extent={{-90,36},{-66,24}},
                lineColor={0,0,127},
                textString="TDewPoi"),
              Text(
                extent={{-92,-74},{-62,-88}},
                lineColor={0,0,127},
                textString="radHor"),
              Text(
                extent={{16,-6},{54,-28}},
                lineColor={0,0,255},
                textString="bs"),
              Text(
                extent={{-88,-24},{-64,-36}},
                lineColor={0,0,127},
                textString="nOpa")}));
      end BlackBody;
    annotation (preferedView="info",
    Documentation(info="<html>
This package contains models to compute the black body sky temperature.
</html>"));
    end SkyTemperature;

    package SolarGeometry "Package with models to compute solar geometry"
      extends Modelica.Icons.VariantsPackage;

      block IncidenceAngle "Solar incidence angle on a tilted surface"
        extends Modelica.Blocks.Interfaces.BlockIcon;
    public
        parameter Modelica.SIunits.Angle lat "Latitude";
        parameter Modelica.SIunits.Angle azi "Surface azimuth";
        parameter Modelica.SIunits.Angle til "Surface tilt";

        Modelica.Blocks.Interfaces.RealOutput y(
          final quantity="Angle",
          final unit="rad",
          displayUnit="deg") "Incidence angle" annotation (Placement(transformation(
                extent={{100,-10},{120,10}}), iconTransformation(extent={{100,-10},{
                  120,10}})));
    protected
        Buildings.BoundaryConditions.SolarGeometry.BaseClasses.Declination decAng
        "Declination angle"
          annotation (Placement(transformation(extent={{-40,30},{-20,50}})));
        Buildings.BoundaryConditions.SolarGeometry.BaseClasses.SolarHourAngle
          solHouAng "Solar hour angle"
          annotation (Placement(transformation(extent={{-40,-50},{-20,-30}})));
        Buildings.BoundaryConditions.SolarGeometry.BaseClasses.IncidenceAngle incAng(
          final lat=lat,
          final azi=azi,
          final til=til) "Incidence angle"
          annotation (Placement(transformation(extent={{40,-10},{60,10}})));
    public
        WeatherData.Bus weaBus
          annotation (Placement(transformation(extent={{-110,-6},{-90,14}})));
      equation
        connect(incAng.incAng, y) annotation (Line(
            points={{61,6.10623e-16},{88.25,6.10623e-16},{88.25,1.16573e-15},{95.5,
                1.16573e-15},{95.5,5.55112e-16},{110,5.55112e-16}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(decAng.decAng, incAng.decAng) annotation (Line(
            points={{-19,40},{20,40},{20,5.4},{37.8,5.4}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(solHouAng.solHouAng, incAng.solHouAng) annotation (Line(
            points={{-19,-40},{20,-40},{20,-4.8},{38,-4.8}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(weaBus.cloTim, decAng.nDay) annotation (Line(
            points={{-100,4},{-80,4},{-80,40},{-42,40}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(weaBus.solTim, solHouAng.solTim) annotation (Line(
            points={{-100,4},{-80,4},{-80,-40},{-42,-40}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        annotation (
          defaultComponentName="incAng",
          Documentation(info="<html>
<p>
This component computes the solar incidence angle on a tilted surface.
For a definition of the parameters, see the 
<a href=\"modelica://Buildings.BoundaryConditions.UsersGuide\">User's Guide</a>.
</p>
</html>
",       revisions="<html>
<ul>
<li>
November 30, 2011, by Michael Wetter:<br>
Removed <code>connect(y, y)</code> statement.
</li>
<li>
February 28, 2011, by Wangda Zuo:<br>
Use local civil time instead of clock time.
</li>
<li>
May 19, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"),Diagram(coordinateSystem(preserveAspectRatio=true,extent={{-100,-100},{100,
                  100}}), graphics),
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={Text(
                extent={{-150,110},{150,150}},
                textString="%name",
                lineColor={0,0,255})}));
      end IncidenceAngle;

      block ZenithAngle "Zenith angle"
        extends Modelica.Blocks.Interfaces.BlockIcon;
    public
        parameter Modelica.SIunits.Angle lat "Latitude";
        Modelica.Blocks.Interfaces.RealOutput y(
          final quantity="Angle",
          final unit="rad",
          displayUnit="deg") "Zenith angle"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));
    protected
         Buildings.BoundaryConditions.SolarGeometry.BaseClasses.ZenithAngle zen(final lat=lat)
          annotation (Placement(transformation(extent={{60,-10},{80,10}})));
         Buildings.BoundaryConditions.SolarGeometry.BaseClasses.Declination decAng
        "Declination angle"
          annotation (Placement(transformation(extent={{-20,30},{0,50}})));
         Buildings.BoundaryConditions.SolarGeometry.BaseClasses.SolarHourAngle
          solHouAng
          annotation (Placement(transformation(extent={{-20,-50},{0,-30}})));
    public
        WeatherData.Bus weaBus
          annotation (Placement(transformation(extent={{-112,-10},{-92,10}})));
      equation
        connect(decAng.decAng, zen.decAng) annotation (Line(
            points={{1,40},{50,40},{50,5.4},{58,5.4}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(solHouAng.solHouAng, zen.solHouAng) annotation (Line(
            points={{1,-40},{50,-40},{50,-4.8},{58,-4.8}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(zen.zen, y) annotation (Line(
            points={{81,6.10623e-16},{88.25,6.10623e-16},{88.25,1.16573e-15},{95.5,
                1.16573e-15},{95.5,5.55112e-16},{110,5.55112e-16}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(weaBus.cloTim, decAng.nDay) annotation (Line(
            points={{-102,5.55112e-16},{-60,5.55112e-16},{-60,40},{-22,40}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(weaBus.solTim, solHouAng.solTim) annotation (Line(
            points={{-102,5.55112e-16},{-60,5.55112e-16},{-60,-40},{-22,-40}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        annotation (
          defaultComponentName="zen",
          Documentation(info="<html>
<p>
This component computes the zenith angle, which is the angle between the earth surface normal and the sun's beam.
For a definition of the parameters, see the 
<a href=\"modelica://Buildings.BoundaryConditions.UsersGuide\">User's Guide</a>.
</p>
</html>
",       revisions="<html>
<ul>
<li>
May 17, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"),Diagram(coordinateSystem(preserveAspectRatio=true,extent={{-100,-100},{100,
                  100}}), graphics),
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={Text(
                extent={{-150,110},{150,150}},
                textString="%name",
                lineColor={0,0,255})}));
      end ZenithAngle;

      package BaseClasses
      "Package with base classes for Buildings.BoundaryConditions.SolarGeometry"
        extends Modelica.Icons.BasesPackage;

        block Declination "Declination angle"
          extends Modelica.Blocks.Interfaces.BlockIcon;
      public
          Modelica.Blocks.Interfaces.RealInput nDay(quantity="Time", unit="s")
          "One-based day number in seconds"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput decAng(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") "Declination angle"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        equation
          decAng = Modelica.Math.asin(-sin(23.45*2*Modelica.Constants.pi/360)*
            Modelica.Math.cos((nDay/86400 + 10)*2*Modelica.Constants.pi/365.25))
          "(A4.5)";
          annotation (
            defaultComponentName="decAng",
            Documentation(info="<html>
<p>
This component computes the angle between the equatorial plane and the solar beam.
</p>
</html>
",         revisions="<html>
<ul>
<li>
Dec 7, 2010, by Michael Wetter:<br>
Rewrote equation in explicit form to avoid nonlinear equations in room model.
</li>
<li>
May 17, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"),  Diagram(coordinateSystem(preserveAspectRatio=true,extent={{-100,-100},{100,
                    100}}), graphics),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255})}));
        end Declination;

        block IncidenceAngle "The solar incidence angle on a tilted surface"
          extends Modelica.Blocks.Interfaces.BlockIcon;
      public
          parameter Modelica.SIunits.Angle lat "Latitude";
          parameter Modelica.SIunits.Angle azi(displayUnit="degree")
          "Surface azimuth. azi=-90 degree if surface outward unit normal points toward east; azi=0 if it points toward south";
          parameter Modelica.SIunits.Angle til(displayUnit="degree")
          "Surface tilt. til=90 degree for walls; til=0 for ceilings; til=180 for roof";
          Modelica.Blocks.Interfaces.RealInput solHouAng(quantity="Angle", unit="rad")
          "Solar hour angle"
            annotation (Placement(transformation(extent={{-140,-68},{-100,-28}})));
          Modelica.Blocks.Interfaces.RealInput decAng(quantity="Angle", unit="rad")
          "Declination"
            annotation (Placement(transformation(extent={{-142,34},{-102,74}})));
          Modelica.Blocks.Interfaces.RealOutput incAng(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") "Incidence angle on a tilted surfce"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
      protected
          Real dec_c=Modelica.Math.cos(decAng);
          Real dec_s=Modelica.Math.sin(decAng);
          Real sol_c=Modelica.Math.cos(solHouAng);
          Real sol_s=Modelica.Math.sin(solHouAng);
          Real lat_c=Modelica.Math.cos(lat);
          Real lat_s=Modelica.Math.sin(lat);
        equation
          incAng = Modelica.Math.acos(Modelica.Math.cos(til)*(dec_c*sol_c*lat_c + dec_s
            *lat_s) + Modelica.Math.sin(til)*(Modelica.Math.sin(azi)*dec_c*sol_s +
            Modelica.Math.cos(azi)*(dec_c*sol_c*lat_s - dec_s*lat_c)))
          "(A.4.13)";
          annotation (
            defaultComponentName="incAng",
            Documentation(info="<html>
<p>
This component computes the solar incidence angle on a tilted surface using the solar hour angle and the declination angle as input.
</p>
</html>
",         revisions="<html>
<ul>
<li>
Dec 7, 2010, by Michael Wetter:<br>
Rewrote equation in explicit form to avoid nonlinear equations in room model.
</li>
<li>
May 19, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"),  Diagram(coordinateSystem(preserveAspectRatio=true,extent={{-100,-100},{100,
                    100}}), graphics),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-98,60},{-56,50}},
                  lineColor={0,0,127},
                  textString="decAng"),
                Text(
                  extent={{-98,-42},{-42,-54}},
                  lineColor={0,0,127},
                  textString="solHouAng")}));
        end IncidenceAngle;

        block SolarHourAngle "Solar hour angle"
          extends Modelica.Blocks.Interfaces.BlockIcon;
      public
          Modelica.Blocks.Interfaces.RealInput solTim(quantity="Time", unit="s")
          "Solar time"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput solHouAng(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") "Solar hour angle"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        equation
          solHouAng = (solTim/3600 - 12)*2*Modelica.Constants.pi/24
          "Our unit is s instead of h in (A4.6)";
          annotation (
            defaultComponentName="solHouAng",
            Documentation(info="<html>
<p>
This component computes the solar hour angle, which is defined as the angle between the circle that passes through an observer, the north pole and the south pole, 
and the circle that passes through the sun, the north and the south pole.
</p>
</html>
",         revisions="<html>
<ul>
<li>
May 17, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"),  Diagram(coordinateSystem(preserveAspectRatio=true,extent={{-100,-100},{100,
                    100}}), graphics),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255})}));
        end SolarHourAngle;

        block ZenithAngle "Zenith angle"
          extends Modelica.Blocks.Interfaces.BlockIcon;
      public
          parameter Modelica.SIunits.Angle lat "Latitude";
          Modelica.Blocks.Interfaces.RealInput solHouAng(quantity="Angle", unit="rad")
          "Solar hour angle"
            annotation (Placement(transformation(extent={{-140,-68},{-100,-28}})));
          Modelica.Blocks.Interfaces.RealInput decAng(quantity="Angle", unit="rad")
          "Declination"
            annotation (Placement(transformation(extent={{-142,34},{-102,74}}),
                iconTransformation(extent={{-140,34},{-100,74}})));
          Modelica.Blocks.Interfaces.RealOutput zen(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") "Zenith angle"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        equation
          zen =  Modelica.Math.acos(Modelica.Math.cos(lat)*Modelica.Math.cos(decAng)*
            Modelica.Math.cos(solHouAng) + Modelica.Math.sin(lat)*Modelica.Math.sin(
            decAng)) "(A4.8)";
          annotation (
            defaultComponentName="zen",
            Documentation(info="<html>
<p>
This component computes the zenith angle, which is the angle between the earth surface normal and the sun's beam. 
Input are the solar hour angle and the declination angle.
</p>
</html>
",         revisions="<html>
<ul>
<li>
Dec 7, 2010, by Michael Wetter:<br>
Rewrote equation in explicit form to avoid nonlinear equations in room model.
</li>
<li>
May 17, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"),  Diagram(coordinateSystem(preserveAspectRatio=true,extent={{-100,-100},{100,100}}),
                            graphics),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-98,62},{-46,46}},
                  lineColor={0,0,127},
                  textString="decAng"),
                Text(
                  extent={{-98,-40},{-22,-58}},
                  lineColor={0,0,127},
                  textString="solHouAng")}));
        end ZenithAngle;
      annotation (preferedView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.BoundaryConditions.SolarGeometry\">Buildings.BoundaryConditions.SolarGeometry</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferedView="info",
    Documentation(info="<html>
This package contains models to compute the solar geometry and incidence
angles on tilted surfaces.
</html>"));
    end SolarGeometry;

    package SolarIrradiation "Package with models to compute solar irradition"
      extends Modelica.Icons.VariantsPackage;

      block DiffusePerez
      "Hemispherical diffuse irradiation on a tilted surface using Perez's anisotropic sky model"
        extends
        Buildings.BoundaryConditions.SolarIrradiation.BaseClasses.PartialSolarIrradiation;

        parameter Real rho=0.2 "Ground reflectance";
        parameter Modelica.SIunits.Angle lat "Latitude";
        parameter Modelica.SIunits.Angle azi "Surface azimuth";

    protected
        BaseClasses.DiffusePerez HDifTil(final til=til, final rho=
                rho) annotation (Placement(transformation(extent={{46,-21},{88,21}})));
        BaseClasses.SkyClearness skyCle
          annotation (Placement(transformation(extent={{-52,16},{-44,24}})));
        BaseClasses.BrighteningCoefficient briCoe
          annotation (Placement(transformation(extent={{2,-34},{10,-26}})));
        BaseClasses.RelativeAirMass relAirMas
          annotation (Placement(transformation(extent={{-52,-48},{-44,-40}})));
        BaseClasses.SkyBrightness skyBri
          annotation (Placement(transformation(extent={{-30,-56},{-22,-48}})));
        SolarGeometry.IncidenceAngle incAng(
          lat=lat,
          azi=azi,
          til=til)
          annotation (Placement(transformation(extent={{-86,-96},{-76,-86}})));
        SolarGeometry.ZenithAngle zen(lat=lat)
          annotation (Placement(transformation(extent={{-86,-44},{-78,-36}})));
      equation
        connect(relAirMas.relAirMas, skyBri.relAirMas) annotation (Line(
            points={{-43.6,-44},{-34,-44},{-34,-50.4},{-30.8,-50.4}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(skyBri.skyBri, briCoe.skyBri) annotation (Line(
            points={{-21.6,-52},{-16,-52},{-16,-30},{1.2,-30}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(skyCle.skyCle, briCoe.skyCle) annotation (Line(
            points={{-43.6,20},{-10,20},{-10,-27.6},{1.2,-27.6}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(incAng.y, HDifTil.incAng) annotation (Line(
            points={{-75.5,-91},{34,-91},{34,-14},{41.8,-14},{41.8,-14.7}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(zen.y, skyCle.zen) annotation (Line(
            points={{-77.6,-40},{-70,-40},{-70,17.6},{-52.8,17.6}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(zen.y, relAirMas.zen) annotation (Line(
            points={{-77.6,-40},{-66,-40},{-66,-44},{-52.8,-44}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(zen.y, briCoe.zen) annotation (Line(
            points={{-77.6,-40},{-70,-40},{-70,-64},{-10,-64},{-10,-34},{1.2,-34},{
                1.2,-32.4}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(HDifTil.zen, zen.y) annotation (Line(
            points={{41.8,-8.4},{26,-8.4},{26,-80},{-70,-80},{-70,-40},{-77.6,-40}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(weaBus.HGloHor, skyCle.HGloHor) annotation (Line(
            points={{-100,5.55112e-16},{-70,5.55112e-16},{-70,22.4},{-52.8,22.4}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(weaBus.HDifHor, skyCle.HDifHor) annotation (Line(
            points={{-100,5.55112e-16},{-82,5.55112e-16},{-82,20},{-52.8,20}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(weaBus.HDifHor, skyBri.HDifHor) annotation (Line(
            points={{-100,5.55112e-16},{-36,5.55112e-16},{-36,-53.6},{-30.8,-53.6}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(weaBus.HGloHor, HDifTil.HGloHor) annotation (Line(
            points={{-100,5.55112e-16},{20,5.55112e-16},{20,16.8},{41.8,16.8}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(weaBus.HDifHor, HDifTil.HDifHor) annotation (Line(
            points={{-100,5.55112e-16},{2,5.55112e-16},{2,10.5},{41.8,10.5}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(briCoe.F2, HDifTil.briCof2) annotation (Line(
            points={{10.4,-31.6},{22,-31.6},{22,-2.1},{41.8,-2.1}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(briCoe.F1, HDifTil.briCof1) annotation (Line(
            points={{10.4,-28.4},{16,-28.4},{16,4.2},{41.8,4.2}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(HDifTil.HDifTil, H) annotation (Line(
            points={{90.1,-6.60583e-16},{96.05,-6.60583e-16},{96.05,5.55112e-16},{110,
                5.55112e-16}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(weaBus, incAng.weaBus) annotation (Line(
            points={{-100,5.55112e-16},{-92,5.55112e-16},{-92,-90.8},{-86,-90.8}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(weaBus, zen.weaBus) annotation (Line(
            points={{-100,5.55112e-16},{-92,5.55112e-16},{-92,-40},{-86.08,-40}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        annotation (
          defaultComponentName="HDifTil",
          Documentation(info="<html>
<p>
This component computes the hemispherical diffuse irradiation on a tilted surface using an anisotropic 
sky model proposed by Perez. 
For a definition of the parameters, see the 
<a href=\"modelica://Buildings.BoundaryConditions.UsersGuide\">User's Guide</a>.
</p>
<h4>References</h4>
<ul>
<li>
P. Ineichen, R. Perez and R. Seals (1987).
<i>The Importance of Correct Albedo Determination for Adequately Modeling Energy Received by Tilted Surface</i>,
Solar Energy, 39(4): 301-305.
</li>
<li>
R. Perez, R. Seals, P. Ineichen, R. Stewart and D. Menicucci (1987).
<i>A New Simplified Version of the Perez Diffuse Irradiance Model for Tilted Surface</i>,
Solar Energy, 39(3): 221-231.
</li>
<li>
R. Perez, P. Ineichen, R. Seals, J. Michalsky and R. Stewart (1990).
<i>Modeling Dyalight Availability and Irradiance Componets From Direct and Global Irradiance</i>,
Solar Energy, 44(5):271-289.
</li>
</ul>
</html>
",       revisions="<html>
<ul>
<li>
May 24, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"),Diagram(coordinateSystem(preserveAspectRatio=true,extent={{-100,-100},{100,
                  100}}), graphics),
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={Text(
                extent={{-150,110},{150,150}},
                textString="%name",
                lineColor={0,0,255})}));
      end DiffusePerez;

      block DirectTiltedSurface "Direct solar irradiation on a tilted surface"
        import Buildings;
        extends
        Buildings.BoundaryConditions.SolarIrradiation.BaseClasses.PartialSolarIrradiation;

        parameter Modelica.SIunits.Angle lat "Latitude";
        parameter Modelica.SIunits.Angle azi "Surface azimuth";

        Buildings.BoundaryConditions.WeatherData.Bus weaBus
          annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));

        Modelica.Blocks.Interfaces.RealOutput inc(
          final quantity="Angle",
          final unit="rad",
          displayUnit="deg") "Incidence angle"
          annotation (Placement(transformation(extent={{100,-50},{120,-30}})));

    protected
        SolarGeometry.IncidenceAngle incAng(
          final azi=azi,
          final til=til,
          final lat=lat)
          annotation (Placement(transformation(extent={{-50,-30},{-30,-10}})));
        Buildings.BoundaryConditions.SolarIrradiation.BaseClasses.DirectTiltedSurface
          HDirTil annotation (Placement(transformation(extent={{0,-20},{40,20}})));

      equation
        connect(incAng.y, HDirTil.incAng) annotation (Line(
            points={{-29,-20},{-12,-20},{-12,-12},{-4,-12}},
            color={0,0,127},
            smooth=Smooth.None));

        connect(weaBus.HDirNor, HDirTil.HDirNor) annotation (Line(
            points={{-100,5.55112e-16},{-80,5.55112e-16},{-80,12},{-4,12}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(incAng.y, inc) annotation (Line(
            points={{-29,-20},{-20,-20},{-20,-40},{110,-40}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(HDirTil.HDirTil, H) annotation (Line(
            points={{42,1.22125e-15},{72,1.22125e-15},{72,5.55112e-16},{110,
                5.55112e-16}},
            color={0,0,127},
            smooth=Smooth.None));

        connect(weaBus, incAng.weaBus) annotation (Line(
            points={{-100,5.55112e-16},{-80,5.55112e-16},{-80,-19.6},{-50,-19.6}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        annotation (
          defaultComponentName="HDirTil",
          Documentation(info="<html>
<p>
This component computes the direct solar irradiation on a tilted surface.
For a definition of the parameters, see the 
<a href=\"modelica://Buildings.BoundaryConditions.UsersGuide\">User's Guide</a>.
</p>
</html>
",       revisions="<html>
<ul>
<li>
December 12, 2010, by Michael Wetter:<br>
Added incidence angle as output as this is needed for the room model.
</li>
<li>
May 24, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"),Diagram(coordinateSystem(preserveAspectRatio=true,extent={{-100,-100},{100,
                  100}}), graphics),
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={Text(
                extent={{-150,110},{150,150}},
                textString="%name",
                lineColor={0,0,255})}));
      end DirectTiltedSurface;

      package BaseClasses
      "Package with base classes for Buildings.BoundaryConditions.SolarIrradiation"
        extends Modelica.Icons.BasesPackage;

        block BrighteningCoefficient
        "Circumsolar and horizon brightening coefficients"
          extends Modelica.Blocks.Interfaces.BlockIcon;
          import H = Buildings.Utilities.Math.Functions.spliceFunction;
      public
          Modelica.Blocks.Interfaces.RealInput zen(
            quantity="Angle",
            unit="rad",
            displayUnit="degree") "Zenith angle of the sun beam"
            annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));
          Modelica.Blocks.Interfaces.RealInput skyCle
          "Sky clearness. skyCle=1: overcast sky; skyCle=8 clear sky"
            annotation (Placement(transformation(extent={{-140,40},{-100,80}})));
          Modelica.Blocks.Interfaces.RealInput skyBri "Sky brightness [0,1]"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput F1
          "Circumsolar brightening coefficient"
            annotation (Placement(transformation(extent={{100,30},{120,50}})));
          Modelica.Blocks.Interfaces.RealOutput F2
          "Horizon brightening coefficient"
            annotation (Placement(transformation(extent={{100,-50},{120,-30}})));
      protected
          Real F11;
          Real F12;
          Real F13;
          Real F21;
          Real F22;
          Real F23;
          Real d=0.01;
          Real a1;
          Real a2;
          Real a3;
          Real a4;
          Real a5;
          Real a6;
          Real a7;
          Real a8;
          Real b1;
          Real b2;
          Real b3;
          Real b4;
          Real b5;
          Real b6;
          Real b7;
          Real b8;
        equation
          b1 = H(
            1,
            0,
            1.065 - skyCle,
            d);
          b2 = H(
            1,
            0,
            1.23 - skyCle,
            d);
          b3 = H(
            1,
            0,
            1.50 - skyCle,
            d);
          b4 = H(
            1,
            0,
            1.95 - skyCle,
            d);
          b5 = H(
            1,
            0,
            2.80 - skyCle,
            d);

          b6 = H(
            1,
            0,
            4.50 - skyCle,
            d);
          b7 = H(
            1,
            0,
            6.20 - skyCle,
            d);
          b8 = H(
            1,
            0,
            skyCle - 6.20,
            d);

          a1 = b1;
          a2 = b2 - b1;
          a3 = b3 - b2;
          a4 = b4 - b3;
          a5 = b5 - b4;
          a6 = b6 - b5;
          a7 = b7 - b6;
          a8 = b8;

          F11 = -0.0083117*a1 + 0.1299457*a2 + 0.3296958*a3 + 0.5682053*a4 + 0.8730280*
            a5 + 1.1326077*a6 + 1.0601591*a7 + 0.6777470*a8;
          F12 = 0.5877285*a1 + 0.6825954*a2 + 0.4868735*a3 + 0.1874525*a4 - 0.3920403*
            a5 - 1.2367284*a6 - 1.5999137*a7 - 0.3272588*a8;
          F13 = -0.0620636*a1 - 0.1513725*a2 - 0.2210958*a3 - 0.2951290*a4 - 0.3616149*
            a5 - 0.4118494*a6 - 0.3589221*a7 - 0.2504286*a8;
          F21 = -0.0596012*a1 - 0.0189325*a2 + 0.0554140*a3 + 0.1088631*a4 + 0.2255647*
            a5 + 0.2877813*a6 + 0.2642124*a7 + 0.1561313*a8;
          F22 = 0.0721249*a1 + 0.0659650*a2 - 0.0639588*a3 - 0.1519229*a4 - 0.4620442*
            a5 - 0.8230357*a6 - 1.1272340*a7 - 1.3765031*a8;
          F23 = -0.0220216*a1 - 0.0288748*a2 - 0.0260542*a3 - 0.0139754*a4 + 0.0012448*
            a5 + 0.0558651*a6 + 0.1310694*a7 + 0.2506212*a8;
          F1 = Buildings.Utilities.Math.Functions.smoothMax(
            0,
            F11 + F12*skyBri + F13*zen,
            0.01);
          F2 = F21 + F22*skyBri + F23*zen;
          annotation (
            defaultComponentName="briCoe",
            Documentation(info="<html>
<p>
This component computes the circumsolar and horizon brightening coefficients.
</p>
</html>
",         revisions="<html>
<ul>
<li>
May 25, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"),  Diagram(coordinateSystem(preserveAspectRatio=true,extent={{-100,-100},{100,
                    100}}), graphics),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-96,72},{-52,50}},
                  lineColor={0,0,127},
                  textString="skyCle"),
                Text(
                  extent={{-96,14},{-52,-8}},
                  lineColor={0,0,127},
                  textString="skyBri"),
                Text(
                  extent={{-96,-46},{-52,-68}},
                  lineColor={0,0,127},
                  textString="zen"),
                Text(
                  extent={{62,50},{106,28}},
                  lineColor={0,0,127},
                  textString="F1"),
                Text(
                  extent={{60,-30},{104,-52}},
                  lineColor={0,0,127},
                  textString="F2")}),
            Diagram(graphics));
        end BrighteningCoefficient;

        block DiffusePerez
        "Hemispherical diffuse irradiation on a tilted surface with Perez's anisotropic model"
          extends Modelica.Blocks.Interfaces.BlockIcon;
      public
          parameter Real rho=0.2 "Ground reflectance";
          parameter Modelica.SIunits.Angle til(displayUnit="deg")
          "Surface tilt angle";
          Modelica.Blocks.Interfaces.RealInput briCof1
          "Brightening Coeffcient F1"
            annotation (Placement(transformation(extent={{-140,0},{-100,40}})));
          Modelica.Blocks.Interfaces.RealInput briCof2
          "Brightening Coeffcient F2"
            annotation (Placement(transformation(extent={{-140,-30},{-100,10}})));
          Modelica.Blocks.Interfaces.RealInput HDifHor(quantity=
                "RadiantEnergyFluenceRate", unit="W/m2")
          "Diffuse horizontal solar radiation"
            annotation (Placement(transformation(extent={{-140,30},{-100,70}})));
          Modelica.Blocks.Interfaces.RealInput HGloHor(quantity=
                "RadiantEnergyFluenceRate", unit="W/m2")
          "Global horizontal radiation"
            annotation (Placement(transformation(extent={{-140,60},{-100,100}})));
          Modelica.Blocks.Interfaces.RealOutput HDifTil(final quantity=
                "RadiantEnergyFluenceRate", final unit="W/m2")
          "Hemispherical diffuse solar irradiation on a tilted surfce"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          Modelica.Blocks.Interfaces.RealInput zen(
            quantity="Angle",
            unit="rad",
            displayUnit="degree") "Zenith angle of the sun beam"
            annotation (Placement(transformation(extent={{-140,-60},{-100,-20}})));
          Modelica.Blocks.Interfaces.RealInput incAng(
            quantity="Angle",
            unit="rad",
            displayUnit="degree") "Solar incidence angle on the surface"
            annotation (Placement(transformation(extent={{-140,-90},{-100,-50}})));
      protected
          Real a;
          Real b;
          constant Real bMin=Modelica.Math.cos(Modelica.Constants.pi*85/180)
          "Lower bound for b";
        equation
          a = Buildings.Utilities.Math.Functions.smoothMax(
            0,
            Modelica.Math.cos(incAng),
            0.01);
          b = Buildings.Utilities.Math.Functions.smoothMax(
            bMin,
            Modelica.Math.cos(zen),
            0.01);
          HDifTil = HDifHor*(0.5*(1 - briCof1)*(1 + Modelica.Math.cos(til)) +
            briCof1*a/b + briCof2*Modelica.Math.sin(til)) + HGloHor*0.5*rho*(1 -
            Modelica.Math.cos(til));

          annotation (
            defaultComponentName="HDifTil",
            Documentation(info="<html>
<p>
This component computes the hemispherical diffuse irradiation on a tilted surface by using an anisotropic model proposed by Perez. 
</p>
<h4>References</h4>
<ul>
<li>
P. Ineichen, R. Perez and R. Seals (1987).
<i>The Importance of Correct Albedo Determination for Adequately Modeling Energy Received by Tilted Surface</i>,
Solar Energy, 39(4): 301-305.
</li>
<li>
R. Perez, R. Seals, P. Ineichen, R. Stewart and D. Menicucci (1987).
<i>A New Simplified Version of the Perez Diffuse Irradiance Model for Tilted Surface</i>,
Solar Energy, 39(3): 221-231.
</li>
<li>
R. Perez, P. Ineichen, R. Seals, J. Michalsky and R. Stewart (1990).
<i>Modeling Dyalight Availability and Irradiance Componets From Direct and Global Irradiance</i>,
Solar Energy, 44(5):271-289.
</li>
</ul>
</html>
",         revisions="<html>
<ul>
<li>
May 24, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"),  Diagram(coordinateSystem(preserveAspectRatio=true,extent={{-100,-100},{100,
                    100}}), graphics),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-48,74},{-100,86}},
                  lineColor={0,0,127},
                  textString="HGloHor"),
                Text(
                  extent={{-50,44},{-102,56}},
                  lineColor={0,0,127},
                  textString="HDifHor"),
                Text(
                  extent={{-50,14},{-102,26}},
                  lineColor={0,0,127},
                  textString="briCof1"),
                Text(
                  extent={{-50,-16},{-102,-4}},
                  lineColor={0,0,127},
                  textString="briCof2"),
                Text(
                  extent={{-50,-46},{-102,-34}},
                  lineColor={0,0,127},
                  textString="zen"),
                Text(
                  extent={{-52,-76},{-104,-64}},
                  lineColor={0,0,127},
                  textString="incAng")}));
        end DiffusePerez;

        block DirectTiltedSurface
        "Direct solar irradiation on a tilted surface"
          extends Modelica.Blocks.Interfaces.BlockIcon;
          Modelica.Blocks.Interfaces.RealInput incAng(
            quantity="Angle",
            unit="rad",
            displayUnit="degree")
          "Incidence angle of the sun beam on a tilted surface"
            annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));
          Modelica.Blocks.Interfaces.RealInput HDirNor(quantity=
                "RadiantEnergyFluenceRate", unit="W/m2")
          "Direct normal radiation"
            annotation (Placement(transformation(extent={{-140,40},{-100,80}})));
          Modelica.Blocks.Interfaces.RealOutput HDirTil(final quantity=
                "RadiantEnergyFluenceRate", final unit="W/m2")
          "Direct solar irradiation on a tilted surfce"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

        algorithm
          HDirTil := max(0, Modelica.Math.cos(incAng)*HDirNor);
          annotation (
            defaultComponentName="HDirTil",
            Documentation(info="<html>
<p>
This component computes the direct solar irradiation on a tilted surface.
</p>
</html>
",         revisions="<html>
<ul>
<li>
May 24, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"),  Diagram(coordinateSystem(preserveAspectRatio=true,extent={{-100,-100},{100,
                    100}}), graphics),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-50,56},{-102,68}},
                  lineColor={0,0,127},
                  textString="HDirNor"),
                Text(
                  extent={{-54,-66},{-106,-54}},
                  lineColor={0,0,127},
                  textString="incAng")}));
        end DirectTiltedSurface;

        block RelativeAirMass "Relative air mass"
          extends Modelica.Blocks.Interfaces.BlockIcon;
      public
          Modelica.Blocks.Interfaces.RealInput zen(
            quantity="Angle",
            unit="rad",
            displayUnit="degree") "Zenith angle of the sun beam"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput relAirMas "Relative air mass"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
      protected
          Real zenLim;
          Real zenDeg;
        equation
          zenLim = Buildings.Utilities.Math.Functions.smoothMin(
            zen,
            Modelica.Constants.pi/2,
            0.01);
          zenDeg = zenLim*180/Modelica.Constants.pi;
          relAirMas = 1/(Modelica.Math.cos(zenLim) + 0.15*(93.9 - zenDeg)^(-1.253));
          annotation (
            defaultComponentName="relAirMas",
            Documentation(info="<html>
<p>
This component computes the relative air mass for sky brightness.
</p>
<h4>References</h4>
R. Perez (1999).
<i>Fortran Function irrpz.f</i>,
Emailed by R. Perez to F.C. Winkelmann on May 21, 1999.<br>
</html>
",         revisions="<html>
<ul>
<li>
July 07, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"),  Diagram(coordinateSystem(preserveAspectRatio=true,extent={{-100,-100},{100,
                    100}}), graphics),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255})}));
        end RelativeAirMass;

        block SkyBrightness "Sky brightness"
          extends Modelica.Blocks.Interfaces.BlockIcon;
      public
          Modelica.Blocks.Interfaces.RealInput relAirMas "Relative Air Mass"
            annotation (Placement(transformation(extent={{-140,20},{-100,60}})));
          Modelica.Blocks.Interfaces.RealInput HDifHor(quantity=
                "RadiantEnergyFluenceRate", unit="W/m2")
          "Horizontal diffuse solar radiation"
            annotation (Placement(transformation(extent={{-140,-60},{-100,-20}})));
          Modelica.Blocks.Interfaces.RealOutput skyBri "Sky Brightness"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        equation
          skyBri = Buildings.Utilities.Math.Functions.smoothMin(
            HDifHor*relAirMas/1367,
            1,
            0.025);
          annotation (
            defaultComponentName="skyBri",
            Documentation(info="<html>
<p>
This component computes the sky brightness.
</p>
<h4>References</h4>
R. Perez, P. Ineichen, R. Seals, J. Michalsky and R. Stewart (1990).
<i>Modeling Dyalight Availability and Irradiance Componets From Direct and Global Irradiance</i>,
Solar Energy, 44(5):271-289.
</html>
",         revisions="<html>
<ul>
<li>
July 07, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"),  Diagram(coordinateSystem(preserveAspectRatio=true,extent={{-100,-100},{100,
                    100}}), graphics),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-44,36},{-96,48}},
                  lineColor={0,0,127},
                  textString="relAirMas"),
                Text(
                  extent={{-44,-46},{-96,-34}},
                  lineColor={0,0,127},
                  textString="HDifHor")}));
        end SkyBrightness;

        block SkyClearness "Sky clearness"
          extends Modelica.Blocks.Interfaces.BlockIcon;
      public
          Modelica.Blocks.Interfaces.RealInput zen(
            quantity="Angle",
            unit="rad",
            displayUnit="degreeC") "Zenith angle of the sun beam"
            annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));
          Modelica.Blocks.Interfaces.RealInput HDifHor(quantity=
                "RadiantEnergyFluenceRate", unit="W/m2")
          "Horizontal diffuse solar radiation"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealInput HGloHor(quantity=
                "RadiantEnergyFluenceRate", unit="W/m2")
          "Horizontal global solar radiation"
            annotation (Placement(transformation(extent={{-140,40},{-100,80}})));
          Modelica.Blocks.Interfaces.RealOutput skyCle
          "Sky clearness. skyCle=1: overast sky; skyCle=8: clear sky"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
      protected
          Real tmp1;
        algorithm
          tmp1 := 5.534e-6*(zen*180/Modelica.Constants.pi)^3;

          skyCle := smooth(1, if (HGloHor < Modelica.Constants.small) then 1 else
            Buildings.Utilities.Math.Functions.smoothLimit(
            (HGloHor/Buildings.Utilities.Math.Functions.smoothMax(
              HDifHor,
              1e-4,
              1e-5) + tmp1)/(1 + tmp1),
            1,
            8,
            0.1));
          annotation (
            defaultComponentName="skyCle",
            Documentation(info="<html>
<p>
This component computes the sky clearness.
</p>
</html>
",         revisions="<html>
<ul>
<li>
July 07, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"),  Diagram(coordinateSystem(preserveAspectRatio=true,extent={{-100,-100},{100,
                    100}}), graphics),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-48,-6},{-100,6}},
                  lineColor={0,0,127},
                  textString="HDifHor"),
                Text(
                  extent={{-48,54},{-100,66}},
                  lineColor={0,0,127},
                  textString="HGloHor"),
                Text(
                  extent={{-48,-66},{-100,-54}},
                  lineColor={0,0,127},
                  textString="zen")}));
        end SkyClearness;

        partial block PartialSolarIrradiation
        "Partial model that is used to compute the direct and diffuse solar irradiation"
          extends Modelica.Blocks.Interfaces.BlockIcon;
          parameter Modelica.SIunits.Angle til(displayUnit="deg")
          "Surface tilt";
          Modelica.Blocks.Interfaces.RealOutput H(
             final quantity="RadiantEnergyFluenceRate",
             final unit="W/m2") "Radiation per unit area"
            annotation (Placement(transformation(extent={{100,-10},{120,10}},
                rotation=0)));

          WeatherData.Bus weaBus "Bus with weather data"
            annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));

          annotation (
            Documentation(info="<html>
<p>
This is a partial model that is used to implement the direct and diffuse irradiation.
</p>
</html>
",         revisions="<html>
<ul>
<li>
Dec. 12, 2010, by Michael Wetter:<br>
Changed output signal to avoid ambiguity in blocks that output also other
quantities such as the incidence angle.
</li>
<li>
Sep. 4, 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),  Diagram(coordinateSystem(preserveAspectRatio=true,extent={{-100,-100},{100,
                    100}}), graphics),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255})}));
        end PartialSolarIrradiation;
      annotation (preferedView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.BoundaryConditions.SolarIrradiation\">Buildings.BoundaryConditions.SolarIrradiation</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferedView="info",
    Documentation(info="<html>
This package contains models to compute the solar irradiation
for different sky models.
</html>"));
    end SolarIrradiation;

    package WeatherData "Weather data reader"
      extends Modelica.Icons.VariantsPackage;

      block ReaderTMY3 "Reader for TMY3 weather data "
        //--------------------------------------------------------------
        // Atmospheric pressure
        parameter Buildings.BoundaryConditions.Types.DataSource pAtmSou=Buildings.BoundaryConditions.Types.DataSource.Parameter
        "Atmospheric pressure"
          annotation (Evaluate=true, Dialog(group="Data source"));
        parameter Modelica.SIunits.Pressure pAtm=101325
        "Atmospheric pressure (used if pAtmSou=Parameter)"
          annotation (Evaluate=true, Dialog(group="Data source"));
        Modelica.Blocks.Interfaces.RealInput pAtm_in(
          final quantity="Pressure",
          final unit="Pa",
          displayUnit="Pa") if (pAtmSou == Buildings.BoundaryConditions.Types.DataSource.Input)
        "Input pressure"
          annotation (Placement(transformation(extent={{-240,180},{-200,220}}),
              iconTransformation(extent={{-240,180},{-200,220}})));
        //--------------------------------------------------------------
        // Dry bulb temperature
        parameter Buildings.BoundaryConditions.Types.DataSource TDryBulSou=Buildings.BoundaryConditions.Types.DataSource.File
        "Dry bulb temperature"
          annotation (Evaluate=true, Dialog(group="Data source"));
        parameter Modelica.SIunits.Temperature TDryBul(displayUnit="degC") = 293.15
        "Dry bulb temperature (used if TDryBul=Parameter)"
          annotation (Evaluate=true, Dialog(group="Data source"));
        Modelica.Blocks.Interfaces.RealInput TDryBul_in(
          final quantity="Temperature",
          final unit="K",
          displayUnit="degC") if (TDryBulSou == Buildings.BoundaryConditions.Types.DataSource.Input)
        "Input dry bulb temperature"
          annotation (Placement(transformation(extent={{-240,120},{-200,160}})));
        //--------------------------------------------------------------
        // Relative humidity
        parameter Buildings.BoundaryConditions.Types.DataSource relHumSou=Buildings.BoundaryConditions.Types.DataSource.File
        "Relative humidity"   annotation (Evaluate=true, Dialog(group="Data source"));
        parameter Real relHum(
          min=0,
          max=1,
          unit="1") = 0.5 "Relative humidity (used if relHum=Parameter)"
          annotation (Evaluate=true, Dialog(group="Data source"));
        Modelica.Blocks.Interfaces.RealInput relHum_in(
          min=0,
          max=1,
          unit="1") if (relHumSou == Buildings.BoundaryConditions.Types.DataSource.Input)
        "Input relative humidity"
          annotation (Placement(transformation(extent={{-240,60},{-200,100}}),
              iconTransformation(extent={{-240,60},{-200,100}})));
        //--------------------------------------------------------------
        // Wind speed
        parameter Buildings.BoundaryConditions.Types.DataSource winSpeSou=Buildings.BoundaryConditions.Types.DataSource.File
        "Wind speed"   annotation (Evaluate=true, Dialog(group="Data source"));
        parameter Modelica.SIunits.Velocity winSpe(min=0) = 1
        "Wind speed (used if winSpe=Parameter)"
          annotation (Evaluate=true, Dialog(group="Data source"));
        Modelica.Blocks.Interfaces.RealInput winSpe_in(
          final quantity="Velocity",
          final unit="m/s",
          min=0,
          displayUnit="m/s") if (winSpeSou == Buildings.BoundaryConditions.Types.DataSource.Input)
        "Input wind speed"
          annotation (Placement(transformation(extent={{-240,0},{-200,40}}),
              iconTransformation(extent={{-240,0},{-200,40}})));
        //--------------------------------------------------------------
        // Wind direction
        parameter Buildings.BoundaryConditions.Types.DataSource winDirSou=Buildings.BoundaryConditions.Types.DataSource.File
        "Wind direction"   annotation (Evaluate=true, Dialog(group="Data source"));
        parameter Modelica.SIunits.Angle winDir=1.0
        "Wind direction (used if winDir=Parameter)"
          annotation (Evaluate=true, Dialog(group="Data source"));
        Modelica.Blocks.Interfaces.RealInput winDir_in(
          final quantity="Angle",
          final unit="rad",
          displayUnit="deg") if (winDirSou == Buildings.BoundaryConditions.Types.DataSource.Input)
        "Input wind direction"
          annotation (Placement(transformation(extent={{-240,-60},{-200,-20}}),
              iconTransformation(extent={{-240,-60},{-200,-20}})));
        //--------------------------------------------------------------
        // Global horizontal radiation
        parameter Buildings.BoundaryConditions.Types.DataSource HGloHorSou=Buildings.BoundaryConditions.Types.DataSource.File
        "Global horizontal radiation"
          annotation (Evaluate=true, Dialog(group="Data source"));
        parameter Modelica.SIunits.RadiantEnergyFluenceRate HGloHor=100
        "Global horizontal radiation (used if HGloHor=Parameter)"
          annotation (Evaluate=true, Dialog(group="Data source"));
        Modelica.Blocks.Interfaces.RealInput HGloHor_in(
          final quantity="RadiantEnergyFluenceRate",
          final unit="W/m2",
          displayUnit="W/m2") = 100 if (HGloHorSou == Buildings.BoundaryConditions.Types.DataSource.Input)
        "Input global horizontal radiation"
          annotation (Placement(transformation(extent={{-240,-120},{-200,-80}}),
              iconTransformation(extent={{-240,-120},{-200,-80}})));
        //--------------------------------------------------------------
        // Diffuse horizontal radiation
        parameter Buildings.BoundaryConditions.Types.DataSource HDifHorSou=Buildings.BoundaryConditions.Types.DataSource.File
        "Diffuse horizontal radiation"
          annotation (Evaluate=true, Dialog(group="Data source"));
        parameter Modelica.SIunits.RadiantEnergyFluenceRate HDifHor=50
        "Diffuse horizontal radiation (used if HDifHor=Parameter)"
          annotation (Evaluate=true, Dialog(group="Data source"));
        Modelica.Blocks.Interfaces.RealInput HDifHor_in(
          final quantity="RadiantEnergyFluenceRate",
          final unit="W/m2",
          displayUnit="W/m2") if (HDifHorSou == Buildings.BoundaryConditions.Types.DataSource.Input)
        "Input diffuse horizontal radiation"
          annotation (Placement(transformation(extent={{-240,-180},{-200,-140}}),
              iconTransformation(extent={{-240,-180},{-200,-140}})));
        parameter String filNam "Name of weather data file" annotation (Dialog(
              __Dymola_loadSelector(filter="Weather files (*.mos)", caption=
                  "Select weather file")));
        final parameter Modelica.SIunits.Angle lon(displayUnit="deg")=
          Buildings.BoundaryConditions.WeatherData.BaseClasses.getLongitudeTMY3(
          filNam) "Longitude";
        final parameter Modelica.SIunits.Time timZon(displayUnit="h")=
          Buildings.BoundaryConditions.WeatherData.BaseClasses.getTimeZoneTMY3(filNam)
        "Time zone";
        Bus weaBus "Weather Data Bus" annotation (Placement(transformation(extent={{
                  294,-10},{314,10}}), iconTransformation(extent={{190,-10},{210,10}})));
        parameter Buildings.BoundaryConditions.Types.SkyTemperatureCalculation
          calTSky=Buildings.BoundaryConditions.Types.SkyTemperatureCalculation.TemperaturesAndSkyCover
        "Computation of black-body sky temperature"   annotation (
          choicesAllMatching=true,
          Evaluate=true,
          Dialog(group="Sky temperature"));
    protected
        Modelica.Blocks.Tables.CombiTable1Ds datRea(
          final tableOnFile=true,
          final tableName="tab1",
          final fileName=filNam,
          final smoothness=Modelica.Blocks.Types.Smoothness.ContinuousDerivative,
          final columns={2,3,4,5,6,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,
              28,29,30}) "Data reader"
          annotation (Placement(transformation(extent={{-80,-40},{-60,-20}})));
        Buildings.BoundaryConditions.WeatherData.BaseClasses.CheckTemperature
          cheTemDryBul "Check dry bulb temperature "
          annotation (Placement(transformation(extent={{160,-200},{180,-180}})));
        Buildings.BoundaryConditions.WeatherData.BaseClasses.CheckTemperature
          cheTemDewPoi "Check dew point temperature"
          annotation (Placement(transformation(extent={{160,-240},{180,-220}})));
        Buildings.BoundaryConditions.WeatherData.BaseClasses.ConvertRelativeHumidity
          conRelHum "Convert the relative humidity from percentage to [0, 1] "
          annotation (Placement(transformation(extent={{120,20},{140,40}})));
        BaseClasses.CheckPressure chePre "Check the air pressure"
          annotation (Placement(transformation(extent={{160,60},{180,80}})));
        BaseClasses.CheckSkyCover cheTotSkyCov "Check the total sky cover"
          annotation (Placement(transformation(extent={{160,-40},{180,-20}})));
        BaseClasses.CheckSkyCover cheOpaSkyCov "Check the opaque sky cover"
          annotation (Placement(transformation(extent={{160,-160},{180,-140}})));
        BaseClasses.CheckRadiation cheGloHorRad
        "Check the global horizontal radiation"
          annotation (Placement(transformation(extent={{160,160},{180,180}})));
        BaseClasses.CheckRadiation cheDifHorRad
        "Check the diffuse horizontal radiation"
          annotation (Placement(transformation(extent={{160,120},{180,140}})));
        BaseClasses.CheckRadiation cheDirNorRad
        "Check the direct normal radiation"
          annotation (Placement(transformation(extent={{160,200},{180,220}})));
        BaseClasses.CheckCeilingHeight cheCeiHei "Check the ceiling height"
          annotation (Placement(transformation(extent={{160,-120},{180,-100}})));
        BaseClasses.CheckWindSpeed cheWinSpe "Check the wind speed"
          annotation (Placement(transformation(extent={{160,-80},{180,-60}})));
        BaseClasses.CheckRadiation cheHorRad "Check the horizontal radiation"
          annotation (Placement(transformation(extent={{160,240},{180,260}})));
        BaseClasses.CheckWindDirection cheWinDir "Check the wind direction"
          annotation (Placement(transformation(extent={{160,-280},{180,-260}})));
        SkyTemperature.BlackBody TBlaSky(final calTSky=calTSky)
        "Check the sky black-body temperature"
          annotation (Placement(transformation(extent={{240,-220},{260,-200}})));
        Utilities.SimulationTime simTim "Simulation time"
          annotation (Placement(transformation(extent={{-180,-10},{-160,10}})));
        Modelica.Blocks.Math.Add add
        "Add 30 minutes to time to shift weather data reader"
          annotation (Placement(transformation(extent={{-140,160},{-120,180}})));
        Modelica.Blocks.Sources.Constant con30mins(final k=1800)
        "Constant used to shift weather data reader"
          annotation (Placement(transformation(extent={{-180,192},{-160,212}})));
        Buildings.BoundaryConditions.WeatherData.BaseClasses.LocalCivilTime locTim(
            final lon=lon, final timZon=timZon) "Local civil time"
          annotation (Placement(transformation(extent={{-120,-160},{-100,-140}})));
        Modelica.Blocks.Tables.CombiTable1Ds datRea1(
          final tableOnFile=true,
          final tableName="tab1",
          final fileName=filNam,
          final smoothness=Modelica.Blocks.Types.Smoothness.ContinuousDerivative,
          final columns=8:11) "Data reader"
          annotation (Placement(transformation(extent={{-80,160},{-60,180}})));
        Buildings.BoundaryConditions.WeatherData.BaseClasses.ConvertTime conTim1
        "Convert simulation time to calendar time"
          annotation (Placement(transformation(extent={{-110,160},{-90,180}})));
        BaseClasses.ConvertTime conTim
        "Convert simulation time to calendar time"
          annotation (Placement(transformation(extent={{-120,-40},{-100,-20}})));
        BaseClasses.EquationOfTime eqnTim "Equation of time"
          annotation (Placement(transformation(extent={{-120,-120},{-100,-100}})));
        BaseClasses.SolarTime solTim "Solar time"
          annotation (Placement(transformation(extent={{-80,-140},{-60,-120}})));
        // Conditional connectors
        Modelica.Blocks.Interfaces.RealInput pAtm_in_internal(
          final quantity="Pressure",
          final unit="Pa",
          displayUnit="bar") "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput TDryBul_in_internal(
          final quantity="Temperature",
          final unit="K",
          displayUnit="degC") "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput relHum_in_internal(
          final quantity="1",
          min=0,
          max=1) "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput winSpe_in_internal(
          final quantity="Velocity",
          final unit="m/s",
          displayUnit="m/s") "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput winDir_in_internal(
          final quantity="Angle",
          final unit="rad",
          displayUnit="deg") "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput HGloHor_in_internal(
          final quantity="RadiantEnergyFluenceRate",
          final unit="W/m2",
          displayUnit="W/m2") "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput HDifHor_in_internal(
          final quantity="RadiantEnergyFluenceRate",
          final unit="W/m2",
          displayUnit="W/m2") "Needed to connect to conditional connector";
        Modelica.Blocks.Math.UnitConversions.From_deg conWinDir
        "Convert the wind direction unit from [deg] to [rad]"
          annotation (Placement(transformation(extent={{120,-280},{140,-260}})));
        Modelica.Blocks.Math.UnitConversions.From_degC conTDryBul
          annotation (Placement(transformation(extent={{120,-200},{140,-180}})));
        BaseClasses.ConvertRadiation conHorRad
          annotation (Placement(transformation(extent={{120,240},{140,260}})));
        Modelica.Blocks.Math.UnitConversions.From_degC conTDewPoi
        "Convert the dew point temperature form [degC] to [K]"
          annotation (Placement(transformation(extent={{120,-240},{140,-220}})));
        BaseClasses.ConvertRadiation conDirNorRad
          annotation (Placement(transformation(extent={{120,200},{140,220}})));
        BaseClasses.ConvertRadiation conGloHorRad
          annotation (Placement(transformation(extent={{120,160},{140,180}})));
        BaseClasses.ConvertRadiation conDifHorRad
          annotation (Placement(transformation(extent={{120,120},{140,140}})));
        BaseClasses.CheckRelativeHumidity cheRelHum
          annotation (Placement(transformation(extent={{160,20},{180,40}})));
      equation
        //---------------------------------------------------------------------------
        // Select atmospheric pressure connector
        if pAtmSou == Buildings.BoundaryConditions.Types.DataSource.Parameter then
          pAtm_in_internal = pAtm;
        elseif pAtmSou == Buildings.BoundaryConditions.Types.DataSource.File then
          connect(datRea.y[4], pAtm_in_internal);
        else
          connect(pAtm_in, pAtm_in_internal);
        end if;
        connect(pAtm_in_internal, chePre.PIn);
        //---------------------------------------------------------------------------
        // Select dry bulb temperature connector
        if TDryBulSou == Buildings.BoundaryConditions.Types.DataSource.Parameter then
          TDryBul_in_internal = TDryBul;
        elseif TDryBulSou == Buildings.BoundaryConditions.Types.DataSource.Input then
          connect(TDryBul_in, TDryBul_in_internal);
        else
          connect(conTDryBul.y, TDryBul_in_internal);
        end if;
        connect(TDryBul_in_internal, cheTemDryBul.TIn);
        //---------------------------------------------------------------------------
        // Select relative humidity connector
        if relHumSou == Buildings.BoundaryConditions.Types.DataSource.Parameter then
          relHum_in_internal = relHum;
        elseif relHumSou == Buildings.BoundaryConditions.Types.DataSource.Input then
          connect(relHum_in, relHum_in_internal);
        else
          connect(conRelHum.relHumOut, relHum_in_internal);
        end if;
        connect(relHum_in_internal, cheRelHum.relHumIn);
        //---------------------------------------------------------------------------
        // Select wind speed connector
        if winSpeSou == Buildings.BoundaryConditions.Types.DataSource.Parameter then
          winSpe_in_internal = winSpe;
        elseif winSpeSou == Buildings.BoundaryConditions.Types.DataSource.Input then
          connect(winSpe_in, winSpe_in_internal);
        else
          connect(datRea.y[12], winSpe_in_internal);
        end if;
        connect(winSpe_in_internal, cheWinSpe.winSpeIn);
        //---------------------------------------------------------------------------
        // Select wind direction connector
        if winDirSou == Buildings.BoundaryConditions.Types.DataSource.Parameter then
          winDir_in_internal = winDir;
        elseif winDirSou == Buildings.BoundaryConditions.Types.DataSource.Input then
          connect(winDir_in, winDir_in_internal);
        else
          connect(conWinDir.y, winDir_in_internal);
        end if;
        connect(winDir_in_internal, cheWinDir.nIn);
        //---------------------------------------------------------------------------
        // Select global horizontal radiation connector
        if HGloHorSou == Buildings.BoundaryConditions.Types.DataSource.Parameter then
          HGloHor_in_internal = HGloHor;
        elseif HGloHorSou == Buildings.BoundaryConditions.Types.DataSource.Input then
          connect(HGloHor_in, HGloHor_in_internal);
        else
          connect(conGloHorRad.HOut, HGloHor_in_internal);
        end if;
        connect(HGloHor_in_internal, cheGloHorRad.HIn);
        //---------------------------------------------------------------------------
        // Select diffuse horizontal radiation connector
        if HDifHorSou == Buildings.BoundaryConditions.Types.DataSource.Parameter then
          HDifHor_in_internal = HDifHor;
        elseif HDifHorSou == Buildings.BoundaryConditions.Types.DataSource.Input then
          connect(HDifHor_in, HDifHor_in_internal);
        else
          connect(conDifHorRad.HOut, HDifHor_in_internal);
        end if;
        connect(HDifHor_in_internal, cheDifHorRad.HIn);
        connect(chePre.POut, weaBus.pAtm) annotation (Line(
            points={{181,70},{220,70},{220,5.55112e-16},{304,5.55112e-16}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheTotSkyCov.nOut, weaBus.nTot) annotation (Line(
            points={{181,-30},{220,-30},{220,5.55112e-16},{304,5.55112e-16}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheOpaSkyCov.nOut, weaBus.nOpa) annotation (Line(
            points={{181,-150},{220,-150},{220,5.55112e-16},{304,5.55112e-16}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheGloHorRad.HOut, weaBus.HGloHor) annotation (Line(
            points={{181,170},{220,170},{220,5.55112e-16},{304,5.55112e-16}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheDifHorRad.HOut, weaBus.HDifHor) annotation (Line(
            points={{181,130},{220,130},{220,5.55112e-16},{304,5.55112e-16}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheDirNorRad.HOut, weaBus.HDirNor) annotation (Line(
            points={{181,210},{220,210},{220,5.55112e-16},{304,5.55112e-16}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheCeiHei.ceiHeiOut, weaBus.celHei) annotation (Line(
            points={{181,-110},{220,-110},{220,5.55112e-16},{304,5.55112e-16}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheWinSpe.winSpeOut, weaBus.winSpe) annotation (Line(
            points={{181,-70},{220,-70},{220,5.55112e-16},{304,5.55112e-16}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheHorRad.HOut, weaBus.radHor) annotation (Line(
            points={{181,250},{220,250},{220,5.55112e-16},{304,5.55112e-16}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheWinDir.nOut, weaBus.winDir) annotation (Line(
            points={{181,-270},{280,-270},{280,5.55112e-16},{304,5.55112e-16}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheOpaSkyCov.nOut, TBlaSky.nOpa) annotation (Line(
            points={{181,-150},{220,-150},{220,-213},{238,-213}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(cheHorRad.HOut, TBlaSky.radHor) annotation (Line(
            points={{181,250},{220,250},{220,-218},{238,-218}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(TBlaSky.TBlaSky, weaBus.TBlaSky) annotation (Line(
            points={{261,-210},{280,-210},{280,0},{292,0},{292,5.55112e-16},{304,
                5.55112e-16}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(simTim.y, weaBus.cloTim) annotation (Line(
            points={{-159,6.10623e-16},{34.75,6.10623e-16},{34.75,0},{124.5,0},{124.5,
                5.55112e-16},{304,5.55112e-16}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(simTim.y, add.u2) annotation (Line(
            points={{-159,6.10623e-16},{-150,6.10623e-16},{-150,164},{-142,164}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(con30mins.y, add.u1) annotation (Line(
            points={{-159,202},{-150,202},{-150,176},{-142,176}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(add.y, conTim1.simTim) annotation (Line(
            points={{-119,170},{-112,170}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(conTim1.calTim, datRea1.u) annotation (Line(
            points={{-89,170},{-82,170}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(simTim.y, locTim.cloTim) annotation (Line(
            points={{-159,6.10623e-16},{-150,6.10623e-16},{-150,-150},{-122,-150}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(simTim.y, conTim.simTim) annotation (Line(
            points={{-159,6.10623e-16},{-150,6.10623e-16},{-150,-30},{-122,-30}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(conTim.calTim, datRea.u) annotation (Line(
            points={{-99,-30},{-82,-30}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(simTim.y, eqnTim.nDay) annotation (Line(
            points={{-159,6.10623e-16},{-150,6.10623e-16},{-150,-110},{-122,-110}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(eqnTim.eqnTim, solTim.equTim) annotation (Line(
            points={{-99,-110},{-88,-110},{-88,-124},{-82,-124}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(locTim.locTim, solTim.locTim) annotation (Line(
            points={{-99,-150},{-88,-150},{-88,-135.4},{-82,-135.4}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(solTim.solTim, weaBus.solTim) annotation (Line(
            points={{-59,-130},{-20,-130},{-20,0},{284,0},{284,5.55112e-16},{304,
                5.55112e-16}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(datRea.y[13], cheTotSkyCov.nIn) annotation (Line(
            points={{-59,-30},{158,-30}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(datRea.y[14], cheOpaSkyCov.nIn) annotation (Line(
            points={{-59,-30},{20,-30},{20,-150},{158,-150}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(datRea.y[16], cheCeiHei.ceiHeiIn) annotation (Line(
            points={{-59,-30},{20,-30},{20,-110},{158,-110}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(datRea.y[11], conWinDir.u) annotation (Line(
            points={{-59,-30},{20,-30},{20,-270},{118,-270}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(datRea1.y[1], conHorRad.HIn) annotation (Line(
            points={{-59,170},{20,170},{20,250},{118,250}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(conHorRad.HOut, cheHorRad.HIn) annotation (Line(
            points={{141,250},{158,250}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(cheTemDryBul.TOut, TBlaSky.TDryBul) annotation (Line(
            points={{181,-190},{220,-190},{220,-202},{238,-202}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(datRea.y[1], conTDryBul.u) annotation (Line(
            points={{-59,-30},{20,-30},{20,-190},{118,-190}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(datRea.y[2], conTDewPoi.u) annotation (Line(
            points={{-59,-30},{20,-30},{20,-230},{118,-230}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(conTDewPoi.y, cheTemDewPoi.TIn) annotation (Line(
            points={{141,-230},{158,-230}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(cheTemDewPoi.TOut, weaBus.TDewPoi) annotation (Line(
            points={{181,-230},{280,-230},{280,5.55112e-16},{304,5.55112e-16}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(TBlaSky.TDewPoi, cheTemDewPoi.TOut) annotation (Line(
            points={{238,-207},{220,-207},{220,-230},{181,-230}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(datRea1.y[3], conDirNorRad.HIn) annotation (Line(
            points={{-59,170},{20,170},{20,210},{118,210}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(conDirNorRad.HOut, cheDirNorRad.HIn) annotation (Line(
            points={{141,210},{158,210}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(datRea1.y[2], conGloHorRad.HIn) annotation (Line(
            points={{-59,170},{118,170}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(datRea1.y[4], conDifHorRad.HIn) annotation (Line(
            points={{-59,170},{20,170},{20,130},{118,130}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(conRelHum.relHumIn, datRea.y[3]) annotation (Line(
            points={{118,30},{20,30},{20,-30},{-59,-30}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(cheRelHum.relHumOut, weaBus.relHum) annotation (Line(
            points={{181,30},{280,30},{280,5.55112e-16},{304,5.55112e-16}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheTemDryBul.TOut, weaBus.TDryBul) annotation (Line(
            points={{181,-190},{280,-190},{280,5.55112e-16},{304,5.55112e-16}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        annotation (
          defaultComponentName="weaDat",
          Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-200,-200},{200,200}},
              initialScale=0.05), graphics={
              Rectangle(
                extent={{-200,-200},{200,200}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-162,270},{138,230}},
                textString="%name",
                lineColor={0,0,255}),
              Ellipse(
                extent={{-64,72},{80,-66}},
                lineColor={255,0,0},
                fillColor={255,0,0},
                fillPattern=FillPattern.Solid,
                lineThickness=1),
              Line(
                points={{6,116},{6,78}},
                color={255,0,0},
                smooth=Smooth.None,
                thickness=1),
              Line(
                points={{10,-78},{10,-116}},
                color={255,0,0},
                smooth=Smooth.None,
                thickness=1),
              Line(
                points={{0,19},{0,-19}},
                color={255,0,0},
                smooth=Smooth.None,
                thickness=1,
                origin={110,1},
                rotation=90),
              Line(
                points={{0,19},{0,-19}},
                color={255,0,0},
                smooth=Smooth.None,
                thickness=1,
                origin={-96,-1},
                rotation=90),
              Line(
                points={{25,10},{0,-19}},
                color={255,0,0},
                smooth=Smooth.None,
                thickness=1,
                origin={-76,55},
                rotation=90),
              Line(
                points={{25,10},{0,-19}},
                color={255,0,0},
                smooth=Smooth.None,
                thickness=1,
                origin={80,-83},
                rotation=90),
              Line(
                points={{102,82},{72,56}},
                color={255,0,0},
                smooth=Smooth.None,
                thickness=1),
              Line(
                points={{-58,-62},{-88,-88}},
                color={255,0,0},
                smooth=Smooth.None,
                thickness=1),
              Text(
                visible=(pAtmSou == Buildings.BoundaryConditions.Types.DataSource.Input),
                extent={{-190,216},{-164,184}},
                lineColor={0,0,127},
                textString="p"),
              Text(
                visible=(TDryBulSou == Buildings.BoundaryConditions.Types.DataSource.Input),
                extent={{-194,162},{-118,118}},
                lineColor={0,0,127},
                textString="TDryBul"),
              Text(
                visible=(relHumSou == Buildings.BoundaryConditions.Types.DataSource.Input),
                extent={{-190,92},{-104,66}},
                lineColor={0,0,127},
                textString="relHum"),
              Text(
                visible=(winSpeSou == Buildings.BoundaryConditions.Types.DataSource.Input),
                extent={{-196,44},{-110,2}},
                lineColor={0,0,127},
                textString="winSpe"),
              Text(
                visible=(winDirSou == Buildings.BoundaryConditions.Types.DataSource.Input),
                extent={{-192,-18},{-106,-60}},
                lineColor={0,0,127},
                textString="winDir"),
              Text(
                visible=(HGloHorSou == Buildings.BoundaryConditions.Types.DataSource.Input),
                extent={{-188,-82},{-98,-122}},
                lineColor={0,0,127},
                textString="HGloHor"),
              Text(
                visible=(HDifHorSou == Buildings.BoundaryConditions.Types.DataSource.Input),
                extent={{-192,-148},{-98,-172}},
                lineColor={0,0,127},
                textString="HDifHor")}),
          Documentation(info="<html>
<p>
This component reads TMY3 weather data (Wilcox and Marion, 2008) or user specified weather data. 
The parameter 
<code>lon</code> is the longitude of the weather station, and 
the parameter <code>timZone</code> is the time zone
relative to Greenwich Mean Time. 
By default, the reader obtains values for these parameters 
by scanning the TMY3 weather data file except the atmospheric pressure which use 101325 Pascals as default value.
</p>
This model has the option of using a constant value, using the data from the weather file, 
or from an input connector for the following variables: 
atmospheric pressure, relative humidity, dry bulb temperature, 
global horizontal radiation, diffuse horizontal radiation, wind direction and wind speed.
<p>
For instance, the atmospheric pressure is set to the parameter <code>pAtm = 101325</code> Pascals.
The parameter <code>pAtmSou</code> can be used to change the source that is used as the atmospheric pressure.
The input connector will be enabled if 
<code>pAtmSou = Buildings.BoundaryConditions.Types.DataSource.Input</code>.
The the weather file will be read if
<code>pAtmSou = Buildings.BoundaryConditions.Types.DataSource.File</code>.
</p>
<b>Note:</b> In HVAC systems, when the fan is off, changes in atmospheric pressure can cause small air flow rates
in the duct system due to change in pressure and hence in the mass of air that is stored
in air volumes (such as in fluid junctions or in the room model). 
This may increase computing time. Therefore, the default value for the atmospheric pressure
is set to a constant.
Furthermore, if the initial pressure of air volumes are different
from the atmospheric pressure, then fast pressure transients can happen in the first few seconds of the simulation.
This can cause numerical problems for the solver. To avoid this problem, set the atmospheric pressure to the
same value as the medium default pressure, which is typically set to the parameter <code>Medium.p_default</code>.
</p>
<h4>Implementation</h4>
<p>
To read weather data from the TMY3 weather data file, there are
two data readers in this model. One data reader obtains all data
except solar radiation, and the other data reader reads only the
solar radiation data, shifted by <i>30</i> minutes.
The reason for this time shift is as follows:
The TMY3 weather data file contains for solar radiation the 
\"...radiation received
on a horizontal surface during
the 60-minute period ending at
the timestamp.\"

Thus, as the figure below shows, a more accurate interpolation is obtained if 
time is shifted by <i>30</i> minutes prior to reading the weather data.   
</p>
<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/BoundaryConditions/WeatherData/RadiationTimeShift.png\" border=\"1\">
</p>
<b>Note:</b>The data units of user specified input files should be SI units consistent with Modelica standard. 
For instance, the unit for the solar radiation should be <code>W/m2</code> and that for the wind direction should be <code>rad</code>.
<h4>References</h4>
<p>
<ul>
<li>
Wilcox S. and W. Marion. <i>Users Manual for TMY3 Data Sets</i>. 
Technical Report, NREL/TP-581-43156, revised May 2008.
</li>
</ul>
</p>
</html>
",       revisions="<html>
<ul>
<li>
November 29, 2011, by Michael Wetter:<br>
Fixed wrong display unit for <code>pAtm_in_internal</code> and 
made propagation of parameter final.
</li>
<li>
October 27, 2011, by Wangda Zuo:<br>
1. Added optional connectors for dry bulb temperature, relative humidity, wind speed, wind direction, global horizontal radiation, diffuse horizontal radiation.<br>
2. Separate the unit convertion for TMY3 data and data validity check. 
</li>
<li>
October 3, 2011, by Michael Wetter:<br>
Propagated value for sky temperature calculation to make it accessible as a parameter.
</li>
<li>
July 20, 2011, by Michael Wetter:<br>
Added the option to use a constant, an input signal or the weather file as the source
for the atmospheric pressure.
</li><li>
March 15, 2011, by Wangda Zuo:<br>
Delete the wet bulb temperature since it may cause numerical problem.
</li>
<li>
March 7, 2011, by Wangda Zuo:<br>
Added wet bulb temperature. Changed reader to read only needed columns. 
Added explanation for 30 minutes shift for radiation data.  
</li>
<li>
March 5, 2011, by Michael Wetter:<br>
Changed implementation to obtain longitude and time zone directly
from weather file.
</li>
<li>
June 25, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"),Diagram(coordinateSystem(preserveAspectRatio=true,extent={{-200,-300},{300,
                  300}}), graphics));
      end ReaderTMY3;

      expandable connector Bus "Data bus that stores weather data"
        extends Modelica.Icons.SignalBus;

        annotation (
          defaultComponentName="weaBus",
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={Rectangle(
                extent={{-20,2},{22,-2}},
                lineColor={255,204,51},
                lineThickness=0.5)}),
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics),
          Documentation(info="<html>
<p>
This component is an expandable connector that is used to implement a bus that contains the weather data.
</p>
</html>
",       revisions="<html>
<ul>
<li>
June 25, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"));
      end Bus;

      package BaseClasses
      "Package with base classes for Buildings.BoundaryConditions.WeatherData"
        extends Modelica.Icons.BasesPackage;

        block CheckCeilingHeight
        "Ensures that the ceiling height is above a lower bound"
          extends Modelica.Blocks.Interfaces.BlockIcon;
      public
          Modelica.Blocks.Interfaces.RealInput ceiHeiIn(final quantity="Height", final unit=
                   "m") "Input ceiling height"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput ceiHeiOut(final quantity="Height",
              final unit="m") "Ceiling height"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          constant Modelica.SIunits.Height ceiHeiMin=0
          "Minimum allowed ceiling height";
        equation

          ceiHeiOut = Buildings.Utilities.Math.Functions.smoothMax(
            ceiHeiIn,
            ceiHeiMin,
            0.1);

          annotation (
            defaultComponentName="cheCeiHei",
            Documentation(info="<html>
<p>
This component ensures that the ceiling height is at least <i>0</i> meters.
</p>
</html>
",         revisions="<html>
<ul>
<li>
July 14, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"),  Diagram(coordinateSystem(preserveAspectRatio=true,extent={{-100,-100},{100,
                    100}}), graphics),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-28,42},{26,-34}},
                  lineColor={0,0,255},
                  textString="m")}));
        end CheckCeilingHeight;

        block CheckRadiation "Ensure that the radiation is not smaller than 0"
          extends Modelica.Blocks.Interfaces.BlockIcon;
      public
          Modelica.Blocks.Interfaces.RealInput HIn(final quantity=
                "RadiantEnergyFluenceRate", final unit="W/m2")
          "Input radiation"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput HOut(final quantity=
                "RadiantEnergyFluenceRate", final unit="W/m2") "Radiation"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

          constant Modelica.SIunits.RadiantEnergyFluenceRate HMin=0.0001
          "Minimum value for radiation";
        equation

          HOut = Buildings.Utilities.Math.Functions.smoothMax(
            x1=HIn,
            x2=HMin,
            deltaX=HMin/10);
          annotation (
            defaultComponentName="cheRad",
            Documentation(info="<html>
<p>
This component ensures that the radiation is not smaller than 0. 
Modelica Table will interpolate data when it reads the data from a file.
Thus, it is possible to generate negative value due to the interpolation.
</p>
</html>
",         revisions="<html>
<ul>
<li>
October 27, 2011, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"),  Diagram(coordinateSystem(preserveAspectRatio=true,extent={{-100,-100},{100,
                    100}}), graphics),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-24,44},{30,-32}},
                  lineColor={0,0,255},
                  textString="H")}));
        end CheckRadiation;

        block CheckRelativeHumidity "Check the validity of relative humidity"
          extends Modelica.Blocks.Interfaces.BlockIcon;
      public
          Modelica.Blocks.Interfaces.RealInput relHumIn(final unit="1")
          "Input relative humidity"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput relHumOut(final unit="1")
          "Relative humidity"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          constant Real delta=0.01 "Smoothing parameter";
      protected
          constant Real relHumMin=delta "Lower bound";
          constant Real relHumMax=1 - delta "Upper bound";

        equation
          relHumOut = Buildings.Utilities.Math.Functions.smoothLimit(
            relHumIn,
            relHumMin,
            relHumMax,
            delta/10);
          annotation (
            defaultComponentName="cheRelHum",
            Documentation(info="<html>
<p>
This component constrains the value of relative humidity to a range of <i>[0, 1]</i>.
</p>
</html>
",         revisions="<html>
<ul>
<li>
October 27, 2011, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"),  Diagram(coordinateSystem(preserveAspectRatio=true,extent={{-100,-100},{100,
                    100}}), graphics),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Bitmap(extent={{-56,52},{62,-42}}, fileName=
                      "modelica://Buildings/Resources/Images/Utilities/IO/WeatherData/BaseClasses/RelativeHumidity.png")}));
        end CheckRelativeHumidity;

        block CheckPressure
        "Ensures that the interpolated pressure is between prescribed bounds"
          extends Modelica.Blocks.Interfaces.BlockIcon;
      public
          Modelica.Blocks.Interfaces.RealInput PIn(final quantity="Pressure", final unit=
                   "Pa") "Input pressure"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput POut(final quantity="Pressure", final unit=
                   "Pa") "Atmospheric pressure"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          constant Modelica.SIunits.Pressure PMin=3100
          "Minimum allowed pressure";
          constant Modelica.SIunits.Pressure PMax=120000
          "Maximum allowed pressure";
        equation
          assert(PIn > PMin, "Pressure out of bounds.\n" + "   PIn = " + String(PIn));
          assert(PIn < PMax, "Pressure out of bounds.\n" + "   PIn = " + String(PIn));
          POut = PIn;

          annotation (
            defaultComponentName="chePre",
            Documentation(info="<html>
<p>
This component ensures that the interpolated pressure is between <i>31,000</i> Pa and <i>120,000</i> Pa.
</p>
</html>
",         revisions="<html>
<ul>
<li>
July 14, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"),  Diagram(coordinateSystem(preserveAspectRatio=true,extent={{-100,-100},{100,
                    100}}), graphics),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-28,42},{26,-34}},
                  lineColor={0,0,255},
                  textString="P")}));
        end CheckPressure;

        block CheckSkyCover "Constrains the sky cover to [0, 1]"
          extends Modelica.Blocks.Interfaces.BlockIcon;
      public
          Modelica.Blocks.Interfaces.RealInput nIn "Input sky cover [0, 10]"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput nOut(unit="1")
          "Sky cover [0, 10]"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

          constant Real delta=0.01 "Smoothing parameter";
      protected
          constant Real nMin=delta "Lower bound";
          constant Real nMax=10 - delta "Upper bound";
        equation
          nOut = Buildings.Utilities.Math.Functions.smoothLimit(
            nIn,
            nMin,
            nMax,
            delta/10)/10;
          annotation (
            defaultComponentName="cheSkyCov",
            Documentation(info="<html>
<p>
This component constrains the interpolated sky cover between <i>0</i> and <i>10</i>.
</p>
</html>
",         revisions="<html>
<ul>
<li>
July 14, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"),  Diagram(coordinateSystem(preserveAspectRatio=true,extent={{-100,-100},{100,
                    100}}), graphics),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-34,56},{46,-48}},
                  lineColor={0,0,255},
                  textString="Sky")}));
        end CheckSkyCover;

        block CheckTemperature "Check the validity of temperature data"
          extends Modelica.Blocks.Interfaces.BlockIcon;
      public
          Modelica.Blocks.Interfaces.RealInput TIn(
            final quantity="Temperature",
            final unit="K",
            displayUnit="degC") "Input Temperature"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput TOut(
            final quantity="Temperature",
            final unit="K",
            displayUnit="degC") "Output temperature"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

          parameter Modelica.SIunits.Temperature TMin(displayUnit="degC") = 203.15
          "Minimum allowed temperature";
          parameter Modelica.SIunits.Temperature TMax(displayUnit="degC") = 343.15
          "Maximum allowed temperature";

        equation
          TOut = TIn;
          assert(TOut > TMin, "Temperature out of bounds.\n" + "   TOut = " + String(
            TOut));
          assert(TOut < TMax, "Temperature out of bounds.\n" + "   TOut = " + String(
            TOut));

          annotation (
            defaultComponentName="cheTem",
            Documentation(info="<html>
<p>
This component checks the value of temperature. 
If the temperature is outside <code>TMin</code> and <code>TMax</code>, 
the simulation will stop with an error.
</p>
</html>
",         revisions="<html>
<ul>
<li>
October 27, 2011, by Wangda Zuo:<br>
Delete the unit convertion part and name it from ConvertTemperature to CheckTemperature.
</li>
<li>
March 23, 2011, by Michael Wetter:<br>
Set <code>displayUnit</code> argument for temperature output signal.
</li>
<li>
July 08, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"),  Diagram(coordinateSystem(preserveAspectRatio=true,extent={{-100,-100},{100,
                    100}}), graphics),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{42,44},{-38,-36}},
                  lineColor={0,0,0},
                  textString="T")}));
        end CheckTemperature;

        block CheckWindDirection
        "Constrains the wind direction to [0, 2*pi] degree"
          extends Modelica.Blocks.Interfaces.BlockIcon;
      public
          Modelica.Blocks.Interfaces.RealInput nIn(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") "Input wind direction"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput nOut(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") "Wind direction"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

          constant Real delta=0.01 "Smoothing parameter";
      protected
          constant Real nMin=0 "Lower bound";
          constant Real nMax=2*Modelica.Constants.pi "Upper bound";
        equation

          nOut = Buildings.Utilities.Math.Functions.smoothLimit(
            nIn,
            nMin,
            nMax,
            delta/10);
          annotation (
            defaultComponentName="cheWinDir",
            Documentation(info="<html>
<p>
This component constrains the interpolated wind direction between <i>0</i> and <i>360</i> degree.
</p>
</html>
",         revisions="<html>
<ul>
<li>
October 27, 2011, by Wangda Zuo:<br>
Delete the unit convertion part since it will be done outside.
</li>
<li>
July 14, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"),  Diagram(coordinateSystem(preserveAspectRatio=true,extent={{-100,-100},{100,
                    100}}), graphics),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics));
        end CheckWindDirection;

        block CheckWindSpeed "Ensures that the wind speed is non-negative"
          extends Modelica.Blocks.Interfaces.BlockIcon;
      public
          Modelica.Blocks.Interfaces.RealInput winSpeIn(final quantity="Velocity",
              final unit="m/s") "Input wind speed"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput winSpeOut(final quantity="Velocity",
              final unit="m/s") "Wind speed"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          constant Modelica.SIunits.Velocity winSpeMin=1e-6
          "Minimum allowed wind speed";

        equation
          // Modelica Table will interpolate data when it reads the weather data file.
          // It can generate negative values due to the interpolation.
          winSpeOut = Buildings.Utilities.Math.Functions.smoothMax(
            x1=winSpeIn,
            x2=winSpeMin,
            deltaX=winSpeMin/10);

          annotation (
            defaultComponentName="cheWinSpe",
            Documentation(info="<html>
<p>
This component ensures that the wind speed is non-negative.
</p>
</html>
",         revisions="<html>
<ul>
<li>
July 14, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"),  Diagram(coordinateSystem(preserveAspectRatio=true,extent={{-100,-100},{100,
                    100}}), graphics),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-28,42},{26,-34}},
                  lineColor={0,0,255},
                  textString="m/s")}));
        end CheckWindSpeed;

        block ConvertRadiation
        "Convert the unit of solar radiation received from the TMY3 data file"
          extends Modelica.Blocks.Interfaces.BlockIcon;
      public
          Modelica.Blocks.Interfaces.RealInput HIn(final unit="W.h/m2")
          "Input radiation"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput HOut(final quantity=
                "RadiantEnergyFluenceRate", final unit="W/m2") "Radiation"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

      protected
          constant Modelica.SIunits.Time Hou=3600 "1 hour";

        equation
          HOut = HIn/Modelica.SIunits.Conversions.to_hour(Hou);
          annotation (
            defaultComponentName="conRad",
            Documentation(info="<html>
<p>
The TMY3 data for solar radiation is the radiation accumulated in one hour. Thus, it used a unit of <code>Wh/m2</code>.
This component converts <code>Wh/m2</code> to <code>W/m2</code> that is the standard unit in Modelica.
</p>
</html>
",         revisions="<html>
<ul>
<li>
October 27, 2011, by Wangda Zuo:<br>
Add the unit conversion and delete the data validity check.
</li>
<li>
July 14, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"),  Diagram(coordinateSystem(preserveAspectRatio=true,extent={{-100,-100},{100,
                    100}}), graphics),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-24,44},{30,-32}},
                  lineColor={0,0,255},
                  textString="H")}));
        end ConvertRadiation;

        block ConvertRelativeHumidity
        "Convert the relative humidity from percentage to real"
          extends Modelica.Blocks.Interfaces.BlockIcon;
      public
          Modelica.Blocks.Interfaces.RealInput relHumIn(unit="1")
          "Value of relative humidity in percentage"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput relHumOut(unit="1")
          "Relative humidity between 0 and 1"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        equation
          relHumOut = relHumIn/100;
          annotation (
            defaultComponentName="conRelHum",
            Documentation(info="<html>
<p>
This component converts the relative humidity from percentage to real.
Input is the relative humidity in percentage, as this is the data
format that is used in the Typical Meteorological Year weather data.
</p>
</html>
",         revisions="<html>
<ul>
<li>
October 27, 2011, by Wangda Zuo:<br>
Separate the checking function to CheckRelativeHumidity.
</li>
<li>
July 14, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"),  Diagram(coordinateSystem(preserveAspectRatio=true,extent={{-100,-100},{100,
                    100}}), graphics),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Bitmap(extent={{-56,52},{62,-42}}, fileName=
                      "modelica://Buildings/Resources/Images/Utilities/IO/WeatherData/BaseClasses/RelativeHumidity.png")}));
        end ConvertRelativeHumidity;

        block ConvertTime
        "Converts the simulation time to calendar time in scale of 1 year (365 days)"
          extends Modelica.Blocks.Interfaces.BlockIcon;
      public
          Modelica.Blocks.Interfaces.RealInput simTim(final quantity="Time", final unit=
               "s") "Simulation time"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput calTim(final quantity="Time", final
              unit="s") "Calendar time"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

      protected
          constant Modelica.SIunits.Time year=31536000
          "Number of seconds in a year";
          discrete Modelica.SIunits.Time tStart "Start time of period";
          //Integer count "Period count";

        initial algorithm
          tStart := integer(simTim/year)*year;
        equation
          when simTim - pre(tStart) > year then
            tStart = integer(simTim/year)*year;
          end when;
          calTim = simTim - tStart;
          annotation (
            defaultComponentName="conTim",
            Documentation(info="<html>
<p>
This component converts the simulation time to calendar time in a scale of 1 year (365 days).
</p>
</html>
",         revisions="<html>
<ul>
<li>
September 27, 2011, by Wangda Zuo, Michael Wetter:<br>
Modify it to convert negative value of time. 
Use the when-then to allow dymola differentiating this model when conducting index reduction which is not allowed in previous implementation.
</li>
<li>
February 27, 2011, by Wangda Zuo:<br>
Renamed the component.
</li>
<li>
July 08, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"),  Diagram(coordinateSystem(preserveAspectRatio=true,extent={{-100,-100},{100,
                    100}}), graphics),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Text(
                  extent={{-98,6},{-74,-4}},
                  lineColor={0,0,127},
                  textString="simTim"),
                Text(
                  extent={{74,6},{98,-4}},
                  lineColor={0,0,127},
                  textString="calTim"),
                Bitmap(extent={{-50,60},{52,-60}}, fileName=
                      "modelica://Buildings/Resources/Images/Utilities/IO/WeatherData/BaseClasses/calendar.png")}));
        end ConvertTime;

        block EquationOfTime "Equation of time"
          extends Modelica.Blocks.Interfaces.BlockIcon;
      public
          Modelica.Blocks.Interfaces.RealInput nDay(quantity="Time", unit="s")
          "Zero-based day number in seconds (January 1=0, January 2=86400)"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput eqnTim(
            final quantity="Time",
            final unit="s",
            displayUnit="min") "Equation of time"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
      protected
          Real Bt;
        equation
          Bt = Modelica.Constants.pi*((nDay + 86400)/86400 - 81)/182
          "Our unit is s instead of day in (A.4.2b)";
          eqnTim = 60*(9.87*Modelica.Math.sin(2*Bt) - 7.53*Modelica.Math.cos(Bt) - 1.5*
            Modelica.Math.sin(Bt)) "Our unit is s instead of min in (A.4.2a)";
          annotation (
            defaultComponentName="eqnTim",
            Documentation(info="<html>
<p>
This component computes the difference between solar noon and noon of local civic time.
</p>
</html>
",         revisions="<html>
<ul>
<li>
May 13, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"),  Diagram(coordinateSystem(preserveAspectRatio=true,extent={{-100,-100},{100,
                    100}}), graphics),
            Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-58,38},{38,-24}},
                  lineColor={0,0,255},
                  textString="t"),
                Text(
                  extent={{-6,4},{52,-24}},
                  lineColor={0,0,255},
                  textString="equ")}));
        end EquationOfTime;

        block LocalCivilTime "Converts the clock time to local civil time."
          extends Modelica.Blocks.Interfaces.BlockIcon;
      public
          Modelica.Blocks.Interfaces.RealInput cloTim(final quantity="Time", final unit=
               "s") "Clock time"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          parameter Modelica.SIunits.Time timZon(displayUnit="h") "Time zone";
          parameter Modelica.SIunits.Angle lon(displayUnit="deg") "Longitude";
          Modelica.Blocks.Interfaces.RealOutput locTim(final quantity="Time", final unit=
                   "s") "Local civil time"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

        equation
          locTim = cloTim - timZon + lon*43200/Modelica.Constants.pi;

          annotation (
            defaultComponentName="locTim",
            Documentation(info="<html>
<p>
This component converts the clock time to local civil time. 
The parameter <code>timZon</code> represents the time zone of the facility  (relative to Greenwich Mean Time or the 0th meridian). Time zones west of GMT (e.g. North America) are represented as negative; 
east of GMT as positive. Fraction of hours are represented in decimals (e.g. for <i>6:30</i>, use <i>6.5</i>).
</p>
<p>
The formula is based on Michael Wetter's thesis (A4.1):<pre>
  locTim = greTim + (lon*180/pi)*86400/360 = cloTim - timZon + lon*43200/pi 
</pre>
</p>
</html>
",         revisions="<html>
<ul>
<li>
February 27, 2011, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"),  Diagram(coordinateSystem(preserveAspectRatio=true,extent={{-100,-100},{100,
                    100}}), graphics),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-98,6},{-60,-6}},
                  lineColor={0,0,127},
                  textString="cloTim"), Text(
                  extent={{74,6},{98,-4}},
                  lineColor={0,0,127},
                  textString="calTim")}));
        end LocalCivilTime;

        block SolarTime "Solar time"
          extends Modelica.Blocks.Interfaces.BlockIcon;
      public
          Modelica.Blocks.Interfaces.RealInput locTim(quantity="Time", unit="s")
          "Local time"   annotation (Placement(transformation(extent={{-140,-74},{-100,
                    -34}}), iconTransformation(extent={{-140,-74},{-100,-34}})));
          Modelica.Blocks.Interfaces.RealInput equTim(quantity="Time", unit="s")
          "Equation of time"   annotation (Placement(transformation(extent={{-140,40},{
                    -100,80}}), iconTransformation(extent={{-140,40},{-100,80}})));
          Modelica.Blocks.Interfaces.RealOutput solTim(
            final quantity="Time",
            final unit="s",
            displayUnit="s") "Solar time"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        algorithm
          solTim := locTim + equTim "Our unit is s in stead of h in (A.4.3)";

          annotation (
            defaultComponentName="solTim",
            Documentation(info="<html>
<p>
This component computes the local solar time.
</p>
</html>
",         revisions="<html>
<ul>
<li>
Feb. 16, 2010, by Michael Wetter:<br>
Removed section that limits solar time to 
<code>0 &le; solTim &le; 86400</code> as this triggers
events, and is not needed because solar time is used in
trigonometric functions only.
</li>
<li>
May 13, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"),  Diagram(coordinateSystem(preserveAspectRatio=true,extent={{-100,-100},{100,
                    100}}), graphics),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-54,38},{42,-24}},
                  lineColor={0,0,255},
                  textString="t"),
                Text(
                  extent={{-4,4},{52,-24}},
                  lineColor={0,0,255},
                  textString="sol"),
                Text(
                  extent={{-94,66},{-42,50}},
                  lineColor={0,0,127},
                  textString="equTim"),
                Text(
                  extent={{-96,-44},{-44,-60}},
                  lineColor={0,0,127},
                  textString="locTim")}));
        end SolarTime;

        function getHeaderElementTMY3
        "Gets an element from the header of a TMY3 weather data file"
         input String filNam "Name of weather data file"
         annotation (Dialog(
                __Dymola_loadSelector(filter="Weather files (*.mos)", caption=
                    "Select weather file")));
         input String start "Start of the string that contains the elements";
         input String name = "longitude"
          "Name of data element, used in error reporting";
         input Integer position(min=1)
          "Position of the element on the line that contains 'start'";
         output String element
          "Element at position 'pos' of the line that starts with 'start'";
      protected
         String lin "Line that is used in parser";
         Integer iLin "Line number";
         Integer index "Index of string #LOCATION";
         Integer staInd "Start index used when parsing a real number";
         Integer nexInd "Next index used when parsing a real number";
         Boolean found "Flag, true if #LOCATION has been found";
         Boolean EOF "Flag, true if EOF has been reached";
         String fouDel "Found delimiter";
        algorithm
          // Get line that starts with 'start'
          iLin :=0;
          EOF :=false;
          while (not EOF) and (index == 0) loop
            iLin:=iLin + 1;
            (lin, EOF) :=Modelica.Utilities.Streams.readLine(fileName=filNam,
              lineNumber=iLin);
            index :=Modelica.Utilities.Strings.find(
              string=lin,
              searchString=start,
              startIndex=1,
              caseSensitive=false);
          end while;
          assert(not EOF, "Error: Did not find '" + start + "' when scanning the weather file."
                              + "\n   Check for correct weather file syntax.");
          // Loop over the tokens until the position is reached
          nexInd :=1;
          for i in 1:position-1 loop
          nexInd :=Modelica.Utilities.Strings.find(
              string=lin,
              searchString=  ",",
              startIndex=nexInd+1);
           assert(nexInd > 0, "Error when scanning weather file. Not enough tokens to find " + name + "."
                 + "\n   Check for correct file syntax." + "\n   The scanned line is '" +
                lin + "'.");
          end for;
          staInd := nexInd;
          // Find the next delimiter
          nexInd :=Modelica.Utilities.Strings.find(
              string=lin,
              searchString=  ",",
              startIndex=nexInd+1);
          assert(nexInd > 0, "Error when scanning weather file. Not enough tokens to find " + name + "."
                 + "\n   Check for correct file syntax." + "\n   The scanned line is '" +
                 lin + "'.");
          // Get the element
          element :=Modelica.Utilities.Strings.substring(lin, startIndex=staInd+1, endIndex=nexInd-1);
          annotation (Inline=false,
          Documentation(info="<html>
This function scans the weather data file for a line that starts with the string <pre>
start
</pre>
where <code>start</code> is a parameter.
When this line is found, the function returns the element at the position number
<code>position</code>, where <code>position</code> is a parameter.
A comma is used as the delimiter of the elements.
</html>",         revisions="<html>
<ul>
<li>
March 5, 2011, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end getHeaderElementTMY3;

        function getLongitudeTMY3
        "Gets the longitude from a TMY3 weather data file"
         input String filNam "Name of weather data file"
         annotation (Dialog(
                __Dymola_loadSelector(filter="Weather files (*.mos)", caption=
                    "Select weather file")));
         output Modelica.SIunits.Angle lon "Longitude from the weather file";
      protected
         Integer nexInd "Next index, used for error handling";
         String element "String representation of the returned element";
        algorithm
          element :=
            Buildings.BoundaryConditions.WeatherData.BaseClasses.getHeaderElementTMY3(
              filNam=filNam,
              start="#LOCATION",
              name=  "longitude",
              position=8);
           (nexInd, lon) :=Modelica.Utilities.Strings.Advanced.scanReal(
            string=element,
            startIndex=1,
            unsigned=false);
           assert(nexInd > 1, "Error when converting the longitude '" +
                              element + "' from a String to a Real.");
           // Convert from degree to rad
           lon :=lon*Modelica.Constants.pi/180;
           // Check if longitude is valid
           assert(abs(lon) < 2*Modelica.Constants.pi,
               "Wrong value for longitude. Received lon = " +
               String(lon) + " (= " + String(lon*180/Modelica.Constants.pi) + " degrees).");

          annotation (Documentation(info="<html>
This function returns the longitude of the TMY3 weather data file.
</html>",         revisions="<html>
<ul>
<li>
March 5, 2011, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end getLongitudeTMY3;

        function getTimeZoneTMY3
        "Gets the time zone from a TMY3 weather data file"
         input String filNam "Name of weather data file"
         annotation (Dialog(
                __Dymola_loadSelector(filter="Weather files (*.mos)", caption=
                    "Select weather file")));
         output Modelica.SIunits.Time timZon "Time zone from the weather file";
      protected
         Integer nexInd "Next index, used for error handling";
         String element "String representation of the returned element";
        algorithm
          element :=
            Buildings.BoundaryConditions.WeatherData.BaseClasses.getHeaderElementTMY3(
              filNam=filNam,
              start="#LOCATION",
              name=  "longitude",
              position=9);
           (nexInd, timZon) :=Modelica.Utilities.Strings.Advanced.scanReal(
            string=element,
            startIndex=1,
            unsigned=false);
           assert(nexInd > 1, "Error when converting the time zone '" +
                              element + "' from a String to a Real.");
           timZon :=timZon*3600;
           // Check if time zone is valid
           assert(abs(timZon) < 24*3600,
               "Wrong value for time zone. Received timZon = " +
               String(timZon) + " (= " + String(timZon/3600) + " hours).");

          annotation (Documentation(info="<html>
This function returns the time zone of the TMY3 weather data file.
</html>",         revisions="<html>
<ul>
<li>
March 5, 2011, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end getTimeZoneTMY3;
      annotation (preferedView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData\">Buildings.BoundaryConditions.WeatherData</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferedView="info",
    Documentation(info="<html>
This package contains models to read weather data. It also contains
an expandable connector called <code>Bus</code> that
is used in the library to provide weather data to the different models.
</html>"));
    end WeatherData;

    package Types "Package with type definitions"

      type DataSource = enumeration(
        File "Use data from file",
        Parameter "Use parameter",
        Input "Use input connector") "Enumeration to define data source"
            annotation(Documentation(info="<html>
<p>
Enumeration to define the data source used in the weather data reader.
</p>
</html>",     revisions=
              "<html>
<ul>
<li>
July 20, 2011, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));

      type SkyTemperatureCalculation = enumeration(
        HorizontalRadiation "Use horizontal irradiation",
        TemperaturesAndSkyCover
          "Use dry-bulb and dew-point temperatures and sky cover")
      "Enumeration for computation of sky temperature"   annotation (Documentation(
            info =                "<html>
<p>
Enumeration to define the method used to compute the sky temperature.
</p>
</html>",     revisions=
              "<html>
<ul>
<li>
October 3, 2011, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
    annotation (preferedView="info", Documentation(info="<html>
This package contains type definitions.
</html>"));
    end Types;
  annotation (preferedView="info",
  Documentation(info="<html>
This package contains models to compute boundary conditions such as weather data. 
For models that set boundary conditions for fluid flow systems, 
see
<a href=\"modelica://Buildings.Fluid.Sources\">
Buildings.Fluid.Sources</a>.
</html>"));
  end BoundaryConditions;

  package Controls "Package with models for controls"
    extends Modelica.Icons.Package;

    package Continuous "Package with models for discrete time controls"
      extends Modelica.Icons.VariantsPackage;

      block LimPID
      "P, PI, PD, and PID controller with limited output, anti-windup compensation and setpoint weighting"
        extends Modelica.Blocks.Continuous.LimPID(
          addP(k1=revAct*wp, k2=-revAct),
          addD(k1=revAct*wd, k2=-revAct),
          addI(k1=revAct, k2=-revAct),
          yMin=0,
          yMax=1);

        parameter Boolean reverseAction = false
        "Set to true for throttling the water flow rate through a cooling coil controller";
    protected
        parameter Real revAct = if reverseAction then -1 else 1;
        annotation (
      defaultComponentName="conPID",
      Documentation(info="<html>
This model is identical to 
<a href=\"Modelica:Modelica.Blocks.Continuous.LimPID\">
Modelica.Blocks.Continuous.LimPID</a> except
that it can be configured to have a reverse action.
</P>
<p>
If the parameter <code>reverseAction=false</code> (the default),
then <code>u_m &lt; u_s</code> increases the controller output, 
otherwise the controller output is decreased.
Thus, 
<ul>
<li>
for a heating coil with a two-way valve, set <code>reverseAction = false</code>,
</li>
<li>
for a cooling coils with a two-way valve, set <code>reverseAction = true</code>.
</li>
</ul>
</html>",
      revisions="<html>
<ul>
<li>
February 24, 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),       Icon(graphics={
              Rectangle(
                extent={{-6,-20},{66,-66}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Text(
                visible=(controllerType == Modelica.Blocks.Types.SimpleController.P),
                extent={{-32,-22},{68,-62}},
                lineColor={0,0,0},
                textString="P",
                fillPattern=FillPattern.Solid,
                fillColor={175,175,175}),
              Text(
                visible=(controllerType == Modelica.Blocks.Types.SimpleController.PI),
                extent={{-28,-22},{72,-62}},
                lineColor={0,0,0},
                textString="PI",
                fillPattern=FillPattern.Solid,
                fillColor={175,175,175}),
              Text(
                visible=(controllerType == Modelica.Blocks.Types.SimpleController.PD),
                extent={{-16,-22},{88,-62}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Solid,
                fillColor={175,175,175},
                textString="P D"),
              Text(
                visible=(controllerType == Modelica.Blocks.Types.SimpleController.PID),
                extent={{-14,-22},{86,-62}},
                lineColor={0,0,0},
                textString="PID",
                fillPattern=FillPattern.Solid,
                fillColor={175,175,175})}));
      end LimPID;
    annotation (preferedView="info", Documentation(info="<html>
This package contains components models for continuous time controls.
For additional models, see also 
<a href=\"Modelica:Modelica.Blocks.Continuous\">
Modelica.Blocks.Discrete</a>.
</html>"));
    end Continuous;

    package SetPoints "Package with models for control set points"
      extends Modelica.Icons.VariantsPackage;

      block OccupancySchedule "Occupancy schedule with look-ahead"
        extends Modelica.Blocks.Interfaces.BlockIcon;

        parameter Real occupancy[:]=3600*{7, 19}
        "Occupancy table, each entry switching occupancy on or off";
        parameter Boolean firstEntryOccupied = true
        "Set to true if first entry in occupancy denotes a changed from unoccupied to occupied";
        parameter Modelica.SIunits.Time startTime = 0
        "Start time of periodicity";
        parameter Modelica.SIunits.Time endTime =   86400
        "End time of periodicity";

        Modelica.Blocks.Interfaces.RealOutput tNexNonOcc
        "Time until next non-occupancy"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        Modelica.Blocks.Interfaces.RealOutput tNexOcc
        "Time until next occupancy"
          annotation (Placement(transformation(extent={{100,50},{120,70}})));
        Modelica.Blocks.Interfaces.BooleanOutput occupied
        "Outputs true if occupied at current time"
          annotation (Placement(transformation(extent={{100,-70},{120,-50}})));

    protected
        final parameter Modelica.SIunits.Time period = endTime-startTime;
        final parameter Integer nRow = size(occupancy,1);

        output Integer nexStaInd "Next index when occupancy starts";
        output Integer nexStoInd "Next index when occupancy stops";

        output Integer iPerSta
        "Counter for the period in which the next occupancy starts";
        output Integer iPerSto
        "Counter for the period in which the next occupancy stops";
        output Modelica.SIunits.Time schTim
        "Time in schedule (not exceeding max. schedule time)";
        output Modelica.SIunits.Time tMax "Maximum time in schedule";
        output Modelica.SIunits.Time tOcc "Time when next occupancy starts";
        output Modelica.SIunits.Time tNonOcc
        "Time when next non-occupancy starts";
      initial algorithm
        // Check parameters for correctness
       assert(mod(nRow, 2) < 0.1,
         "The parameter \"occupancy\" must have an even number of elements.\n");
       assert(startTime < occupancy[1],
         "The parameter \"startTime\" must be smaller than the first element of \"occupancy\"."
         + "\n   Received startTime    = " + String(startTime)
         + "\n            occupancy[1] = " + String(occupancy[1]));
       assert(endTime > occupancy[nRow],
         "The parameter \"endTime\" must be greater than the last element of \"occupancy\"."
         + "\n   Received endTime      = " + String(endTime)
         + "\n            occupancy[" + String(nRow) +
           "] = " + String(occupancy[nRow]));
        for i in 1:nRow-1 loop
          assert(occupancy[i] < occupancy[i+1],
            "The elements of the parameter \"occupancy\" must be strictly increasing.");
        end for;
       // Initialize variables
       // if the firstEntryOccupied == false, then set the current time to the
       // the time when occupancy starts.
       tOcc    :=if firstEntryOccupied then occupancy[1] else time;
       tNonOcc :=if firstEntryOccupied then time else occupancy[1];

       iPerSta   := 0;
       iPerSto   := 0;
       nexStaInd := if firstEntryOccupied then 1 else 2;
       nexStoInd := if firstEntryOccupied then 2 else 1;
       occupied := not firstEntryOccupied;
       tOcc    := occupancy[nexStaInd];
       tNonOcc := occupancy[nexStoInd];
      algorithm
        assert(startTime < endTime, "Wrong parameter values.");
        tMax :=endTime;
        schTim :=startTime + mod(time-startTime, period);

        // Changed the index that computes the time until the next occupancy
        when time >= pre(occupancy[nexStaInd])+ iPerSta*period then
          nexStaInd :=nexStaInd + 2;
          occupied := not occupied;
          // Wrap index around
          if nexStaInd > nRow then
             nexStaInd := if firstEntryOccupied then 1 else 2;
             iPerSta := iPerSta + 1;
          end if;
          tOcc := occupancy[nexStaInd] + iPerSta*(period);
        end when;

        // Changed the index that computes the time until the next non-occupancy
        when time >= pre(occupancy[nexStoInd])+ iPerSto*period then
          nexStoInd :=nexStoInd + 2;
          occupied := not occupied;
          // Wrap index around
          if nexStoInd > nRow then
             nexStoInd := if firstEntryOccupied then 2 else 1;
             iPerSto := iPerSto + 1;
          end if;
          tNonOcc := occupancy[nexStoInd] + iPerSto*(period);
        end when;

       tNexOcc    := tOcc-time;
       tNexNonOcc := tNonOcc-time;
        annotation (
          Icon(graphics={
              Line(
                points={{-62,-68},{-38,-20},{-14,-70}},
                color={0,0,255},
                smooth=Smooth.None),
              Line(
                points={{-38,-20},{-38,44}},
                color={0,0,255},
                smooth=Smooth.None),
              Ellipse(extent={{-54,74},{-22,44}}, lineColor={0,0,255}),
              Line(
                points={{-66,22},{-38,36}},
                color={0,0,255},
                smooth=Smooth.None),
              Line(
                points={{-38,36},{-6,20}},
                color={0,0,255},
                smooth=Smooth.None),
              Text(
                extent={{34,74},{90,50}},
                lineColor={0,0,255},
                textString="occupancy"),
              Text(
                extent={{32,16},{92,-16}},
                lineColor={0,0,255},
                textString="non-occupancy"),
              Text(
                extent={{34,-44},{94,-76}},
                lineColor={0,0,255},
                textString="occupied")}),
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics),
      defaultComponentName="occSch",
      Documentation(info="<html>
<p>
This model outputs whether the building is currently occupied,
and how long it will take until the next time when the building 
will be occupied or non-occupied.
The latter may be used, for example, to start a ventilation system
half an hour before occupancy starts in order to ventilate the room.
</p>
<p>
The occupancy is defined by a time schedule of the form
<pre>
  occupancy = 3600*{7, 12, 14, 19}
</pre>
This indicates that the occupancy is from <i>7:00</i> until <i>12:00</i>
and from <i>14:00</i> to <i>19:00</i>. This will be repeated periodically.
The parameters <code>startTime<code> and <code>endTime</code> define the periodicity.
</p>
</html>",       revisions="<html>
<ul>
<li>
April 2, 2009, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
      end OccupancySchedule;
    annotation (preferedView="info", Documentation(info="<html>
This package contains components models to compute set points of control systems.
For additional models, see also 
<a href=\"Modelica:Modelica.Blocks.Continuous\">
Modelica.Blocks.Continuous</a>.
</html>"));
    end SetPoints;
  annotation (preferedView="info", Documentation(info="<html>
This package contains components models for controls.
For additional models, see also 
<a href=\"Modelica:Modelica.Blocks\">
Modelica.Blocks</a>.
</html>"));
  end Controls;

  package Fluid "Package with models for fluid flow systems"
    extends Modelica.Icons.Package;

    package Actuators "Package with actuator models such as valves and dampers"
      extends Modelica.Icons.VariantsPackage;

      package Dampers "Package with air damper models"
        extends Modelica.Icons.VariantsPackage;

        model VAVBoxExponential
        "VAV box with a fixed resistance plus a damper model withe exponential characteristics"
          extends
          Buildings.Fluid.Actuators.BaseClasses.PartialDamperExponential(
          dp(nominal=dp_nominal),
          final kFixed=sqrt(kResSqu));
          parameter Boolean dp_nominalIncludesDamper = true
          "set to true if dp_nominal includes the pressure loss of the open damper"
                                                      annotation(Dialog(group = "Nominal condition"));
      protected
          parameter Modelica.SIunits.Pressure dpDamOpe_nominal = k1*m_flow_nominal^2/2/Medium.density(sta0)/A^2
          "Pressure drop of fully open damper at nominal flow rate";
          parameter Real kResSqu(unit="kg.m", fixed=false)
          "Resistance coefficient for fixed resistance element";
        initial equation
          kResSqu = if dp_nominalIncludesDamper then
               m_flow_nominal^2 / (dp_nominal-dpDamOpe_nominal) else
               m_flow_nominal^2 / dp_nominal;
          assert(kResSqu > 0,
                 "Wrong parameters in damper model: dp_nominal < dpDamOpe_nominal"
                  + "\n  dp_nominal = "       + String(dp_nominal)
                  + "\n  dpDamOpe_nominal = " + String(dpDamOpe_nominal));
           annotation (
        defaultComponentName="vavDam",
        Documentation(info="<html>
<p>
Model of two resistances in series. One resistance has a fixed flow coefficient, the
other resistance is an air damper whose flow coefficient is an exponential function of the opening angle.
</p>
<p>
If <code>dp_nominalIncludesDamper=true</code>, then the parameter <code>dp_nominal</code>
is equal to the pressure drop of the damper plus the fixed flow resistance at the nominal
flow rate.
If <code>dp_nominalIncludesDamper=false</code>, then <code>dp_nominal</code>
does not include the flow resistance of the air damper.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 13, 2010 by Michael Wetter:<br>
Added <code>noEvent</code> to guard evaluation of the square root
for negative numbers during the solver iterations.
</li>
<li>
June 10, 2008 by Michael Wetter:<br>
Introduced new partial base class, 
<a href=\"modelica://Buildings.Fluid.Actuators.BaseClasses.PartialDamperExponential\">
PartialDamperExponential</a>.
</li>
<li>
September 11, 2007 by Michael Wetter:<br>
Redefined <code>kRes</code>, now the pressure drop of the fully open damper is subtracted from the fixed resistance.
<li>
February 24, 2010 by Michael Wetter:<br>
Added parameter <code>dp_nominalIncludesDamper</code>.
<li>
July 27, 2007 by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),         Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
                    {100,100}}), graphics={
                Rectangle(
                  extent={{-100,22},{100,-24}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={0,127,255}),
                Rectangle(
                  extent={{-80,40},{80,-40}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={0,127,255}),
                Text(
                  extent={{-110,-34},{12,-100}},
                  lineColor={0,0,255},
                  textString="dp_nominal=%dp_nominal"),
                Text(
                  extent={{-102,-76},{10,-122}},
                  lineColor={0,0,255},
                  textString="m0=%m_flow_nominal"),
                Polygon(
                  points={{-24,8},{24,50},{24,38},{-24,-4},{-24,8}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,-36},{28,6},{28,-6},{-20,-48},{-20,-36}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillPattern=FillPattern.Solid)}),
            Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{
                    100,100}}),
                    graphics));
        end VAVBoxExponential;

        model MixingBox "Outside air mixing box with interlocked air dampers"
          extends Buildings.BaseClasses.BaseIconLow;
          outer Modelica.Fluid.System system "System wide properties";
          replaceable package Medium =
              Modelica.Media.Interfaces.PartialMedium "Medium in the component"
            annotation (choicesAllMatching = true);
          import Modelica.Constants;

          parameter Boolean allowFlowReversal = system.allowFlowReversal
          "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)"
            annotation(Dialog(tab="Assumptions"), Evaluate=true);

          VAVBoxExponential damOA(A=AOut,
            redeclare package Medium = Medium,
            dp_nominal=dpOut_nominal,
            dp_nominalIncludesDamper=dp_nominalIncludesDamper,
            from_dp=from_dp,
            linearized=linearized,
            use_deltaM=use_deltaM,
            deltaM=deltaM,
            use_v_nominal=use_v_nominal,
            v_nominal=v_nominal,
            roundDuct=roundDuct,
            ReC=ReC,
            m_flow_small=m_flow_small,
            a=a,
            b=b,
            yL=yL,
            yU=yU,
            k0=k0,
            k1=k1,
            use_constant_density=use_constant_density,
            allowFlowReversal=allowFlowReversal,
            m_flow_nominal=mOut_flow_nominal)
            annotation (Placement(transformation(extent={{-40,50},{-20,70}},   rotation=
                   0)));
          parameter Boolean use_deltaM = true
          "Set to true to use deltaM for turbulent transition, else ReC is used";
          parameter Real deltaM = 0.3
          "Fraction of nominal mass flow rate where transition to turbulent occurs"
            annotation(Dialog(enable=use_deltaM));
          parameter Boolean use_v_nominal = true
          "Set to true to use face velocity to compute area";
          parameter Modelica.SIunits.Velocity v_nominal=1
          "Nominal face velocity"
            annotation(Dialog(enable=use_v_nominal));

          parameter Boolean roundDuct = false
          "Set to true for round duct, false for square cross section"
            annotation(Dialog(enable=not use_deltaM));
          parameter Real ReC=4000
          "Reynolds number where transition to turbulent starts"
            annotation(Dialog(enable=not use_deltaM));

          parameter Modelica.SIunits.Area AOut=mOut_flow_nominal/rho_nominal/v_nominal
          "Face area outside air damper"
            annotation(Dialog(enable=not use_v_nominal));
          VAVBoxExponential damExh(                            A=AExh,
            redeclare package Medium = Medium,
            m_flow_nominal=mExh_flow_nominal,
            dp_nominal=dpExh_nominal,
            dp_nominalIncludesDamper=dp_nominalIncludesDamper,
            from_dp=from_dp,
            linearized=linearized,
            use_deltaM=use_deltaM,
            deltaM=deltaM,
            use_v_nominal=use_v_nominal,
            v_nominal=v_nominal,
            roundDuct=roundDuct,
            ReC=ReC,
            m_flow_small=m_flow_small,
            a=a,
            b=b,
            yL=yL,
            yU=yU,
            k0=k0,
            k1=k1,
            use_constant_density=use_constant_density,
            allowFlowReversal=allowFlowReversal) "Exhaust air damper"
            annotation (Placement(transformation(extent={{-20,-70},{-40,-50}}, rotation=
                   0)));
          parameter Modelica.SIunits.Area AExh=mExh_flow_nominal/rho_nominal/v_nominal
          "Face area exhaust air damper"
            annotation(Dialog(enable=not use_v_nominal));
          VAVBoxExponential damRec(                            A=ARec,
            redeclare package Medium = Medium,
            m_flow_nominal=mRec_flow_nominal,
            dp_nominal=dpRec_nominal,
            dp_nominalIncludesDamper=dp_nominalIncludesDamper,
            from_dp=from_dp,
            linearized=linearized,
            use_deltaM=use_deltaM,
            deltaM=deltaM,
            use_v_nominal=use_v_nominal,
            v_nominal=v_nominal,
            roundDuct=roundDuct,
            ReC=ReC,
            m_flow_small=m_flow_small,
            a=a,
            b=b,
            yL=yL,
            yU=yU,
            k0=k0,
            k1=k1,
            use_constant_density=use_constant_density,
            allowFlowReversal=allowFlowReversal) "Recirculation air damper"
                                       annotation (Placement(transformation(
                origin={30,0},
                extent={{-10,-10},{10,10}},
                rotation=90)));
          parameter Modelica.SIunits.Area ARec=mRec_flow_nominal/rho_nominal/v_nominal
          "Face area recirculation air damper"
            annotation(Dialog(enable=not use_v_nominal));

          parameter Boolean dp_nominalIncludesDamper=false
          "set to true if dp_nominal includes the pressure loss of the open damper"
            annotation (Dialog(group="Nominal condition"));

          parameter Modelica.SIunits.MassFlowRate mOut_flow_nominal
          "Mass flow rate outside air damper"
            annotation (Dialog(group="Nominal condition"));
          parameter Modelica.SIunits.Pressure dpOut_nominal(min=0, displayUnit="Pa")
          "Pressure drop outside air leg"
             annotation (Dialog(group="Nominal condition"));

          parameter Modelica.SIunits.MassFlowRate mRec_flow_nominal
          "Mass flow rate recirculation air damper"
            annotation (Dialog(group="Nominal condition"));
          parameter Modelica.SIunits.Pressure dpRec_nominal(min=0, displayUnit="Pa")
          "Pressure drop recirculation air leg"
             annotation (Dialog(group="Nominal condition"));

          parameter Modelica.SIunits.MassFlowRate mExh_flow_nominal
          "Mass flow rate exhaust air damper"
            annotation (Dialog(group="Nominal condition"));
          parameter Modelica.SIunits.Pressure dpExh_nominal(min=0, displayUnit="Pa")
          "Pressure drop exhaust air leg"
             annotation (Dialog(group="Nominal condition"));

          parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate m_flow_small=1E-4
              *mOut_flow_nominal
          "Small mass flow rate for regularization of zero flow"
            annotation (Dialog(tab="Advanced"));
          parameter Boolean from_dp=true
          "= true, use m_flow = f(dp) else dp = f(m_flow)"
            annotation (Dialog(tab="Advanced"));
          parameter Boolean linearized=false
          "= true, use linear relation between m_flow and dp for any flow rate"
            annotation (Dialog(tab="Advanced"));
          parameter Boolean use_constant_density=true
          "Set to true to use constant density for flow friction"
            annotation (Dialog(tab="Advanced"));
          parameter Real a=-1.51 "Coefficient a for damper characteristics"
            annotation (Dialog(tab="Damper coefficients"));
          parameter Real b=0.105*90 "Coefficient b for damper characteristics"
            annotation (Dialog(tab="Damper coefficients"));
          parameter Real yL=15/90 "Lower value for damper curve"
            annotation (Dialog(tab="Damper coefficients"));
          parameter Real yU=55/90 "Upper value for damper curve"
            annotation (Dialog(tab="Damper coefficients"));
          parameter Real k0=1E6
          "Flow coefficient for y=0, k0 = pressure drop divided by dynamic pressure"
            annotation (Dialog(tab="Damper coefficients"));
          parameter Real k1=0.45
          "Flow coefficient for y=1, k1 = pressure drop divided by dynamic pressure"
            annotation (Dialog(tab="Damper coefficients"));

          Modelica.Fluid.Interfaces.FluidPort_a port_Out(redeclare package
            Medium =
                Medium, m_flow(start=0, min=if allowFlowReversal then -Constants.inf else
                        0))
          "Fluid connector a (positive design flow direction is from port_a to port_b)"
            annotation (Placement(transformation(extent={{-110,50},{-90,70}},
                  rotation=0)));
          Modelica.Fluid.Interfaces.FluidPort_b port_Exh(redeclare package
            Medium =
                Medium, m_flow(start=0, max=if allowFlowReversal then +Constants.inf else
                        0))
          "Fluid connector b (positive design flow direction is from port_a to port_b)"
            annotation (Placement(transformation(extent={{-90,-70},{-110,-50}},
                  rotation=0)));
          Modelica.Fluid.Interfaces.FluidPort_a port_Ret(redeclare package
            Medium =
                Medium, m_flow(start=0, min=if allowFlowReversal then -Constants.inf else
                        0))
          "Fluid connector a (positive design flow direction is from port_a to port_b)"
            annotation (Placement(transformation(extent={{110,-70},{90,-50}}, rotation=
                    0)));
          Modelica.Fluid.Interfaces.FluidPort_b port_Sup(redeclare package
            Medium =
                Medium, m_flow(start=0, max=if allowFlowReversal then +Constants.inf else
                        0))
          "Fluid connector b (positive design flow direction is from port_a to port_b)"
            annotation (Placement(transformation(extent={{110,50},{90,70}}, rotation=0)));
          Modelica.Blocks.Interfaces.RealInput y
          "Damper position (0: closed, 1: open)"
            annotation (Placement(transformation(extent={{-20,-20},{20,20}},   rotation=270,
                origin={0,120})));
          Modelica.Blocks.Sources.Constant uni(k=1) "Unity signal"
            annotation (Placement(transformation(extent={{-90,-4},{-70,16}},rotation=0)));

          Modelica.Blocks.Math.Add add(k2=-1)
                                     annotation (Placement(transformation(extent={{-40,-10},
                    {-20,10}},    rotation=0)));

      protected
          parameter Medium.Density rho_nominal=Medium.density(sta_nominal)
          "Density, used to compute fluid volume";
          parameter Medium.ThermodynamicState sta_nominal=
             Medium.setState_pTX(T=Medium.T_default, p=Medium.p_default, X=Medium.X_default);
        equation
          connect(y, damOA.y) annotation (Line(points={{1.11022e-15,120},{0,120},{0,80},
                  {-30,80},{-30,68}},
                             color={0,0,127}));
          connect(y, damExh.y) annotation (Line(points={{1.11022e-15,120},{0,120},{0,
                  -40},{-30,-40},{-30,-52}},   color={0,0,127}));
          connect(uni.y, add.u1) annotation (Line(points={{-69,6},{-42,6},{-42,6}},
                color={0,0,127}));
          connect(y, add.u2) annotation (Line(points={{1.11022e-15,120},{0,120},{0,-20},
                  {-52,-20},{-52,-6},{-42,-6}},
                        color={0,0,127}));
          connect(add.y, damRec.y) annotation (Line(points={{-19,6.10623e-16},{-19,0},{
                  22,0},{22,1.15598e-15}},
                                     color={0,0,127}));
          connect(damOA.port_a, port_Out) annotation (Line(
              points={{-40,60},{-100,60}},
              color={0,127,255},
              smooth=Smooth.None));
          connect(damExh.port_b, port_Exh) annotation (Line(
              points={{-40,-60},{-100,-60}},
              color={0,127,255},
              smooth=Smooth.None));
          connect(port_Sup, damOA.port_b) annotation (Line(
              points={{100,60},{-20,60}},
              color={0,127,255},
              smooth=Smooth.None));
          connect(damRec.port_b, port_Sup) annotation (Line(
              points={{30,10},{30,60},{100,60}},
              color={0,127,255},
              smooth=Smooth.None));
          connect(port_Ret, damExh.port_a) annotation (Line(
              points={{100,-60},{-20,-60}},
              color={0,127,255},
              smooth=Smooth.None));
          connect(port_Ret, damRec.port_a) annotation (Line(
              points={{100,-60},{30,-60},{30,-10}},
              color={0,127,255},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=true,  extent={{-100,
                    -100},{100,100}}),
                              graphics),
                               Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,
                    -100},{100,100}}), graphics={
                Rectangle(
                  extent={{-98,66},{94,54}},
                  lineColor={0,0,255},
                  fillColor={0,0,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-94,-54},{96,-66}},
                  lineColor={0,0,255},
                  fillColor={0,0,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-6,66},{6,-56}},
                  lineColor={0,0,255},
                  fillColor={0,0,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-70,42},{-48,78},{-30,78},{-54,42},{-70,42}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{68,66},{90,60},{68,54},{68,66}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{72,-58},{92,-62}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{72,-54},{48,-60},{72,-66},{72,-54}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{2,104},{28,82}},
                  lineColor={0,0,127},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid,
                  textString="y"),
                Rectangle(
                  extent={{48,62},{68,58}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-74,-76},{-52,-40},{-34,-40},{-58,-76},{-74,-76}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,-18},{2,18},{20,18},{-4,-18},{-20,-18}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid)}),
        defaultComponentName="eco",
        Documentation(revisions="<html>
<ul>
<li>
February 23, 2010 by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>",         info="<html>
<p>
Model of an outside air mixing box with air dampers.
Set <code>y=0</code> to close the outside air and exhast air dampers.
</p>
<p>
If <code>dp_nominalIncludesDamper=true</code>, then the parameter <code>dp_nominal</code>
is equal to the pressure drop of the damper plus the fixed flow resistance at the nominal
flow rate.
If <code>dp_nominalIncludesDamper=false</code>, then <code>dp_nominal</code>
does not include the flow resistance of the air damper.
</p>
</html>"));
        end MixingBox;
      annotation (preferedView="info", Documentation(info="<html>
This package contains components models for air dampers.
For motor models, see
<a href=\"modelica://Buildings.Fluid.Actuators.Motors\">Buildings.Fluid.Actuators.Motors</a>.
</html>"));
      end Dampers;

      package Valves "Package with valve models"
        extends Modelica.Icons.VariantsPackage;

        model TwoWayLinear "Two way valve with linear flow characteristics"
          extends BaseClasses.PartialTwoWayValve;

        equation
          phi = l + y * (1 - l);
        annotation (
        defaultComponentName="val",
        Documentation(info="<html>
<p>
Two way valve with linear opening characteristic.
</p><p>
This model is based on the partial valve model 
<a href=\"modelica://Buildings.Fluid.Actuators.BaseClasses.PartialTwoWayValve\">
PartialTwoWayValve</a>. Check this model for more information, such
as the leakage flow or regularization near the origin.
</p>
</html>",
        revisions="<html>
<ul>
<li>
June 3, 2008 by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end TwoWayLinear;
      annotation (preferedView="info", Documentation(info="<html>
This package contains components models for two- and three-way valves.
For motor models, see
<a href=\"modelica://Buildings.Fluid.Actuators.Motors\">Buildings.Fluid.Actuators.Motors</a>.
</html>"));
      end Valves;

      package BaseClasses
      "Package with base classes for Buildings.Fluid.Actuators"
        extends Modelica.Icons.BasesPackage;

        partial model PartialActuator "Partial model of an actuator"
            extends Buildings.Fluid.Interfaces.PartialTwoPortInterface(
             show_T=false, show_V_flow=false,
             m_flow(start=0, nominal=m_flow_nominal_pos),
             dp(start=0, nominal=dp_nominal_pos));

          parameter Boolean from_dp = false
          "= true, use m_flow = f(dp) else dp = f(m_flow)"
            annotation (Evaluate=true, Dialog(tab="Advanced"));
          parameter Modelica.SIunits.MassFlowRate m_flow_nominal
          "Nominal mass flow rate"
            annotation(Dialog(group = "Nominal condition"));
          parameter Modelica.SIunits.Pressure dp_nominal(displayUnit="Pa")
          "Pressure drop at nominal mass flow rate"
             annotation(Dialog(group = "Nominal condition"));
          parameter Boolean homotopyInitialization = true
          "= true, use homotopy method"
            annotation(Evaluate=true, Dialog(tab="Advanced"));
          parameter Boolean linearized = false
          "= true, use linear relation between m_flow and dp for any flow rate"
            annotation(Evaluate=true, Dialog(tab="Advanced"));
          Modelica.Blocks.Interfaces.RealInput y(min=0, max=1)
          "Actuator position (0: closed, 1: open)"
            annotation (Placement(transformation(extent={{-20,-20},{20,20}},
                  rotation=270,
                origin={0,80}), iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={0,80})));
          Modelica.SIunits.MassFlowRate m_flow_turbulent(min=0)
          "Turbulent flow if |m_flow| >= m_flow_turbulent, not a parameter because k can be a function of time"
             annotation(Evaluate=true);

      protected
          parameter Medium.ThermodynamicState sta0=
             Medium.setState_pTX(T=Medium.T_default, p=Medium.p_default, X=Medium.X_default);
          parameter Modelica.SIunits.DynamicViscosity eta_nominal=Medium.dynamicViscosity(sta0)
          "Dynamic viscosity, used to compute transition to turbulent flow regime";
          parameter Modelica.SIunits.SpecificEnthalpy h0=Medium.h_default
          "Initial value for solver for specific enthalpy";             //specificEnthalpy(sta0)
         constant Real conv(unit="m.s2/kg") = 1
          "Factor, needed to satisfy unit check";
         constant Real conv2 = sqrt(conv)
          "Factor, needed to satisfy unit check";

      protected
          final parameter Modelica.SIunits.MassFlowRate m_flow_nominal_pos = abs(m_flow_nominal)
          "Absolute value of nominal flow rate";
          final parameter Modelica.SIunits.Pressure dp_nominal_pos = abs(dp_nominal)
          "Absolute value of nominal pressure";

        equation
          // Isenthalpic state transformation (no storage and no loss of energy)
          port_a.h_outflow = inStream(port_b.h_outflow);
          port_b.h_outflow = inStream(port_a.h_outflow);

          // Mass balance (no storage)
          port_a.m_flow + port_b.m_flow = 0;

          // Transport of substances
          port_a.Xi_outflow = inStream(port_b.Xi_outflow);
          port_b.Xi_outflow = inStream(port_a.Xi_outflow);

          port_a.C_outflow = inStream(port_b.C_outflow);
          port_b.C_outflow = inStream(port_a.C_outflow);

           annotation (Documentation(info="<html>
Partial actuator that is the base class for dampers and two way valves.
Models that extend this class need to implement an equation for 
<code>m_flow</code> and for <code>dp</code>.
</html>",         revisions="<html>
<ul>
<li>
August 1, by Michael Wetter:<br>
Set start values for <code>dp</code> and <code>m_flow</code>
to zero.
</li>
<li>
April 4, 2008, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),         Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},
                    {100,100}}), graphics={Text(
                  extent={{38,112},{62,74}},
                  lineColor={0,0,127},
                  textString="y")}),
            Diagram(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{
                    100,100}}),
                    graphics));
        end PartialActuator;

        partial model PartialDamperExponential
        "Partial model for air dampers with exponential opening characteristics"
         extends Buildings.Fluid.Actuators.BaseClasses.PartialActuator;
         parameter Boolean use_deltaM = true
          "Set to true to use deltaM for turbulent transition, else ReC is used";
         parameter Real deltaM = 0.3
          "Fraction of nominal mass flow rate where transition to turbulent occurs"
           annotation(Dialog(enable=use_deltaM));
         parameter Boolean use_v_nominal = true
          "Set to true to use face velocity to compute area";
         parameter Modelica.SIunits.Velocity v_nominal=1
          "Nominal face velocity"
           annotation(Dialog(enable=use_v_nominal));
         parameter Modelica.SIunits.Area A=m_flow_nominal/rho_nominal/v_nominal
          "Face area"
           annotation(Dialog(enable=not use_v_nominal));
         parameter Boolean roundDuct = false
          "Set to true for round duct, false for square cross section"
           annotation(Dialog(enable=not use_deltaM));
         parameter Real ReC=4000
          "Reynolds number where transition to turbulent starts"
           annotation(Dialog(enable=not use_deltaM));
         parameter Real a(unit="")=-1.51
          "Coefficient a for damper characteristics"
          annotation(Dialog(tab="Damper coefficients"));
         parameter Real b(unit="")=0.105*90
          "Coefficient b for damper characteristics"
          annotation(Dialog(tab="Damper coefficients"));
         parameter Real yL = 15/90 "Lower value for damper curve"
          annotation(Dialog(tab="Damper coefficients"));
         parameter Real yU = 55/90 "Upper value for damper curve"
          annotation(Dialog(tab="Damper coefficients"));
         parameter Real k0(min=0) = 1E6
          "Flow coefficient for y=0, k0 = pressure drop divided by dynamic pressure"
          annotation(Dialog(tab="Damper coefficients"));
         parameter Real k1(min=0) = 0.45
          "Flow coefficient for y=1, k1 = pressure drop divided by dynamic pressure"
          annotation(Dialog(tab="Damper coefficients"));
         parameter Boolean use_constant_density=true
          "Set to true to use constant density for flow friction"
           annotation (Dialog(tab="Advanced"));
         Medium.Density rho "Medium density";
         parameter Real kFixed(unit="")
          "Flow coefficient of fixed resistance that may be in series with damper, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2).";
         Real kDam(unit="")
          "Flow coefficient of damper, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
         Real k(unit="")
          "Flow coefficient of damper plus fixed resistance, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
      protected
         parameter Medium.Density rho_nominal=Medium.density(sta0)
          "Density, used to compute fluid volume";
         parameter Real[3] cL=
            {(Modelica.Math.log(k0) - b - a)/yL^2,
              (-b*yL - 2*Modelica.Math.log(k0) + 2*b + 2*a)/yL,
              Modelica.Math.log(k0)}
          "Polynomial coefficients for curve fit for y < yl";
         parameter Real[3] cU=
            {(Modelica.Math.log(k1) - a)/(yU^2 - 2*yU + 1),
            (-b*yU^2 - 2*Modelica.Math.log(k1)*yU - (-2*b - 2*a)*yU - b)/(yU^2 - 2*yU + 1),
            (Modelica.Math.log(k1)*yU^2 + b*yU^2 + (-2*b - 2*a)*yU + b + a)/(yU^2 - 2*yU + 1)}
          "Polynomial coefficients for curve fit for y > yu";
         parameter Real facRouDuc= if roundDuct then sqrt(Modelica.Constants.pi)/2 else 1;
         parameter Modelica.SIunits.Area area=
            if use_v_nominal then m_flow_nominal/rho_nominal/v_nominal else A
          "Face velocity used in the computation";
        initial equation
          assert(k0 > k1, "k0 must be bigger than k1.");
          assert(m_flow_turbulent > 0, "m_flow_turbulent must be bigger than zero.");

        equation
          rho = if use_constant_density then
                 rho_nominal else
                 Medium.density(Medium.setState_phX(port_a.p, inStream(port_a.h_outflow), inStream(port_a.Xi_outflow)));
          m_flow_turbulent=if use_deltaM then deltaM * m_flow_nominal else
              eta_nominal*ReC*sqrt(area)*facRouDuc;

          // flow coefficient, k=m_flow/sqrt(dp)
          kDam=sqrt(2*rho)*area/Buildings.Fluid.Actuators.BaseClasses.exponentialDamper(
            y=y,
            a=a,
            b=b,
            cL=cL,
            cU=cU,
            yL=yL,
            yU=yU);
          k = if (kFixed>Modelica.Constants.eps) then sqrt(1/(1/kFixed^2 + 1/kDam^2)) else kDam;

          // Pressure drop calculation
          if linearized then
            m_flow*m_flow_nominal_pos = k^2*dp;
          else
            if homotopyInitialization then
              if from_dp then
                m_flow=homotopy(
                   actual=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(
                          dp=dp, k=k,
                          m_flow_turbulent=m_flow_turbulent),
                   simplified=m_flow_nominal_pos*dp/dp_nominal_pos);
              else
                dp=homotopy(
                   actual=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(
                          m_flow=m_flow, k=k,
                          m_flow_turbulent=m_flow_turbulent),
                   simplified=dp_nominal_pos*m_flow/m_flow_nominal_pos);
               end if;  // from_dp
            else // do not use homotopy
              if from_dp then
                m_flow=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(
                         dp=dp, k=k, m_flow_turbulent=m_flow_turbulent);
              else
                dp=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(
                         m_flow=m_flow, k=k, m_flow_turbulent=m_flow_turbulent);
              end if;  // from_dp
            end if; // homotopyInitialization
          end if; // linearized

        annotation(Documentation(info="<html>
<p>
Partial model for air dampers with exponential opening characteristics. 
This is the base model for air dampers and variable air volume flow boxes.
The model implements the functions that relate the opening signal, 
the pressure drop and the mass flow rate.
The model also defines parameters that are used by different air damper
models.
</p>
<p>
For a description of the opening characteristics and typical parameter values, see the damper model
<a href=\"modelica://Buildings.Fluid.Actuators.Dampers.Exponential\">
Exponential</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
August 5, 2011, by Michael Wetter:<br>
Moved linearized pressure drop equation from the function body to the equation
section. With the previous implementation, 
the symbolic processor may not rearrange the equations, which can lead 
to coupled equations instead of an explicit solution.
</li>
<li>
June 22, 2008 by Michael Wetter:<br>
Extended range of control signal from 0 to 1 by implementing the function 
<a href=\"modelica://Buildings.Fluid.Actuators.BaseClasses.exponentialDamper\">
exponentialDamper</a>.
</li>
<li>
June 10, 2008 by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>",  Icon(graphics={Line(
                 points={{0,100},{0,-24}},
                 color={0,0,0},
                 smooth=Smooth.None),
                Rectangle(
                  extent={{-100,40},{100,-42}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={192,192,192}),
                Rectangle(
                  extent={{-100,22},{100,-24}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={0,127,255})}),
                     Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                   -100},{100,100}}), graphics={Polygon(
                 points={{-20,4},{4,50},{16,50},{-8,4},{-20,4}},
                 lineColor={0,0,255},
                 pattern=LinePattern.None,
                 fillColor={0,0,0},
                 fillPattern=FillPattern.Solid), Polygon(
                 points={{-22,-46},{2,0},{14,0},{-10,-46},{-22,-46}},
                 lineColor={0,0,255},
                 pattern=LinePattern.None,
                 fillColor={0,0,0},
                 fillPattern=FillPattern.Solid)})));
        end PartialDamperExponential;

        partial model PartialTwoWayValve "Partial model for a two way valve"
          extends Buildings.Fluid.Actuators.BaseClasses.PartialActuator(
               dp_nominal=6000);
          extends Buildings.Fluid.Actuators.BaseClasses.ValveParameters(
              rhoStd=Medium.density_pTX(101325, 273.15+4, Medium.X_default),
              final dpVal_nominal=dp_nominal);

          parameter Real l(min=1e-10, max=1) = 0.0001
          "Valve leakage, l=Cv(y=0)/Cvs";
          Real phi "Ratio actual to nominal mass flow rate, phi=Cv(y)/Cv(y=1)";
        initial equation
          // Since the flow model Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow computes
          // 1/k^2, the parameter l must not be zero.
          assert(l > 0, "Valve leakage parameter l must be bigger than zero.");
        equation
         m_flow_turbulent = deltaM * abs(m_flow_nominal);
         if linearized then
           // This implementation yields m_flow_nominal = phi*kv_SI * sqrt(dp_nominal)
           // if m_flow = m_flow_nominal and dp = dp_nominal
           m_flow*m_flow_nominal_pos = (phi*Kv_SI)^2 * dp;
         else
           if homotopyInitialization then
             if from_dp then
                 m_flow=homotopy(actual=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(dp=dp, k=phi*Kv_SI,
                                        m_flow_turbulent=m_flow_turbulent),
                                        simplified=m_flow_nominal_pos*dp/dp_nominal_pos);
              else
                 dp=homotopy(actual=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(m_flow=m_flow, k=phi*Kv_SI,
                                        m_flow_turbulent=m_flow_turbulent),
                                        simplified=dp_nominal_pos*m_flow/m_flow_nominal_pos);
             end if;
           else // do not use homotopy
             if from_dp then
               m_flow=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(dp=dp, k=phi*Kv_SI,
                                        m_flow_turbulent=m_flow_turbulent);
              else
                dp=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(m_flow=m_flow, k=phi*Kv_SI,
                                        m_flow_turbulent=m_flow_turbulent);
              end if;
            end if; // homotopyInitialization
         end if; // linearized
          annotation (Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,
                    -100},{100,100}}), graphics={
                Polygon(
                  points={{2,-2},{-76,60},{-76,-60},{2,-2}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-50,40},{0,-2},{54,40},{54,40},{-50,40}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-48,-40},{0,-4},{56,38},{52,-42},{-48,-40}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{0,-2},{82,60},{82,-60},{0,-2}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{0,100},{0,-2}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{-40,48},{40,48}},
                  color={0,0,0},
                  smooth=Smooth.None)}),
        Documentation(info="<html>
<p>
Partial model for a two way valve. This is the base model for valves
with different opening characteristics, such as linear, equal percentage
or quick opening.
</p>
<p><b>Modelling options</b></p>
<p>The following options have been adapted from the valve implementation 
in <a href=\"modelica://Modelica.Fluid\">
Modelica.Fluid</a> and are described in 
<a href=\"modelica://Buildings.Fluid.Actuators.BaseClasses.ValveParameters\">
Buildings.Fluid.Actuators.BaseClasses.ValveParameters</a>.
<p>
In contrast to the model in <a href=\"modelica://Modelica.Fluid\">
Modelica.Fluid</a>, this model uses the parameter <code>Kv_SI</code>,
which is the flow coefficient in SI units, i.e., 
it is the ratio between mass flow rate in <code>kg/s</code> and square root 
of pressure drop in <code>Pa</code>.
</p><p>
To prevent the derivative <code>d/dP (m_flow)</code> to be infinite near
the origin, this model linearizes the pressure drop vs. flow relation
ship. The region in which it is linearized is parameterized by 
<pre>
  m_turbulent_flow = deltaM * m_flow_nominal
</pre>
Because the parameterization contains <code>Kv_SI</code>, the values for
<code>deltaM</code> and <code>dp_nominal</code> need not be changed if the valve size
changes.
</p>
<h4>Implementation</h4>
<p>
The two way valve models are implemented using this partial model, as opposed to using
different functions for the valve opening characteristics, because
each valve opening characteristics has different parameters.
</html>",
        revisions="<html>
<ul>
<li>
August 12, 2011 by Michael Wetter:<br>
Added <code>assert</code> statement to prevent <code>l=0</code> due to the
implementation of 
<a href=\"modelica://Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow\">
Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow</a>.
</li>
<li>
April 4, 2011 by Michael Wetter:<br>
Revised implementation to use new base class for actuators.
</li>
<li>
February 18, 2009 by Michael Wetter:<br>
Implemented parameterization of flow coefficient as in 
<code>Modelica.Fluid</code>.
</li>
<li>
August 15, 2008 by Michael Wetter:<br>
Set valve leakage to nonzero value.
</li>
<li>
June 3, 2008 by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end PartialTwoWayValve;

        partial model ValveParameters "Model with parameters for valves"

          parameter Buildings.Fluid.Types.CvTypes CvData=Buildings.Fluid.Types.CvTypes.OpPoint
          "Selection of flow coefficient"
           annotation(Evaluate=true, Dialog(group = "Flow Coefficient"));
          parameter Real Kv(
            fixed= if CvData==Buildings.Fluid.Types.CvTypes.Kv then true else false) = 0
          "Kv (metric) flow coefficient [m3/h/(bar)^(1/2)]"
          annotation(Dialog(group = "Flow Coefficient",
                            enable = (CvData==Buildings.Fluid.Types.CvTypes.Kv)));
          parameter Real Cv(
            fixed= if CvData==Buildings.Fluid.Types.CvTypes.Cv then true else false) = 0
          "Cv (US) flow coefficient [USG/min/(psi)^(1/2)]"
          annotation(Dialog(group = "Flow Coefficient",
                            enable = (CvData==Buildings.Fluid.Types.CvTypes.Cv)));
          parameter Modelica.SIunits.Area Av(
            fixed= if CvData==Buildings.Fluid.Types.CvTypes.Av then true else false) = 0
          "Av (metric) flow coefficient"
           annotation(Evaluate=true, Dialog(group = "Flow Coefficient",
                             enable = (CvData==Buildings.Fluid.Types.CvTypes.Av)));
          parameter Real deltaM = 0.02
          "Fraction of nominal flow rate where linearization starts, if y=1"
            annotation(Dialog(group="Pressure-flow linearization"));
          parameter Modelica.SIunits.MassFlowRate m_flow_nominal(min=0)
          "Nominal mass flow rate"
            annotation(Dialog(group = "Nominal condition"));
          parameter Modelica.SIunits.Pressure dpVal_nominal
          "Nominal pressure drop"
            annotation(Dialog(group="Nominal condition"));

          parameter Real Kv_SI(
            min=0,
            fixed= if CvData==Buildings.Fluid.Types.CvTypes.OpPoint then true else false,
            start=m_flow_nominal/sqrt(dpVal_nominal)) = m_flow_nominal/sqrt(dpVal_nominal)
          "Flow coefficient for fully open valve in SI units, Kv=m_flow/sqrt(dp) [kg/s/(Pa)^(1/2)]"
          annotation(Dialog(group = "Flow Coefficient",
                            enable = (CvData==Buildings.Fluid.Types.CvTypes.OpPoint)));

          parameter Modelica.SIunits.Density rhoStd
          "Inlet density for which valve coefficients are defined"
          annotation(Dialog(group="Nominal condition", tab="Advanced"));

        initial equation
            Kv_SI = Av * sqrt(rhoStd);
            Kv_SI = Kv*rhoStd/3600/sqrt(1E5)
          "Unit conversion m3/(h*sqrt(bar)) to kg/(s*sqrt(Pa))";
            Kv_SI = Cv*rhoStd*0.0631/1000/sqrt(6895)
          "Unit conversion USG/(min*sqrt(psi)) to kg/(s*sqrt(Pa))";
          annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}), graphics),
        Documentation(info="<html>
<p>
Model that computes the flow coefficients of valves. This base class allows the following modeling options,
which have been adapted from the valve implementation 
in <a href=\"modelica://Modelica.Fluid\">
Modelica.Fluid</a>
to specify the valve flow coefficient in fully open conditions:
<ul><li><code>CvData = Buildings.Fluid.Types.CvTypes.Av</code>: the flow coefficient is given by the metric <code>Av</code> coefficient (m^2).
<li><code>CvData = Buildings.Fluid.Types.CvTypes.Kv</code>: the flow coefficient is given by the metric <code>Kv</code> coefficient (m^3/h).
<li><code>CvData = Buildings.Fluid.Types.CvTypes.Cv</code>: the flow coefficient is given by the US <code>Cv</code> coefficient (USG/min).
<li><code>CvData = Buildings.Fluid.Types.CvTypes.OpPoint</code>: the flow is computed from the nominal operating point specified by <code>dp_nominal</code> and <code>m_flow_nominal</code>.
</ul>
</p>
<p>
The treatment of parameters <code>Kv</code> and <code>Cv</code> is
explained in detail in the 
<a href=\"modelica://Modelica.Fluid.UsersGuide.ComponentDefinition.ValveCharacteristics\">Users Guide</a>.
</p>
<p>
In contrast to the model in <a href=\"modelica://Modelica.Fluid\">
Modelica.Fluid</a>, this model uses the parameter <code>Kv_SI</code>,
which is the flow coefficient in SI units, i.e., 
it is the ratio between mass flow rate in <code>kg/s</code> and square root 
of pressure drop in <code>Pa</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
February 18, 2009 by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),
        revisions="<html>
<ul>
<li>
June 3, 2008 by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>");
        end ValveParameters;

        function exponentialDamper
        "Damper opening characteristics for an exponential damper"

          input Real y(min=0, max=1, unit="")
          "Control signal, y=0 is closed, y=1 is open";
          input Real a(unit="") "Coefficient a for damper characteristics";
          input Real b(unit="") "Coefficient b for damper characteristics";
          input Real[3] cL "Polynomial coefficients for curve fit for y < yl";
          input Real[3] cU "Polynomial coefficients for curve fit for y > yu";
          input Real yL "Lower value for damper curve";
          input Real yU "Upper value for damper curve";

          output Real kThetaSqRt(min=0)
          "Flow coefficient, kThetaSqRT = =sqrt(kTheta) = sqrt(pressure drop/dynamic pressure)";
      protected
          Real yC(min=0, max=1, unit="")
          "y constrained to 0 <= y <= 1 to avoid numerical problems";
        algorithm
          if y < yL then
            yC :=max(0, y);
            kThetaSqRt := sqrt(Modelica.Math.exp(cL[3] + yC * (cL[2] + yC * cL[1])));
          else
            if (y > yU) then
              yC := min(1, y);
              kThetaSqRt := sqrt(Modelica.Math.exp(cU[3] + yC * (cU[2] + yC * cU[1])));
            else
              kThetaSqRt := sqrt(Modelica.Math.exp(a+b*(1-y))) "y=0 is closed";
            end if;
          end if;
        annotation (
        Documentation(info="<html>
<p>
This function computes the opening characteristics of an exponential damper.
</p><p>
The function is used by the model 
<a href=\"modelica://Buildings.Fluid.Actuators.Dampers.Exponential\">
Dampers.Exponential</a>.
</p><p>
For <code>yL &lt; y &lt; yU</code>, the damper characteristics is 
</p>
<p align=\"center\" style=\"font-style:italic;\">
  k = exp(a+b (1-y)).
</p>
<p>
Outside this range, the damper characteristic is defined by a quadratic polynomial.
</p>
<p>
Note that this implementation returns <code>sqrt(k)</code> instead of <code>k</code>.
This is done for numerical reason since otherwise <code>k</code> may be an iteration
variable, which may cause a lot of warnings and slower convergence if the solver
attempts <code>k &lt; 0</code> during the iterative solution procedure.
</p>
</html>",
        revisions="<html>
<ul>
<li>
July 1, 2011 by Michael Wetter:<br>
Added constraint to control input to avoid using a number outside
<code>0</code> and <code>1</code> in case that the control input
has a numerical integration error.
</li>
<li>
April 4, 2010 by Michael Wetter:<br>
Reformulated implementation. The new implementation computes
<code>sqrt(kTheta)</code>. This avoid having <code>kTheta</code> in
the iteration variables, which caused warnings when the solver attempted
<code>kTheta &lt; 0</code>.
</li>
<li>
June 22, 2008 by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),           smoothOrder=1);
        end exponentialDamper;
      annotation (preferedView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Fluid.Actuators\">Buildings.Fluid.Actuators</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferedView="info", Documentation(info="<html>
This package contains components models for actuators.
</html>"));
    end Actuators;

    package Delays "Package with delay models"
      extends Modelica.Icons.VariantsPackage;

      model DelayFirstOrder
      "Delay element, approximated by a first order differential equation"
        extends Buildings.Fluid.MixingVolumes.MixingVolume(final V=V0);

        parameter Modelica.SIunits.Time tau = 60
        "Time constant at nominal flow"
          annotation (Dialog(tab="Dynamics", group="Nominal condition"));

    protected
         parameter Modelica.SIunits.Volume V0 = m_flow_nominal*tau/rho_nominal
        "Volume of delay element";
        annotation (Diagram(graphics),
          Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                  100}}), graphics={Ellipse(
                extent={{-100,98},{100,-102}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Sphere,
                fillColor={170,213,255}), Text(
                extent={{-72,22},{68,-18}},
                lineColor={0,0,0},
                textString="tau=%tau")}),
      defaultComponentName="del",
          Documentation(info="<html>
<p>
This model approximates a transport delay using a first order differential equations.
</p>
<p>
The model consists of a mixing volume with two ports. The size of the
mixing volume is such that at the nominal mass flow rate 
<code>m_flow_nominal</code>,
the time constant of the volume is equal to the parameter <code>tau</code>.
</p>
<p>
The heat flux connector is optional, it need not be connnected.
</p>
</html>",
      revisions="<html>
<ul>
<li>
September 24, 2008, by Michael Wetter:<br>
Changed base class from <code>Modelica.Fluid</code> to <code>Buildings</code> library.
This was done to track the auxiliary species flow <code>mC_flow</code>.
</li>
<li>
September 4, 2008, by Michael Wetter:<br>
Fixed bug in assignment of parameter <code>sta0</code>. 
The earlier implementation
required temperature to be a state, which is not always the case.
</li>
<li>
March 17, 2008, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
      end DelayFirstOrder;
    annotation (preferedView="info", Documentation(info="<html>
This package contains components models for transport delays in
piping networks.
The model 
<a href=\"modelica://Buildings.Fluid.Delays.DelayFirstOrder\">
Buildings.Fluid.Delays.DelayFirstOrder</a>
approximates transport delay using a first order differential equation.
</html>"));
    end Delays;

    package FixedResistances
    "Package with models for fixed flow resistances (pipes, diffusers etc.)"
      extends Modelica.Icons.VariantsPackage;

      model FixedResistanceDpM
      "Fixed flow resistance with dp and m_flow as parameter"
        extends Buildings.Fluid.BaseClasses.PartialResistance;
        parameter Boolean use_dh = false
        "Set to true to specify hydraulic diameter"
             annotation(Evaluate=true, Dialog(enable = not linearized));
        parameter Modelica.SIunits.Length dh=1 "Hydraulic diameter"
             annotation(Evaluate=true, Dialog(enable = use_dh and not linearized));
        parameter Real ReC(min=0)=4000
        "Reynolds number where transition to turbulent starts"
             annotation(Evaluate=true, Dialog(enable = use_dh and not linearized));
        parameter Real deltaM(min=0.01) = 0.3
        "Fraction of nominal mass flow rate where transition to turbulent occurs"
             annotation(Evaluate=true, Dialog(enable = not use_dh and not linearized));
      initial equation
       assert(m_flow_nominal_pos > 0, "m_flow_nominal_pos must be non-zero. Check parameters.");
       if ( m_flow_turbulent > m_flow_nominal_pos) then
         Modelica.Utilities.Streams.print("Warning: In FixedResistanceDpM, m_flow_nominal is smaller than m_flow_turbulent."
                 + "\n"
                 + "  m_flow_nominal = " + String(m_flow_nominal) + "\n"
                 + "  dh      = " + String(dh) + "\n"
                 + "  To fix, set dh < " +
                      String(     4*m_flow_nominal/eta_nominal/Modelica.Constants.pi/ReC) + "\n"
                 + "  Suggested value: dh = " +
                      String(1/10*4*m_flow_nominal/eta_nominal/Modelica.Constants.pi/ReC));
       end if;

      equation
       // if computeFlowResistance = false, then equations of this model are disabled.
       if computeFlowResistance then
         m_flow_turbulent = if use_dh then
                            eta_nominal*dh/4*Modelica.Constants.pi*ReC else
                            deltaM * m_flow_nominal_pos;
         k = m_flow_nominal_pos / sqrt(dp_nominal_pos);
       else
         m_flow_turbulent = 0;
         k = 0;
       end if;
        annotation (Diagram(coordinateSystem(preserveAspectRatio=true,  extent={{-100,
                  -100},{100,100}}),
                            graphics),
      defaultComponentName="res",
      Documentation(info="<html>
<p>
This is a model of a resistance with a fixed flow coefficient 
<p align=\"center\" style=\"font-style:italic;\">
k = m &frasl; 
&radic;<span style=\"text-decoration:overline;\">&Delta;P</span>.
</p>
Near the origin, the square root relation is regularized to ensure that the derivative is bounded.
</p>
</html>",       revisions="<html>
<ul>
<li>
May 30, 2008 by Michael Wetter:<br>
Added parameters <code>use_dh</code> and <code>deltaM</code> for easier parameterization.
</li>
<li>
July 20, 2007 by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                  100}}), graphics={Text(
                extent={{-102,86},{-4,22}},
                lineColor={0,0,255},
                textString="dp_nominal=%dp_nominal"), Text(
                extent={{-106,106},{6,60}},
                lineColor={0,0,255},
                textString="m0=%m_flow_nominal")}));
      end FixedResistanceDpM;

      model SplitterFixedResistanceDpM
      "Flow splitter with fixed resistance at each port"
          extends Buildings.BaseClasses.BaseIcon;
          extends Buildings.Fluid.BaseClasses.PartialThreeWayResistance(
          mDyn_flow_nominal = sum(abs(m_flow_nominal[:])/3),
            redeclare Buildings.Fluid.FixedResistances.FixedResistanceDpM res1(
               redeclare package Medium=Medium,
                  final allowFlowReversal=true,
                  from_dp=from_dp,
                  final m_flow_nominal=m_flow_nominal[1],
                  final dp_nominal=dp_nominal[1],
                  final ReC=ReC[1],
                  final dh=dh[1],
                  linearized=linearized,
                  homotopyInitialization=homotopyInitialization,
                  deltaM=deltaM),
            redeclare Buildings.Fluid.FixedResistances.FixedResistanceDpM res2(
               redeclare package Medium=Medium,
                  final allowFlowReversal=true,
                  from_dp=from_dp,
                  final m_flow_nominal=m_flow_nominal[2],
                  final dp_nominal=dp_nominal[2],
                  final ReC=ReC[2],
                  final dh=dh[2],
                  linearized=linearized,
                  homotopyInitialization=homotopyInitialization,
                  deltaM=deltaM),
            redeclare Buildings.Fluid.FixedResistances.FixedResistanceDpM res3(
               redeclare package Medium=Medium,
                  final allowFlowReversal=true,
                  from_dp=from_dp,
                  final m_flow_nominal=m_flow_nominal[3],
                  final dp_nominal=dp_nominal[3],
                  final ReC=ReC[3],
                  final dh=dh[3],
                  linearized=linearized,
                  homotopyInitialization=homotopyInitialization,
                  deltaM=deltaM));

        parameter Boolean use_dh = false
        "Set to true to specify hydraulic diameter"
          annotation(Evaluate=true, Dialog(enable = not linearized));
        parameter Modelica.SIunits.MassFlowRate[3] m_flow_nominal
        "Mass flow rate. Set negative at outflowing ports."   annotation(Dialog(group = "Nominal condition"));
        parameter Modelica.SIunits.Pressure[3] dp_nominal(each displayUnit = "Pa")
        "Pressure. Set negative at outflowing ports."
          annotation(Dialog(group = "Nominal condition"));
        parameter Real deltaM(min=0) = 0.3
        "Fraction of nominal mass flow rate where transition to turbulent occurs"
             annotation(Dialog(enable = not use_dh and not linearized));

        parameter Modelica.SIunits.Length[3] dh={1, 1, 1} "Hydraulic diameter"
          annotation(Dialog(enable = use_dh and not linearized));
        parameter Real[3] ReC(each min=0)={4000, 4000, 4000}
        "Reynolds number where transition to turbulent starts"
            annotation(Dialog(enable = use_dh and not linearized));
        parameter Boolean linearized = false
        "= true, use linear relation between m_flow and dp for any flow rate"
          annotation(Dialog(tab="Advanced"));
        parameter Boolean homotopyInitialization = true
        "= true, use homotopy method"
          annotation(Evaluate=true, Dialog(tab="Advanced"));

        annotation (Diagram(graphics),
                             Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,
                  -100},{100,100}}), graphics={
              Polygon(
                points={{-100,-46},{-32,-40},{-32,-100},{30,-100},{30,-36},{100,-30},
                    {100,38},{-100,52},{-100,-46}},
                lineColor={0,0,0},
                fillColor={175,175,175},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-100,-34},{-18,-28},{-18,-100},{18,-100},{18,-26},{100,-20},
                    {100,22},{-100,38},{-100,-34}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={0,128,255}),
              Ellipse(
                visible=dynamicBalance,
                extent={{-38,36},{40,-40}},
                lineColor={0,0,127},
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid)}),
      defaultComponentName="spl",
          Documentation(info="<html>
<p>
Model of a flow splitter or mixer with a fixed resistance in each flow leg.
</p>
</html>"),
      revisions="<html>
<ul>
<li>
August 4, 2011 by Michael Wetter:<br>
Added <code>final allowFlowReversal=true</code> to all resistances since it is impractical
to avoid flow reversal in large flow networks where such a setting may be useful.
</li>
<li>
June 11, 2008 by Michael Wetter:<br>
Based class on 
<a href=\"modelica://Buildings.Fluid.BaseClasses.PartialThreeWayFixedResistance\">
PartialThreeWayFixedResistance</a>.
</li>
<li>
July 20, 2007 by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>");
      end SplitterFixedResistanceDpM;
    annotation (preferedView="info", Documentation(info="<html>
This package contains components models for fixed flow resistances. 
By fixed flow resistance, we mean resistances that do not change the 
flow coefficient
<p align=\"center\" style=\"font-style:italic;\">
k = m &frasl; 
&radic;<span style=\"text-decoration:overline;\">&Delta;P</span>.
</p>
<p>
For models of valves and air dampers, see
<a href=\"modelica://Buildings.Fluid.Actuators\">
Buildings.Fluid.Actuators</a>.
For models of flow resistances as part of the building constructions, see 
<a href=\"modelica://Buildings.Airflow.Multizone\">
Buildings.Airflow.Multizone</a>.
</p>
<p>
The model
<a href=\"modelica://Buildings.Fluid.FixedResistances.FixedResistanceDpM\">
Buildings.Fluid.FixedResistances.FixedResistanceDpM</a>
is a fixed flow resistance that takes as parameter a nominal flow rate and a nominal pressure drop. The actual resistance is scaled using the above equation.
</p>
<p>
The model
<a href=\"modelica://Buildings.Fluid.FixedResistances.LosslessPipe\">
Buildings.Fluid.FixedResistances.LosslessPipe</a>
is an ideal pipe segment with no pressure drop. It is primarily used
in models in which the above pressure drop model need to be replaced by a model with no pressure drop.
</p>
<p>
The model
<a href=\"modelica://Buildings.Fluid.FixedResistances.SplitterFixedResistanceDpM\">
Buildings.Fluid.FixedResistances.SplitterFixedResistanceDpM</a>
can be used to model flow splitters or flow merges.
</p>
</html>"));
    end FixedResistances;

    package HeatExchangers "Package with heat exchanger models"
      extends Modelica.Icons.VariantsPackage;

      model DryEffectivenessNTU
      "Heat exchanger with effectiveness - NTU relation and no moisture condensation"
        extends Buildings.Fluid.HeatExchangers.BaseClasses.PartialEffectiveness(
            sensibleOnly1=true, sensibleOnly2=true,
            Q1_flow = eps*QMax_flow,
            Q2_flow = -Q1_flow,
            mXi1_flow = zeros(Medium1.nXi),
            mXi2_flow = zeros(Medium2.nXi));
        import con = Buildings.Fluid.Types.HeatExchangerConfiguration;
        import flo = Buildings.Fluid.Types.HeatExchangerFlowRegime;

        parameter Modelica.SIunits.HeatFlowRate Q_flow_nominal
        "Nominal heat transfer"   annotation (Dialog(group="Nominal condition"));
        parameter Modelica.SIunits.Temperature T_a1_nominal
        "Nominal temperature at port a1"
          annotation (Dialog(group="Nominal condition"));
        parameter Modelica.SIunits.Temperature T_a2_nominal
        "Nominal temperature at port a2"
          annotation (Dialog(group="Nominal condition"));
        parameter con configuration "Heat exchanger configuration"
          annotation (Evaluate=true);

        parameter Real r_nominal(
          min=0,
          max=1) = 2/3
        "Ratio between air-side and water-side convective heat transfer (hA-value) at nominal condition";
        Buildings.Fluid.HeatExchangers.BaseClasses.HADryCoil hA(
          final r_nominal=r_nominal,
          final UA_nominal=UA_nominal,
          final m_flow_nominal_w=m1_flow_nominal,
          final m_flow_nominal_a=m2_flow_nominal,
          waterSideTemperatureDependent=false,
          airSideTemperatureDependent=false)
        "Model for convective heat transfer coefficient";
        Modelica.SIunits.ThermalConductance UA "UA value";

        Real eps(min=0, max=1) "Heat exchanger effectiveness";
        Real Z(min=0, max=1) "Ratio of capacity flow rate (CMin/CMax)";
        // NTU has been removed as NTU goes to infinity as CMin goes to zero.
        // This quantity is not good for modeling.
        //  Real NTU(min=0) "Number of transfer units";

        final parameter Modelica.SIunits.ThermalConductance UA_nominal(fixed=false)
        "Nominal UA value";
        final parameter Real NTU_nominal(min=0, fixed=false)
        "Nominal number of transfer units";
        final parameter Real eps_nominal(fixed=false)
        "Nominal heat transfer effectiveness";

    protected
        parameter Modelica.SIunits.SpecificHeatCapacity cp1_nominal(fixed=false)
        "Specific heat capacity of medium 1 at nominal condition";
        parameter Modelica.SIunits.SpecificHeatCapacity cp2_nominal(fixed=false)
        "Specific heat capacity of medium 2 at nominal condition";

        parameter Modelica.SIunits.ThermalConductance C1_flow_nominal(fixed=false)
        "Nominal capacity flow rate of Medium 1";
        parameter Modelica.SIunits.ThermalConductance C2_flow_nominal(fixed=false)
        "Nominal capacity flow rate of Medium 2";
        parameter Modelica.SIunits.ThermalConductance CMin_flow_nominal(fixed=false)
        "Minimal capacity flow rate at nominal condition";
        parameter Modelica.SIunits.ThermalConductance CMax_flow_nominal(fixed=false)
        "Maximum capacity flow rate at nominal condition";
        parameter Real Z_nominal(
          min=0,
          max=1,
          fixed=false) "Ratio of capacity flow rate at nominal condition";
        parameter Modelica.SIunits.Temperature T_b1_nominal(fixed=false)
        "Nominal temperature at port b1";
        parameter Modelica.SIunits.Temperature T_b2_nominal(fixed=false)
        "Nominal temperature at port b2";
        parameter flo flowRegime_nominal(fixed=false)
        "Heat exchanger flow regime at nominal flow rates";

        flo flowRegime(fixed=false, start=flowRegime_nominal)
        "Heat exchanger flow regime";
      initial equation
        assert(m1_flow_nominal > 0,
          "m1_flow_nominal must be positive, m1_flow_nominal = " + String(
          m1_flow_nominal));
        assert(m2_flow_nominal > 0,
          "m2_flow_nominal must be positive, m2_flow_nominal = " + String(
          m2_flow_nominal));
        cp1_nominal = Medium1.specificHeatCapacityCp(Medium1.setState_pTX(
          Medium1.p_default,
          T_a1_nominal,
          Medium1.X_default));
        cp2_nominal = Medium2.specificHeatCapacityCp(Medium2.setState_pTX(
          Medium2.p_default,
          T_a2_nominal,
          Medium2.X_default));
        // heat transfered from fluid 1 to 2 at nominal condition
        Q_flow_nominal = m1_flow_nominal*cp1_nominal*(T_a1_nominal - T_b1_nominal);
        Q_flow_nominal = -m2_flow_nominal*cp2_nominal*(T_a2_nominal - T_b2_nominal);
        C1_flow_nominal = m1_flow_nominal*cp1_nominal;
        C2_flow_nominal = m2_flow_nominal*cp2_nominal;
        CMin_flow_nominal = min(C1_flow_nominal, C2_flow_nominal);
        CMax_flow_nominal = max(C1_flow_nominal, C2_flow_nominal);
        Z_nominal = CMin_flow_nominal/CMax_flow_nominal;
        eps_nominal = abs(Q_flow_nominal/((T_a1_nominal - T_a2_nominal)*
          CMin_flow_nominal));
        assert(eps_nominal > 0 and eps_nominal < 1,
          "eps_nominal out of bounds, eps_nominal = " + String(eps_nominal) +
          "\n  To achieve the required heat transfer rate at epsilon=0.8, set |T_a1_nominal-T_a2_nominal| = "
           + String(abs(Q_flow_nominal/0.8*CMin_flow_nominal)) +
          "\n  or increase flow rates. The current parameters result in " +
          "\n  CMin_flow_nominal = " + String(CMin_flow_nominal) +
          "\n  CMax_flow_nominal = " + String(CMax_flow_nominal));

        // Assign the flow regime for the given heat exchanger configuration and capacity flow rates
        if (configuration == con.CrossFlowStream1MixedStream2Unmixed) then
          flowRegime_nominal = if (C1_flow_nominal < C2_flow_nominal) then flo.CrossFlowCMinMixedCMaxUnmixed
             else flo.CrossFlowCMinUnmixedCMaxMixed;
        elseif (configuration == con.CrossFlowStream1UnmixedStream2Mixed) then
          flowRegime_nominal = if (C1_flow_nominal < C2_flow_nominal) then flo.CrossFlowCMinUnmixedCMaxMixed
             else flo.CrossFlowCMinMixedCMaxUnmixed;
        elseif (configuration == con.ParallelFlow) then
          flowRegime_nominal = flo.ParallelFlow;
        elseif (configuration == con.CounterFlow) then
          flowRegime_nominal = flo.CounterFlow;
        elseif (configuration == con.CrossFlowUnmixed) then
          flowRegime_nominal = flo.CrossFlowUnmixed;
        else
          flowRegime_nominal = 0;
          assert(configuration > 0 and configuration < 6,
            "Invalid heat exchanger configuration.");
        end if;

        // The equation sorter of Dymola 7.3 does not guarantee that the above assert is tested prior to the
        // function call on the next line. Thus, we add the test on eps_nominal to avoid an error in ntu_epsilonZ
        // for invalid input arguments
        NTU_nominal = if (eps_nominal > 0 and eps_nominal < 1) then
          Buildings.Fluid.HeatExchangers.BaseClasses.ntu_epsilonZ(
          eps=eps_nominal,
          Z=Z_nominal,
          flowRegime=flowRegime_nominal) else 0;
        UA_nominal = NTU_nominal*CMin_flow_nominal;

      equation
        // Assign the flow regime for the given heat exchanger configuration and capacity flow rates
        if (configuration == con.ParallelFlow) then
          flowRegime = if (C1_flow*C2_flow >= 0) then flo.ParallelFlow else flo.CounterFlow;
        elseif (configuration == con.CounterFlow) then
          flowRegime = if (C1_flow*C2_flow >= 0) then flo.CounterFlow else flo.ParallelFlow;
        elseif (configuration == con.CrossFlowUnmixed) then
          flowRegime = flo.CrossFlowUnmixed;
        elseif (configuration == con.CrossFlowStream1MixedStream2Unmixed) then
          flowRegime = if (C1_flow < C2_flow) then flo.CrossFlowCMinMixedCMaxUnmixed
             else flo.CrossFlowCMinUnmixedCMaxMixed;
        else
          // have ( configuration == con.CrossFlowStream1UnmixedStream2Mixed)
          flowRegime = if (C1_flow < C2_flow) then flo.CrossFlowCMinUnmixedCMaxMixed
             else flo.CrossFlowCMinMixedCMaxUnmixed;
        end if;
        // Convective heat transfer coefficient
        hA.m1_flow = m1_flow;
        hA.m2_flow = m2_flow;
        hA.T_1 = T_in1;
        hA.T_2 = T_in2;
        UA = 1/(1/hA.hA_1 + 1/hA.hA_2);
        // effectiveness
        (eps,Z) = Buildings.Fluid.HeatExchangers.BaseClasses.epsilon_C(
          UA=UA,
          C1_flow=C1_flow,
          C2_flow=C2_flow,
          flowRegime=flowRegime,
          CMin_flow_nominal=CMin_flow_nominal,
          CMax_flow_nominal=CMax_flow_nominal,
          delta=delta);
        annotation (
          Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                  100}}), graphics={Rectangle(
                extent={{-70,78},{70,-82}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid)}),
          preferedView="info",
      defaultComponentName="hex",
          Documentation(info="<html>
<p>
Model of a heat exchanger without humidity condensation. 
This model transfers heat in the amount of 
<p align=\"center\" style=\"font-style:italic;\">
  Q = Q<sub>max</sub>  &epsilon;<br>
  &epsilon; = f(NTU, Z, flowRegime),
</p>
where
<i>Q<sub>max</sub></i> is the maximum heat that can be transferred,
<i>&epsilon;</i> is the heat transfer effectiveness, 
<i>NTU</i> is the Number of Transfer Units,
<i>Z</i> is the ratio of minimum to maximum capacity flow rate and
<i>flowRegime</i> is the heat exchanger flow regime.
such as
parallel flow, cross flow or counter flow.
</p>
<p>
The flow regimes depend on the heat exchanger configuration. All configurations
defined in
<a href=\"modelica://Buildings.Fluid.Types.HeatExchangerConfiguration\">
Buildings.Fluid.Types.HeatExchangerConfiguration</a>
are supported.
</p>
<p>
For a heat and moisture exchanger, use
<a href=\"modelica://Buildings.Fluid.MassExchangers.ConstantEffectiveness\">
Buildings.Fluid.MassExchangers.ConstantEffectiveness</a>
instead of this model.
</p>
</html>",       revisions="<html>
<ul>
<li>
February 12, 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{
                  100,100}}), graphics));
      end DryEffectivenessNTU;

      model DryCoilCounterFlow
      "Counterflow coil with discretization along the flow paths and without humidity condensation"
        extends Fluid.Interfaces.PartialFourPortInterface(show_T=false);
        extends Buildings.Fluid.Interfaces.FourPortFlowResistanceParameters(
          final computeFlowResistance1=false,
          final computeFlowResistance2=false,
          from_dp1=false,
          from_dp2=false);

        parameter Modelica.SIunits.ThermalConductance UA_nominal(min=0)
        "Thermal conductance at nominal flow, used to compute heat capacity"
          annotation (Dialog(tab="General", group="Nominal condition"));
        parameter Real r_nominal=2/3
        "Ratio between air-side and water-side convective heat transfer coefficient"
          annotation (Dialog(group="Nominal condition"));
        parameter Integer nEle(min=1) = 4
        "Number of pipe segments used for discretization"
          annotation (Dialog(group="Geometry"));

        parameter Modelica.Fluid.Types.Dynamics energyDynamics1=Modelica.Fluid.Types.Dynamics.DynamicFreeInitial
        "Default formulation of energy balances for volume 1"
          annotation (Evaluate=true,Dialog(tab="Dynamics", group="Equations"));
        parameter Modelica.Fluid.Types.Dynamics energyDynamics2=Modelica.Fluid.Types.Dynamics.DynamicFreeInitial
        "Default formulation of energy balances for volume 2"
          annotation (Evaluate=true,Dialog(tab="Dynamics", group="Equations"));

        parameter Modelica.SIunits.Time tau1=20
        "Time constant at nominal flow for medium 1"
          annotation (Dialog(group="Nominal condition", enable=not steadyState_1));
        parameter Modelica.SIunits.Time tau2=1
        "Time constant at nominal flow for medium 2"
          annotation (Dialog(group="Nominal condition", enable=not steadyState_2));
        parameter Modelica.SIunits.Time tau_m=20
        "Time constant of metal at nominal UA value"
          annotation (Dialog(group="Nominal condition"));

        parameter Boolean waterSideFlowDependent=true
        "Set to false to make water-side hA independent of mass flow rate"
          annotation (Dialog(tab="Heat transfer"));
        parameter Boolean airSideFlowDependent=true
        "Set to false to make air-side hA independent of mass flow rate"
          annotation (Dialog(tab="Heat transfer"));
        parameter Boolean waterSideTemperatureDependent=false
        "Set to false to make water-side hA independent of temperature"
          annotation (Dialog(tab="Heat transfer"));
        parameter Boolean airSideTemperatureDependent=false
        "Set to false to make air-side hA independent of temperature"
          annotation (Dialog(tab="Heat transfer"));

        Modelica.SIunits.HeatFlowRate Q1_flow
        "Heat transfered from solid into medium 1";
        Modelica.SIunits.HeatFlowRate Q2_flow
        "Heat transfered from solid into medium 2";

        Modelica.SIunits.Temperature T1[nEle] "Water temperature";
        Modelica.SIunits.Temperature T2[nEle] "Air temperature";
        Modelica.SIunits.Temperature T_m[nEle] "Metal temperature";

        BaseClasses.HADryCoil hA(
          final UA_nominal=UA_nominal,
          final m_flow_nominal_a=m2_flow_nominal,
          final m_flow_nominal_w=m1_flow_nominal,
          final waterSideTemperatureDependent=waterSideTemperatureDependent,
          final waterSideFlowDependent=waterSideFlowDependent,
          final airSideTemperatureDependent=airSideTemperatureDependent,
          final airSideFlowDependent=airSideFlowDependent,
          r_nominal=r_nominal) "Model for convective heat transfer coefficient"
          annotation (Placement(transformation(extent={{-60,80},{-40,100}}, rotation=
                  0)));
    protected
        constant Boolean allowCondensation=false
        "Set to false to compute sensible heat transfer only"
          annotation (Dialog(tab="Heat transfer"));
        Buildings.Fluid.Sensors.TemperatureTwoPort temSen_1(redeclare package
          Medium =
              Medium1,
          allowFlowReversal=allowFlowReversal1,
          m_flow_nominal=m1_flow_nominal) "Temperature sensor"
                                            annotation (Placement(transformation(
                extent={{-58,54},{-48,66}}, rotation=0)));
        Buildings.Fluid.Sensors.MassFlowRate masFloSen_1(redeclare package
          Medium =
              Medium1) "Mass flow rate sensor" annotation (Placement(transformation(
                extent={{-80,54},{-68,66}}, rotation=0)));
        Buildings.Fluid.Sensors.TemperatureTwoPort temSen_2(redeclare package
          Medium =
              Medium2,
          final allowFlowReversal=allowFlowReversal2,
          m_flow_nominal=m2_flow_nominal) "Temperature sensor"
                                            annotation (Placement(transformation(
                extent={{58,-66},{44,-54}}, rotation=0)));
        Buildings.Fluid.Sensors.MassFlowRate masFloSen_2(redeclare package
          Medium =
              Medium2) "Mass flow rate sensor" annotation (Placement(transformation(
                extent={{82,-66},{70,-54}}, rotation=0)));
        Modelica.Blocks.Math.Gain gai_1(k=1/nEle)
        "Gain medium-side 1 to take discretization into account"   annotation (
            Placement(transformation(extent={{-18,84},{-6,96}}, rotation=0)));
        Modelica.Blocks.Math.Gain gai_2(k=1/nEle)
        "Gain medium-side 2 to take discretization into account"   annotation (
            Placement(transformation(extent={{-18,62},{-6,74}}, rotation=0)));

        BaseClasses.HexElement ele[nEle](
          redeclare each package Medium1 = Medium1,
          redeclare each package Medium2 = Medium2,
          redeclare each Buildings.Fluid.MixingVolumes.MixingVolumeDryAir vol2,
          each allowFlowReversal1=allowFlowReversal1,
          each allowFlowReversal2=allowFlowReversal2,
          each tau1=tau1/nEle,
          each m1_flow_nominal=m1_flow_nominal,
          each tau2=tau2,
          each m2_flow_nominal=m2_flow_nominal,
          each tau_m=tau_m/nEle,
          each UA_nominal=UA_nominal/nEle,
          each energyDynamics1=energyDynamics1,
          each energyDynamics2=energyDynamics2,
          each allowCondensation=allowCondensation,
          each deltaM1=deltaM1,
          each deltaM2=deltaM2,
          each from_dp1=from_dp1,
          each from_dp2=from_dp2,
          dp1_nominal={if i == 1 then dp1_nominal else 0 for i in 1:nEle},
          dp2_nominal={if i == nEle then 0 else dp2_nominal for i in 1:nEle})
        "Heat exchanger element"
          annotation (Placement(transformation(extent={{0,0},{20,20}})));
        Modelica.Blocks.Routing.Replicator rep1(nout=nEle) "Signal replicator"
          annotation (Placement(transformation(extent={{4,82},{18,98}})));
        Modelica.Blocks.Routing.Replicator rep2(nout=nEle) "Signal replicator"
          annotation (Placement(transformation(extent={{4,60},{18,76}})));

      initial equation
        assert(UA_nominal > 0,
          "Parameter UA_nominal is negative. Check heat exchanger parameters.");
      equation
        Q1_flow = sum(ele[i].Q1_flow for i in 1:nEle);
        Q2_flow = sum(ele[i].Q2_flow for i in 1:nEle);
        T1[:] = ele[:].vol1.T;
        T2[:] = ele[:].vol2.T;
        T_m[:] = ele[:].mas.T;
        connect(masFloSen_1.m_flow, hA.m1_flow) annotation (Line(points={{-74,66.6},{
                -74,72},{-82,72},{-82,97},{-61,97}}, color={0,0,127}));
        connect(port_a2, masFloSen_2.port_a)
          annotation (Line(points={{100,-60},{82,-60}}, color={0,127,255}));
        connect(masFloSen_2.port_b, temSen_2.port_a)
          annotation (Line(points={{70,-60},{58,-60}}, color={0,127,255}));
        connect(temSen_2.T, hA.T_2) annotation (Line(points={{51,-53.4},{51,-46},{-88,
                -46},{-88,87},{-61,87}}, color={0,0,127}));
        connect(masFloSen_2.m_flow, hA.m2_flow) annotation (Line(points={{76,-53.4},{
                76,-44},{-86,-44},{-86,83},{-61,83}}, color={0,0,127}));
        connect(hA.hA_1, gai_1.u) annotation (Line(points={{-39,97},{-28,97},{-28,90},
                {-19.2,90}}, color={0,0,255}));
        connect(hA.hA_2, gai_2.u) annotation (Line(points={{-39,83},{-27.5,83},{-27.5,
                68},{-19.2,68}}, color={0,0,255}));
        connect(port_a1, masFloSen_1.port_a) annotation (Line(
            points={{-100,60},{-80,60}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(masFloSen_1.port_b, temSen_1.port_a) annotation (Line(
            points={{-68,60},{-58,60}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(temSen_1.T, hA.T_1) annotation (Line(
            points={{-53,66.6},{-53,74},{-78,74},{-78,93},{-61,93}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(temSen_1.port_b, ele[1].port_a1) annotation (Line(
            points={{-48,60},{-30,60},{-30,16},{0,16}},
            color={0,127,255},
            smooth=Smooth.None));

        connect(ele[nEle].port_b1, port_b1) annotation (Line(
            points={{20,16},{40,16},{40,60},{100,60}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(temSen_2.port_b, ele[nEle].port_a2) annotation (Line(
            points={{44,-60},{30,-60},{30,4},{20,4}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(ele[1].port_b2, port_b2) annotation (Line(
            points={{0,4},{-30,4},{-30,-60},{-100,-60}},
            color={0,127,255},
            smooth=Smooth.None));
        for i in 1:nEle - 1 loop
          connect(ele[i].port_b1, ele[i + 1].port_a1) annotation (Line(
              points={{20,16},{30,16},{30,30},{-10,30},{-10,16},{0,16}},
              color={0,127,255},
              smooth=Smooth.None));
          connect(ele[i].port_a2, ele[i + 1].port_b2) annotation (Line(
              points={{20,4},{-12,4},{-12,-10},{30,-10},{30,4},{0,4}},
              color={0,127,255},
              smooth=Smooth.None));
        end for;

        connect(gai_1.y, rep1.u) annotation (Line(
            points={{-5.4,90},{2.6,90}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(rep1.y, ele.Gc_1) annotation (Line(
            points={{18.7,90},{22,90},{22,46},{6,46},{6,20}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(gai_2.y, rep2.u) annotation (Line(
            points={{-5.4,68},{2.6,68}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(rep2.y, ele.Gc_2) annotation (Line(
            points={{18.7,68},{26,68},{26,-6},{14,-6},{14,0}},
            color={0,0,127},
            smooth=Smooth.None));
        annotation (
      defaultComponentName="heaCoi",
      Documentation(info="<html>
<p>
Model of a discretized coil without water vapor condensation.
The coil consists of two flow paths which are, at the design flow direction,
in opposite direction to model a counterflow heat exchanger.
The flow paths are discretized into <code>nEle</code> elements. 
Each element is modeled by an instance of
<a href=\"modelica://Buildings.Fluid.HeatExchangers.BaseClasses.HexElement\">
Buildings.Fluid.HeatExchangers.BaseClasses.HexElement</a>.
Each element has a state variable for the metal. Depending
on the value of the boolean parameters <code>steadyState_1</code> and
<code>steadyState_2</code>, the fluid states are modeled dynamically or in steady
state.
</p>
<p>
The convective heat transfer coefficients can, for each fluid individually, be 
computed as a function of the flow rate and/or the temperature,
or assigned to a constant. This computation is done using an instance of
<a href=\"modelica://Buildings.Fluid.HeatExchangers.BaseClasses.HADryCoil\">
Buildings.Fluid.HeatExchangers.BaseClasses.HADryCoil</a>.
</p>
<p>
To model humidity condensation, use the model 
<a href=\"modelica://Buildings.Fluid.HeatExchangers.WetCoilCounterFlow\">
Buildings.Fluid.HeatExchangers.WetCoilCounterFlow</a> instead of this model, as
this model computes only sensible heat transfer.
</p>
</html>",       revisions="<html>
<ul>
<li>
October 8, 2011, by Michael Wetter:<br>
Set <code>show_T=false</code> to avoid state events near zero flow.
</li>
<li>
May 27, 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-100,-100},{100,100}},
              grid={2,2},
              initialScale=0.5), graphics={
              Rectangle(
                extent={{-70,80},{70,-80}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{36,80},{40,-80}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-40,80},{-36,-80}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-2,80},{2,-80}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-100,-55},{101,-65}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,127,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-98,65},{103,55}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,255},
                fillPattern=FillPattern.Solid)}),
          Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={2,2},
              initialScale=0.5), graphics={Text(
                extent={{60,72},{84,58}},
                lineColor={0,0,255},
                textString="water-side"), Text(
                extent={{50,-32},{90,-38}},
                lineColor={0,0,255},
                textString="air-side")}));
      end DryCoilCounterFlow;

      model WetCoilCounterFlow
      "Counterflow coil with discretization along the flow paths and humidity condensation"
        extends Buildings.Fluid.HeatExchangers.DryCoilCounterFlow(
          final allowCondensation = true,
          ele(redeclare each final
            Buildings.Fluid.MixingVolumes.MixingVolumeMoistAir                        vol2));

        Modelica.SIunits.HeatFlowRate QSen2_flow
        "Sensible heat input into air stream (negative if air is cooled)";
        Modelica.SIunits.HeatFlowRate QLat2_flow
        "Latent heat input into air (negative if air is dehumidified)";
        Real SHR(
          min=0,
          max=1,
          unit="1") "Sensible to total heat ratio";

        Modelica.SIunits.MassFlowRate mWat_flow "Water flow rate";

      equation
        mWat_flow = sum(ele[i].vol2.mWat_flow for i in 1:nEle);
        QLat2_flow = sum(Medium2.enthalpyOfCondensingGas(ele[i].vol2.heatPort.T)*ele[i].vol2.mWat_flow for i in 1:nEle);
        Q2_flow = QSen2_flow + QLat2_flow;
        Q2_flow*SHR = QSen2_flow;
       annotation (
      defaultComponentName="cooCoi",
          Documentation(info="<html>
<p>
Model of a discretized coil with water vapor condensation.
The coil consists of two flow paths which are, at the design flow direction,
in opposite direction to model a counterflow heat exchanger.
The flow paths are discretized into <code>nEle</code> elements. 
Each element is modeled by an instance of
<a href=\"modelica://Buildings.Fluid.HeatExchangers.BaseClasses.HexElement\">
Buildings.Fluid.HeatExchangers.BaseClasses.HexElement</a>.
Each element has a state variable for the metal. Depending
on the value of the boolean parameters <code>steadyState_1</code> and
<code>steadyState_2</code>, the fluid states are modeled dynamically or in steady
state.
</p>
<p>
The convective heat transfer coefficients can, for each fluid individually, be 
computed as a function of the flow rate and/or the temperature,
or assigned to a constant. This computation is done using an instance of
<a href=\"modelica://Buildings.Fluid.HeatExchangers.BaseClasses.HADryCoil\">
Buildings.Fluid.HeatExchangers.BaseClasses.HADryCoil</a>.
</p>
<p>
In this model, the water (or liquid) flow path
needs to be connected to <code>port_a1</code> and <code>port_b1</code>, and
the air flow path needs to be connected to the other two ports.
</p>
<p>
The mass transfer from the fluid 2 to the metal is computed using a similarity law between
heat and mass transfer, as implemented by the model
<a href=\"modelica://Buildings.Fluid.HeatExchangers.BaseClasses.MassExchange\">
Buildings.Fluid.HeatExchangers.BaseClasses.MassExchange</a>. 
</p>
<p>
This model can only be used with medium models that
implement the function <code>enthalpyOfLiquid</code> and that contain
an integer variable <code>Water</code> whose value is the element number where
the water vapor is stored in the species concentration vector. Examples for
such media are
<a href=\"modelica://Buildings.Media.PerfectGases.MoistAir\">
Buildings.Media.PerfectGases.MoistAir</a> and
<a href=\"Modelica:Modelica.Media.Air.MoistAir\">
Modelica.Media.Air.MoistAir</a>.
</p>
<p>
To model this coil for conditions without humidity condensation, use the model 
<a href=\"modelica://Buildings.Fluid.HeatExchangers.DryCoilCounterFlow\">
Buildings.Fluid.HeatExchangers.DryCoilCounterFlow</a> instead of this model.
</p>
</html>",       revisions="<html>
<ul>
<li>
May 27, 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),       Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-100,-100},{100,100}},
              grid={2,2},
              initialScale=0.5), graphics={
              Rectangle(
                extent={{-70,80},{70,-80}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{36,80},{40,-80}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-40,80},{-36,-80}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-2,80},{2,-80}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-100,-55},{101,-65}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,127,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-98,65},{103,55}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,255},
                fillPattern=FillPattern.Solid)}),
          Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={2,2},
              initialScale=0.5), graphics={Text(
                extent={{60,72},{84,58}},
                lineColor={0,0,255},
                textString="water-side"), Text(
                extent={{50,-32},{90,-38}},
                lineColor={0,0,255},
                textString="air-side")}));
      end WetCoilCounterFlow;

      package BaseClasses
      "Package with base classes for Buildings.Fluid.HeatExchangers"
        extends Modelica.Icons.BasesPackage;

        model HADryCoil
        "Sensible convective heat transfer model for air to water coil"
          extends Buildings.BaseClasses.BaseIcon;
          parameter Modelica.SIunits.ThermalConductance UA_nominal(min=0)
          "Thermal conductance at nominal flow"
                  annotation(Dialog(tab="General", group="Nominal condition"));

          parameter Modelica.SIunits.MassFlowRate m_flow_nominal_w
          "Water mass flow rate"
                  annotation(Dialog(tab="General", group="Nominal condition"));
          parameter Modelica.SIunits.MassFlowRate m_flow_nominal_a
          "Air mass flow rate"
                  annotation(Dialog(tab="General", group="Nominal condition"));

          Modelica.Blocks.Interfaces.RealInput m1_flow
          "Mass flow rate medium 1"
            annotation (Placement(transformation(extent={{-120,60},{-100,80}}, rotation=
                   0)));
          Modelica.Blocks.Interfaces.RealInput m2_flow
          "Mass flow rate medium 2"
            annotation (Placement(transformation(extent={{-120,-80},{-100,-60}},
                  rotation=0)));
          Modelica.Blocks.Interfaces.RealInput T_1 "Temperature medium 1"
            annotation (Placement(transformation(extent={{-120,20},{-100,40}}, rotation=
                   0)));
          Modelica.Blocks.Interfaces.RealInput T_2 "Temperature medium 2"
            annotation (Placement(transformation(extent={{-120,-40},{-100,-20}},
                  rotation=0)));

          Modelica.Blocks.Interfaces.RealOutput hA_1
          "Convective heat transfer medium 1"   annotation (Placement(transformation(
                  extent={{100,60},{120,80}}, rotation=0)));
          Modelica.Blocks.Interfaces.RealOutput hA_2
          "Convective heat transfer medium 2"   annotation (Placement(transformation(
                  extent={{100,-80},{120,-60}}, rotation=0)));

          parameter Real r_nominal(min=0, max=1)=0.5
          "Ratio between air-side and water-side convective heat transfer coefficient"
                  annotation(Dialog(tab="General", group="Nominal condition"));
          parameter Modelica.SIunits.ThermalConductance hA_nominal_w(min=0)=UA_nominal * (r_nominal+1)/r_nominal
          "Water side convective heat transfer coefficient"
                  annotation(Dialog(tab="General", group="Nominal condition"));
          parameter Modelica.SIunits.ThermalConductance hA_nominal_a(min=0)=r_nominal * hA_nominal_w
          "Air side convective heat transfer coefficient, including fin resistance"
                  annotation(Dialog(tab="General", group="Nominal condition"));
          parameter Real n_w(min=0, max=1)=0.85
          "Water-side exponent for convective heat transfer coefficient, h~m_flow^n";
          parameter Real n_a(min=0, max=1)=0.8
          "Air-side exponent for convective heat transfer coefficient, h~m_flow^n";
          parameter Modelica.SIunits.Temperature T0_w=
                  Modelica.SIunits.Conversions.from_degC(20)
          "Water temperature"
                  annotation(Dialog(tab="General", group="Nominal condition"));
          parameter Modelica.SIunits.Temperature T0_a=
                  Modelica.SIunits.Conversions.from_degC(20) "Air temperature"
                  annotation(Dialog(tab="General", group="Nominal condition"));
          parameter Boolean waterSideFlowDependent=true
          "Set to false to make water-side hA independent of mass flow rate"
            annotation(Dialog(tab="Advanced", group="Modeling detail"), Evaluate=true);
          parameter Boolean airSideFlowDependent = true
          "Set to false to make air-side hA independent of mass flow rate"
            annotation(Dialog(tab="Advanced", group="Modeling detail"), Evaluate=true);
          parameter Boolean waterSideTemperatureDependent = true
          "Set to false to make water-side hA independent of temperature"
            annotation(Dialog(tab="Advanced", group="Modeling detail"), Evaluate=true);
          parameter Boolean airSideTemperatureDependent = true
          "Set to false to make air-side hA independent of temperature"
            annotation(Dialog(tab="Advanced", group="Modeling detail"), Evaluate=true);
      protected
          Real x_a(min=0)
          "Factor for air side temperature dependent variation of heat transfer coefficient";
          Real x_w(min=0)
          "Factor for water side temperature dependent variation of heat transfer coefficient";
          parameter Real s_w(min=0, fixed=false)
          "Coefficient for temperature dependence of water side heat transfer coefficient";
          Real fm_w "Fraction of actual to nominal mass flow rate";
          Real fm_a "Fraction of actual to nominal mass flow rate";
        initial equation
          s_w =  if waterSideTemperatureDependent then
                    0.014/(1+0.014*Modelica.SIunits.Conversions.to_degC(T0_w)) else
                      1;
        equation
          fm_w = if waterSideFlowDependent then
                      m1_flow / m_flow_nominal_w else 1;
          fm_a = if airSideFlowDependent then
                      m2_flow / m_flow_nominal_a else 1;
          x_w = if waterSideTemperatureDependent then
                 1 + s_w * (T_1-T0_w) else
                      1;
          x_a = if airSideTemperatureDependent then
                 1 + 4.769E-3 * (T_2-T0_a) else
                      1;
          if waterSideFlowDependent then
            hA_1 = x_w * hA_nominal_w
                       * Buildings.Utilities.Math.Functions.regNonZeroPower(fm_w, n_w, 0.1);
          else
            hA_1 = x_w * hA_nominal_w;
          end if;

          if airSideFlowDependent then
            hA_2 = x_a * hA_nominal_a
                       * Buildings.Utilities.Math.Functions.regNonZeroPower(fm_a, n_a, 0.1);
          else
            hA_2 = x_a * hA_nominal_a;
          end if;
        annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}),
                            graphics),
        Documentation(info="<html>
<p>
Model for sensible convective heat transfer coefficients for an air to water coil.
</p>
<p>
This model computes the convective heat transfer coefficient
for an air to water coil.
The parameters allow a user to enable or disable, individually
for each medium, the mass flow and/or the temperature dependence
of the convective heat transfer coefficients.
For a detailed explanation of the equation, see
the references below.
</p>
<h4>References</h4>
<p>
<ul>
<li>
Wetter Michael,
<A HREF=\"http://www.osti.gov/energycitations/product.biblio.jsp?osti_id=7353\">
Simulation model finned water-air-coil without condensation</a>,
LBNL-42355,
Lawrence Berkeley National Laboratory,
Berkeley, CA, 1999.
</li>
<li>
Wetter Michael,
<A HREF=\"http://www.osti.gov/energycitations/product.biblio.jsp?osti_id=7352\">
Simulation model air-to-air plate heat exchanger</A>,
LBNL-42354,
Lawrence Berkeley National Laboratory,
Berkeley, CA, 1999.
</li>
</ul>
</p>
</html>",
        revisions="<html>
<ul>
<li>
June 8, 2010, by Michael Wetter:<br>
Fixed bug in computation of <code>s_w</code>.
The old implementation used the current inlet water temperature instead
of the design condition that corresponds to <code>UA_nominal</code>.
</li>
<li>
April 16, 2008, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                    100}}), graphics={Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid), Text(
                  extent={{-66,74},{92,-50}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  textString="hA")}),
                      Icon(
              Rectangle(extent=[-36,-36; -24,-72],   style(
                  color=0,
                  fillColor=8,
                  fillPattern=8)),
              Line(points=[-12,-52; 26,-52],    style(color=42, fillColor=45)),
              Line(points=[-4,-40; -4,-68],    style(color=69, fillColor=47)),
              Line(points=[-4,-68; -10,-58],    style(color=69, fillColor=47)),
              Line(points=[-4,-68; 2,-58],      style(color=69, fillColor=47)),
              Line(points=[14,-58; 26,-52],    style(color=42, fillColor=45)),
              Line(points=[14,-46; 26,-52],    style(color=42, fillColor=45)),
              Line(points=[16,-40; 16,-68],    style(color=69, fillColor=47)),
              Line(points=[16,-68; 10,-58],     style(color=69, fillColor=47)),
              Line(points=[16,-68; 22,-58],     style(color=69, fillColor=47)),
              Rectangle(extent=[-36,66; -24,30],     style(
                  color=0,
                  fillColor=8,
                  fillPattern=8)),
              Line(points=[-12,50; 26,50],      style(color=42, fillColor=45)),
              Line(points=[-4,62; -4,34],      style(color=69, fillColor=47)),
              Line(points=[-4,34; -10,44],      style(color=69, fillColor=47)),
              Line(points=[-4,34; 2,44],        style(color=69, fillColor=47)),
              Line(points=[14,44; 26,50],      style(color=42, fillColor=45)),
              Line(points=[14,56; 26,50],      style(color=42, fillColor=45)),
              Line(points=[16,62; 16,34],      style(color=69, fillColor=47)),
              Line(points=[16,34; 10,44],       style(color=69, fillColor=47)),
              Line(points=[16,34; 22,44],       style(color=69, fillColor=47))));
        end HADryCoil;

        model HexElement "Element of a heat exchanger"
          extends Buildings.Fluid.Interfaces.FourPortHeatMassExchanger(
            vol1( V=m1_flow_nominal*tau1/rho1_nominal,
                  nPorts=2,
                  final energyDynamics=energyDynamics1,
                  final massDynamics=energyDynamics1),
            redeclare
            Buildings.Fluid.MixingVolumes.BaseClasses.PartialMixingVolumeWaterPort
                vol2(
                  nPorts = 2,
                  V=m2_flow_nominal*tau2/rho2_nominal,
                  final energyDynamics=energyDynamics2,
                  final massDynamics=energyDynamics2));
          // Note that we MUST declare the value of vol2.V here.
          // Otherwise, if the class of vol2 is redeclared at a higher level,
          // it will overwrite the assignment of V in the base class
          // FourPortHeatMassExchanger, which will cause V=0.
          // Assigning the values for vol1 here is optional, but we added
          // it to be consistent in the implementation of vol1 and vol2.

          parameter Modelica.SIunits.ThermalConductance UA_nominal
          "Thermal conductance at nominal flow, used to compute time constant"
             annotation(Dialog(group = "Nominal condition"));
          parameter Modelica.SIunits.Time tau_m(min=0) = 60
          "Time constant of metal at nominal UA value"
                  annotation(Dialog(tab="General", group="Nominal condition"));
          parameter Modelica.SIunits.HeatCapacity C=2*UA_nominal*tau_m
          "Heat capacity of metal (= cp*m)";

          Modelica.Blocks.Interfaces.RealInput Gc_1
          "Signal representing the convective thermal conductance medium 1 in [W/K]"
            annotation (Placement(transformation(
                origin={-40,100},
                extent={{-20,-20},{20,20}},
                rotation=270)));
          Modelica.Blocks.Interfaces.RealInput Gc_2
          "Signal representing the convective thermal conductance medium 2 in [W/K]"
            annotation (Placement(transformation(
                origin={40,-100},
                extent={{-20,-20},{20,20}},
                rotation=90)));

          parameter Boolean allowCondensation = true
          "Set to false to compute sensible heat transfer only";

          MassExchange masExc(
               redeclare package Medium = Medium2) if allowCondensation
          "Model for mass exchange"          annotation (Placement(transformation(
                  extent={{48,-44},{68,-24}}, rotation=0)));

          parameter Modelica.Fluid.Types.Dynamics energyDynamics1=
            Modelica.Fluid.Types.Dynamics.DynamicFreeInitial
          "Default formulation of energy balances for volume 1"
            annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));
          parameter Modelica.Fluid.Types.Dynamics energyDynamics2=
            Modelica.Fluid.Types.Dynamics.DynamicFreeInitial
          "Default formulation of energy balances for volume 2"
            annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));

          Modelica.Thermal.HeatTransfer.Components.HeatCapacitor mas(
                                                          C=C, T(stateSelect=StateSelect.always))
          "Mass of metal"
            annotation (Placement(transformation(
                origin={-82,0},
                extent={{-10,-10},{10,10}},
                rotation=90)));
          Modelica.Thermal.HeatTransfer.Components.Convection con1(dT(min=-200))
          "Convection (and conduction) on fluid side 1"
            annotation (Placement(transformation(extent={{-60,10},{-40,30}}, rotation=0)));
          Modelica.Thermal.HeatTransfer.Components.Convection con2(dT(min=-200))
          "Convection (and conduction) on fluid side 2"
            annotation (Placement(transformation(extent={{-60,-30},{-40,-10}}, rotation=
                   0)));
          Modelica.Thermal.HeatTransfer.Sensors.TemperatureSensor temSen(
            T(final quantity="Temperature",
              final unit = "K", displayUnit = "degC", min=0))
          "Temperature sensor of metal"
            annotation (Placement(transformation(extent={{8,-10},{28,10}},  rotation=0)));
          Modelica.Thermal.HeatTransfer.Sensors.HeatFlowSensor heaFloSen_1
          "Heat input into fluid 1"   annotation (Placement(transformation(extent={{-34,10},
                    {-14,30}},   rotation=0)));
          Modelica.Thermal.HeatTransfer.Sensors.HeatFlowSensor heaFloSen_2
          "Heat input into fluid 1"   annotation (Placement(transformation(extent={{-24,-30},
                    {-4,-10}},     rotation=0)));
        equation
          connect(Gc_1, con1.Gc) annotation (Line(points={{-40,100},{-40,40},{-50,40},{
                  -50,30}}, color={0,0,127}));
          connect(Gc_2, con2.Gc) annotation (Line(points={{40,-100},{40,-76},{-34,-76},
                  {-34,-4},{-50,-4},{-50,-10}}, color={0,0,127}));
          connect(temSen.T, masExc.TSur) annotation (Line(points={{28,0},{36,0},{36,-26},
                  {46,-26}},                    color={0,0,127}));
          connect(Gc_2, masExc.Gc) annotation (Line(points={{40,-100},{40,-42},{46,-42}},
                color={0,0,127}));
          connect(masExc.mWat_flow, vol2.mWat_flow) annotation (Line(points={{69,-32},{
                  80,-32},{80,-52},{14,-52}},  color={0,0,127}));
          connect(masExc.TLiq, vol2.TWat) annotation (Line(points={{69,-38},{72,-38},{
                  72,-55.2},{14,-55.2}},
                                     color={0,0,127}));
          connect(vol2.X_w, masExc.XInf) annotation (Line(points={{-10,-64},{-20,-64},
                  {-20,-34},{46,-34}}, color={0,0,127}));
          connect(con1.solid,mas. port) annotation (Line(points={{-60,20},{-72,20},{-72,
                  -6.12323e-016}}, color={191,0,0}));
          connect(con2.solid,mas. port) annotation (Line(points={{-60,-20},{-60,-20.5},
                  {-72,-20.5},{-72,-6.12323e-016}}, color={191,0,0}));
          connect(mas.port,temSen. port)      annotation (Line(points={{-72,
                  -6.12323e-016},{-39,-6.12323e-016},{-39,0},{8,0}},
                                  color={191,0,0}));
          connect(con1.fluid,heaFloSen_1. port_a)
            annotation (Line(points={{-40,20},{-34,20}}, color={191,0,0}));
          connect(con2.fluid,heaFloSen_2. port_a) annotation (Line(points={{-40,-20},{
                  -24,-20}}, color={191,0,0}));
          connect(heaFloSen_1.port_b, vol1.heatPort) annotation (Line(
              points={{-14,20},{-14,60},{-10,60}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(heaFloSen_2.port_b, vol2.heatPort) annotation (Line(
              points={{-4,-20},{22,-20},{22,-60},{12,-60}},
              color={191,0,0},
              smooth=Smooth.None));
          annotation (
            Documentation(info="<html>
<p>
Element of a heat exchanger with dynamics on the fluids and the solid. 
The <i>hA</i> value for both fluids is an input.
The driving force for the heat transfer is the temperature difference
between the fluid volumes and the solid.
<p>
The heat capacity <i>C</i> of the metal is assigned as follows.
Suppose the metal temperature is governed by
<p align=\"center\" style=\"font-style:italic;\">
  C dT &frasl; dt = (hA)<sub>1</sub> (T<sub>1</sub> - T)
  + (hA)<sub>2</sub> (T<sub>2</sub> - T)
</p>
where <i>hA</i> are the convective heat transfer coefficients times 
heat transfer area that also take
into account heat conduction in the heat exchanger fins and
<i>T<sub>1</sub></i> and <i>T<sub>2</sub></i> are the medium temperatures.
Assuming <i>(hA)<sub>1</sub>=(hA)<sub>2</sub></i>, 
this equation can be rewritten as
<p align=\"center\" style=\"font-style:italic;\">
  C dT &frasl; dt =
  2 (UA)<sub>0</sub> ( (T<sub>1</sub> - T) + (T<sub>2</sub> - T) )

</p>
where <i>(UA)<sub>0</sub></i> is the <i>UA</i> value at nominal conditions. 
Hence we set the heat capacity of the metal 
to
<p align=\"center\" style=\"font-style:italic;\">
C = 2 (UA)<sub>0</sub> &tau;<sub>m</sub>
</p>
where <i>&tau;<sub>m</sub></i> is the time constant that the metal
of the heat exchanger has if the metal is approximated by a lumped
thermal mass.
</p>
</html>",
        revisions="<html>
<ul>
<li>
July 11, 2011, by Michael Wetter:<br>
Removed assignment of medium in <code>vol1</code> and <code>vol2</code>,
since this assignment is already done in the base class using the
<code>final</code> modifier.
</li>
<li>
August 12, 2008, by Michael Wetter:<br>
Introduced option to compute each medium using a steady state model or
a dynamic model.
</li>
<li>
March 25, 2008, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),         Diagram(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},
                    {100,100}}),
                           graphics),
            Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-84,114},{-62,86}},
                  lineColor={0,0,255},
                  textString="h"), Text(
                  extent={{58,-92},{84,-120}},
                  lineColor={0,0,255},
                  textString="h")}));
        end HexElement;

        model MassExchange
        "Block to compute the latent heat transfer based on the Lewis number"
          import Buildings;
          extends Buildings.BaseClasses.BaseIcon;
          replaceable package Medium = Modelica.Media.Interfaces.PartialMedium
          "Fluid medium model"
              annotation (choicesAllMatching=true);

          Modelica.Blocks.Interfaces.RealInput XInf
          "Water mass fraction of medium"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}},
                  rotation=0)));
          Modelica.Blocks.Interfaces.RealInput TSur(final quantity="Temperature",
                                                    final unit = "K", displayUnit = "degC", min=0)
          "Surface temperature"
            annotation (Placement(transformation(extent={{-140,60},{-100,100}},
                  rotation=0)));
          Modelica.Blocks.Interfaces.RealOutput mWat_flow(final unit = "kg/s")
          "Water flow rate"
            annotation (Placement(transformation(extent={{100,10},{120,30}}, rotation=0)));
          Modelica.Blocks.Interfaces.RealOutput TLiq(final quantity="Temperature",
                                                     final unit = "K", displayUnit = "degC", min=0)
          "Temperature at which condensate drains from system"
            annotation (Placement(transformation(extent={{100,-50},{120,-30}}, rotation=
                   0)));
          Modelica.Blocks.Interfaces.RealInput Gc
          "Signal representing the convective (sensible) thermal conductance in [W/K]"
            annotation (Placement(transformation(extent={{-140,-100},{-100,-60}},
                  rotation=0)));
          parameter Real Le = 1
          "Lewis number (around 1 for water vapor in air)";
          parameter Real n = 1/3
          "Exponent in bondary layer ratio, delta/delta_t = Pr^n";
      public
          Buildings.Utilities.Psychrometrics.X_pW humRatPre(              use_p_in=
                false)
          "Model to convert water vapor pressure into humidity ratio"
            annotation (Placement(transformation(extent={{0,0},{20,20}}, rotation=0)));
          Buildings.Utilities.Psychrometrics.pW_TDewPoi TDewPoi
          "Model to compute the water vapor pressure at the dew point"
            annotation (Placement(transformation(extent={{-60,40},{-40,60}}, rotation=0)));
          Modelica.Blocks.Math.Gain gain(k=1/cpLe)
          "Constant to convert from heat transfer to mass transfer"
            annotation (Placement(transformation(extent={{-80,-90},{-60,-70}}, rotation=
                   0)));
          Modelica.Blocks.Math.Product mWat "Water flow rate"
            annotation (Placement(transformation(extent={{60,-80},{80,-60}}, rotation=0)));
          Modelica.Blocks.Math.Min min annotation (Placement(transformation(extent={{20,
                    -60},{40,-40}}, rotation=0)));
          Modelica.Blocks.Sources.Constant zero(k=0) "Constant for zero"
            annotation (Placement(transformation(extent={{-20,-40},{0,-20}}, rotation=0)));
          Modelica.Blocks.Math.Add delX(k2=-1, k1=1) "Humidity difference"
            annotation (Placement(transformation(extent={{-40,-66},{-20,-46}}, rotation=
                   0)));
      protected
         parameter Medium.ThermodynamicState sta0 = Medium.setState_phX(h=Medium.h_default,
               p=Medium.p_default, X=Medium.X_default);
         parameter Modelica.SIunits.SpecificHeatCapacity cp=Medium.specificHeatCapacityCp(sta0)
          "Density, used to compute fluid volume";
         parameter Real cpLe(unit="J/(kg.K)") = cp * Le^(1-n);
        equation
          connect(TSur, TDewPoi.T) annotation (Line(points={{-120,80},{-80,80},{-80,50},
                  {-61,50}}, color={0,0,127}));
          connect(TDewPoi.p_w, humRatPre.p_w) annotation (Line(points={{-39,50},{-20,50},
                  {-20,10},{-1,10}},color={0,0,255}));
          connect(TSur, TLiq) annotation (Line(points={{-120,80},{80,80},{80,-40},{110,
                  -40}}, color={0,0,127}));
          connect(Gc, gain.u) annotation (Line(points={{-120,-80},{-82,-80}}, color={0,
                  0,127}));
          connect(gain.y, mWat.u2) annotation (Line(points={{-59,-80},{0,-80},{0,-76},{
                  58,-76}}, color={0,0,127}));
          connect(mWat.y, mWat_flow) annotation (Line(points={{81,-70},{90,-70},{90,20},
                  {110,20}}, color={0,0,127}));
          connect(zero.y,min. u1) annotation (Line(points={{1,-30},{10,-30},{10,-44},{
                  18,-44}}, color={0,0,127}));
          connect(delX.u2,XInf)  annotation (Line(points={{-42,-62},{-80,-62},{-80,
                  1.11022e-15},{-120,1.11022e-15}},   color={0,0,127}));
          connect(humRatPre.X_w, delX.u1) annotation (Line(points={{21,10},{28,10},{28,
                  -8},{-60,-8},{-60,-50},{-42,-50}},
                                   color={0,0,255}));
          connect(delX.y, min.u2)
            annotation (Line(points={{-19,-56},{18,-56}}, color={0,0,127}));
          connect(min.y, mWat.u1) annotation (Line(points={{41,-50},{48,-50},{48,-64},{
                  58,-64}}, color={0,0,127}));
          annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}), graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-92,96},{-48,54}},
                  lineColor={0,0,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  textString="TSur"),
                Text(
                  extent={{-96,22},{-48,-26}},
                  lineColor={0,0,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  textString="XMed"),
                Text(
                  extent={{-90,-66},{-58,-98}},
                  lineColor={0,0,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  textString="Gc"),
                Text(
                  extent={{54,-20},{92,-58}},
                  lineColor={0,0,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  textString="TLiq"),
                Text(
                  extent={{56,28},{96,12}},
                  lineColor={0,0,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  textString="m"),
                Ellipse(
                  extent={{72,38},{76,34}},
                  lineColor={0,0,127},
                  fillColor={0,0,127},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-30,66},{-36,46},{-38,32},{-36,26},{-30,22},{-20,22},{-12,28},
                      {-10,36},{-14,52},{-24,84},{-30,66}},
                  lineColor={0,0,255},
                  fillColor={0,0,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{10,26},{4,6},{2,-8},{4,-14},{10,-18},{20,-18},{28,-12},{30,-4},
                      {26,12},{16,44},{10,26}},
                  lineColor={0,0,255},
                  fillColor={0,0,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-38,-18},{-44,-38},{-46,-52},{-44,-58},{-38,-62},{-28,-62},{
                      -20,-56},{-18,-48},{-22,-32},{-32,0},{-38,-18}},
                  lineColor={0,0,255},
                  fillColor={0,0,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{14,-46},{8,-66},{6,-80},{8,-86},{14,-90},{24,-90},{32,-84},{
                      34,-76},{30,-60},{20,-28},{14,-46}},
                  lineColor={0,0,255},
                  fillColor={0,0,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{38,100},{32,80},{30,66},{32,60},{38,56},{48,56},{56,62},{58,
                      70},{54,86},{50,100},{38,100}},
                  lineColor={0,0,255},
                  fillColor={0,0,255},
                  fillPattern=FillPattern.Solid)}),
                                    Diagram(coordinateSystem(preserveAspectRatio=false,
                  extent={{-100,-100},{100,100}}),
                                            graphics),
            Documentation(info="<html>
<p>
This model computes the mass transfer based on similarity laws between
the convective sensible heat transfer coefficient and the mass transfer coefficient.
</p>
<p>
Using the Lewis number which is defined as the ratio between the heat and mass
diffusion coefficients, one can obtain the ratio between convection 
heat transfer coefficient <i>h</i> in (W/(m^2*K)) and
mass transfer coefficient <i>h<sub>m</sub></i> in (m/s) as follows:
<p align=\"center\" style=\"font-style:italic;\">
  h &frasl; h<sub>m</sub> = &rho;  c<sub>p</sub>  Le<sup>(1-n)</sup>,
 h_m
</p>
where <i>&rho;</i> is the mass density,
<i>c<sub>p</sub></i> is the specific heat capacity
of the bulk medium and <i>n</i> is a coefficient from the boundary layer analysis, which
is typically <i>n=1/3</i>.
From this equation, we can compute the water vapor mass flow rate 
<i>n<sub>A</sub></i> in (kg/s) as
<p align=\"center\" style=\"font-style:italic;\">
  n<sub>A</sub> = G<sub>c</sub> &frasl; (c<sub>p</sub> Le<sup>(1-n)</sup>)
  (X<sub>s</sub> - X<sub>&#8734;</sub>),
</p>
where <i>G<sub>c</sub></i> is the sensible heat conductivity in (W/K) and 
<i>X<sub>s</sub></i> and 
<i>X<sub>&#8734;</sub></i> are the water vapor mass per unit volume 
in the boundary layer and in the 
bulk of the medium. In this model, 
<i>X<sub>s</sub></i> is the saturation water vapor pressure
corresponding to the temperature <i>T<sub>sur</sub></i> which is an input.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 13, 2008 by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end MassExchange;

        partial model PartialEffectiveness
        "Partial model to implement heat exchangers based on effectiveness model"
          extends Fluid.Interfaces.StaticFourPortHeatMassExchanger(show_T=false);

          Modelica.SIunits.Temperature T_in1 "Inlet temperature medium 1";
          Modelica.SIunits.Temperature T_in2 "Inlet temperature medium 2";
          Modelica.SIunits.ThermalConductance C1_flow
          "Heat capacity flow rate medium 1";
          Modelica.SIunits.ThermalConductance C2_flow
          "Heat capacity flow rate medium 2";
          Modelica.SIunits.ThermalConductance CMin_flow(min=0)
          "Minimum heat capacity flow rate";
          Modelica.SIunits.HeatFlowRate QMax_flow
          "Maximum heat flow rate into medium 1";
      protected
          parameter Real delta=1E-3 "Parameter used for smoothing";

          parameter Modelica.SIunits.SpecificHeatCapacity cp1_default(fixed=false)
          "Specific heat capacity of medium 1 at default medium state";
          parameter Modelica.SIunits.SpecificHeatCapacity cp2_default(fixed=false)
          "Specific heat capacity of medium 2 at default medium state";
          parameter Modelica.SIunits.ThermalConductance CMin_flow_small(fixed=false)
          "Small value for smoothing of minimum heat capacity flow rate";
          Real fra_a1(min=0, max=1)
          "Fraction of incoming state taken from port a2 (used to avoid excessive calls to regStep)";
          Real fra_b1(min=0, max=1)
          "Fraction of incoming state taken from port b2 (used to avoid excessive calls to regStep)";
          Real fra_a2(min=0, max=1)
          "Fraction of incoming state taken from port a2 (used to avoid excessive calls to regStep)";
          Real fra_b2(min=0, max=1)
          "Fraction of incoming state taken from port b2 (used to avoid excessive calls to regStep)";
        initial equation
          cp1_default = Medium1.specificHeatCapacityCp(Medium1.setState_pTX(
            Medium1.p_default,
            Medium1.T_default,
            Medium1.X_default));
          cp2_default = Medium2.specificHeatCapacityCp(Medium2.setState_pTX(
            Medium2.p_default,
            Medium2.T_default,
            Medium2.X_default));
          CMin_flow_small = min(m1_flow_small*cp1_default, m2_flow_small*cp2_default);
        equation
          if allowFlowReversal2 then
            fra_a2 = Modelica.Fluid.Utilities.regStep(
              m2_flow,
              1,
              0,
              m2_flow_small);
            fra_b2 = 1-fra_a2;
          else
            fra_a2 = 1;
            fra_b2 = 0;
          end if;
          if allowFlowReversal1 then
            fra_a1 = Modelica.Fluid.Utilities.regStep(
              m1_flow,
              1,
              0,
              m1_flow_small);
            fra_b1 = 1-fra_a1;
          else
            fra_a1 = 1;
            fra_b1 = 0;
          end if;

          /////////////////////////////////////////////////////////
          // Definitions for heat transfer effectiveness model
          T_in1 = if allowFlowReversal1 then
            fra_a1 * Medium1.temperature(state_a1_inflow) + fra_b1 * Medium1.temperature(state_b1_inflow) else
            Medium1.temperature(state_a1_inflow);
          T_in2 = if allowFlowReversal2 then
            fra_a2 * Medium2.temperature(state_a2_inflow) + fra_b2 * Medium2.temperature(state_b2_inflow) else
            Medium2.temperature(state_a2_inflow);

          C1_flow = abs(m1_flow)*
            ( if allowFlowReversal1 then
                   fra_a1 * Medium1.specificHeatCapacityCp(state_a1_inflow) +
                   fra_b1 * Medium1.specificHeatCapacityCp(state_b1_inflow) else
                Medium1.specificHeatCapacityCp(state_a1_inflow));
          C2_flow = abs(m2_flow)*
            ( if allowFlowReversal2 then
                   fra_a2 * Medium2.specificHeatCapacityCp(state_a2_inflow) +
                   fra_b2 * Medium2.specificHeatCapacityCp(state_b2_inflow) else
                Medium2.specificHeatCapacityCp(state_a2_inflow));
          CMin_flow = min(C1_flow, C2_flow);

          // QMax_flow is maximum heat transfer into medium 1
          QMax_flow = CMin_flow*(T_in2 - T_in1);

          annotation (
            Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                    100}}), graphics={Rectangle(
                  extent={{-70,78},{70,-82}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid)}),
            Documentation(info="<html>
<p>
Partial model to implement heat exchanger models
</p>
<p>
Classes that extend this model need to implement heat and 
mass balance equations in a form like<pre>
  // transfered heat
  Q1_flow = eps * QMax_flow;
  // no heat loss to ambient
  0 = Q1_flow + Q2_flow;
  // no mass exchange
  mXi1_flow = zeros(Medium1.nXi);
  mXi2_flow = zeros(Medium2.nXi);
</pre>
Thus, if medium 1 is heated in this device, then <code>Q1_flow &gt; 0</code>
and <code>QMax_flow &gt; 0</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
October 8, 2011, by Michael Wetter:<br>
Set <code>show_T=false</code> to avoid state events near zero flow.
</li>
<li>
August 31, 2011, by Michael Wetter:<br>
Removed unused variables <code>gai1</code> and <code>gai2</code>.
</li>
<li>
February 12, 2010, by Michael Wetter:<br>
Changed model structure to implement effectiveness-NTU model.
</li>
<li>
January 28, 2010, by Michael Wetter:<br>
Added regularization near zero flow.
</li>
<li>
October 2, 2009, by Michael Wetter:<br>
Changed computation of inlet temperatures to use 
<code>state_*_inflow</code> which is already known in base class.
</li>
<li>
April 28, 2008, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),  Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{
                    100,100}}), graphics));
        end PartialEffectiveness;

        function epsilon_C
        "Computes heat exchanger effectiveness for given capacity flow rates and heat exchanger flow regime"
          import f = Buildings.Fluid.Types.HeatExchangerFlowRegime;
          input Modelica.SIunits.ThermalConductance UA "UA value";
          input Modelica.SIunits.ThermalConductance C1_flow
          "Enthalpy flow rate medium 1";
          input Modelica.SIunits.ThermalConductance C2_flow
          "Enthalpy flow rate medium 2";
          input Buildings.Fluid.Types.HeatExchangerFlowRegime flowRegime
          "Heat exchanger flow regime";
          input Modelica.SIunits.ThermalConductance CMin_flow_nominal
          "Minimum enthalpy flow rate at nominal condition";
          input Modelica.SIunits.ThermalConductance CMax_flow_nominal
          "Maximum enthalpy flow rate at nominal condition";
          input Real delta = 1E-3 "Small value used for smoothing";
          output Real eps(min=0, max=1) "Heat exchanger effectiveness";
          output Real NTU "Number of transfer units";
          output Real Z(min=0, max=1) "Ratio of capacity flow rate (CMin/CMax)";
      protected
          Modelica.SIunits.ThermalConductance deltaCMin
          "Small number for capacity flow rate";
          Modelica.SIunits.ThermalConductance deltaCMax
          "Small number for capacity flow rate";
          Modelica.SIunits.ThermalConductance CMin_flow
          "Minimum capacity flow rate";
          Modelica.SIunits.ThermalConductance CMax_flow
          "Maximum capacity flow rate";
          Modelica.SIunits.ThermalConductance CMinNZ_flow
          "Minimum capacity flow rate, bounded away from zero";
          Modelica.SIunits.ThermalConductance CMaxNZ_flow
          "Maximum capacity flow rate, bounded away from zero";
          Real gai(min=0, max=1)
          "Gain used to force UA to zero for very small flow rates";
        algorithm
          deltaCMin := delta*CMin_flow_nominal;
          deltaCMax := delta*CMax_flow_nominal;
          // effectiveness
          CMin_flow :=Buildings.Utilities.Math.Functions.smoothMin(
            C1_flow,
            C2_flow,
            deltaCMin/4);
          CMax_flow :=Buildings.Utilities.Math.Functions.smoothMax(
            C1_flow,
            C2_flow,
            deltaCMax/4);
          // CMin and CMax, constrained to be non-zero to compute eps-NTU-Z relationship
          CMinNZ_flow :=Buildings.Utilities.Math.Functions.smoothMax(
            CMin_flow,
            deltaCMin,
            deltaCMin/4);
          CMaxNZ_flow :=Buildings.Utilities.Math.Functions.smoothMax(
            CMax_flow,
            deltaCMax,
            deltaCMax/4);
          Z :=CMin_flow/CMaxNZ_flow;
          // Gain that goes to zero as CMin_flow gets below deltaCMin
          // This is needed to allow zero flow
          gai := Buildings.Utilities.Math.Functions.spliceFunction(
                         pos=1, neg=0, x=CMin_flow-deltaCMin, deltax=deltaCMin/2);
          if ( gai == 0) then
            NTU := 0;
            eps := 1; // around zero flow, eps=Q/(CMin*dT) should be one
          else
            NTU :=gai*UA/CMinNZ_flow;
            eps := gai*Buildings.Fluid.HeatExchangers.BaseClasses.epsilon_ntuZ(NTU=NTU, Z=Z, flowRegime=flowRegime);
          end if;

          annotation(preferedView="info",
                   smoothOrder=1,
                   Documentation(info="<html>
This function computes the heat exchanger effectiveness,
the Number of Transfer Units, and the capacity flow ratio
for given capacity flow rates.
</p>
<p>
The implementation allows for zero flow rate.
As <code>CMin_flow</code> crosses <code>delta*CMin_flow_nominal</code> from above,
the Number of Transfer Units and the heat exchanger effectiveness go to zero.
</p>
</html>",
        revisions="<html>
<ul>
<li>
February 20, 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end epsilon_C;

        function epsilon_ntuZ
        "Computes heat exchanger effectiveness for given number of transfer units and heat exchanger flow regime"
          import f = Buildings.Fluid.Types.HeatExchangerFlowRegime;
          input Real NTU "Number of transfer units";
          input Real Z(min=0, max=1) "Ratio of capacity flow rate (CMin/CMax)";
          input Buildings.Fluid.Types.HeatExchangerFlowRegime flowRegime
          "Heat exchanger flow regime";
          output Real eps(min=0, max=1) "Heat exchanger effectiveness";
      protected
          Real a "Auxiliary variable";
        algorithm
          if (flowRegime == f.ParallelFlow) then // parallel flow
            a := 0;
            eps := (1 - Modelica.Math.exp(-NTU*(1 + Z)))/(1 + Z);
          elseif (flowRegime == f.CounterFlow) then// counter flow
           // a is constraining Z since eps is not defined for Z=1.
            a := smooth(1, if Z < 0.97 then Z else
              Buildings.Utilities.Math.Functions.smoothMin(
              x1=Z,
              x2=0.98,
              deltaX=0.01));
            eps := (1 - Modelica.Math.exp(-NTU*(1 - a)))/(1 - a*Modelica.Math.exp(-NTU*(
              1 - a)));
          elseif (flowRegime == f.CrossFlowUnmixed) then
           a := NTU^(-0.22);
            eps := 1 - Modelica.Math.exp( ( Modelica.Math.exp( - NTU * Z * a)  - 1)  / (Z * a));
          elseif (flowRegime == f.CrossFlowCMinUnmixedCMaxMixed) then
            // cross flow, (single pass), CMax mixed, CMin unmixed. (Coil with one row.)
            a := 0;
            eps := (1 - Modelica.Math.exp(-Z*(1 - Modelica.Math.exp(-NTU))))/Z;
          elseif (flowRegime == f.CrossFlowCMinMixedCMaxUnmixed) then
            // cross flow, (single pass), CMin mixed, CMax unmixed.
            a := 0;
            eps := 1 - Modelica.Math.exp(-(1 - Modelica.Math.exp(-Z*NTU))/Z);
          else
            a := 0;
            eps := 0;
            assert(0 < flowRegime and flowRegime < 6, "Flow regime is not implemented.");
          end if;
          annotation(preferedView="info",
                     inverse(NTU=Buildings.Fluid.HeatExchangers.BaseClasses.ntu_epsilonZ(eps=eps, Z=Z, flowRegime=flowRegime)),
                   smoothOrder=1,
                   Documentation(info="<html>
This function computes the heat exchanger effectiveness for a given number of transfer units, capacity flow ratio and heat exchanger flow regime.
</html>",
        revisions="<html>
<ul>
<li>
February 11, 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end epsilon_ntuZ;

        function ntu_epsilonZ
        "Computes number of transfer units for given heat exchanger effectiveness and heat exchanger flow regime"
          import f = Buildings.Fluid.Types.HeatExchangerFlowRegime;
          input Real eps(min=0, max=0.999) "Heat exchanger effectiveness";
          input Real Z(min=0, max=1) "Ratio of capacity flow rate (CMin/CMax)";
          input Buildings.Fluid.Types.HeatExchangerFlowRegime flowRegime
          "Heat exchanger flow regime";
          output Real NTU "Number of transfer units";

      protected
          Real a "Auxiliary variable";
        algorithm
          if (flowRegime == f.ParallelFlow) then // parallel flow
            a := Z+1;
            assert(eps < 1/a,
              "Invalid input data. eps > 1/(1+Z) is physically not possible for parallel flow." +
              "\n  Received eps = " + String(eps) +
              "\n             Z = " + String(Z) +
              "\n       1/(Z+1) = " + String(1/a));
            NTU := -(Modelica.Math.log(1-eps*a))/(a);
          elseif (flowRegime == f.CounterFlow) then// counter flow
           // a is constraining Z since eps is not defined for Z=1.
            a := smooth(1, if Z < 0.97 then Z else
              Buildings.Utilities.Math.Functions.smoothMin(
              x1=Z,
              x2=0.98,
              deltaX=0.01));
            NTU := Modelica.Math.log((1-eps)/(1-eps*a)) / (a-1);

          elseif (flowRegime == f.CrossFlowUnmixed) then
            a := 0;
            // The function Internal.solve evaluates epsilon_ntuZ at NTU=x_min-1e-10 and NTU=x_max+1e-10
            // when it solves iteratively epsilon_ntuZ for ntu
            // Therefore, we set x_min=1.5*1e-10 to prevent computing NTU^(-0.22)=(-1e-10)^(-0.22).
            NTU := Internal.solve(y_zero=eps, x_min=1.5*1e-10, x_max=1E6, pressure=Z);
          elseif (flowRegime == f.CrossFlowCMinUnmixedCMaxMixed) then
            // cross flow, (single pass), CMax mixed, CMin unmixed. (Coil with one row.)
           a := smooth(1, if Z > 0.03 then Z else
              Buildings.Utilities.Math.Functions.smoothMin(
              x1=0.02,
              x2=Z,
              deltaX=0.01));
            NTU := -Modelica.Math.log(1+(Modelica.Math.log(1-eps*a)/a));
          elseif (flowRegime == f.CrossFlowCMinMixedCMaxUnmixed) then
            // cross flow, (single pass), CMin mixed, CMax unmixed.
           a := smooth(1, if Z > 0.03 then Z else
              Buildings.Utilities.Math.Functions.smoothMin(
              x1=0.02,
              x2=Z,
              deltaX=0.01));
            NTU := -Modelica.Math.log(1+Z*Modelica.Math.log(1-eps))/Z;
          else
            a := 0;
            NTU := 0;
            assert(0 < flowRegime and flowRegime < 6, "Flow regime is not implemented.");
          end if;

          annotation (preferedView="info",
                     inverse(eps=Buildings.Fluid.HeatExchangers.BaseClasses.epsilon_ntuZ(NTU=NTU, Z=Z, flowRegime=flowRegime)),
                   smoothOrder=1,
        Documentation(info="<html>
This function computes the number of transfer units for a given heat exchanger effectiveness,
capacity flow ratio and heat exchanger flow regime.
</p>
<p>
Note that for the flow regime <code>CrossFlowUnmixed</code>, computing the
function requires the numerical solution of an equation in one variable.
This is handled internally and not exposed to the global solver.
</p>
</html>",
        revisions="<html>
<ul>
<li>
August 10, 2011, by Michael Wetter:<br>
Changed implementation to use 
<code>Modelica.Media.Common.OneNonLinearEquation</code> instead of
<code>Buildings.Utilities.Math.BaseClasses.OneNonLinearEquation</code>.
</li>
<li>
February 11, 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end ntu_epsilonZ;

        function lmtd "Log-mean temperature difference"
          input Modelica.SIunits.Temperature T_a1 "Temperature at port a1";
          input Modelica.SIunits.Temperature T_b1 "Temperature at port b1";
          input Modelica.SIunits.Temperature T_a2 "Temperature at port a2";
          input Modelica.SIunits.Temperature T_b2 "Temperature at port b2";
          output Modelica.SIunits.TemperatureDifference lmtd
          "Log-mean temperature difference";
      protected
          Modelica.SIunits.TemperatureDifference dT1
          "Temperature difference side 1";
          Modelica.SIunits.TemperatureDifference dT2
          "Temperature difference side 2";
        algorithm
          dT1 :=T_a1 - T_b2;
          dT2 :=T_b1 - T_a2;
          lmtd :=(dT2 - dT1)/Modelica.Math.log(dT2/dT1);
        annotation (preferedView="info",
        Documentation(info="<html>
<p>
This function computes the log mean temperature difference of a heat exchanger.
</p>
<p>
Note that the implementation requires the temperature differences to be non-zero.
</p>
</html>",
        revisions="<html>
<ul>
<li>
May 28, 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end lmtd;

        package Internal "Solve f(x, data) for x with given f"
          extends Modelica.Media.Common.OneNonLinearEquation;

          redeclare function extends f_nonlinear
          algorithm
          assert(x>0, "NTU needs to be strictly positive.
Received NTU = "         + String(x) + "
         Z   = "         + String(p));
            y := epsilon_ntuZ(NTU=x, Z=p,
                 flowRegime=Buildings.Fluid.Types.HeatExchangerFlowRegime.CrossFlowUnmixed);
          end f_nonlinear;
        annotation (
        Documentation(
        info="<html>
<p>
Function that internally solves a scalar equation.
</p>
</html>",
        revisions="<html>
<ul>
<li>
August 10, 2011, by Michael Wetter:
<ul>
<li>
Changed implementation to use
<code>Modelica.Media.Common.OneNonLinearEquation</code> instead of
<code>Buildings.Utilities.Math.BaseClasses.OneNonLinearEquation</code>.
</li>
<li>
Added assert statement as <code>epsilon_ntuZ</code> computes <code>NTU^(-0.22)</code>.
</li>
</ul>
</li>
<li>
February 16, 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end Internal;
      annotation (preferedView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Fluid.HeatExchangers\">Buildings.Fluid.HeatExchangers</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferedView="info", Documentation(info="<html>
This package contains models for heat exchangers with and without humidity condensation.
</html>"));
    end HeatExchangers;

    package MixingVolumes "Package with mixing volumes"
      extends Modelica.Icons.VariantsPackage;

      model MixingVolume
      "Mixing volume with inlet and outlet ports (flow reversal is allowed)"
        outer Modelica.Fluid.System system "System properties";
        extends Buildings.Fluid.Interfaces.LumpedVolumeDeclarations;
        parameter Modelica.SIunits.MassFlowRate m_flow_nominal(min=0)
        "Nominal mass flow rate"
          annotation(Dialog(group = "Nominal condition"));
        // Port definitions
        parameter Integer nPorts=0 "Number of ports"
          annotation(Evaluate=true, Dialog(connectorSizing=true, tab="General",group="Ports"));
        parameter Medium.MassFlowRate m_flow_small(min=0) = 1E-4*abs(m_flow_nominal)
        "Small mass flow rate for regularization of zero flow"
          annotation(Dialog(tab = "Advanced"));
        parameter Boolean homotopyInitialization = true
        "= true, use homotopy method"
          annotation(Evaluate=true, Dialog(tab="Advanced"));
        parameter Boolean allowFlowReversal = system.allowFlowReversal
        "= true to allow flow reversal in medium, false restricts to design direction (ports[1] -> ports[2]). Used only if model has two ports."
          annotation(Dialog(tab="Assumptions"), Evaluate=true);
        parameter Modelica.SIunits.Volume V "Volume";
        parameter Boolean prescribedHeatFlowRate=false
        "Set to true if the model has a prescribed heat flow at its heatPort"
         annotation(Evaluate=true, Dialog(tab="Assumptions",
            enable=use_HeatTransfer,
            group="Heat transfer"));
        Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b ports[nPorts](
            redeclare each package Medium = Medium) "Fluid inlets and outlets"
          annotation (Placement(transformation(extent={{-40,-10},{40,10}},
            origin={0,-100})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort
        "Heat port connected to outflowing medium"
          annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
        Modelica.SIunits.Temperature T "Temperature of the fluid";
        Modelica.SIunits.Pressure p "Pressure of the fluid";
        Modelica.SIunits.MassFraction Xi[Medium.nXi]
        "Species concentration of the fluid";
        Medium.ExtraProperty C[Medium.nC](nominal=C_nominal)
        "Trace substance mixture content";
         // Models for the steady-state and dynamic energy balance.
    protected
        Buildings.Fluid.Interfaces.StaticTwoPortHeatMassExchanger steBal(
          sensibleOnly = true,
          redeclare final package Medium=Medium,
          final m_flow_nominal = m_flow_nominal,
          final dp_nominal = 0,
          final allowFlowReversal = allowFlowReversal,
          final m_flow_small = m_flow_small,
          final homotopyInitialization = homotopyInitialization,
          final show_V_flow = false,
          final from_dp = false,
          final linearizeFlowResistance = true,
          final deltaM = 0.3,
          Q_flow = Q_flow,
          mXi_flow = zeros(Medium.nXi)) if
              useSteadyStateTwoPort
        "Model for steady-state balance if nPorts=2";
        Buildings.Fluid.Interfaces.LumpedVolume dynBal(
          redeclare final package Medium = Medium,
          final nPorts = nPorts,
          final energyDynamics=energyDynamics,
          final massDynamics=massDynamics,
          final p_start=p_start,
          final T_start=T_start,
          final X_start=X_start,
          final C_start=C_start,
          final C_nominal=C_nominal,
          final fluidVolume = V,
          m(start=V*rho_nominal),
          U(start=V*rho_nominal*Medium.specificInternalEnergy(
              state_start)),
          Q_flow = Q_flow,
          mXi_flow = zeros(Medium.nXi)) if
              not useSteadyStateTwoPort "Model for dynamic energy balance";

        parameter Medium.ThermodynamicState state_start = Medium.setState_pTX(
            T=T_start,
            p=p_start,
            X=X_start[1:Medium.nXi]) "Start state";

        parameter Modelica.SIunits.Density rho_nominal=Medium.density(
         Medium.setState_pTX(
           T=T_start,
           p=p_start,
           X=X_start[1:Medium.nXi])) "Density, used to compute fluid mass"
        annotation (Evaluate=true);
        ////////////////////////////////////////////////////
        final parameter Boolean useSteadyStateTwoPort=(nPorts == 2) and
            prescribedHeatFlowRate and (
            energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) and (
            massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) and (
            substanceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) and (
            traceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)
        "Flag, true if the model has two ports only and uses a steady state balance"
          annotation (Evaluate=true);
        Modelica.SIunits.HeatFlowRate Q_flow
        "Heat flow across boundaries or energy source/sink";
        // Outputs that are needed to assign the medium properties
        Modelica.Blocks.Interfaces.RealOutput hOut_internal(unit="J/kg")
        "Internal connector for leaving temperature of the component";
        Modelica.Blocks.Interfaces.RealOutput XiOut_internal[Medium.nXi](unit="1")
        "Internal connector for leaving species concentration of the component";
        Modelica.Blocks.Interfaces.RealOutput COut_internal[Medium.nC](unit="1")
        "Internal connector for leaving trace substances of the component";
      equation
        ///////////////////////////////////////////////////////////////////////////
        // asserts
        if not allowFlowReversal then
          assert(ports[1].m_flow > -m_flow_small,
      "Model has flow reversal, but the parameter allowFlowReversal is set to false.
  m_flow_small    = "       + String(m_flow_small) + "
  ports[1].m_flow = "       + String(ports[1].m_flow) + "
");
        end if;
      // Only one connection allowed to a port to avoid unwanted ideal mixing
        if not useSteadyStateTwoPort then
          for i in 1:nPorts loop
          assert(cardinality(ports[i]) == 2 or cardinality(ports[i]) == 0,"
each ports[i] of volume can at most be connected to one component.
If two or more connections are present, ideal mixing takes
place with these connections, which is usually not the intention
of the modeller. Increase nPorts to add an additional port.
");
           end for;
        end if;
        // actual definition of port variables
        // If the model computes the energy and mass balances as steady-state,
        // and if it has only two ports,
        // then we use the same base class as for all other steady state models.
        if useSteadyStateTwoPort then
          connect(ports[1], steBal.port_a);
          connect(ports[2], steBal.port_b);
          connect(hOut_internal,  steBal.hOut);
          connect(XiOut_internal, steBal.XiOut);
          connect(COut_internal,  steBal.COut);
        else
          connect(ports, dynBal.ports);
          connect(hOut_internal,  dynBal.hOut);
          connect(XiOut_internal, dynBal.XiOut);
          connect(COut_internal,  dynBal.COut);
        end if;
        // Medium properties
        p = if nPorts > 0 then ports[1].p else p_start;
        T = Medium.temperature_phX(p=p, h=hOut_internal, X=cat(1,Xi,{1-sum(Xi)}));
        Xi = XiOut_internal;
        C = COut_internal;
        // Port properties
        heatPort.T = T;
        heatPort.Q_flow = Q_flow;
        annotation (
      defaultComponentName="vol",
      Documentation(info="<html>
This model represents an instantaneously mixed volume. 
Potential and kinetic energy at the port are neglected,
and there is no pressure drop at the ports.
The volume can exchange heat through its <code>heatPort</code>.
</p>
<p>
The volume can be parameterized as a steady-state model or as
dynamic model.
</p>
<p>
To increase the numerical robustness of the model, the parameter
<code>prescribedHeatFlowRate</code> can be set by the user. 
This parameter only has an effect if the model has exactly two fluid ports connected,
and if it is used as a steady-state model.
Use the following settings:
<ul>
<li>Set <code>prescribedHeatFlowRate=true</code> if there is a model connected to <code>heatPort</code>
that computes the heat flow rate <i>not</i> as a function of the temperature difference
between the medium and an ambient temperature. Examples include an ideal electrical heater,
a pump that rejects heat into the fluid stream, or a chiller that removes heat based on a performance curve.
</li>
<li>Set <code>prescribedHeatFlowRate=true</code> if the only means of heat flow at the <code>heatPort</code>
is computed as <i>K * (T-heatPort.T)</i>, for some temperature <i>T</i> and some conductance <i>K</i>,
which may itself be a function of temperature or mass flow rate.
</li>
</ul>
</p>
<h4>Implementation</h4>
<p>
If the model is operated in steady-state and has two fluid ports connected,
then the same energy and mass balance implementation is used as in
steady-state component models, i.e., the use of <code>actualStream</code>
is not used for the properties at the port.
</p>
<p>
The implementation of these balance equations is done in the instances
<code>dynBal</code> for the dynamic balance and <code>steBal</code>
for the steady-state balance. Both models use the same input variables:
<ul>
<li>
The variable <code>Q_flow</code> is used to add sensible <i>and</i> latent heat to the fluid.
For example, <code>Q_flow</code> participates in the steady-state energy balance<pre>
    port_b.h_outflow = inStream(port_a.h_outflow) + Q_flow * m_flowInv;
</pre>
where <code>m_flowInv</code> approximates the expression <code>1/m_flow</code>.
</li>
<li>
The variable <code>mXi_flow</code> is used to add a species mass flow rate to the fluid.
</li>
</ul>
</p>
<p>
For simple models that uses this model, see
<a href=\"modelica://Buildings.Fluid.HeatExchangers.HeaterCoolerPrescribed\">
Buildings.Fluid.HeatExchangers.HeaterCoolerPrescribed</a> and
<a href=\"modelica://Buildings.Fluid.MassExchangers.HumidifierPrescribed\">
Buildings.Fluid.MassExchangers.HumidifierPrescribed</a>.
</p>
</html>",       revisions="<html>
<ul>
<li>
September 17, 2011 by Michael Wetter:<br>
Removed instance <code>medium</code> as this is already used in <code>dynBal</code>.
Removing the base properties led to 30% faster computing time for a solar thermal system
that contains many fluid volumes. 
</li>
<li>
September 13, 2011 by Michael Wetter:<br>
Changed in declaration of <code>medium</code> the parameter assignment
<code>preferredMediumStates=true</code> to
<code>preferredMediumStates= not (energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)</code>.
Otherwise, for a steady-state model, Dymola 2012 may differentiate the model to obtain <code>T</code>
as a state. See ticket Dynasim #13596.
</li>
<li>
July 26, 2011 by Michael Wetter:<br>
Revised model to use new declarations from
<a href=\"Buildings.Fluid.Interfaces.LumpedVolumeDeclarations\">
Buildings.Fluid.Interfaces.LumpedVolumeDeclarations</a>.
</li>
<li>
July 14, 2011 by Michael Wetter:<br>
Added start values for mass and internal energy of dynamic balance
model.
</li>
<li>
May 25, 2011 by Michael Wetter:<br>
<ul>
<li>
Changed implementation of balance equation. The new implementation uses a different model if 
exactly two fluid ports are connected, and in addition, the model is used as a steady-state
component. For this model configuration, the same balance equations are used as were used
for steady-state component models, i.e., instead of <code>actualStream(...)</code>, the
<code>inStream(...)</code> formulation is used.
This changed required the introduction of a new parameter <code>m_flow_nominal</code> which
is used for smoothing in the steady-state balance equations of the model with two fluid ports.
This implementation also simplifies the implementation of 
<a href=\"modelica://Buildings.Fluid.MixingVolumes.BaseClasses.PartialMixingVolumeWaterPort\">
Buildings.Fluid.MixingVolumes.BaseClasses.PartialMixingVolumeWaterPort</a>,
which now uses the same equations as this model.
</li>
<li>
Another revision was the removal of the parameter <code>use_HeatTransfer</code> as there is
no noticable overhead in always having the <code>heatPort</code> connector present.
</li>
</ul>
</li>
<li>
July 30, 2010 by Michael Wetter:<br>
Added nominal value for <code>mC</code> to avoid wrong trajectory 
when concentration is around 1E-7.
See also <a href=\"https://trac.modelica.org/Modelica/ticket/393\">
https://trac.modelica.org/Modelica/ticket/393</a>.
</li>
<li>
February 7, 2010 by Michael Wetter:<br>
Simplified model and its base classes by removing the port data
and the vessel area.
Eliminated the base class <code>PartialLumpedVessel</code>.
</li>
<li>
October 12, 2009 by Michael Wetter:<br>
Changed base class to
<a href=\"modelica://Buildings.Fluid.MixingVolumes.BaseClasses.ClosedVolume\">
Buildings.Fluid.MixingVolumes.BaseClasses.ClosedVolume</a>.
</li>
</ul>
</html>"),       Diagram(graphics),
          Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                  100}}), graphics={Ellipse(
                extent={{-100,98},{100,-102}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Sphere,
                fillColor={170,213,255}), Text(
                extent={{-58,14},{58,-18}},
                lineColor={0,0,0},
                textString="V=%V"),         Text(
                extent={{-152,100},{148,140}},
                textString="%name",
                lineColor={0,0,255})}));
      end MixingVolume;

      model MixingVolumeDryAir
      "Mixing volume with heat port for latent heat exchange, to be used with dry air"
        extends BaseClasses.PartialMixingVolumeWaterPort(
          steBal(
          final sensibleOnly = true));

      equation
        if cardinality(mWat_flow) == 0 then
          mWat_flow = 0;
        end if;
        if cardinality(TWat) == 0 then
          TWat = Medium.T_default;
        end if;
        HWat_flow = 0;
        mXi_flow  = zeros(Medium.nXi);
      // Assign output port
        X_w = 0;
        annotation (Diagram(graphics),
                             Icon(graphics),
      defaultComponentName="vol",
      Documentation(info="<html>
Model for an ideally mixed fluid volume and the ability 
to store mass and energy. The volume is fixed, 
and sensible heat can be exchanged.
<p>
This model has the same ports as
<a href=\"modelica://Buildings.Fluid.MixingVolumes.MixingVolumeMoistAir\">
Buildings.Fluid.MixingVolumes.MixingVolumeMoistAir</a>.
However, there is no mass exchange with the medium other than through the port
<code>ports</code>.
</p>
<p>
For media that do provide water as a species, use the model
<a href=\"modelica://Buildings.Fluid.MixingVolumes.MixingVolumeMoistAir\">
Buildings.Fluid.MixingVolumes.MixingVolumeMoistAir</a> to add
or subtract moisture using a signal that is connected to the port
<code>mWat_flow</code> and <code>TWat</code>.
</p>
</html>",       revisions="<html>
<ul>
<li>
August 7, 2008 by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
      end MixingVolumeDryAir;

      model MixingVolumeMoistAir
      "Mixing volume with heat port for latent heat exchange, to be used with media that contain water"
        extends BaseClasses.PartialMixingVolumeWaterPort(nPorts(min=2, max=2),
          steBal(
          final sensibleOnly = false));
        // redeclare Medium with a more restricting base class. This improves the error
        // message if a user selects a medium that does not contain the function
        // enthalpyOfLiquid(.)
        replaceable package Medium =
          Modelica.Media.Interfaces.PartialCondensingGases
            annotation (choicesAllMatching = true);

    protected
        parameter Integer i_w(min=1, fixed=false) "Index for water substance";
        parameter Real s[Medium.nXi](fixed=false)
        "Vector with zero everywhere except where species is";

      initial algorithm
        i_w:= -1;
        if cardinality(mWat_flow) > 0 then
        for i in 1:Medium.nXi loop
            if Modelica.Utilities.Strings.isEqual(string1=Medium.substanceNames[i],
                                                  string2="Water",
                                                  caseSensitive=false) then
            i_w := i;
            s[i] :=1;
          else
            s[i] :=0;
          end if;
         end for;
          assert(i_w > 0, "Substance 'water' is not present in medium '"
               + Medium.mediumName + "'.\n"
               + "Check medium model.");
          end if;

      equation
        if cardinality(mWat_flow) == 0 then
          mWat_flow = 0;
          HWat_flow = 0;
          mXi_flow  = zeros(Medium.nXi);
        else
          if cardinality(TWat) == 0 then
             HWat_flow = mWat_flow * Medium.enthalpyOfLiquid(Medium.T_default);
          else
             HWat_flow = mWat_flow * Medium.enthalpyOfLiquid(TWat);
          end if;
        // We obtain the substance concentration with a vector multiplication
        // because Dymola 7.4 cannot find the derivative in the model
        // Buildings.Fluid.HeatExchangers.Examples.WetCoilDiscretizedPControl
        // if we set mXi_flow[i] = if ( i == i_w) then mWat_flow else 0;
          mXi_flow = mWat_flow * s;
        end if;
      // Medium species concentration
        X_w = s * Xi;

        annotation (Diagram(graphics),
                             Icon(graphics),
      defaultComponentName="vol",
      Documentation(info="<html>
Model for an ideally mixed fluid volume and the ability 
to store mass and energy. The volume is fixed, 
and latent and sensible heat can be exchanged.
<p>
This model represents the same physics as 
<a href=\"modelica://Buildings.Fluid.MixingVolumes.MixingVolume\">
Buildings.Fluid.MixingVolumes.MixingVolume</a>, but in addition, it allows
adding or subtracting water in liquid phase.
The mass flow rate of the added or subtracted water is
specified at the port <code>mWat_flow</code>.
The water flow rate is assumed to be added or subtracted at the
temperature of the input port <code>TWat</code>, or 
if this port is not connected, at the medium default temperature as
defined by <code>Medium.T_default</code>.
Adding water causes a change in 
enthalpy and species concentration in the volume. 
</p>
<p>
Note that this model can only be used with medium models that include water
as a substance. In particular, the medium model needs to implement the function
<code>enthalpyOfLiquid(T)</code> and the integer variable <code>Water</code> that
contains the index to the water substance. For medium that do not provide this
functionality, use
<a href=\"modelica://Buildings.Fluid.MixingVolumes.MixingVolumeDryAir\">
Buildings.Fluid.MixingVolumes.MixingVolumeDryAir</a>.
</p>
</html>",       revisions="<html>
<ul>
<li>
February 22, by Michael Wetter:<br>
Improved the code that searches for the index of 'water' in the medium model.
</li>
<li>
May 29, 2010 by Michael Wetter:<br>
Rewrote computation of index of water substance.
For the old formulation, Dymola 7.4 failed to differentiate the 
model when trying to reduce the index of the DAE.
</li>
<li>
August 7, 2008 by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
      end MixingVolumeMoistAir;

      package BaseClasses
      "Package with base classes for Buildings.Fluid.MixingVolumes"
        extends Modelica.Icons.BasesPackage;

        partial model PartialMixingVolumeWaterPort
        "Partial mixing volume that allows adding or subtracting water vapor"
          extends Buildings.Fluid.MixingVolumes.MixingVolume(
           steBal(
            sensibleOnly = false,
            final Q_flow = Q_flow + HWat_flow,
            final mXi_flow = mXi_flow),
           dynBal(
            final Q_flow = Q_flow + HWat_flow,
            final mXi_flow = mXi_flow));

         // additional declarations
          Modelica.Blocks.Interfaces.RealInput mWat_flow(final quantity="MassFlowRate",
                                                         final unit = "kg/s")
          "Water flow rate added into the medium"
            annotation (Placement(transformation(extent={{-140,60},{-100,100}},rotation=
                   0)));
          Modelica.Blocks.Interfaces.RealInput TWat(final quantity="Temperature",
                                                    final unit = "K", displayUnit = "degC", min=260)
          "Temperature of liquid that is drained from or injected into volume"
            annotation (Placement(transformation(extent={{-140,28},{-100,68}},
                  rotation=0)));
          Modelica.Blocks.Interfaces.RealOutput X_w
          "Species composition of medium"
            annotation (Placement(transformation(extent={{100,-60},{140,-20}}, rotation=
                   0)));
          Medium.MassFlowRate mXi_flow[Medium.nXi]
          "Mass flow rates of independent substances added to the medium";
          Modelica.SIunits.HeatFlowRate HWat_flow
          "Enthalpy flow rate of extracted water";

          annotation (
            Documentation(info="<html>
Model for an ideally mixed fluid volume with <code>nP</code> ports and the ability 
to store mass and energy. The volume is fixed. 
<p>
This model represents the same physics as 
<a href=\"Modelica:Modelica.Fluid.Vessels.Volume\">
Modelica.Fluid.Vessels.Volume</a> but in addition,
it allows to connect signals for the water exchanged with the volume.
The model is partial in order to allow a submodel that can be used with media
that contain water as a substance, and a submodel that can be used with dry air.
Having separate models is required because calls to the medium property function
<code>enthalpyOfLiquid</code> results in a linker error if a medium such as 
<a href=\"Modelica:Modelica.Media.Air.SimpleAir\">Modelica.Media.Air.SimpleAir</a>
is used that does not implement this function.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 10, 2011 by Michael Wetter:<br>
Removed <code>ports_p_static</code> and used instead <code>medium.p</code> since
<code>ports_p_static</code> is not available in 
<a href=\"modelica://Buildings.Fluid.MixingVolumes.MixingVolume\">
Buildings.Fluid.MixingVolumes.MixingVolume</a> which is sometimes used to replace this model.
</li>
<li>
July 30, 2010 by Michael Wetter:<br>
Added nominal value for <code>mC</code> to avoid wrong trajectory 
when concentration is around 1E-7.
See also <a href=\"https://trac.modelica.org/Modelica/ticket/393\">
https://trac.modelica.org/Modelica/ticket/393</a>.
</li>
<li>
March 24, 2010 by Michael Wetter:<br>
Changed base class from <code>Modelica.Fluid</code> to <code>Buildings.Fluid</code>.
<li>
August 12, 2008 by Michael Wetter:<br>
Introduced option to compute model in steady state. This allows the heat exchanger model
to switch from a dynamic model for the medium to a steady state model.
</li>
<li>
August 13, 2008 by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),         Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                    -100},{100,100}}),
                           graphics),
            Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                    100}}), graphics={
                Text(
                  extent={{-76,-6},{198,-48}},
                  lineColor={255,255,255},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid,
                  textString="X_w"),
                Text(
                  extent={{-122,114},{-80,82}},
                  lineColor={0,0,0},
                  textString="mWat_flow"),
                Text(
                  extent={{-152,74},{-42,50}},
                  lineColor={0,0,0},
                  textString="TWat"),
                Ellipse(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  fillColor={170,213,255}),
                Text(
                  extent={{-60,16},{56,-16}},
                  lineColor={0,0,0},
                  textString="V=%V")}));
        end PartialMixingVolumeWaterPort;
      annotation (preferedView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Fluid.MixingVolumes\">Buildings.Fluid.MixingVolumes</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (Documentation(info="<html>
<p>
This package contains models for completely mixed volumes.
Optionally, heat can be added to the volume by setting the 
parameter <code>use_HeatTransfer</code> to <code>true</code>.
</p>
<p>
For most situations, the model
<a href=\"modelica://Buildings.Fluid.MixingVolumes.MixingVolume\">
Buildings.Fluid.MixingVolumes.MixingVolume</a> should be used.
The other models are only of interest if water should be added to
or subtracted from the fluid volume, such as needed in a 
dynamic model of a coil with water vapor condensation.
</p>
</html>"));
    end MixingVolumes;

    package Movers "Package with fan and pump models"
      extends Modelica.Icons.VariantsPackage;

      model FlowMachine_y
      "Fan or pump with ideally controlled normalized speed y as input signal"
        extends Buildings.Fluid.Movers.BaseClasses.PrescribedFlowMachine(
        final N_nominal=1500 "fix N_nominal as it is used only for scaling");

        Modelica.Blocks.Interfaces.RealInput y(min=0, max=1)
        "Constant normalized rotational speed"
          annotation (Placement(transformation(
              extent={{-20,-20},{20,20}},
              rotation=-90,
              origin={0,100}), iconTransformation(
              extent={{-20,-20},{20,20}},
              rotation=-90,
              origin={0,100})));

      equation
        N = y*N_nominal;
        annotation (defaultComponentName="fan",
          Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                  100}}), graphics={Text(extent={{20,100},{112,78}}, textString
                =   "y_in [0, 1]")}),
          Diagram(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{
                  100,100}}), graphics),
          Documentation(info="<html>
<p>
This model describes a fan or pump with prescribed normalized speed.
The input connector provides the normalized rotational speed (between 0 and 1).
The head is computed based on the performance curve that take as an argument
the actual volume flow rate divided by the maximum flow rate and the relative
speed of the fan.
The efficiency of the device is computed based
on the efficiency curves that take as an argument
the actual volume flow rate divided by the maximum possible volume flow rate, or
based on the motor performance curves.
</p>
<p>
See the 
<a href=\"modelica://Buildings.Fluid.Movers.UsersGuide\">
User's Guide</a> for more information.
</p>
</html>",   revisions="<html>
<ul>
<li>
May 25, 2011, by Michael Wetter:<br>
Revised implementation of energy balance to avoid having to use conditionally removed models.
</li>
<li>
July 27, 2010, by Michael Wetter:<br>
Redesigned model to fix bug in medium balance.
</li>
<li>March 24, 2010, by Michael Wetter:<br>
Revised implementation to allow zero flow rate.
</li>
<li>October 1, 2009,
    by Michael Wetter:<br>
       Model added to the Buildings library. Changed control signal from rpm to normalized value between 0 and 1</li>
<li><i>31 Oct 2005</i>
    by <a href=\"mailto:francesco.casella@polimi.it\">Francesco Casella</a>:<br>
       Model added to the Fluid library</li>
</ul>
</html>"));
      end FlowMachine_y;

      package BaseClasses
      "Package with base classes for Buildings.Fluid.Movers"
        extends Modelica.Icons.BasesPackage;

        package Characteristics "Functions for fan or pump characteristics"

          record flowParameters "Record for flow parameters"
            extends Modelica.Icons.Record;
            parameter Modelica.SIunits.VolumeFlowRate V_flow[:](each min=0)
            "Volume flow rate at user-selected operating points";
            parameter Modelica.SIunits.Pressure dp[size(V_flow,1)](
               each min=0, each displayUnit="Pa")
            "Fan or pump total pressure at these flow rates";
            annotation (Documentation(info="<html>
<p>
Data record for performance data that describe volume flow rate versus
pressure rise.
The volume flow rate <code>V_flow</code> must be increasing, i.e.,
<code>V_flow[i] &lt; V_flow[i+1]</code>.
Both vectors, <code>V_flow</code> and <code>dp</code>
must have the same size.
</p>
</html>", revisions="<html>
<ul>
<li>
September 28, 2011, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
          end flowParameters;

          record efficiencyParameters "Record for efficiency parameters"
            extends Modelica.Icons.Record;
            parameter Real  r_V[:](each min=0, each max=1, each displayUnit="1")
            "Volumetric flow rate divided by nominal flow rate at user-selected operating points";
            parameter Real eta[size(r_V,1)](
               each min=0, each max=1, each displayUnit="1")
            "Fan or pump efficiency at these flow rates";
            annotation (Documentation(info="<html>
<p>
Data record for performance data that describe volume flow rate versus
efficiency.
The volume flow rate <code>r_V</code> must be increasing, i.e.,
<code>r_V[i] &lt; r_V[i+1]</code>.
Both vectors, <code>r_V</code> and <code>eta</code>
must have the same size.
</p>
</html>", revisions="<html>
<ul>
<li>
September 28, 2011, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
          end efficiencyParameters;

          record powerParameters "Record for electrical power parameters"
            extends Modelica.Icons.Record;
            parameter Modelica.SIunits.VolumeFlowRate V_flow[:](each min=0)= {0}
            "Volume flow rate at user-selected operating points";
            parameter Modelica.SIunits.Power P[size(V_flow,1)](
               each min=0, max=1, each displayUnit="1") = {0}
            "Fan or pump electrical power at these flow rates";
            annotation (Documentation(info="<html>
<p>
Data record for performance data that describe volume flow rate versus
electrical power.
The volume flow rate <code>V_flow</code> must be increasing, i.e.,
<code>V_flow[i] &lt; V_flow[i+1]</code>.
Both vectors, <code>V_flow</code> and <code>P</code>
must have the same size.
</p>
</html>", revisions="<html>
<ul>
<li>
September 28, 2011, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
          end powerParameters;

          function pressure
          "Flow vs. head characteristics for fan or pump pressure raise"
            extends Modelica.Icons.Function;
            input
            Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParameters       data
            "Pressure performance data";
            input Modelica.SIunits.VolumeFlowRate V_flow "Volumetric flow rate";
            input Real r_N(unit="1") "Relative revolution, r_N=N/N_nominal";
            input Modelica.SIunits.VolumeFlowRate VDelta_flow
            "Small volume flow rate";
            input Modelica.SIunits.Pressure dpDelta "Small pressure";

            input Modelica.SIunits.VolumeFlowRate V_flow_max
            "Maximum volume flow rate at r_N=1 and dp=0";
            input Modelica.SIunits.Pressure dpMax(min=0)
            "Maximum pressure at r_N=1 and V_flow=0";

            input Real d[:]
            "Derivatives at support points for spline interpolation";
            input Real delta
            "Small value used to transition to other fan curve";
            input Real cBar[2]
            "Coefficients for linear approximation of pressure vs. flow rate";
            input Real kRes(unit="kg/(s.m4)")
            "Linear coefficient for fan-internal pressure drop";
            output Modelica.SIunits.Pressure dp "Pressure raise";

        protected
             Integer dimD(min=2)=size(data.V_flow, 1)
            "Dimension of data vector";

            function performanceCurve "Performance curve away from the origin"
              input Modelica.SIunits.VolumeFlowRate V_flow
              "Volumetric flow rate";
              input Real r_N(unit="1") "Relative revolution, r_N=N/N_nominal";
              input Real d[dimD]
              "Coefficients for polynomial of pressure vs. flow rate";
              input
              Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParameters
                                                                                      data
              "Pressure performance data";
              input Integer dimD "Dimension of data vector";

              output Modelica.SIunits.Pressure dp "Pressure raise";

          protected
              Modelica.SIunits.VolumeFlowRate rat "Ratio of V_flow/r_N";
              Integer i "Integer to select data interval";
            algorithm
              rat := V_flow/r_N;
              i :=1;
              // Since the coefficients for the spline were evaluated for
              // rat_nominal = V_flow_nominal/r_N_nominal = V_flow_nominal/1, we use
              // V_flow_nominal below
              for j in 1:dimD-1 loop
                 if rat > data.V_flow[j] then
                   i := j;
                 end if;
              end for;
              // Extrapolate or interpolate the data
              dp:=r_N^2*Buildings.Utilities.Math.Functions.cubicHermiteLinearExtrapolation(
                          x=rat,
                          x1=data.V_flow[i],
                          x2=data.V_flow[i + 1],
                          y1=data.dp[i],
                          y2=data.dp[i + 1],
                          y1d=d[i],
                          y2d=d[i+1]);
              annotation(smoothOrder=1);
            end performanceCurve;

          algorithm
            if r_N >= delta then
               dp := performanceCurve(V_flow=V_flow, r_N=r_N, d=d,
                                      data=data, dimD=dimD);
            elseif r_N <= delta/2 then
              dp := flowApproximationAtOrigin(r_N=r_N, V_flow=V_flow,
                                              VDelta_flow=  VDelta_flow, dpDelta=dpDelta,
                                              delta=delta, cBar=cBar);
            else
              dp := Modelica.Fluid.Utilities.regStep(x=r_N-0.75*delta,
                                                     y1=performanceCurve(V_flow=V_flow, r_N=r_N, d=d,
                                                                         data=data, dimD=dimD),
                                                     y2=flowApproximationAtOrigin(r_N=r_N, V_flow=V_flow,
                                                             VDelta_flow=VDelta_flow, dpDelta=dpDelta,
                                                             delta=delta, cBar=cBar),
                                                     x_small=delta/4);
            end if;
            dp := dp - V_flow*kRes;
            annotation(smoothOrder=1,
                        Documentation(info="<html>
<p>
This function computes the fan static
pressure raise as a function of volume flow rate and revolution in the form
</p>
<p align=\"center\" style=\"font-style:italic;\">
  &Delta;p = r<sub>N</sub><sup>2</sup> &nbsp; s(V/r<sub>N</sub>, d)
  - &Delta;p<sub>r</sub> ,
</p>
<p>
where
<i>&Delta;p</i> is the pressure rise,
<i>r<sub>N</sub></i> is the normalized fan speed,
<i>V</i> is the volume flow rate and
<i>d</i> are performance data for fan or pump power consumption at <i>r<sub>N</sub>=1</i>.
The term
</p>
<p align=\"center\" style=\"font-style:italic;\">
&Delta;p<sub>r</sub> = V &nbsp; &Delta;p<sub>max</sub> &frasl; V<sub>max</sub> &nbsp; &delta;
</p>
<p>
models the flow resistance of the fan, approximated using a linear equation. 
This is done for numerical reasons to avoid a singularity at <i>r<sub>N</sub>=0</i>. Since <i>&delta;</i> is small, the contribution of this term is small.
The fan and pump models in 
<a href=\"modelica://Buildings.Fluid.Movers\">
Buildings.Fluid.Movers</a> modify the user-supplied performance data to add the term
<i>&Delta;p<sub>r</sub></i> prior to computing the performance curve.
Thus, at full speed, the fan or pump can operate exactly at the user-supplied performance data.
</p>
<h4>Implementation</h4>
<p>
The function <i>s(&middot;, &middot;)</i> is a cubic hermite spline.
If the data <i>d</i> define a monotone decreasing sequence, then 
<i>s(&middot;, d)</i> is a monotone decreasing function.
</p>
<p>
For <i>r<sub>N</sub> &lt; &delta;</i>, the polynomial is replaced with an other model to avoid
a singularity at the origin. The composite model is once continuously differentiable
in all input variables.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 25, 2011, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),             smoothOrder=1);
          end pressure;

          function flowApproximationAtOrigin
          "Approximation for fan or pump pressure raise at origin"
            extends Modelica.Icons.Function;
            input Modelica.SIunits.VolumeFlowRate V_flow "Volumetric flow rate";
            input Real r_N(unit="1") "Relative revolution, r_N=N/N_nominal";
            input Modelica.SIunits.VolumeFlowRate VDelta_flow
            "Small volume flow rate";
            input Modelica.SIunits.Pressure dpDelta "Small pressure";
            input Real delta
            "Small value used to transition to other fan curve";
            input Real cBar[2]
            "Coefficients for linear approximation of pressure vs. flow rate";
            output Modelica.SIunits.Pressure dp "Pressure raise";
          algorithm
            dp := r_N * dpDelta + r_N^2 * (cBar[1] + cBar[2]*V_flow);
            annotation (Documentation(info="<html>
<p>
This function computes the fan static
pressure raise as a function of volume flow rate and revolution near the origin.
It is used to avoid a singularity in the pump or fan curve if the revolution 
approaches zero.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 25, 2011, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),             smoothOrder=100);
          end flowApproximationAtOrigin;

          function power
          "Flow vs. electrical power characteristics for fan or pump"
            extends Modelica.Icons.Function;
            input
            Buildings.Fluid.Movers.BaseClasses.Characteristics.powerParameters       data
            "Pressure performance data";
            input Modelica.SIunits.VolumeFlowRate V_flow "Volumetric flow rate";
            input Real r_N(unit="1") "Relative revolution, r_N=N/N_nominal";
            input Real d[:]
            "Derivatives at support points for spline interpolation";
            output Modelica.SIunits.Power P "Power consumption";

        protected
             Integer n=size(data.V_flow, 1) "Dimension of data vector";

             Modelica.SIunits.VolumeFlowRate rat "Ratio of V_flow/r_N";
             Integer i "Integer to select data interval";

          algorithm
            if n == 1 then
              P := r_N^3*data.P[1];
            else
              i :=1;
              // Since the coefficients for the spline were evaluated for
              // rat_nominal = V_flow_nominal/r_N_nominal = V_flow_nominal/1, we use
              // V_flow_nominal below
              for j in 1:n-1 loop
                 if V_flow > data.V_flow[j] then
                   i := j;
                 end if;
              end for;
              // Extrapolate or interpolate the data
              P:=r_N^3*Buildings.Utilities.Math.Functions.cubicHermiteLinearExtrapolation(
                          x=V_flow,
                          x1=data.V_flow[i],
                          x2=data.V_flow[i + 1],
                          y1=data.P[i],
                          y2=data.P[i + 1],
                          y1d=d[i],
                          y2d=d[i+1]);
            end if;
            annotation(smoothOrder=1,
                        Documentation(info="<html>
<p>
This function computes the fan power consumption for given volume flow rate,
speed and performance data. The power consumption is
</p>
<p align=\"center\" style=\"font-style:italic;\">
  P = r<sub>N</sub><sup>3</sup> &nbsp; s(V, d),
</p>
<p>
where
<i>P</i> is the power consumption,
<i>r<sub>N</sub></i> is the normalized fan speed,
<i>V</i> is the volume flow rate and
<i>d</i> are performance data for fan or pump power consumption at <i>r<sub>N</sub>=1</i>.
</p>
<h4>Implementation</h4>
<p>
The function <i>s(&middot;, &middot;)</i> is a cubic hermite spline.
If the data <i>d</i> define a monotone decreasing sequence, then 
<i>s(&middot;, d)</i> is a monotone decreasing function.
</p>
</html>",         revisions="<html>
<ul>
<li>
September 28, 2011, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),             smoothOrder=1);
          end power;

          function efficiency
          "Flow vs. efficiency characteristics for fan or pump"
            extends Modelica.Icons.Function;
            input
            Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiencyParameters
              data "Efficiency performance data";
            input Real r_V(unit="1")
            "Volumetric flow rate divided by nominal flow rate";
            input Real d[:]
            "Derivatives at support points for spline interpolation";
            output Real eta(min=0, unit="1") "Efficiency";

        protected
            Integer n = size(data.r_V, 1) "Number of data points";
            Integer i "Integer to select data interval";
          algorithm
            if n == 1 then
              eta := data.eta[1];
            else
              i :=1;
              for j in 1:n-1 loop
                 if r_V > data.r_V[j] then
                   i := j;
                 end if;
              end for;
              // Extrapolate or interpolate the data
              eta:=Buildings.Utilities.Math.Functions.cubicHermiteLinearExtrapolation(
                          x=r_V,
                          x1=data.r_V[i],
                          x2=data.r_V[i + 1],
                          y1=data.eta[i],
                          y2=data.eta[i + 1],
                          y1d=d[i],
                          y2d=d[i+1]);
            end if;

            annotation(smoothOrder=1,
                        Documentation(info="<html>
<p>
This function computes the fan or pump efficiency for given normalized volume flow rate
and performance data. The efficiency is
</p>
<p align=\"center\" style=\"font-style:italic;\">
  &eta; = s(r<sub>V</sub>, d),
</p>
<p>
where
<i>&eta;</i> is the efficiency,
<i>r<sub>V</sub></i> is the normalized volume flow rate, and
<i>d</i> are performance data for fan or pump efficiency.
</p>
<h4>Implementation</h4>
<p>
The function <i>s(&middot;, &middot;)</i> is a cubic hermite spline.
If the data <i>d</i> define a monotone decreasing sequence, then 
<i>s(&middot;, d)</i> is a monotone decreasing function.
</p>
</html>",         revisions="<html>
<ul>
<li>
September 28, 2011, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),             smoothOrder=1);
          end efficiency;
          annotation (Documentation(info="<html>
<p>
This package implements performance curves for fans and pumps,
and records for parameter that can be used with these performance
curves.
</p>
<p>
The following performance curves are implemented:
<table border=\"1\" cellspacing=0 cellpadding=2 style=\"border-collapse:collapse;\">
<tr>
<th>Independent variable</th>
<th>Dependent variable</th>
<th>Record for performance data</th>
<th>Function</th>
</tr>
<tr>
<td>Volume flow rate</td>
<td>Pressure</td>
<td><a href=\"modelica://Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParameters\">
flowParameters</a></td>
<td><a href=\"modelica://Buildings.Fluid.Movers.BaseClasses.Characteristics.pressure\">
pressure</a></td>
</tr>
<tr>
<td>Relative volumetric flow rate</td>
<td>Efficiency</td>
<td><a href=\"modelica://Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiencyParameters\">
efficiencyParameters</a></td>
<td><a href=\"modelica://Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiency\">
efficiency</a></td>
</tr>
<tr>
<td>Volume flow rate</td>
<td>Power</td>
<td><a href=\"modelica://Buildings.Fluid.Movers.BaseClasses.Characteristics.powerParameters\">
powerParameters</a></td>
<td><a href=\"modelica://Buildings.Fluid.Movers.BaseClasses.Characteristics.power\">
power</a></td>
</tr>
</table>
</p>
</html>",
        revisions="<html>
<ul>
<li>
September 29, 2011, by Michael Wetter:<br>
New implementation due to changes from polynomial to cubic hermite splines.
</li>
</ul>
</html>"));
        end Characteristics;

        partial model PrescribedFlowMachine
        "Partial model for fan or pump with speed (y or Nrpm) as input signal"
          extends Buildings.Fluid.Movers.BaseClasses.PartialFlowMachine(
              final show_V_flow = false,
              final m_flow_nominal = max(pressure.V_flow)*rho_nominal,
              preSou(final control_m_flow=false));

          extends Buildings.Fluid.Movers.BaseClasses.FlowMachineInterface(
            V_flow_max(start=V_flow_nominal),
            final rho_nominal = Medium.density_pTX(Medium.p_default, Medium.T_default, Medium.X_default));

          // Models
      protected
          Modelica.Blocks.Sources.RealExpression dpMac(y=-dpMachine)
          "Pressure drop of the pump or fan"
            annotation (Placement(transformation(extent={{0,20},{20,40}})));

          Modelica.Blocks.Sources.RealExpression PToMedium_flow(y=Q_flow + WFlo) if  addPowerToMedium
          "Heat and work input into medium"
            annotation (Placement(transformation(extent={{-100,10},{-80,30}})));
        equation
         VMachine_flow = -port_b.m_flow/rho;
         rho = rho_in;

          connect(preSou.dp_in, dpMac.y) annotation (Line(
              points={{36,8},{36,30},{21,30}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(PToMedium_flow.y, prePow.Q_flow) annotation (Line(
              points={{-79,20},{-70,20}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                    100}}), graphics={
                Polygon(
                  points={{-48,-60},{-72,-100},{72,-100},{48,-60},{-48,-60}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={0,0,0},
                  fillPattern=FillPattern.VerticalCylinder),
                Rectangle(
                  extent={{-100,46},{100,-46}},
                  lineColor={0,0,0},
                  fillColor={0,127,255},
                  fillPattern=FillPattern.HorizontalCylinder),
                Polygon(
                  points={{2,70},{2,-66},{72,4},{2,70}},
                  lineColor={0,0,0},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={255,255,255}),
                Ellipse(
                  extent={{-80,80},{80,-80}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  fillColor={0,100,199}),
                Polygon(
                  points={{0,72},{0,-68},{74,4},{0,72}},
                  lineColor={0,0,0},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={255,255,255}),
                Ellipse(
                  extent={{16,18},{46,-12}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  visible=dynamicBalance,
                  fillColor={0,100,199})}),
            Diagram(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                    100}}),
                    graphics),
            Documentation(info="<html>
<p>This is the base model for fans and pumps that take as 
input a control signal in the form of the pump speed <code>Nrpm</code>
or the normalized pump speed <code>y=Nrpm/N_nominal</code>.
</p>
</html>",     revisions="<html>
<ul>
<li>
May 25, 2011, by Michael Wetter:<br>
Revised implementation of energy balance to avoid having to use conditionally removed models.
</li>
<li>
July 27, 2010, by Michael Wetter:<br>
Redesigned model to fix bug in medium balance.
</li>
<li>March 24 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end PrescribedFlowMachine;

        partial model PartialFlowMachine
        "Partial model to interface fan or pump models with the medium"
          extends Buildings.Fluid.Interfaces.LumpedVolumeDeclarations;
          import Modelica.Constants;

          extends Buildings.Fluid.Interfaces.PartialTwoPortInterface(show_T=false,
            port_a(
              h_outflow(start=h_outflow_start),
              final m_flow(min = if allowFlowReversal then -Constants.inf else 0)),
            port_b(
              h_outflow(start=h_outflow_start),
              p(start=p_start),
              final m_flow(max = if allowFlowReversal then +Constants.inf else 0)));

          Delays.DelayFirstOrder vol(
            redeclare package Medium = Medium,
            tau=tau,
            energyDynamics=if dynamicBalance then energyDynamics else Modelica.Fluid.Types.Dynamics.SteadyState,
            massDynamics=if dynamicBalance then massDynamics else Modelica.Fluid.Types.Dynamics.SteadyState,
            T_start=T_start,
            X_start=X_start,
            C_start=C_start,
            m_flow_nominal=m_flow_nominal,
            p_start=p_start,
            prescribedHeatFlowRate=true,
            allowFlowReversal=allowFlowReversal,
            nPorts=2) "Fluid volume for dynamic model"
            annotation (Placement(transformation(extent={{-40,0},{-20,20}})));
           parameter Boolean dynamicBalance = true
          "Set to true to use a dynamic balance, which often leads to smaller systems of equations"
            annotation (Evaluate=true, Dialog(tab="Dynamics", group="Equations"));

          parameter Boolean addPowerToMedium=true
          "Set to false to avoid any power (=heat and flow work) being added to medium (may give simpler equations)";

          parameter Modelica.SIunits.Time tau=1
          "Time constant of fluid volume for nominal flow, used if dynamicBalance=true"
            annotation (Dialog(tab="Dynamics", group="Nominal condition", enable=dynamicBalance));

          // Models
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort
            annotation (Placement(transformation(extent={{-70,-90},{-50,-70}})));

      protected
          Modelica.SIunits.Density rho_in "Density of inflowing fluid";

          Buildings.Fluid.Movers.BaseClasses.IdealSource preSou(
          redeclare package Medium = Medium,
            allowFlowReversal=allowFlowReversal) "Pressure source"
            annotation (Placement(transformation(extent={{20,-10},{40,10}})));

          Buildings.HeatTransfer.Sources.PrescribedHeatFlow prePow if addPowerToMedium
          "Prescribed power (=heat and flow work) flow for dynamic model"
            annotation (Placement(transformation(extent={{-70,10},{-50,30}})));

          parameter Medium.ThermodynamicState sta_start=Medium.setState_pTX(
              T=T_start, p=p_start, X=X_start);
          parameter Modelica.SIunits.SpecificEnthalpy h_outflow_start = Medium.specificEnthalpy(sta_start)
          "Start value for outflowing enthalpy";

        equation
          // For computing the density, we assume that the fan operates in the design flow direction.
          rho_in = Medium.density(
               Medium.setState_phX(port_a.p, inStream(port_a.h_outflow), inStream(port_a.Xi_outflow)));
          connect(prePow.port, vol.heatPort) annotation (Line(
              points={{-50,20},{-44,20},{-44,10},{-40,10}},
              color={191,0,0},
              smooth=Smooth.None));

          connect(vol.heatPort, heatPort) annotation (Line(
              points={{-40,10},{-40,-80},{-60,-80}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(port_a, vol.ports[1]) annotation (Line(
              points={{-100,5.55112e-16},{-66,5.55112e-16},{-66,-5.55112e-16},{-32,
                  -5.55112e-16}},
              color={0,127,255},
              smooth=Smooth.None));
          connect(vol.ports[2], preSou.port_a) annotation (Line(
              points={{-28,-5.55112e-16},{-5,-5.55112e-16},{-5,6.10623e-16},{20,
                  6.10623e-16}},
              color={0,127,255},
              smooth=Smooth.None));
          connect(preSou.port_b, port_b) annotation (Line(
              points={{40,6.10623e-16},{70,6.10623e-16},{70,5.55112e-16},{100,
                  5.55112e-16}},
              color={0,127,255},
              smooth=Smooth.None));
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                    100}}), graphics={
                Polygon(
                  points={{-48,-60},{-72,-100},{72,-100},{48,-60},{-48,-60}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={0,0,0},
                  fillPattern=FillPattern.VerticalCylinder),
                Rectangle(
                  extent={{-100,46},{100,-46}},
                  lineColor={0,0,0},
                  fillColor={0,127,255},
                  fillPattern=FillPattern.HorizontalCylinder),
                Polygon(
                  points={{2,70},{2,-66},{72,4},{2,70}},
                  lineColor={0,0,0},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={255,255,255}),
                Ellipse(
                  extent={{-80,80},{80,-80}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  fillColor={0,100,199}),
                Polygon(
                  points={{0,72},{0,-68},{74,4},{0,72}},
                  lineColor={0,0,0},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={255,255,255}),
                Ellipse(
                  extent={{16,18},{46,-12}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  visible=dynamicBalance,
                  fillColor={0,100,199})}),
            Diagram(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                    100}}),
                    graphics),
            Documentation(info="<html>
<p>This is the base model for fans and pumps.
It provides an interface
between the equations that compute head and power consumption,
and the implementation of the energy and pressure balance
of the fluid.
</p>
<p>
Depending on the value of
the parameter <code>dynamicBalance</code>, the fluid volume
is computed using a dynamic balance or a steady-state balance.
</p>
<p>
The parameter <code>addPowerToMedium</code> determines whether 
any power is added to the fluid. The default is <code>addPowerToMedium=true</code>,
and hence the outlet enthalpy is higher than the inlet enthalpy if the
flow device is operating.
The setting <code>addPowerToMedium=false</code> is physically incorrect
(since the flow work, the flow friction and the fan heat do not increase
the enthalpy of the medium), but this setting does in some cases lead to simpler equations
and more robust simulation, in particular if the mass flow is equal to zero.
</p>
</html>",     revisions="<html>
<ul>
<li>
May 25, 2011, by Michael Wetter:<br>
Revised implementation of energy balance to avoid having to use conditionally removed models.
</li>
<li>
July 29, 2010, by Michael Wetter:<br>
Reduced fan time constant from 10 to 1 second.
</li>
<li>
July 27, 2010, by Michael Wetter:<br>
Redesigned model to fix bug in medium balance.
</li>
<li>March 24 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end PartialFlowMachine;

        model IdealSource
        "Base class for pressure and mass flow source with optional power input"
          extends Modelica.Fluid.Interfaces.PartialTwoPortTransport(final show_V_flow=true);

          // what to control
          parameter Boolean control_m_flow
          "= false to control dp instead of m_flow"
            annotation(Evaluate = true);
          Modelica.Blocks.Interfaces.RealInput m_flow_in if control_m_flow
          "Prescribed mass flow rate"
            annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=-90,
                origin={-50,82}), iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=-90,
                origin={-60,80})));
          Modelica.Blocks.Interfaces.RealInput dp_in if not control_m_flow
          "Prescribed outlet pressure"
            annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=-90,
                origin={50,82}), iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=-90,
                origin={60,80})));

      protected
          Modelica.Blocks.Interfaces.RealInput m_flow_internal
          "Needed to connect to conditional connector";
          Modelica.Blocks.Interfaces.RealInput dp_internal
          "Needed to connect to conditional connector";
        equation

          // Ideal control
          if control_m_flow then
            m_flow = m_flow_internal;
            dp_internal = 0;
          else
            dp = dp_internal;
            m_flow_internal = 0;
          end if;

          connect(dp_internal, dp_in);
          connect(m_flow_internal, m_flow_in);

          // Energy balance (no storage)
          port_a.h_outflow = inStream(port_b.h_outflow);
          port_b.h_outflow = inStream(port_a.h_outflow);

          annotation (Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,
                    -100},{100,100}}), graphics={
                Rectangle(
                  extent={{-100,60},{100,-60}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={192,192,192}),
                Rectangle(
                  extent={{-100,50},{100,-48}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={0,127,255}),
                Text(
                  visible=not control_m_flow,
                  extent={{24,44},{80,24}},
                  lineColor={255,255,255},
                  textString="dp"),
                Text(
                  visible=control_m_flow,
                  extent={{-80,44},{-24,24}},
                  lineColor={255,255,255},
                  textString="m")}),
            Documentation(info="<html>
<p>
Model of a fictious pipe that is used as a base class
for a pressure source or to prescribe a mass flow rate.
</p>
<p>
Note that for fans and pumps with dynamic balance,
both the heat and the flow work are added to the volume of
air or water. This simplifies the equations compared to 
adding heat to the volume, and flow work to this model.
</p>
</html>",
        revisions="<html>
<ul>
<li>
May 25, 2011 by Michael Wetter:<br>
Removed the option to add power to the medium, as this is dealt with in the volume
that is used in the mover model.
</li>
<li>
July 27, 2010 by Michael Wetter:<br>
Redesigned model to fix bug in medium balance.
</li>
<li>
April 13, 2010 by Michael Wetter:<br>
Made heat connector optional.
</li>
<li>
March 23, 2010 by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),  Diagram(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{
                    100,100}}),
                            graphics));
        end IdealSource;

        partial model PowerInterface
        "Partial model to compute power draw and heat dissipation of fans and pumps"

          import Modelica.Constants;

          parameter Boolean use_powerCharacteristic = false
          "Use powerCharacteristic (vs. efficiencyCharacteristic)"
             annotation(Evaluate=true,Dialog(group="Characteristics"));

          parameter Boolean motorCooledByFluid = true
          "If true, then motor heat is added to fluid stream"
            annotation(Dialog(group="Characteristics"));
          parameter Boolean homotopyInitialization = true
          "= true, use homotopy method"
            annotation(Evaluate=true, Dialog(tab="Advanced"));

          parameter
          Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiencyParameters
              motorEfficiency(r_V={1}, eta={0.7})
          "Normalized volume flow rate vs. efficiency"
            annotation(Placement(transformation(extent={{60,-40},{80,-20}})),
                       Dialog(group="Characteristics"),
                       enable = not use_powerCharacteristic);
          parameter
          Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiencyParameters
              hydraulicEfficiency(r_V={1}, eta={0.7})
          "Normalized volume flow rate vs. efficiency"
            annotation(Placement(transformation(extent={{60,-80},{80,-60}})),
                       Dialog(group="Characteristics"),
                       enable = not use_powerCharacteristic);

          parameter Modelica.SIunits.Density rho_nominal
          "Nominal fluid density";

          Modelica.SIunits.Power PEle "Electrical power input";
          Modelica.SIunits.Power WHyd
          "Hydraulic power input (converted to flow work and heat)";
          Modelica.SIunits.Power WFlo "Flow work";
          Modelica.SIunits.HeatFlowRate Q_flow
          "Heat input from fan or pump to medium";
          Real eta(min=0, max=1) "Global efficiency";
          Real etaHyd(min=0, max=1) "Hydraulic efficiency";
          Real etaMot(min=0, max=1) "Motor efficiency";

          Modelica.SIunits.Pressure dpMachine(displayUnit="Pa")
          "Pressure increase";
          Modelica.SIunits.VolumeFlowRate VMachine_flow "Volume flow rate";
      protected
          parameter Modelica.SIunits.VolumeFlowRate V_flow_max(fixed=false)
          "Maximum volume flow rate, used for smoothing";
          //Modelica.SIunits.HeatFlowRate QThe_flow "Heat input into the medium";
          parameter Modelica.SIunits.VolumeFlowRate delta_V_flow = 1E-3*V_flow_max
          "Factor used for setting heat input into medium to zero at very small flows";
          final parameter Real motDer[size(motorEfficiency.r_V, 1)](fixed=false)
          "Coefficients for polynomial of pressure vs. flow rate"
            annotation (Evaluate=true);
          final parameter Real hydDer[size(hydraulicEfficiency.r_V,1)](fixed=false)
          "Coefficients for polynomial of pressure vs. flow rate"
            annotation (Evaluate=true);

          Modelica.SIunits.HeatFlowRate QThe_flow
          "Heat input from fan or pump to medium";

        initial algorithm
         // Compute derivatives for cubic spline
         motDer :=
           if use_powerCharacteristic then
             zeros(size(motorEfficiency.r_V, 1))
           elseif ( size(motorEfficiency.r_V, 1) == 1)  then
               {0}
           else
              Buildings.Utilities.Math.Functions.splineDerivatives(
              x=motorEfficiency.r_V,
              y=motorEfficiency.eta);
          hydDer :=
             if use_powerCharacteristic then
               zeros(size(hydraulicEfficiency.r_V, 1))
             elseif ( size(hydraulicEfficiency.r_V, 1) == 1)  then
               {0}
             else
               Buildings.Utilities.Math.Functions.splineDerivatives(
                           x=hydraulicEfficiency.r_V,
                           y=hydraulicEfficiency.eta);
        equation
          eta = etaHyd * etaMot;
          WFlo = eta * PEle;
          // Flow work
          WFlo = dpMachine*VMachine_flow;
          // Hydraulic power (transmitted by shaft), etaHyd = WFlo/WHyd
          etaHyd * WHyd   = WFlo;
          // Heat input into medium
          QThe_flow +  WFlo = if motorCooledByFluid then PEle else WHyd;
          // At m_flow = 0, the solver may still obtain positive values for QThe_flow.
          // The next statement sets the heat input into the medium to zero for very small flow rates.
          if homotopyInitialization then
            Q_flow = homotopy(actual=Buildings.Utilities.Math.Functions.spliceFunction(pos=QThe_flow, neg=0,
                               x=noEvent(abs(VMachine_flow))-2*delta_V_flow, deltax=delta_V_flow),
                             simplified=0);
          else
            Q_flow = Buildings.Utilities.Math.Functions.spliceFunction(pos=QThe_flow, neg=0,
                               x=noEvent(abs(VMachine_flow))-2*delta_V_flow, deltax=delta_V_flow);
          end if;
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                    100}}), graphics),
            Diagram(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{
                    100,100}}),
                    graphics),
            Documentation(info="<html>
<p>This is an interface that implements the functions to compute the power draw and the
heat dissipation of fans and pumps. It is used by the model 
<a href=\"modelica://Buildings.Fluid.Movers.BaseClasses.FlowMachineInterface\">
Buildings.Fluid.Movers.BaseClasses.FlowMachineInterface</a>.
</p>
</html>",     revisions="<html>
<ul>
<li><i>March 1, 2010</i>
    by Michael Wetter:<br>
    Revised implementation to allow <code>N=0</code>.
<li><i>October 1, 2009</i>
    by Michael Wetter:<br>
    Changed model so that it is based on total pressure in Pascals instead of the pump head in meters.
    This change is needed if the device is used with air as a medium. The original formulation in Modelica.Fluid
    converts head to pressure using the density medium.d. Therefore, for fans, head would be converted to pressure
    using the density of air. However, for fans, manufacturers typically publish the head in 
    millimeters water (mmH20). Therefore, to avoid confusion and to make this model applicable for any medium,
    the model has been changed to use total pressure in Pascals instead of head in meters.
</li>
<li><i>31 Oct 2005</i>
    by <a href=\"mailto:francesco.casella@polimi.it\">Francesco Casella</a>:<br>
       Model added to the Fluid library</li>
</ul>
</html>"));
        end PowerInterface;

        partial model FlowMachineInterface
        "Partial model with performance curves for fans or pumps"
          extends Buildings.Fluid.Movers.BaseClasses.PowerInterface(
            VMachine_flow(start=V_flow_nominal),
            V_flow_max(start=V_flow_nominal));

          import Modelica.Constants;
          import cha = Buildings.Fluid.Movers.BaseClasses.Characteristics;

          parameter Modelica.SIunits.Conversions.NonSIunits.AngularVelocity_rpm
            N_nominal = 1500 "Nominal rotational speed for flow characteristic"
            annotation(Dialog(group="Characteristics"));
          final parameter Modelica.SIunits.VolumeFlowRate V_flow_nominal = pressure.V_flow[size(pressure.V_flow,1)]
          "Nominal volume flow rate, used for homotopy";
          parameter
          Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParameters           pressure
          "Volume flow rate vs. total pressure rise"
            annotation(Placement(transformation(extent={{20,-80},{40,-60}})),
                       Dialog(group="Characteristics"));
          parameter
          Buildings.Fluid.Movers.BaseClasses.Characteristics.powerParameters           power
          "Volume flow rate vs. electrical power consumption"
            annotation(Placement(transformation(extent={{20,-40},{40,-20}})),
                       Dialog(group="Characteristics", enable = use_powerCharacteristic));

          parameter Boolean homotopyInitialization = true
          "= true, use homotopy method"
            annotation(Evaluate=true, Dialog(tab="Advanced"));

          Modelica.SIunits.Conversions.NonSIunits.AngularVelocity_rpm N(min=0, start = N_nominal)
          "Shaft rotational speed";
          Real r_N(min=0, start=1, unit="1") "Ratio N/N_nominal";
          Real r_V(start=1, unit="1") "Ratio V_flow/V_flow_max";
      protected
          parameter Modelica.SIunits.VolumeFlowRate VDelta_flow(fixed=false, start=delta*V_flow_nominal)
          "Small volume flow rate";
          parameter Modelica.SIunits.Pressure dpDelta(fixed=false, start=100)
          "Small pressure";
          parameter Real delta = 0.05
          "Small value used to transition to other fan curve";
          parameter Real cBar[2](fixed=false)
          "Coefficients for linear approximation of pressure vs. flow rate";
          parameter Modelica.SIunits.Pressure dpMax(min=0, fixed=false);
          parameter Real kRes(min=0, unit="kg/(s.m4)", fixed=false)
          "Coefficient for internal pressure drop of fan or pump";

          parameter Integer curve(min=1, max=3, fixed=false)
          "Flag, used to pick the right representatio of the fan or pump pressure curve";
          parameter
          Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParameters           pCur1(
            V_flow(each fixed=false)=zeros(nOri), dp(each fixed=false))
          "Volume flow rate vs. total pressure rise with correction for pump resistance added";
          parameter
          Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParameters           pCur2(
            V_flow(each fixed=false)=zeros(nOri+1), dp(each fixed=false))
          "Volume flow rate vs. total pressure rise with correction for pump resistance added";
          parameter
          Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParameters           pCur3(
            V_flow(each fixed=false)=zeros(nOri+2), dp(each fixed=false))
          "Volume flow rate vs. total pressure rise with correction for pump resistance added";
          parameter Integer nOri = size(pressure.V_flow,1)
          "Number of data points for pressure curve";
          parameter Real preDer1[nOri](fixed=false)
          "Derivatives of flow rate vs. pressure at the support points";
          parameter Real preDer2[nOri+1](fixed=false)
          "Derivatives of flow rate vs. pressure at the support points";
          parameter Real preDer3[nOri+2](fixed=false)
          "Derivatives of flow rate vs. pressure at the support points";
          parameter Real powDer[size(power.V_flow,1)]=
           if use_powerCharacteristic then
             Buildings.Utilities.Math.Functions.splineDerivatives(
                           x=power.V_flow,
                           y=power.P)
           else
             zeros(size(power.V_flow,1))
          "Coefficients for polynomial of pressure vs. flow rate";

          parameter Boolean haveMinimumDecrease(fixed=false)
          "Flag used for reporting";
          parameter Boolean haveDPMax(fixed=false)
          "Flag, true if user specified data that contain dpMax";
          parameter Boolean haveVMax(fixed=false)
          "Flag, true if user specified data that contain V_flow_max";

          // Variables
          Modelica.SIunits.Density rho "Medium density";

        function getPerformanceDataAsString
          input
            Buildings.Fluid.Movers.BaseClasses.Characteristics.flowParameters     pressure
            "Performance data";
          input Real derivative[:](unit="kg/(s.m4)") "Derivative";
          input Integer minimumLength =  6 "Minimum width of result";
          input Integer significantDigits = 6 "Number of significant digits";
          output String str "String representation";
        algorithm
          str :="";
          for i in 1:size(derivative, 1) loop
            str :=str + "  V_flow[" + String(i) + "]=" + String(
                pressure.V_flow[i],
                minimumLength=minimumLength,
                significantDigits=significantDigits) + "\t" + "dp[" + String(i) + "]=" +
                String(
                pressure.dp[i],
                minimumLength=minimumLength,
                significantDigits=significantDigits) + "\tResulting derivative dp/dV_flow = "
                 + String(
                derivative[i],
                minimumLength=minimumLength,
                significantDigits=significantDigits) + "\n";
          end for;
        end getPerformanceDataAsString;

        function getArrayAsString
          input Real array[:] "Array to be printed";
          input String varName "Variable name";
          input Integer minimumLength =  6 "Minimum width of result";
          input Integer significantDigits = 6 "Number of significant digits";
          output String str "String representation";
        algorithm
          str :="";
          for i in 1:size(array, 1) loop
            str :=str + "  " + varName + "[" + String(i) + "]=" + String(
                array[i],
                minimumLength=minimumLength,
                significantDigits=significantDigits) + "\n";
          end for;
        end getArrayAsString;

        initial algorithm
          // Check validity of data
          assert(size(pressure.V_flow, 1) > 1, "Must have at least two data points for pressure.V_flow.");
          assert(Buildings.Utilities.Math.Functions.isMonotonic(x=pressure.V_flow, strict=true) and
          pressure.V_flow[1] > -Modelica.Constants.eps,
          "The volume flow rate for the fan pressure rise must be a strictly decreasing sequence
  with the first element being non-zero.
The following performance data have been entered:
"         + getArrayAsString(pressure.V_flow, "pressure.V_flow"));

          // Check if V_flow_max or dpMax are provided by user
          haveVMax  :=(abs(pressure.dp[nOri])   < Modelica.Constants.eps);
          haveDPMax :=(abs(pressure.V_flow[1])  < Modelica.Constants.eps);
          // Assign V_flow_max and dpMax
          if haveVMax then
            V_flow_max :=pressure.V_flow[nOri];
          else
            assert((pressure.V_flow[nOri]-pressure.V_flow[nOri-1])/((pressure.dp[nOri]-pressure.dp[nOri-1]))<0,
            "The last two pressure points for the fan or pump performance curve must be decreasing.
    You need to set more reasonable parameters.
Received 
"         + getArrayAsString(pressure.dp, "dp"));
            V_flow_max :=pressure.V_flow[nOri] - (pressure.V_flow[nOri] - pressure.V_flow[
              nOri - 1])/((pressure.dp[nOri] - pressure.dp[nOri - 1]))*pressure.dp[nOri];
          end if;
          if haveDPMax then
            dpMax :=pressure.dp[1];
          else
            dpMax :=pressure.dp[1] - ((pressure.dp[2] - pressure.dp[1])/(pressure.V_flow[
              2] - pressure.V_flow[1]))*pressure.V_flow[1];
          end if;

          // Check if minimum decrease condition is satisfied
          haveMinimumDecrease :=true;
          kRes :=dpMax/V_flow_max*delta^2/10;
          for i in 1:nOri-1 loop
            if ((pressure.dp[i+1]-pressure.dp[i])/(pressure.V_flow[i+1]-pressure.V_flow[i]) >= -kRes) then
              haveMinimumDecrease :=false;
            end if;
          end for;
          // Write warning if the volumetric flow rate versus pressure curve does not satisfy
          // the minimum decrease condition
          if (not haveMinimumDecrease) then
            Modelica.Utilities.Streams.print("
Warning:
========
It is recommended that the volume flow rate versus pressure relation
of the fan or pump satisfies the minimum decrease condition

        (pressure.dp[i+1]-pressure.dp[i])
d[i] = ----------------------------------------- < "         + String(-kRes) + "
       (pressure.V_flow[i+1]-pressure.V_flow[i])
 
is "         + getArrayAsString({(pressure.dp[i+1]-pressure.dp[i])/(pressure.V_flow[i+1]-pressure.V_flow[i]) for i in 1:nOri-1}, "d") + "
Otherwise, a solution to the equations may not exist if the fan or pump speed is reduced.
In this situation, the solver will fail due to non-convergence and 
the simulation stops.");
          end if;

          // Correction for flow resistance of pump or fan
          // Case 1:
          if (haveVMax and haveDPMax) or (nOri == 2) then
            curve :=1; // V_flow_max and dpMax are provided by the user, or we only have two data points
            for i in 1:nOri loop
              pCur1.dp[i]  :=pressure.dp[i] + pressure.V_flow[i] * kRes;
              pCur1.V_flow[i] := pressure.V_flow[i];
            end for;
              pCur2.V_flow := zeros(nOri + 1);
              pCur2.dp     := zeros(nOri + 1);
              pCur3.V_flow := zeros(nOri + 2);
              pCur3.dp     := zeros(nOri + 2);
              preDer1:=Buildings.Utilities.Math.Functions.splineDerivatives(x=pCur1.V_flow, y=pCur1.dp);
              preDer2:=zeros(nOri+1);
              preDer3:=zeros(nOri+2);
          elseif haveVMax or haveDPMax then
            curve :=2; // V_flow_max or dpMax is provided by the user, but not both
            if haveVMax then
              pCur2.V_flow[1] := 0;
              pCur2.dp[1]     := dpMax;
              for i in 1:nOri loop
                pCur2.dp[i+1]  :=pressure.dp[i] + pressure.V_flow[i] * kRes;
                pCur2.V_flow[i+1] := pressure.dp[i];
              end for;
            else
              for i in 1:nOri loop
                pCur2.dp[i]  :=pressure.dp[i] + pressure.V_flow[i] * kRes;
                pCur2.V_flow[i] := pressure.V_flow[i];
              end for;
              pCur2.V_flow[nOri+1] := V_flow_max;
              pCur2.dp[nOri+1]     := 0;
            end if;
            pCur1.V_flow := zeros(nOri);
            pCur1.dp     := zeros(nOri);
            pCur3.V_flow := zeros(nOri + 2);
            pCur3.dp     := zeros(nOri + 2);
            preDer1:=zeros(nOri);
            preDer2:=Buildings.Utilities.Math.Functions.splineDerivatives(x=pCur2.V_flow, y=pCur2.dp);
            preDer3:=zeros(nOri+2);
          else
            curve :=3; // Neither V_flow_max nor dpMax are provided by the user
            pCur3.V_flow[1] := 0;
            pCur3.dp[1]     := dpMax;
            for i in 1:nOri loop
              pCur3.dp[i+1]  :=pressure.dp[i] + pressure.V_flow[i] * kRes;
              pCur3.V_flow[i+1] := pressure.V_flow[i];
            end for;
            pCur3.V_flow[nOri+2] := V_flow_max;
            pCur3.dp[nOri+2]     := 0;
            pCur1.V_flow := zeros(nOri);
            pCur1.dp     := zeros(nOri);
            pCur2.V_flow := zeros(nOri + 1);
            pCur2.dp     := zeros(nOri + 1);
            preDer1:=zeros(nOri);
            preDer2:=zeros(nOri+1);
            preDer3:=Buildings.Utilities.Math.Functions.splineDerivatives(x=pCur3.V_flow, y=pCur3.dp);
          end if;

          // Equation to compute VDelta_flow. By the affinity laws, the volume flow rate is proportional to the speed.
          VDelta_flow :=V_flow_max*delta;

          // Equation to compute dpDelta
          dpDelta :=cha.pressure(
            data=if (curve == 1) then pCur1 elseif (curve == 2) then pCur2 else pCur3,
            V_flow=0,
            r_N=delta,
            VDelta_flow=0,
            dpDelta=0,
            V_flow_max=Modelica.Constants.eps,
            dpMax=0,
            delta=0,
            d=if (curve == 1) then preDer1 elseif (curve == 2) then preDer2 else preDer3,
            cBar=zeros(2),
            kRes=  kRes);

          // Linear equations to determine cBar
          // Conditions for r_N=delta, V_flow = VDelta_flow
          // Conditions for r_N=delta, V_flow = 0
          cBar[1] :=cha.pressure(
            data=if (curve == 1) then pCur1 elseif (curve == 2) then pCur2 else pCur3,
            V_flow=0,
            r_N=delta,
            VDelta_flow=0,
            dpDelta=0,
            V_flow_max=Modelica.Constants.eps,
            dpMax=0,
            delta=0,
            d=if (curve == 1) then preDer1 elseif (curve == 2) then preDer2 else preDer3,
            cBar=zeros(2),
            kRes=  kRes) * (1-delta)/delta^2;

          cBar[2] :=((cha.pressure(
            data=if (curve == 1) then pCur1 elseif (curve == 2) then pCur2 else pCur3,
            V_flow=VDelta_flow,
            r_N=delta,
            VDelta_flow=0,
            dpDelta=0,
            V_flow_max=Modelica.Constants.eps,
            dpMax=0,
            delta=0,
            d=if (curve == 1) then preDer1 elseif (curve == 2) then preDer2 else preDer3,
            cBar=zeros(2),
            kRes=  kRes) - delta*dpDelta)/delta^2 - cBar[1])/VDelta_flow;
        equation
          r_N = N/N_nominal;
          r_V = VMachine_flow/V_flow_max;
          // For the homotopy method, we approximate dpMachine by an equation
          // that is linear in VMachine_flow, and that goes linearly to 0 as r_N goes to 0.
          // The three branches below are identical, except that we pass either
          // pCur1, pCur2 or pCur3, and preDer1, preDer2 or preDer3
          if (curve == 1) then
            if homotopyInitialization then
               dpMachine = homotopy(actual=cha.pressure(data=pCur1,
                                                            V_flow=VMachine_flow, r_N=r_N,
                                                            VDelta_flow=VDelta_flow, dpDelta=dpDelta,
                                                            V_flow_max=V_flow_max, dpMax=dpMax,
                                                            delta=delta, d=preDer1, cBar=cBar, kRes=kRes),
                                  simplified=r_N*
                                      (cha.pressure(data=pCur1,
                                                            V_flow=V_flow_nominal, r_N=1,
                                                            VDelta_flow=VDelta_flow, dpDelta=dpDelta,
                                                            V_flow_max=V_flow_max, dpMax=dpMax,
                                                            delta=delta, d=preDer1, cBar=cBar, kRes=kRes)
                                       +(VMachine_flow-V_flow_nominal)*
                                        (cha.pressure(data=pCur1,
                                                            V_flow=(1+delta)*V_flow_nominal, r_N=1,
                                                            VDelta_flow=VDelta_flow, dpDelta=dpDelta,
                                                            V_flow_max=V_flow_max, dpMax=dpMax,
                                                            delta=delta, d=preDer1, cBar=cBar, kRes=kRes)
                                        -cha.pressure(data=pCur1,
                                                            V_flow=(1-delta)*V_flow_nominal, r_N=1,
                                                            VDelta_flow=VDelta_flow, dpDelta=dpDelta,
                                                            V_flow_max=V_flow_max, dpMax=dpMax,
                                                            delta=delta, d=preDer1, cBar=cBar, kRes=kRes))
                                         /(2*delta*V_flow_nominal)));

             else
               dpMachine = cha.pressure(data=pCur1, V_flow=VMachine_flow, r_N=r_N,
                                                        VDelta_flow=VDelta_flow, dpDelta=dpDelta, V_flow_max=V_flow_max, dpMax=dpMax,
                                                        delta=delta, d=preDer1, cBar=cBar, kRes=kRes);
             end if;
             // end of computation for this branch
           elseif (curve == 2) then
            if homotopyInitialization then
               dpMachine = homotopy(actual=cha.pressure(data=pCur2,
                                                            V_flow=VMachine_flow, r_N=r_N,
                                                            VDelta_flow=VDelta_flow, dpDelta=dpDelta,
                                                            V_flow_max=V_flow_max, dpMax=dpMax,
                                                            delta=delta, d=preDer2, cBar=cBar, kRes=kRes),
                                  simplified=r_N*
                                      (cha.pressure(data=pCur2,
                                                            V_flow=V_flow_nominal, r_N=1,
                                                            VDelta_flow=VDelta_flow, dpDelta=dpDelta,
                                                            V_flow_max=V_flow_max, dpMax=dpMax,
                                                            delta=delta, d=preDer2, cBar=cBar, kRes=kRes)
                                       +(VMachine_flow-V_flow_nominal)*
                                        (cha.pressure(data=pCur2,
                                                            V_flow=(1+delta)*V_flow_nominal, r_N=1,
                                                            VDelta_flow=VDelta_flow, dpDelta=dpDelta,
                                                            V_flow_max=V_flow_max, dpMax=dpMax,
                                                            delta=delta, d=preDer2, cBar=cBar, kRes=kRes)
                                        -cha.pressure(data=pCur2,
                                                            V_flow=(1-delta)*V_flow_nominal, r_N=1,
                                                            VDelta_flow=VDelta_flow, dpDelta=dpDelta,
                                                            V_flow_max=V_flow_max, dpMax=dpMax,
                                                            delta=delta, d=preDer2, cBar=cBar, kRes=kRes))
                                         /(2*delta*V_flow_nominal)));

             else
               dpMachine = cha.pressure(data=pCur2, V_flow=VMachine_flow, r_N=r_N,
                                                        VDelta_flow=VDelta_flow, dpDelta=dpDelta, V_flow_max=V_flow_max, dpMax=dpMax,
                                                        delta=delta, d=preDer2, cBar=cBar, kRes=kRes);
             end if;
             // end of computation for this branch
          else
            if homotopyInitialization then
               dpMachine = homotopy(actual=cha.pressure(data=pCur3,
                                                            V_flow=VMachine_flow, r_N=r_N,
                                                            VDelta_flow=VDelta_flow, dpDelta=dpDelta,
                                                            V_flow_max=V_flow_max, dpMax=dpMax,
                                                            delta=delta, d=preDer3, cBar=cBar, kRes=kRes),
                                  simplified=r_N*
                                      (cha.pressure(data=pCur3,
                                                            V_flow=V_flow_nominal, r_N=1,
                                                            VDelta_flow=VDelta_flow, dpDelta=dpDelta,
                                                            V_flow_max=V_flow_max, dpMax=dpMax,
                                                            delta=delta, d=preDer3, cBar=cBar, kRes=kRes)
                                       +(VMachine_flow-V_flow_nominal)*
                                        (cha.pressure(data=pCur3,
                                                            V_flow=(1+delta)*V_flow_nominal, r_N=1,
                                                            VDelta_flow=VDelta_flow, dpDelta=dpDelta,
                                                            V_flow_max=V_flow_max, dpMax=dpMax,
                                                            delta=delta, d=preDer3, cBar=cBar, kRes=kRes)
                                        -cha.pressure(data=pCur3,
                                                            V_flow=(1-delta)*V_flow_nominal, r_N=1,
                                                            VDelta_flow=VDelta_flow, dpDelta=dpDelta,
                                                            V_flow_max=V_flow_max, dpMax=dpMax,
                                                            delta=delta, d=preDer3, cBar=cBar, kRes=kRes))
                                         /(2*delta*V_flow_nominal)));

             else
               dpMachine = cha.pressure(data=pCur3, V_flow=VMachine_flow, r_N=r_N,
                                                        VDelta_flow=VDelta_flow, dpDelta=dpDelta, V_flow_max=V_flow_max, dpMax=dpMax,
                                                        delta=delta, d=preDer3, cBar=cBar, kRes=kRes);
             end if;
             // end of computation for this branch
          end if;
          // Power consumption
          if use_powerCharacteristic then
            // For the homotopy, we want PEle/V_flow to be bounded as V_flow -> 0 to avoid a very high medium
            // temperature near zero flow.
            if homotopyInitialization then
              PEle = homotopy(actual=cha.power(data=power, V_flow=VMachine_flow, r_N=r_N, d=powDer),
                              simplified=VMachine_flow/V_flow_nominal*
                                    cha.power(data=power, V_flow=V_flow_nominal, r_N=1, d=powDer));
            else
              PEle = (rho/rho_nominal)*cha.power(data=power, V_flow=VMachine_flow, r_N=r_N, d=powDer);
            end if;
            // In this configuration, we only now the total power consumption.
            // Hence, we assign the efficiency in equal parts to the motor and the hydraulic losses
            etaMot = sqrt(eta);
          else
            if homotopyInitialization then
              etaHyd = homotopy(actual=cha.efficiency(data=hydraulicEfficiency,     r_V=r_V, d=hydDer),
                                simplified=cha.efficiency(data=hydraulicEfficiency, r_V=1,   d=hydDer));
              etaMot = homotopy(actual=cha.efficiency(data=motorEfficiency,     r_V=r_V, d=motDer),
                                simplified=cha.efficiency(data=motorEfficiency, r_V=1,   d=motDer));
            else
              etaHyd = cha.efficiency(data=hydraulicEfficiency, r_V=r_V, d=hydDer);
              etaMot = cha.efficiency(data=motorEfficiency,     r_V=r_V, d=motDer);
            end if;
          end if;

          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                    100}}), graphics),
            Diagram(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{
                    100,100}}),
                    graphics),
            Documentation(info="<html>
<p>
This is an interface that implements the functions to compute the head, power draw 
and efficiency of fans and pumps. It is used by the model 
<a href=\"modelica://Buildings.Fluids.Movers.BaseClasses.PrescribedFlowMachine\">PrescribedFlowMachine</a>.
</p>
<p>
The nominal hydraulic characteristic (volume flow rate versus total pressure) is given by a set of data points.
A cubic hermite spline with linear extrapolation is used to compute the performance at other
operating points.
</p>
<p>The fan or pump energy balance can be specified in two alternative ways: </p>
<p>
<ul>
<li>
If <code>use_powerCharacteristic = false</code>, then the data points for
normalized volume flow rate versus efficiency is used to determine the efficiency, 
and then the power consumption. The default is a constant efficiency of 0.8.
</li>
<li>
If <code>use_powerCharacteristic = true</code>, then the data points for
normalized volume flow rate versus power consumption
is used to determine the power consumption, and then the efficiency
is computed based on the actual power consumption and the flow work. 
</p>
<h4>Implementation</h4>
<p>
For numerical reasons, the user-provided data points for volume flow rate 
versus pressure rise are modified to add a fan internal flow resistance.
Because this flow resistance is subtracted during the simulation when
computing the fan pressure rise, the model reproduces the exact points 
that were provided by the user.
</p>
<p>
Also for numerical reasons, the pressure rise at zero flow rate and 
the flow rate at zero pressure rise is added to the user-provided data,
unless the user already provides these data points.
Since Modelica 3.2 does not allow dynamic memory allocation, this 
implementation required the use of three different arrays for the 
situation where no additional point is added, where one additional
point is added and where two additional points are added.
The parameter <code>curve</code> causes the correct data record
to be used during the simulation.
</p>
</html>",
        revisions="<html>
<ul>
<li>
October 4 2011, by Michael Wetter:<br>
Revised the implementation of the pressure drop computation as a function
of speed and volume flow rate.
The new implementation avoids a singularity near zero volume flow rate and zero speed.
</li>
<li>
March 28 2011, by Michael Wetter:<br>
Added <code>homotopy</code> operator.
</li>
<li>
March 23 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end FlowMachineInterface;
      annotation (preferedView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Fluid.Movers\">Buildings.Fluid.Movers</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferedView="info", Documentation(info="<html>
This package contains components models for fans and pumps.
</html>"));
    end Movers;

    package Sensors "Package with sensor models"
      extends Modelica.Icons.SensorsPackage;

      model MassFlowRate "Ideal sensor for mass flow rate"
        extends Buildings.Fluid.Sensors.BaseClasses.PartialFlowSensor(
          final m_flow_nominal = 0,
          final m_flow_small = 0);
        extends Modelica.Icons.RotationalSensor;
        Modelica.Blocks.Interfaces.RealOutput m_flow(quantity="MassFlowRate",
                                                     final unit="kg/s")
        "Mass flow rate from port_a to port_b"   annotation (Placement(
              transformation(
              origin={0,110},
              extent={{10,-10},{-10,10}},
              rotation=270)));

      equation
        m_flow = port_a.m_flow;
      annotation (defaultComponentName="senMasFlo",
        Diagram(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{
                  100,100}}), graphics),
        Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
              graphics={
              Line(points={{70,0},{100,0}}, color={0,128,255}),
              Text(
                extent={{162,120},{2,90}},
                lineColor={0,0,0},
                textString="m_flow"),
              Line(points={{0,100},{0,70}}, color={0,0,127}),
              Line(points={{-100,0},{-70,0}}, color={0,128,255})}),
        Documentation(info="<html>
<p>
This component monitors the mass flow rate flowing from port_a to port_b. 
The sensor is ideal, i.e., it does not influence the fluid.
</p>
</html>
",    revisions="<html>
<ul>
<li>
September 29, 2009, by Michael Wetter:<br>
First implementation.
Implementation is based on <code>Modelica.Fluid</code>.
</li>
</ul>
</html>"));
      end MassFlowRate;

      model RelativePressure "Ideal relative pressure sensor"
        extends Modelica.Icons.TranslationalSensor;
        replaceable package Medium =
          Modelica.Media.Interfaces.PartialMedium "Medium in the sensor"  annotation (
            choicesAllMatching = true);

        Modelica.Fluid.Interfaces.FluidPort_a port_a(m_flow(min=0),
                                      p(start=Medium.p_default),
                                      redeclare package Medium = Medium)
          annotation (Placement(transformation(extent={{-110,-10},{-90,10}},
                rotation=0)));
        Modelica.Fluid.Interfaces.FluidPort_b port_b(m_flow(min=0),
                                      p(start=Medium.p_default),
                                      redeclare package Medium = Medium)
          annotation (Placement(transformation(extent={{110,-12},{90,8}}, rotation=
                  0), iconTransformation(extent={{110,-10},{90,10}})));

        Modelica.Blocks.Interfaces.RealOutput p_rel(final quantity="Pressure",
                                                    final unit="Pa",
                                                    displayUnit="bar")
        "Relative pressure signal"   annotation (Placement(transformation(
              origin={0,-90},
              extent={{10,-10},{-10,10}},
              rotation=90)));
      equation
        // Zero flow equations for connectors
        port_a.m_flow = 0;
        port_b.m_flow = 0;

        // No contribution of specific quantities
        port_a.h_outflow = 0;
        port_b.h_outflow = 0;
        port_a.Xi_outflow = zeros(Medium.nXi);
        port_b.Xi_outflow = zeros(Medium.nXi);
        port_a.C_outflow  = zeros(Medium.nC);
        port_b.C_outflow  = zeros(Medium.nC);

        // Relative pressure
        p_rel = port_a.p - port_b.p;
        annotation (defaultComponentName="senRelPre",
          Icon(graphics={
              Line(points={{-100,0},{-70,0}}, color={0,127,255}),
              Line(points={{70,0},{100,0}}, color={0,127,255}),
              Line(points={{0,-30},{0,-80}}, color={0,0,127}),
              Text(
                extent={{-150,40},{150,80}},
                textString="%name",
                lineColor={0,0,255}),
              Text(
                extent={{130,-70},{4,-100}},
                lineColor={0,0,0},
                textString="p_rel"),
              Line(
                points={{32,3},{-58,3}},
                color={0,128,255},
                smooth=Smooth.None),
              Polygon(
                points={{22,18},{62,3},{22,-12},{22,18}},
                lineColor={0,128,255},
                smooth=Smooth.None,
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid)}),
          Diagram(graphics),
          Documentation(info="<html>
<p>
The relative pressure \"port_a.p - port_b.p\" is determined between
the two ports of this component and is provided as output signal. The
sensor should be connected in parallel with other equipment, no flow
through the sensor is allowed.
</p>
</html>
",    revisions="<html>
<ul>
<li>
September 29, 2009, by Michael Wetter:<br>
First implementation.
Implementation is based on <code>Modelica.Fluid</code>.
</li>
</ul>
</html>"));
      end RelativePressure;

      model TemperatureTwoPort "Ideal two port temperature sensor"
        extends Buildings.Fluid.Sensors.BaseClasses.PartialDynamicFlowSensor;

        Modelica.Blocks.Interfaces.RealOutput T(final quantity="Temperature",
                                                final unit="K",
                                                displayUnit = "degC",
                                                min = 0,
                                                start=T_start)
        "Temperature of the passing fluid"
          annotation (Placement(transformation(
              origin={0,110},
              extent={{10,-10},{-10,10}},
              rotation=270)));

        parameter Modelica.SIunits.Temperature T_start=Medium.T_default
        "Initial or guess value of output (= state)"
          annotation (Dialog(group="Initialization"));
        Medium.Temperature TMed(start=T_start)
        "Medium temperature to which the sensor is exposed";
    protected
        Medium.Temperature T_a_inflow
        "Temperature of inflowing fluid at port_a";
        Medium.Temperature T_b_inflow
        "Temperature of inflowing fluid at port_b or T_a_inflow, if uni-directional flow";
      initial equation
        if dynamic then
          if initType == Modelica.Blocks.Types.Init.SteadyState then
            der(T) = 0;
           elseif initType == Modelica.Blocks.Types.Init.InitialState or
                 initType == Modelica.Blocks.Types.Init.InitialOutput then
            T = T_start;
          end if;
        end if;
      equation
        if allowFlowReversal then
           T_a_inflow = Medium.temperature(Medium.setState_phX(port_b.p, port_b.h_outflow, port_b.Xi_outflow));
           T_b_inflow = Medium.temperature(Medium.setState_phX(port_a.p, port_a.h_outflow, port_a.Xi_outflow));
           TMed = Modelica.Fluid.Utilities.regStep(port_a.m_flow, T_a_inflow, T_b_inflow, m_flow_small);
        else
           TMed = Medium.temperature(Medium.setState_phX(port_b.p, port_b.h_outflow, port_b.Xi_outflow));
           T_a_inflow = TMed;
           T_b_inflow = TMed;
        end if;
        // Output signal of sensor
        if dynamic then
          der(T) = (TMed-T)*k/tau;
        else
          T = TMed;
        end if;

      annotation (defaultComponentName="senTem",
        Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}),
                graphics),
          Icon(graphics={
              Line(points={{-100,0},{92,0}}, color={0,128,255}),
              Ellipse(
                extent={{-20,-58},{20,-20}},
                lineColor={0,0,0},
                lineThickness=0.5,
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Line(points={{-40,60},{-12,60}}, color={0,0,0}),
              Line(points={{-40,30},{-12,30}}, color={0,0,0}),
              Line(points={{-40,0},{-12,0}}, color={0,0,0}),
              Rectangle(
                extent={{-12,60},{12,-24}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-12,60},{-12,80},{-10,86},{-6,88},{0,90},{6,88},{10,86},{12,
                    80},{12,60},{-12,60}},
                lineColor={0,0,0},
                lineThickness=0.5),
              Text(
                extent={{102,140},{-18,90}},
                lineColor={0,0,0},
                textString="T"),
              Line(
                points={{-12,60},{-12,-25}},
                color={0,0,0},
                thickness=0.5),
              Line(
                points={{12,60},{12,-24}},
                color={0,0,0},
                thickness=0.5),
              Line(points={{0,100},{0,50}}, color={0,0,127})}),
          Documentation(info="<html>
<p>
This component monitors the temperature of the medium in the flow
between fluid ports. The sensor does not influence the fluid. 
If the parameter <code>tau</code> is non-zero, then its output
is computed using a first order differential equation. 
Setting <code>tau=0</code> is <i>not</i> recommend. See
<a href=\"modelica://Buildings.Fluid.Sensors.UsersGuide\">
Buildings.Fluid.Sensors.UsersGuide</a> for an explanation.
</p>
</html>
",       revisions="<html>
<html>
<p>
<ul>
<li>
June 3, 2011 by Michael Wetter:<br>
Revised implementation to add dynamics in such a way that 
the time constant increases as the mass flow rate tends to zero.
This significantly improves the numerics.
</li>
<li>
February 26, 2010 by Michael Wetter:<br>
Set start attribute for temperature output. Prior to this change,
the output was 0 at initial time, which caused the plot of the output to 
use 0 Kelvin as the lower value of the ordinate.
</li>
</ul>
</html>"),
      revisions="<html>
<ul>
<li>
September 10, 2008, by Michael Wetter:<br>
First implementation.
Implementation is based on 
<a href=\"modelica://Buildings.Fluid.Sensors.Temperature\">Buildings.Fluid.Sensors.Temperature</a>.
</li>
</ul>
</html>");
      end TemperatureTwoPort;

      model VolumeFlowRate "Ideal sensor for volume flow rate"
        extends Buildings.Fluid.Sensors.BaseClasses.PartialDynamicFlowSensor(tau=0);
        extends Modelica.Icons.RotationalSensor;
        Modelica.Blocks.Interfaces.RealOutput V_flow(final quantity="VolumeFlowRate",
                                                     final unit="m3/s")
        "Volume flow rate from port_a to port_b"
          annotation (Placement(transformation(
              origin={0,110},
              extent={{10,-10},{-10,10}},
              rotation=270)));
        parameter Medium.Density
          d_start=Medium.density(Medium.setState_pTX(p_start, T_start, X_start))
        "Initial or guess value of density"
          annotation (Dialog(group="Initialization"));
        parameter Modelica.SIunits.Temperature T_start=Medium.T_default
        "Temperature used to compute d_start"
          annotation (Dialog(group="Initialization"));
        parameter Modelica.SIunits.Pressure p_start=Medium.p_default
        "Pressure used to compute d_start"
          annotation (Dialog(group="Initialization"));
        parameter Modelica.SIunits.MassFraction X_start[Medium.nX]=Medium.X_default
        "Mass fraction used to compute d_start"
          annotation (Dialog(group="Initialization"));
        Medium.Density dMed(start=d_start)
        "Medium temperature to which the sensor is exposed";
    protected
        Medium.Density d_a_inflow(start=d_start)
        "Density of inflowing fluid at port_a";
        Medium.Density d_b_inflow(start=d_start)
        "Density of inflowing fluid at port_b or rho_a_inflow, if uni-directional flow";
        Medium.Density d(start=d_start) "Density of the passing fluid";
      initial equation
        if dynamic then
          if initType == Modelica.Blocks.Types.Init.SteadyState then
            der(d) = 0;
           elseif initType == Modelica.Blocks.Types.Init.InitialState or
                 initType == Modelica.Blocks.Types.Init.InitialOutput then
            d = d_start;
          end if;
        end if;
      equation
        if allowFlowReversal then
           d_a_inflow = Medium.density(Medium.setState_phX(port_b.p, port_b.h_outflow, port_b.Xi_outflow));
           d_b_inflow = Medium.density(Medium.setState_phX(port_a.p, port_a.h_outflow, port_a.Xi_outflow));
           dMed = Modelica.Fluid.Utilities.regStep(port_a.m_flow, d_a_inflow, d_b_inflow, m_flow_small);
        else
           dMed = Medium.density(Medium.setState_phX(port_b.p, port_b.h_outflow, port_b.Xi_outflow));
           d_a_inflow = dMed;
           d_b_inflow = dMed;
        end if;
        // Output signal of density sensor that is used to compute
        // the volume flow rate
        if dynamic then
          der(d) = (dMed-d)*k/tau;
        else
          d = dMed;
        end if;
        // Volume flow rate
        V_flow = port_a.m_flow/d;
      annotation (defaultComponentName="senVolFlo",
        Diagram(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{
                  100,100}}), graphics),
        Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
              graphics={
              Text(
                extent={{160,120},{0,90}},
                lineColor={0,0,0},
                textString="V_flow"),
              Line(points={{0,100},{0,70}}, color={0,0,127}),
              Line(points={{-100,0},{-70,0}}, color={0,128,255}),
              Line(points={{70,0},{100,0}}, color={0,128,255})}),
        Documentation(info="<html>
<p>
This component monitors the volume flow rate flowing from port_a to port_b. 
The sensor is ideal, i.e. it does not influence the fluid.
If the parameter <code>tau</code> is non-zero, then the measured
density that is used to convert the mass flow rate into
volumetric flow rate is computed using a first order differential equation. 
See <a href=\"modelica://Buildings.Fluid.Sensors.UsersGuide\">
Buildings.Fluid.Sensors.UsersGuide</a> for an explanation.
</p>
</html>
",       revisions="<html>
<html>
<p>
<ul>
<li>
June 3, 2011 by Michael Wetter:<br>
Revised implementation to add dynamics in such a way that 
the time constant increases as the mass flow rate tends to zero.
This significantly improves the numerics.
</li>
<li>
September 29, 2009, by Michael Wetter:<br>
First implementation.
Implementation is based on <code>Modelica.Fluid</code>.
</li>
</ul>
</html>"));
      end VolumeFlowRate;

      package BaseClasses
      "Package with base classes for Buildings.Fluid.Sensors"
        extends Modelica.Icons.BasesPackage;

        partial model PartialDynamicFlowSensor
        "Partial component to model sensors that measure flow properties using a dynamic model"
          extends PartialFlowSensor;

          parameter Modelica.SIunits.Time tau(min=0) = 1
          "Time constant at nominal flow rate"   annotation (Evaluate=true);
          parameter Modelica.Blocks.Types.Init initType = Modelica.Blocks.Types.Init.NoInit
          "Type of initialization (InitialState and InitialOutput are identical)"
             annotation(Evaluate=true, Dialog(group="Initialization"));
      protected
          Real k(start=1)
          "Gain to take flow rate into account for sensor time constant";
          final parameter Boolean dynamic = tau > 1E-10 or tau < -1E-10
          "Flag, true if the sensor is a dynamic sensor";
          Real mNor_flow "Normalized mass flow rate";
        equation
          if dynamic then
            mNor_flow = port_a.m_flow/m_flow_nominal;
            k = Modelica.Fluid.Utilities.regStep(x=port_a.m_flow,
                                                 y1= mNor_flow,
                                                 y2=-mNor_flow,
                                                 x_small=m_flow_small);
          else
            mNor_flow = 1;
            k = 1;
          end if;
          annotation (Icon(graphics={
                Line(visible=(tau <> 0),
                points={{52,60},{58,74},{66,86},{76,92},{88,96},{98,96}}, color={0,
                      0,127})}), Documentation(info="<html>
<p>
Partial component to model a sensor that measures any intensive properties
of a flow, e.g., to get temperature or density in the flow
between fluid connectors.</p>
<p>
The sensor computes a gain that is zero at zero mass flow rate.
This avoids fast transients if the flow is close to zero, thereby
improving the numerical efficiency.
</p>
</html>",         revisions="<html>
<ul>
<li>
July 7, 2011, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end PartialDynamicFlowSensor;

        partial model PartialFlowSensor
        "Partial component to model sensors that measure flow properties"
          extends Modelica.Fluid.Interfaces.PartialTwoPort;
          parameter Medium.MassFlowRate m_flow_nominal(min=0)
          "Nominal mass flow rate, used for regularization near zero flow"
            annotation(Dialog(group = "Nominal condition"));
          parameter Medium.MassFlowRate m_flow_small(min=0) = 1E-4*m_flow_nominal
          "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required)"
            annotation(Dialog(group="Advanced"));
        equation
          // mass balance
          0 = port_a.m_flow + port_b.m_flow;
          // momentum equation (no pressure loss)
          port_a.p = port_b.p;
          // isenthalpic state transformation (no storage and no loss of energy)
          port_a.h_outflow = inStream(port_b.h_outflow);
          port_b.h_outflow = inStream(port_a.h_outflow);
          port_a.Xi_outflow = inStream(port_b.Xi_outflow);
          port_b.Xi_outflow = inStream(port_a.Xi_outflow);
          port_a.C_outflow = inStream(port_b.C_outflow);
          port_b.C_outflow = inStream(port_a.C_outflow);
          annotation (Documentation(info="<html>
<p>
Partial component to model a sensor.
The sensor is ideal. It does not influence mass, energy,
species or substance balance, and it has no flow friction.
</p>
</html>",
        revisions="<html>
<ul>
<li>
February 12, 2011, by Michael Wetter:<br>
First implementation.
Implementation is based on <code>Modelica.Fluid</code>.
</li>
</ul>
</html>"),  Diagram(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-100,-100},{100,100}},
                grid={1,1}), graphics),
            Icon(graphics));
        end PartialFlowSensor;
      annotation (preferedView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Fluid.Sensors\">Buildings.Fluid.Sensors</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferedView="info",
    Documentation(info="<html>
<p align = justify>
Package <code>Sensors</code> consists of idealized sensor components that
provide variables of a medium model and/or fluid ports as
output signals. These signals can be, e.g., further processed
with components of the 
<a href=\"modelica://Modelica.Blocks\">
Modelica.Blocks</a> 
library.
Also more realistic sensor models can be built, by further
processing (e.g., by attaching block 
<a href=\"modelica://Modelica.Blocks.Continuous.FirstOrder\">
Modelica.Blocks.Continuous.FirstOrder</a> to
model the time constant of the sensor).
</p>
</html>", revisions="<html>
<ul>
<li><i>22 Dec 2008</i>
    by R&uuml;diger Franke
    <ul>
    <li>flow sensors based on Modelica.Fluid.Interfaces.PartialTwoPort</li>
    <li>adapted documentation to stream connectors, i.e. less need for two port sensors</li>
    </ul>
<li><i>4 Dec 2008</i>
    by Michael Wetter<br>
       included sensors for trace substance</li>
<li><i>31 Oct 2007</i>
    by Carsten Heinrich<br>
       updated sensor models, included one and two port sensors for thermodynamic state variables</li>
</ul>
</html>"));
    end Sensors;

    package Sources "Package with boundary condition models"
      extends Modelica.Icons.SourcesPackage;

      model FixedBoundary "Boundary source component"
        extends Modelica.Fluid.Sources.BaseClasses.PartialSource;
        parameter Boolean use_p=true "select p or d"
          annotation (Evaluate = true,
                      Dialog(group = "Boundary pressure or Boundary density"));
        parameter Medium.AbsolutePressure p=Medium.p_default
        "Boundary pressure"
          annotation (Dialog(group = "Boundary pressure or Boundary density",
                             enable = use_p));
        parameter Medium.Density d=Medium.density_pTX(Medium.p_default, Medium.T_default, Medium.X_default)
        "Boundary density"
          annotation (Dialog(group = "Boundary pressure or Boundary density",
                             enable=not use_p));
        parameter Boolean use_T=true "select T or h"
          annotation (Evaluate = true,
                      Dialog(group = "Boundary temperature or Boundary specific enthalpy"));
        parameter Medium.Temperature T=Medium.T_default "Boundary temperature"
          annotation (Dialog(group = "Boundary temperature or Boundary specific enthalpy",
                             enable = use_T));
        parameter Medium.SpecificEnthalpy h=Medium.h_default
        "Boundary specific enthalpy"
          annotation (Dialog(group="Boundary temperature or Boundary specific enthalpy",
                      enable = not use_T));
        parameter Medium.MassFraction X[Medium.nX](
             quantity=Medium.substanceNames)=Medium.X_default
        "Boundary mass fractions m_i/m"
          annotation (Dialog(group = "Only for multi-substance flow", enable=Medium.nXi > 0));

        parameter Medium.ExtraProperty C[Medium.nC](
             quantity=Medium.extraPropertiesNames)=fill(0, Medium.nC)
        "Boundary trace substances"
          annotation (Dialog(group = "Only for trace-substance flow", enable=Medium.nC > 0));

      equation
        Modelica.Fluid.Utilities.checkBoundary(Medium.mediumName, Medium.substanceNames,
                                              Medium.singleState, use_p, X,
                                              "FixedBoundary");
        if use_p or Medium.singleState then
          medium.p = p;
        else
          medium.d = d;
        end if;
        if use_T then
          medium.T = T;
        else
          medium.h = h;
        end if;

        medium.Xi = X[1:Medium.nXi];

        ports.C_outflow = fill(C, nPorts);
        annotation (defaultComponentName="boundary",
          Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-100,-100},{100,100}},
              grid={2,2}), graphics={Ellipse(
                extent={{-100,100},{100,-100}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Sphere,
                fillColor={0,127,255}), Text(
                extent={{-150,110},{150,150}},
                textString="%name",
                lineColor={0,0,255})}),
          Documentation(info="<html>
<p>
This model defines constant values for boundary conditions:
</p>
<ul>
<li> Boundary pressure or boundary density.</li>
<li> Boundary temperature or boundary specific enthalpy.</li>
<li> Boundary composition (only for multi-substance or trace-substance flow).</li>
</ul>
<p>
Note, that boundary temperature, density, specific enthalpy,
mass fractions and trace substances have only an effect if the mass flow
is from the Boundary into the port. If mass is flowing from
the port into the boundary, the boundary definitions,
with exception of boundary pressure, do not have an effect.
</p>
</html>",
      revisions="<html>
<ul>
<li>
September 29, 2009, by Michael Wetter:<br>
First implementation.
Implementation is based on <code>Modelica.Fluid</code>.
</li>
</ul>
</html>"));
      end FixedBoundary;

      model Outside
      "Boundary that takes weather data, and optionally trace substances, as an input"
        extends Buildings.Fluid.Sources.BaseClasses.Outside;

      equation
        connect(weaBus.pAtm, p_in_internal);
        connect(weaBus.TDryBul, T_in_internal);
        annotation (defaultComponentName="out",
          Documentation(info="<html>
<p>
This model describes boundary conditions for
pressure, enthalpy, and species concentration that can be obtained 
from weather data. 
</p>
<p>
To use this model, connect weather data from
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData.ReaderTMY3\">
Buildings.BoundaryConditions.WeatherData.ReaderTMY3</a> to the port
<code>weaBus</code> of this model. 
This will cause the medium of this model to be
at the pressure that is obtained from the weather file, and any flow that
leaves this model to be at the temperature and humidity that are obtained
from the weather data.
</p>
<p>If the parameter <code>use_C_in</code> is <code>false</code> (default option), 
the <code>C</code> parameter
is used as the trace substance for flow that leaves the component, and the 
<code>C_in</code> input connector is disabled; if <code>use_C_in</code> is <code>true</code>, 
then the <code>C</code> parameter is ignored, and the value provided by the input connector is used instead.</p> 
<p>
Note that boundary temperature,
mass fractions and trace substances have only an effect if the mass flow
is from the boundary into the port. If mass is flowing from
the port into the boundary, the boundary definitions,
with exception of boundary pressure, do not have an effect.
</p>
</html>",
      revisions="<html>
<ul>
<li>
October 26, 2011 by Michael Wetter:<br>
Introduced new base class to allow implementation of wind pressure for natural ventilation.
</li>
<li>
April 27, 2011 by Michael Wetter:<br>
Revised implementation to allow medium model that do not have water vapor.
</li>
<li>
Feb. 9, 2011 by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),Diagram(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-100,-100},{100,100}},
              grid={2,2}), graphics));
      end Outside;

      model Outside_CpLowRise
      "Boundary that takes weather data as an input and computes wind pressure for low-rise buildings"
        extends Buildings.Fluid.Sources.BaseClasses.Outside;

        parameter Real Cp0(min=0, max=1) = 0.6
        "Wind pressure coefficient for wind normal to wall";
        parameter Real s(min=0)
        "Side ratio, s=length of this wall/length of adjacent wall";
        parameter Modelica.SIunits.Angle azi
        "Surface azimuth (South:0, West:pi/2)"
          annotation (choicesAllMatching=true);

        Modelica.SIunits.Angle alpha "Wind incidence angle (0: normal to wall)";
        Real CpAct "Actual wind pressure coefficient";
        Modelica.SIunits.Pressure pWin(displayUnit="Pa")
        "Change in pressure due to wind force";
    protected
        Modelica.Blocks.Interfaces.RealInput pWea(min=0, nominal=1E5, unit="Pa")
        "Pressure from weather bus";
        Modelica.Blocks.Interfaces.RealInput vWin(unit="m/s")
        "Wind speed from weather bus";
        Modelica.Blocks.Interfaces.RealOutput pTot(min=0, nominal=1E5, unit="Pa")
        "Sum of atmospheric pressure and wind pressure";
        final parameter Real G = Modelica.Math.log(s)
        "Natural logarithm of side ratio";

        Modelica.Blocks.Interfaces.RealInput winDir(unit="rad")
        "Wind direction from weather bus";
        Modelica.SIunits.Angle surOut = azi-Modelica.Constants.pi
        "Angle of surface that is used to compute angle of attack of wind";
      equation
        alpha = winDir-surOut;
        CpAct = Buildings.Airflow.Multizone.BaseClasses.windPressureLowRise(
                  Cp0=Cp0, incAng=alpha, G=G);
        pWin = 0.5*CpAct*medium.d*vWin*vWin;
        pTot = pWea + pWin;

        connect(weaBus.winDir, winDir);
        connect(weaBus.winSpe, vWin);
        connect(weaBus.pAtm, pWea);
        connect(p_in_internal, pTot);
        connect(weaBus.TDryBul, T_in_internal);
        annotation (defaultComponentName="out",
          Documentation(info="<html>
<p>
This model describes boundary conditions for
pressure, enthalpy, and species concentration that can be obtained 
from weather data. The model is identical to
<a href=\"modelica://Buildings.Fluid.Sources.Outside\">
Buildings.Fluid.Sources.Outside</a>,
except that it adds the wind pressure to the 
pressure at the fluid port <code>ports</code>.
The correlation that is used to compute the wind pressure is based
on Swami and Chandra (1987) and valid for low-rise buildings 
with rectangular shape.
The same correlation is also implemented in CONTAM (Persily and Ivy, 2001).
For other buildings, the model 
<a href=\"modelica://Buildings.Fluid.Sources.Outside_Cp\">
Buildings.Fluid.Sources.Outside_Cp</a> should be used that takes
the wind pressure coefficient as an input or parameter.
</p>
<p>
The wind pressure coefficient is computed based on the 
side ratio of the walls, which is defined as
</p>
<p align=\"center\" style=\"font-style:italic;\">
s = x &frasl; y
</p>
<p>
where <i>x</i> is the length of the wall that will be connected to 
this model, and <i>y</i> is the length of the adjacent wall.
The wind direction is computed relative to the azimuth of this surface,
which is equal to the parameter <code>azi</code>.
The surface azimuth is defined in 
<a href=\"modelica://Buildings.HeatTransfer.Types.Azimuth\">
Buildings.HeatTransfer.Types.Azimuth</a>.
For example, if an exterior wall is South oriented, i.e., its outside-facing
surface is towards South, use 
<code>Buildings.HeatTransfer.Types.Azimuth.S</code>.
</p>
<p>
Based on the surface azimuth, the wind direction and the side ratio
of the walls, the model computes how much the wind pressure
is attenuated compared to the reference wind pressure <code>Cp0</code>.
The reference wind pressure <code>Cp0</code> is a user-defined parameter,
and must be equal to the wind pressure at zero wind incidence angle.
Swami and Chandra (1987) recommend <i>C<sub>p0</sub> = 0.6</i> for
all low-rise buildings as this represents the average of 
various values reported in the literature.
The computation of the actual wind pressure coefficient <i>C<sub>p</sub></i>
is explained in the function
<a href=\"modelica://Buildings.Airflow.Multizone.BaseClasses.windPressureLowRise\">
Buildings.Airflow.Multizone.BaseClasses.windPressureLowRise</a>
that is called by this model.
<p>
The pressure <i>p</i> at the port <code>ports</code> is computed as
</p>
<p align=\"center\" style=\"font-style:italic;\">
  p = p<sub>w</sub> + C<sub>p</sub> 1 &frasl; 2 v<sup>2</sup> &rho;,
</p>
<p>
where
<i>p<sub>w</sub></i> is the atmospheric pressure from the weather bus,
<i>v</i> is the wind speed from the weather bus, and
<i>&rho;</i> is the fluid density.
</p>
<p>
<h4>References</h4>
<p>
<ul>
<li>
Muthusamy V. Swami and
Subrato Chandra.
<i>
<a href=\"http://www.fsec.ucf.edu/en/publications/pdf/FSEC-CR-163-86.pdf\">
Procedures for
Calculating Natural
Ventilation Airflow
Rates in Buildings.</a></i>
Florida Solar Energy Center, FSEC-CR-163-86. March, 1987.
Cape Canaveral, Florida.
</li>
<li>
Andrew K. Persily and Elizabeth M. Ivy.
<i>
<a href=\"www.bfrl.nist.gov/IAQanalysis/docs/NISTIR6585.pdf\">
Input Data for Multizone Airflow and IAQ Analysis.</a></i>
NIST, NISTIR 6585.
January, 2001.
Gaithersburg, MD.
</li>
</ol>
</p>
</html>",
      revisions="<html>
<ul>
<li>
October 26, 2011 by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),Icon(graphics={Text(
                visible=use_Cp_in,
                extent={{-140,92},{-92,62}},
                lineColor={0,0,255},
                textString="C_p"),
                Text(
                visible=use_C_in,
                extent={{-154,-28},{-102,-62}},
                lineColor={0,0,255},
                textString="C"),
              Text(
                extent={{-28,22},{28,-22}},
                lineColor={255,255,255},
                textString="Cp")}));
      end Outside_CpLowRise;

      package BaseClasses
      "Package with base classes for Buildings.Fluid.Sources"
        extends Modelica.Icons.BasesPackage;

        partial model Outside
        "Boundary that takes weather data, and optionally trace substances, as an input"
          extends Modelica.Fluid.Sources.BaseClasses.PartialSource;
          parameter Boolean use_C_in = false
          "Get the trace substances from the input connector"
            annotation(Evaluate=true, HideResult=true);
          parameter Medium.ExtraProperty C[Medium.nC](
               quantity=Medium.extraPropertiesNames)=fill(0, Medium.nC)
          "Fixed values of trace substances"
            annotation (Evaluate=true,
                        Dialog(enable = (not use_C_in) and Medium.nC > 0));
          Modelica.Blocks.Interfaces.RealInput C_in[Medium.nC] if use_C_in
          "Prescribed boundary trace substances"
            annotation (Placement(transformation(extent={{-140,-100},{-100,-60}},
                  rotation=0)));
          Buildings.BoundaryConditions.WeatherData.Bus weaBus
          "Bus with weather data"
            annotation (Placement(transformation(extent={{-110,-10},{-90,10}}),
                iconTransformation(extent={{-120,-18},{-80,22}})));
      protected
          final parameter Boolean singleSubstance = ( Medium.nX == 1)
          "True if single substance medium";
          Buildings.Utilities.Psychrometrics.X_pTphi x_pTphi(
            redeclare package Medium = Medium) if
               not singleSubstance "Block to compute water vapor concentration";
          Modelica.Blocks.Interfaces.RealInput X_in_internal[Medium.nX]
          "Needed to connect to conditional connector";
          Modelica.Blocks.Interfaces.RealInput T_in_internal
          "Needed to connect to conditional connector";
          Modelica.Blocks.Interfaces.RealInput p_in_internal
          "Needed to connect to conditional connector";
          Modelica.Blocks.Interfaces.RealInput C_in_internal[Medium.nC]
          "Needed to connect to conditional connector";

        equation
          // Check medium properties
          Modelica.Fluid.Utilities.checkBoundary(Medium.mediumName, Medium.substanceNames,
            Medium.singleState, true, medium.X, "Boundary_pT");

          // Conditional connectors for trace substances
          connect(C_in, C_in_internal);
          if not use_C_in then
            C_in_internal = C;
          end if;
          // Connections to input. This is required to obtain the data from
          // the weather bus in case that the component x_pTphi is conditionally removed
          connect(weaBus.TDryBul, T_in_internal);

          // Connections to compute species concentration
          connect(p_in_internal, x_pTphi.p_in);
          connect(T_in_internal, x_pTphi.T);
          connect(weaBus.relHum, x_pTphi.phi);

          connect(X_in_internal, x_pTphi.X);
          if singleSubstance then
            X_in_internal = zeros(Medium.nX);
          end if;
          // Assign medium properties
          medium.p = p_in_internal;
          medium.T = T_in_internal;
          medium.Xi = X_in_internal[1:Medium.nXi];
          ports.C_outflow = fill(C_in_internal, nPorts);
          annotation (
            Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={2,2}), graphics={
                Ellipse(
                  extent={{-98,100},{102,-100}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  fillColor={0,127,255}),
                Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Line(
                  visible=use_C_in,
                  points={{-100,-80},{-60,-80}},
                  color={0,0,255}),
                Text(
                  visible=use_C_in,
                  extent={{-164,-90},{-62,-130}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  textString="C")}),
            Documentation(info="<html>
<p>
This is the base class for models that describes boundary conditions for
pressure, enthalpy, and species concentration that can be obtained 
from weather data, and that may be modified based on the wind pressure.
</p>
<p>If the parameter <code>use_C_in</code> is <code>false</code> (default option), 
the <code>C</code> parameter
is used as the trace substance for flow that leaves the component, and the 
<code>C_in</code> input connector is disabled; if <code>use_C_in</code> is <code>true</code>, 
then the <code>C</code> parameter is ignored, and the value provided by the input connector is used instead.</p> 
<p>
Note that boundary temperature,
mass fractions and trace substances have only an effect if the mass flow
is from the boundary into the port. If mass is flowing from
the port into the boundary, the boundary definitions,
with exception of boundary pressure, do not have an effect.
</p>
</html>",
        revisions="<html>
<ul>
<li>
October 26, 2011 by Michael Wetter:<br>
Introduced new base class to allow implementation of wind pressure for natural ventilation.
</li>
<li>
April 27, 2011 by Michael Wetter:<br>
Revised implementation to allow medium model that do not have water vapor.
</li>
<li>
Feb. 9, 2011 by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),  Diagram(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-100,-100},{100,100}},
                grid={2,2}), graphics));
        end Outside;
      annotation (preferedView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Fluid.Sources\">Buildings.Fluid.Sources</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferedView="info",
    Documentation(info="<html>
<p>
Package <b>Sources</b> contains generic sources for fluid connectors
to define fixed or prescribed ambient conditions.
</p>
</html>"));
    end Sources;

    package Types "Package with type definitions"

      type CvTypes = enumeration(
        OpPoint "flow coefficient defined by m_flow_nominal/sqrt(dp_nominal)",
        Kv "Kv (metric) flow coefficient",
        Cv "Cv (US) flow coefficient",
        Av "Av (metric) flow coefficient")
      "Enumeration to define the choice of valve flow coefficient"   annotation (
          Documentation(info="<html>
 
<p>
Enumeration to define the choice of valve flow coefficient
(to be selected via choices menu):
</p>
 
<table border=\"1\">
<tr><th>Enumeration</th>
    <th>Description</th></tr>
 
<tr><td>OpPoint</td>
    <td>flow coefficient defined by ratio m_flow_nominal/sqrt(dp_nominal)</td></tr>
 
<tr><td>Kv</td>
    <td>Kv (metric) flow coefficient</td></tr>
 
<tr><td>Cv</td>
    <td>Cv (US) flow coefficient</td></tr>
 
<tr><td>Av</td>
    <td>Av (metric) flow coefficient</td></tr>

</table>

<p>
The details of the coefficients are explained in the 
<a href=\"modelica://Modelica.Fluid.UsersGuide.ComponentDefinition.ValveCharacteristics\">
   Users Guide </a>.
</p>
 
</html>"));

      type HeatExchangerConfiguration = enumeration(
        ParallelFlow "Parallel flow",
        CounterFlow "Counter flow",
        CrossFlowUnmixed "Cross flow, both streams unmixed",
        CrossFlowStream1MixedStream2Unmixed
          "Cross flow, stream 1 mixed, stream 2 unmixed",
        CrossFlowStream1UnmixedStream2Mixed
          "Cross flow, stream 1 unmixed, stream 2 mixed")
      "Enumeration for heat exchanger construction"
      annotation(Documentation(info="<html>
 Enumeration that defines the heat exchanger construction.
</p>
<p>
The following heat exchanger configurations are available in this enumeration:
</p>
<table border=\"1\">
<tr><th>Enumeration</th><th>Description</th></tr>
<tr><td>ParallelFlow</td><td>Parallel flow</td></tr>
<tr><td>CounterFlow</td><td>Counter flow</td></tr>
<tr><td>CrossFlowUnmixed</td><td>Cross flow, both streams unmixed</td></tr>
<tr><td>CrossFlowStream1MixedStream2Unmixed</td><td>Cross flow, stream 1 mixed, stream 2 unmixed</td></tr>
<tr><td>CrossFlowStream1UnmixedStream2Mixed</td><td>Cross flow, stream 1 unmixed, stream 2 mixed</td></tr>
</table>
<p>
Note that for a given heat exchanger, the
 <code>HeatExchangerConfiguration</code> is fixed. However, if the capacity
 flow rates change, then the 
 <a href=\"modelica://Buildings.Fluid.Types.HeatExchangerFlowRegime>
 HeatExchangerFlowRegime</a> may change. For example,
 a counter flow heat exchanger has <code>HeatExchangerConfiguration=CounterFlow</code>,
 but the <a href=\"modelica://Buildings.Fluid.Types.HeatExchangerFlowRegime>
 HeatExchangerFlowRegime</a> can change to parallel flow if one of the two capacity flow rates reverts
 its direction.
 </p>
</html>", revisions=
              "<html>
<ul>
<li>
February 18, 2009, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));

      type HeatExchangerFlowRegime = enumeration(
        ParallelFlow "Parallel flow",
        CounterFlow "Counter flow",
        CrossFlowUnmixed "Cross flow, both streams unmixed",
        CrossFlowCMinMixedCMaxUnmixed "Cross flow, CMin mixed,   CMax unmixed",

        CrossFlowCMinUnmixedCMaxMixed "Cross flow, CMin unmixed, CMax mixed")
      "Enumeration for heat exchanger flow configuration"
      annotation(Documentation(info="<html>
<p>
 Enumeration to define the heat exchanger flow regime.
</p>
<p>
This enumeration defines for the current capacity flow rate the kind of
heat transfer relation that will be used to compute the relation between
effectiveness and Number of Transfer Units.
</p>
<p>
The following heat exchanger flow regimes are available in this enumeration:
</p>
<table border=\"1\">
<tr><th>Enumeration</th><th>Description</th></tr>
<tr><td>ParallelFlow</td><td>Parallel flow</td></tr>
<tr><td>CounterFlow</td><td>Counter flow</td></tr>
<tr><td>CrossFlowUnmixed</td><td>Cross flow, both streams unmixed</td></tr>
<tr><td>CrossFlowCMinMixedCMaxUnmixed</td><td>Cross flow, CMin mixed,   CMax unmixed</td></tr>
<tr><td>CrossFlowCMinUnmixedCMaxMixed</td><td>Cross flow, CMin unmixed, CMax mixed</td></tr>
</table>
</html>"));
    annotation (preferedView="info", Documentation(info="<html>
This package contains type definitions.
</html>"));
    end Types;

    package BaseClasses "Package with base classes for Buildings.Fluid"
      extends Modelica.Icons.BasesPackage;

      package FlowModels "Flow models for pressure drop calculations"
        extends Modelica.Icons.BasesPackage;

        function basicFlowFunction_dp "Basic class for flow models"

          input Modelica.SIunits.Pressure dp(displayUnit="Pa")
          "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
          input Real k(min=0, unit="")
          "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
          input Modelica.SIunits.MassFlowRate m_flow_turbulent(min=0)
          "Mass flow rate";
          output Modelica.SIunits.MassFlowRate m_flow
          "Mass flow rate in design flow direction";
      protected
          Modelica.SIunits.Pressure dp_turbulent(displayUnit="Pa")
          "Turbulent flow if |dp| >= dp_small, not a parameter because k can be a function of time";
      protected
         Real kSqu(unit="kg.m") "Flow coefficient, kSqu=k^2=m_flow^2/|dp|";
        algorithm
         kSqu:=k*k;
         dp_turbulent :=m_flow_turbulent^2/kSqu;
         m_flow :=Modelica.Fluid.Utilities.regRoot2(x=dp, x_small=dp_turbulent, k1=kSqu, k2=kSqu);

        annotation(LateInline=true,
                   inverse(dp=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(m_flow=m_flow, k=k, m_flow_turbulent=m_flow_turbulent)),
                   smoothOrder=2,
                   Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
                    {100,100}}), graphics={Line(
                  points={{-80,-40},{-80,60},{80,-40},{80,60}},
                  color={0,0,255},
                  smooth=Smooth.None,
                  thickness=1), Text(
                  extent={{-40,-40},{40,-80}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  fillColor={232,0,0},
                  textString="%name")}),
        Documentation(info="<html>
<p>
Function that computes the pressure drop of flow elements as
<p align=\"center\" style=\"font-style:italic;\">
  m = sign(&Delta;p) k  &radic;<span style=\"text-decoration:overline;\">&nbsp;&Delta;p &nbsp;</span>
</p>
with regularization near the origin.
Therefore, the flow coefficient is
<p align=\"center\" style=\"font-style:italic;\">
  k = m &frasl; &radic;<span style=\"text-decoration:overline;\">&nbsp;&Delta;p &nbsp;</span> 
</p>
The input <code>m_flow_turbulent</code> determines the location of the regularization.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 10, 2011, by Michael Wetter:<br>
Removed <code>if-then</code> optimization that set <code>m_flow=0</code> if <code>dp=0</code>,
as this causes the derivative to be discontinuous at <code>dp=0</code>.
</li>
<li>
August 4, 2011, by Michael Wetter:<br>
Implemented linearized model in this model instead of 
in the functions
<a href=\"modelica://Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">
Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp</a>
and
<a href=\"modelica://Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow\">
Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow</a>. 
With the previous implementation, 
the symbolic processor may not rearrange the equations, which can lead 
to coupled equations instead of an explicit solution.
</li>
<li>
March 29, 2010 by Michael Wetter:<br>
Changed implementation to allow <code>k=0</code>, which is
the case for a closed valve with no leakage
</li>
</ul>
</html>"),
        revisions="<html>
<ul>
<li>
August 4, 2011, by Michael Wetter:<br>
Removed option to use a linear function. The linear implementation is now done
in models that call this function. With the previous implementation, 
the symbolic processor may not rearrange the equations, which can lead 
to coupled equations instead of an explicit solution.
</li>
<li>
April 13, 2009, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>");
        end basicFlowFunction_dp;

        function basicFlowFunction_m_flow "Basic class for flow models"

          input Modelica.SIunits.MassFlowRate m_flow
          "Mass flow rate in design flow direction";
          input Real k(unit="")
          "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
          input Modelica.SIunits.MassFlowRate m_flow_turbulent(min=0)
          "Mass flow rate";
          output Modelica.SIunits.Pressure dp(displayUnit="Pa")
          "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
      protected
         Real kSquInv(unit="1/(kg.m)") "Flow coefficient";
        algorithm
         kSquInv:=1/k^2;
         dp :=Modelica.Fluid.Utilities.regSquare2(x=m_flow, x_small=m_flow_turbulent, k1=kSquInv, k2=kSquInv);

         annotation (LateInline=true,
                     inverse(m_flow=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(dp=dp, k=k, m_flow_turbulent=m_flow_turbulent)),
                     smoothOrder=2,
                     Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}), graphics={Line(
                  points={{-80,-40},{-80,60},{80,-40},{80,60}},
                  color={0,0,255},
                  smooth=Smooth.None,
                  thickness=1), Text(
                  extent={{-40,-40},{40,-80}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  fillColor={232,0,0},
                  textString="%name")}),
        Documentation(info="<html>
<p>
Function that computes the pressure drop of flow elements as
<p align=\"center\" style=\"font-style:italic;\">
  &Delta;p = sign(m) (m &frasl; k)<sup>2</sup> 
</p>
with regularization near the origin.
Therefore, the flow coefficient is
<p align=\"center\" style=\"font-style:italic;\">
  k = m &frasl; &radic;<span style=\"text-decoration:overline;\">&nbsp;&Delta;p &nbsp;</span> 
</p>
The input <code>m_flow_turbulent</code> determines the location of the regularization.
</p>
</html>"),
        revisions="<html>
<ul>
<li>
August 10, 2011, by Michael Wetter:<br>
Removed <code>if-then</code> optimization that set <code>dp=0</code> if <code>m_flow=0</code>,
as this causes the derivative to be discontinuous at <code>m_flow=0</code>.
</li>
<li>
August 4, 2011, by Michael Wetter:<br>
Removed option to use a linear function. The linear implementation is now done
in models that call this function. With the previous implementation, 
the symbolic processor may not rearrange the equations, which can lead 
to coupled equations instead of an explicit solution.
</li>
<li>
April 13, 2009, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>");
        end basicFlowFunction_m_flow;
      annotation (Documentation(info="<html>
This package contains a basic flow model that is used by the 
various models that compute pressure drop.
Because the density does not change signficantly in heating,
ventilation and air conditioning systems for buildings,
this model computes the pressure drop based on the mass flow
rate and not the volume flow rate. This typically leads to simpler
equations because it does not require
the mass density, which changes when the flow is reversed. 
Although, for conceptual design of building energy system, there is
in general not enough information available that would warrant a more
detailed pressure drop calculation.
If a more detailed computation of the flow resistance is needed,
then a user can use models from the 
<code>Modelica.Fluid</code> library.
</html>",       revisions="<html>
<ul>
<li>
April 10, 2009 by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
      end FlowModels;

      partial model PartialResistance
      "Partial model for a hydraulic resistance"
          extends Buildings.Fluid.Interfaces.PartialTwoPortInterface(
           show_T=false, show_V_flow=false,
           m_flow(start=0, nominal=m_flow_nominal_pos),
           dp(start=0, nominal=dp_nominal_pos));

        parameter Boolean from_dp = false
        "= true, use m_flow = f(dp) else dp = f(m_flow)"
          annotation (Evaluate=true, Dialog(tab="Advanced"));
        parameter Modelica.SIunits.MassFlowRate m_flow_nominal
        "Nominal mass flow rate"
          annotation(Dialog(group = "Nominal condition"));
        parameter Modelica.SIunits.Pressure dp_nominal(displayUnit="Pa")
        "Pressure drop at nominal mass flow rate"                                  annotation(Dialog(group = "Nominal condition"));
        parameter Boolean homotopyInitialization = true
        "= true, use homotopy method"
          annotation(Evaluate=true, Dialog(tab="Advanced"));
        parameter Boolean linearized = false
        "= true, use linear relation between m_flow and dp for any flow rate"
          annotation(Evaluate=true, Dialog(tab="Advanced"));

        Real k(unit="")
        "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
        Modelica.SIunits.MassFlowRate m_flow_turbulent(min=0)
        "Turbulent flow if |m_flow| >= m_flow_turbulent, not a parameter because k can be a function of time"
           annotation(Evaluate=true);

    protected
        parameter Medium.ThermodynamicState sta0=
           Medium.setState_pTX(T=Medium.T_default, p=Medium.p_default, X=Medium.X_default);
        parameter Modelica.SIunits.DynamicViscosity eta_nominal=Medium.dynamicViscosity(sta0)
        "Dynamic viscosity, used to compute transition to turbulent flow regime";
        final parameter Boolean computeFlowResistance=(dp_nominal_pos > Modelica.Constants.eps)
        "Flag to enable/disable computation of flow resistance"
         annotation(Evaluate=true);
    protected
        final parameter Modelica.SIunits.MassFlowRate m_flow_nominal_pos = abs(m_flow_nominal)
        "Absolute value of nominal flow rate";
        final parameter Modelica.SIunits.Pressure dp_nominal_pos = abs(dp_nominal)
        "Absolute value of nominal pressure";
      initial equation
        if computeFlowResistance then
          assert(m_flow_turbulent > 0, "m_flow_turbulent must be bigger than zero.");
        end if;
      equation
        // Pressure drop calculation
        if computeFlowResistance then
          if linearized then
            m_flow*m_flow_nominal_pos = k^2*dp;
          else
            if homotopyInitialization then
              if from_dp then
                m_flow=homotopy(actual=FlowModels.basicFlowFunction_dp(dp=dp, k=k,
                                         m_flow_turbulent=m_flow_turbulent),
                                         simplified=m_flow_nominal_pos*dp/dp_nominal_pos);
              else
                dp=homotopy(actual=FlowModels.basicFlowFunction_m_flow(m_flow=m_flow, k=k,
                                         m_flow_turbulent=m_flow_turbulent),
                          simplified=dp_nominal_pos*m_flow/m_flow_nominal_pos);
               end if;  // from_dp
            else // do not use homotopy
              if from_dp then
                m_flow=FlowModels.basicFlowFunction_dp(dp=dp, k=k, m_flow_turbulent=m_flow_turbulent);
              else
                dp=FlowModels.basicFlowFunction_m_flow(m_flow=m_flow, k=k, m_flow_turbulent=m_flow_turbulent);
              end if;  // from_dp
            end if; // homotopyInitialization
          end if; // linearized
        else // do not compute flow resistance
          dp = 0;
        end if;  // computeFlowResistance

        // Isenthalpic state transformation (no storage and no loss of energy)
        port_a.h_outflow = inStream(port_b.h_outflow);
        port_b.h_outflow = inStream(port_a.h_outflow);

        // Mass balance (no storage)
        port_a.m_flow + port_b.m_flow = 0;

        // Transport of substances
        port_a.Xi_outflow = inStream(port_b.Xi_outflow);
        port_b.Xi_outflow = inStream(port_a.Xi_outflow);

        port_a.C_outflow = inStream(port_b.C_outflow);
        port_b.C_outflow = inStream(port_a.C_outflow);

        annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                  -100},{100,100}}), graphics={
              Rectangle(
                extent={{-100,40},{100,-42}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Rectangle(
                extent={{-100,22},{100,-24}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={0,127,255}),
              Rectangle(
                visible=linearized,
                extent={{-100,22},{100,-24}},
                fillPattern=FillPattern.Backward,
                fillColor={0,128,255},
                pattern=LinePattern.None,
                lineColor={255,255,255})}),
                defaultComponentName="res",
      Documentation(info="<html>
<p>
Partial model for a flow resistance, possible with variable flow coefficient.
The pressure drop is computed by an instance of
<a href=\"modelica://Buildings.Fluid.BaseClasses.FlowModels.BasicFlowModel\">
Buildings.Fluid.BaseClasses.FlowModels.BasicFlowModel</a>,
i.e., using a regularized implementation of the equation
<p align=\"center\" style=\"font-style:italic;\">
  m = sign(&Delta;p) k  &radic;<span style=\"text-decoration:overline;\">&nbsp;&Delta;p &nbsp;</span>
</p>
</html>",       revisions="<html>
<ul>
<li>
August 5, 2011, by Michael Wetter:<br>
Moved linearized pressure drop equation from the function body to the equation
section. With the previous implementation, 
the symbolic processor may not rearrange the equations, which can lead 
to coupled equations instead of an explicit solution.
</li>
<li>
June 20, 2011 by Michael Wetter:<br>
Set start values for <code>m_flow</code> and <code>dp</code> to zero, since
most HVAC systems start at zero flow. With this change, the start values
appear in the GUI and can be set by the user.
</li>
<li>
April 2, 2011 by Michael Wetter:<br>
Added <code>m_flow_nominal_pos</code> and <code>dp_nominal_pos</code> to allow
providing negative nominal values which will be used, for example, to set start
values of flow splitters which may have negative flow rates and pressure drop
at the initial condition.
</li>
<li>
March 23, 2011 by Michael Wetter:<br>
Added homotopy operator.
</li>
<li>
March 30, 2010 by Michael Wetter:<br>
Changed base classes to allow easier initialization.
</li>
<li>
July 20, 2007 by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),
      revisions="<html>
<ul>
<li>
March 27, 2011, by Michael Wetter:<br>
Added <code>homotopy</code> operator.
</li>
<li>
April 13, 2009, by Michael Wetter:<br>
Extracted pressure drop computation and implemented it in the
new model
<a href=\"modelica://Buildings.Fluid.BaseClasses.FlowModels.BasicFlowModel\">
Buildings.Fluid.BaseClasses.FlowModels.BasicFlowModel</a>.
</li>
<li>
September 18, 2008, by Michael Wetter:<br>
Added equations for the mass balance of extra species flow,
i.e., <code>C</code> and <code>mC_flow</code>.
</li>
<li>
July 20, 2007 by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>");
      end PartialResistance;

      partial model PartialThreeWayResistance
      "Flow splitter with partial resistance model at each port"
        extends Buildings.Fluid.Interfaces.LumpedVolumeDeclarations;
        outer Modelica.Fluid.System system "System properties";

        Modelica.Fluid.Interfaces.FluidPort_a port_1(redeclare package Medium
          =   Medium, m_flow(min=if (portFlowDirection_1 == Modelica.Fluid.Types.PortFlowDirection.Entering) then
                      0.0 else -Modelica.Constants.inf, max=if (portFlowDirection_1
                 == Modelica.Fluid.Types.PortFlowDirection.Leaving) then 0.0 else Modelica.Constants.inf))
          annotation (Placement(transformation(extent={{-110,-10},{-90,10}},
                rotation=0)));
        Modelica.Fluid.Interfaces.FluidPort_b port_2(redeclare package Medium
          =   Medium, m_flow(min=if (portFlowDirection_2 == Modelica.Fluid.Types.PortFlowDirection.Entering) then
                      0.0 else -Modelica.Constants.inf, max=if (portFlowDirection_2
                 == Modelica.Fluid.Types.PortFlowDirection.Leaving) then 0.0 else Modelica.Constants.inf))
          annotation (Placement(transformation(extent={{90,-10},{110,10}}, rotation=
                 0)));
        Modelica.Fluid.Interfaces.FluidPort_a port_3(
          redeclare package Medium=Medium,
          m_flow(min=if (portFlowDirection_3==Modelica.Fluid.Types.PortFlowDirection.Entering) then 0.0 else -Modelica.Constants.inf,
          max=if (portFlowDirection_3==Modelica.Fluid.Types.PortFlowDirection.Leaving) then 0.0 else Modelica.Constants.inf))
          annotation (Placement(transformation(extent={{-10,-110},{10,-90}},
          rotation=0)));

        parameter Boolean from_dp = true
        "= true, use m_flow = f(dp) else dp = f(m_flow)"
          annotation (Evaluate=true, Dialog(tab="Advanced"));
        parameter Boolean homotopyInitialization = true
        "= true, use homotopy method"
          annotation(Evaluate=true, Dialog(tab="Advanced"));

        replaceable Buildings.Fluid.Interfaces.PartialTwoPortInterface res1(redeclare
          package Medium =   Medium, allowFlowReversal=true, homotopyInitialization=homotopyInitialization)
        "Partial model, to be replaced with a fluid component"
          annotation (Placement(transformation(extent={{-60,-10},{-40,10}}, rotation=
                  0)));
        replaceable Buildings.Fluid.Interfaces.PartialTwoPortInterface res2(redeclare
          package Medium =   Medium, allowFlowReversal=true, homotopyInitialization=homotopyInitialization)
        "Partial model, to be replaced with a fluid component"
          annotation (Placement(transformation(extent={{60,-10},{40,10}}, rotation=0)));
        replaceable Buildings.Fluid.Interfaces.PartialTwoPortInterface res3(redeclare
          package Medium =   Medium, allowFlowReversal=true, homotopyInitialization=homotopyInitialization)
        "Partial model, to be replaced with a fluid component"
          annotation (Placement(transformation(
              origin={0,-50},
              extent={{-10,10},{10,-10}},
              rotation=90)));

    protected
        parameter Modelica.Fluid.Types.PortFlowDirection portFlowDirection_1=Modelica.Fluid.Types.PortFlowDirection.Bidirectional
        "Flow direction for port_1"
         annotation(Dialog(tab="Advanced"));
        parameter Modelica.Fluid.Types.PortFlowDirection portFlowDirection_2=Modelica.Fluid.Types.PortFlowDirection.Bidirectional
        "Flow direction for port_2"
         annotation(Dialog(tab="Advanced"));
        parameter Modelica.Fluid.Types.PortFlowDirection portFlowDirection_3=Modelica.Fluid.Types.PortFlowDirection.Bidirectional
        "Flow direction for port_3"
         annotation(Dialog(tab="Advanced"));

    public
        Buildings.Fluid.Delays.DelayFirstOrder vol(
          redeclare final package Medium = Medium,
          final nPorts=3,
          final tau=tau,
          final m_flow_nominal=mDyn_flow_nominal,
          final energyDynamics=energyDynamics,
          final massDynamics=massDynamics,
          final p_start=p_start,
          final T_start=T_start,
          final X_start=X_start,
          final C_start=C_start,
          final allowFlowReversal=true,
          final prescribedHeatFlowRate=false) if
             dynamicBalance "Fluid volume to break algebraic loop"
          annotation (Placement(transformation(extent={{-10,0},{10,20}})));
        parameter Boolean dynamicBalance = true
        "Set to true to use a dynamic balance, which often leads to smaller systems of equations"
          annotation (Dialog(tab="Dynamics", group="Equations"));

        parameter Modelica.SIunits.Time tau=10
        "Time constant at nominal flow for dynamic energy and momentum balance"
          annotation (Dialog(tab="Dynamics", group="Nominal condition", enable=dynamicBalance));
        parameter Modelica.SIunits.MassFlowRate mDyn_flow_nominal
        "Nominal mass flow rate for dynamic momentum and energy balance"
          annotation (Dialog(tab="Dynamics", group="Equations", enable=dynamicBalance));

      equation
        connect(port_1, res1.port_a) annotation (Line(points={{-100,0},{-100,0},{-60,0}},
                                                                          color={0,
                127,255}));
        connect(res2.port_a, port_2) annotation (Line(points={{60,0},{60,0},{100,0}},
                                                                     color={0,127,255}));
        connect(res3.port_a, port_3) annotation (Line(points={{-6.12323e-016,-60},{
                -6.12323e-016,-79},{0,-79},{0,-100}},                      color={0,
                127,255}));
        connect(res1.port_b,vol. ports[1]) annotation (Line(
            points={{-40,0},{-30.6666,0},{-30.6666,5.55115e-017},{-21.3333,
                5.55115e-017},{-21.3333,0},{-2.66667,0}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(res2.port_b,vol. ports[2]) annotation (Line(
            points={{40,0},{30,0},{30,5.55115e-017},{20,5.55115e-017},{20,0},{
                2.22045e-016,0}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(res3.port_b,vol. ports[3]) annotation (Line(
            points={{6.12323e-016,-40},{2.66667,-40},{2.66667,0}},
            color={0,127,255},
            smooth=Smooth.None));
        if not dynamicBalance then
          connect(res1.port_b, res3.port_b) annotation (Line(
            points={{-40,0},{-20,0},{-20,-40},{6.12323e-016,-40}},
            color={0,127,255},
            smooth=Smooth.None));
          connect(res1.port_b, res2.port_b) annotation (Line(
            points={{-40,0},{-20,0},{-20,1.22125e-015},{0,1.22125e-015},{0,0},{40,0}},
            color={0,127,255},
            smooth=Smooth.None));
        end if;
        annotation (Diagram(coordinateSystem(preserveAspectRatio=true,  extent={{-100,
                  -100},{100,100}}),
                            graphics),
                             Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                  -100},{100,100}}),
                                  graphics),
           extent=[40,-10; 60,10],
          Documentation(info="<html>
<p>
Partial model for flow resistances with three ports such as a 
flow mixer/splitter or a three way valve.
</p>
<p>
If <code>dynamicBalance=true</code>, then at the junction of the three flows,
a mixing volume will be present. This will introduce a dynamic energy and momentum
balance, which often breaks algebraic loops. 
The time constant of the mixing volume is determined by the parameter <code>tau</code>.
</html>",       revisions="<html>
<ul>
<li>
March 23 2010, by Michael Wetter:<br>
Changed start values from <code>system.p_start</code> or (code <code>T_start</code>)
to <code>Medium.p_default</code>.
</li>
<li>
September 18, 2008 by Michael Wetter:<br>
Replaced splitter model with a fluid port since the 
splitter model in Modelica.Fluid 1.0 beta does not transport
<code>mC_flow</code>.
<li>
June 11, 2008 by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
      end PartialThreeWayResistance;
    annotation (preferedView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Fluid\">Buildings.Fluid</a>.
</p>
</html>"));
    end BaseClasses;

    package Interfaces "Package with interfaces for fluid models"
      extends Modelica.Icons.InterfacesPackage;

      model FourPort "Partial model with four ports"
        import Modelica.Constants;
        outer Modelica.Fluid.System system "System wide properties";

        replaceable package Medium1 =
            Modelica.Media.Interfaces.PartialMedium "Medium 1 in the component"
            annotation (choicesAllMatching = true);
        replaceable package Medium2 =
            Modelica.Media.Interfaces.PartialMedium "Medium 2 in the component"
            annotation (choicesAllMatching = true);

        parameter Boolean allowFlowReversal1 = system.allowFlowReversal
        "= true to allow flow reversal in medium 1, false restricts to design direction (port_a -> port_b)"
          annotation(Dialog(tab="Assumptions"), Evaluate=true);
        parameter Boolean allowFlowReversal2 = system.allowFlowReversal
        "= true to allow flow reversal in medium 2, false restricts to design direction (port_a -> port_b)"
          annotation(Dialog(tab="Assumptions"), Evaluate=true);

        parameter Modelica.SIunits.SpecificEnthalpy h_outflow_a1_start = Medium1.h_default
        "Start value for enthalpy flowing out of port a1"
          annotation (Dialog(tab="Advanced", group="Initialization"));

        parameter Modelica.SIunits.SpecificEnthalpy h_outflow_b1_start = Medium1.h_default
        "Start value for enthalpy flowing out of port b1"
          annotation (Dialog(tab="Advanced", group="Initialization"));

        parameter Modelica.SIunits.SpecificEnthalpy h_outflow_a2_start = Medium2.h_default
        "Start value for enthalpy flowing out of port a2"
          annotation (Dialog(tab="Advanced", group="Initialization"));

        parameter Modelica.SIunits.SpecificEnthalpy h_outflow_b2_start = Medium2.h_default
        "Start value for enthalpy flowing out of port b2"
          annotation (Dialog(tab="Advanced", group="Initialization"));

        Modelica.Fluid.Interfaces.FluidPort_a port_a1(
                                      redeclare package Medium = Medium1,
                           m_flow(min=if allowFlowReversal1 then -Constants.inf else 0),
                           h_outflow(nominal=1E5, start=h_outflow_a1_start),
                           Xi_outflow(nominal=0.01))
        "Fluid connector a1 (positive design flow direction is from port_a1 to port_b1)"
          annotation (Placement(transformation(extent={{-110,50},{-90,70}},
                  rotation=0)));
        Modelica.Fluid.Interfaces.FluidPort_b port_b1(
                                      redeclare package Medium = Medium1,
                           m_flow(max=if allowFlowReversal1 then +Constants.inf else 0),
                           h_outflow(nominal=1E5, start=h_outflow_b1_start),
                           Xi_outflow(nominal=0.01))
        "Fluid connector b1 (positive design flow direction is from port_a1 to port_b1)"
          annotation (Placement(transformation(extent={{110,50},{90,70}},  rotation=
                   0), iconTransformation(extent={{110,50},{90,70}})));

        Modelica.Fluid.Interfaces.FluidPort_a port_a2(
                                      redeclare package Medium = Medium2,
                           m_flow(min=if allowFlowReversal2 then -Constants.inf else 0),
                           h_outflow(nominal=1E5,start=h_outflow_a2_start),
                           Xi_outflow(nominal=0.01))
        "Fluid connector a2 (positive design flow direction is from port_a2 to port_b2)"
          annotation (Placement(transformation(extent={{90,-70},{110,-50}},
                  rotation=0)));
        Modelica.Fluid.Interfaces.FluidPort_b port_b2(
                                      redeclare package Medium = Medium2,
                           m_flow(max=if allowFlowReversal2 then +Constants.inf else 0),
                           h_outflow(nominal=1E5, start=h_outflow_b2_start),
                           Xi_outflow(nominal=0.01))
        "Fluid connector b2 (positive design flow direction is from port_a2 to port_b2)"
          annotation (Placement(transformation(extent={{-90,-70},{-110,-50}},
                                                                           rotation=
                   0), iconTransformation(extent={{-90,-70},{-110,-50}})));

        annotation (
          preferedView="info",
          Diagram(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={1,1}), graphics),
          Documentation(info="<html>
<p>
This model defines an interface for components with four ports. 
The parameters <code>allowFlowReversal1</code> and
<code>allowFlowReversal2</code> may be used by models that extend
this model to treat flow reversal.
</p>
<p>
This model is identical to 
<a href=\"modelica://Modelica.Fluid.Interfaces.PartialTwoPort\">
Modelica.Fluid.Interfaces.PartialTwoPort</a>, except that it has four ports.
</p>
</html>",       revisions="<html>
<ul>
<li>
September 17, 2010 by Michael Wetter:<br>
Fixed bug: The start value for <code>port_b1.h_outflow</code>
was set to <code>h_outflow_b2_start</code> instead of <code>h_outflow_b1_start</code>.
</li>
<li>
February 26, 2010 by Michael Wetter:<br>
Added start values for outflowing enthalpy because they 
are often iteration variables in nonlinear equation systems.
</li>
</ul>
</html>"),Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={1,1}), graphics={Text(
                extent={{-151,147},{149,107}},
                lineColor={0,0,255},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={0,127,255},
                textString="%name")}));
      end FourPort;

      model FourPortHeatMassExchanger
      "Partial model transporting two fluid streams between four ports with storing mass or energy"
        extends Buildings.Fluid.Interfaces.PartialFourPortInterface(
          final h_outflow_a1_start = h1_outflow_start,
          final h_outflow_b1_start = h1_outflow_start,
          final h_outflow_a2_start = h2_outflow_start,
          final h_outflow_b2_start = h2_outflow_start);
        extends Buildings.Fluid.Interfaces.FourPortFlowResistanceParameters(
           final computeFlowResistance1=true, final computeFlowResistance2=true);
        import Modelica.Constants;

        Buildings.Fluid.MixingVolumes.MixingVolume vol1(
          redeclare final package Medium = Medium1,
          nPorts = 2,
          V=m1_flow_nominal*tau1/rho1_nominal,
          final m_flow_nominal=m1_flow_nominal,
          energyDynamics=if tau1 > Modelica.Constants.eps
                               then energyDynamics else
                               Modelica.Fluid.Types.Dynamics.SteadyState,
          massDynamics=if tau1 > Modelica.Constants.eps
                               then massDynamics else
                               Modelica.Fluid.Types.Dynamics.SteadyState,
          final p_start=p1_start,
          final T_start=T1_start,
          final X_start=X1_start,
          final C_start=C1_start,
          final C_nominal=C1_nominal) "Volume for fluid 1"
                                     annotation (Placement(transformation(extent={{-10,70},
                  {10,50}},         rotation=0)));

        replaceable Buildings.Fluid.MixingVolumes.MixingVolume vol2
          constrainedby Buildings.Fluid.MixingVolumes.MixingVolume(
          redeclare final package Medium = Medium2,
          nPorts = 2,
          V=m2_flow_nominal*tau2/rho2_nominal,
          final m_flow_nominal = m2_flow_nominal,
          energyDynamics=if tau2 > Modelica.Constants.eps
                               then energyDynamics else
                               Modelica.Fluid.Types.Dynamics.SteadyState,
          massDynamics=if tau2 > Modelica.Constants.eps
                               then massDynamics else
                               Modelica.Fluid.Types.Dynamics.SteadyState,
          final p_start=p2_start,
          final T_start=T2_start,
          final X_start=X2_start,
          final C_start=C2_start,
          final C_nominal=C2_nominal) "Volume for fluid 2"
         annotation (Placement(transformation(
              origin={2,-60},
              extent={{-10,10},{10,-10}},
              rotation=180)));

        parameter Modelica.SIunits.Time tau1 = 30
        "Time constant at nominal flow"
           annotation (Evaluate=true, Dialog(tab = "Dynamics", group="Nominal condition"));
        parameter Modelica.SIunits.Time tau2 = 30
        "Time constant at nominal flow"
           annotation (Evaluate=true, Dialog(tab = "Dynamics", group="Nominal condition"));
        Modelica.SIunits.HeatFlowRate Q1_flow= sum(vol1.heatPort.Q_flow)
        "Heat flow rate into medium 1";
        Modelica.SIunits.HeatFlowRate Q2_flow= sum(vol2.heatPort.Q_flow)
        "Heat flow rate into medium 2";

        // Advanced
        parameter Boolean homotopyInitialization = true
        "= true, use homotopy method"
          annotation(Evaluate=true, Dialog(tab="Advanced"));

        // Assumptions
        parameter Modelica.Fluid.Types.Dynamics energyDynamics=Modelica.Fluid.Types.Dynamics.DynamicFreeInitial
        "Formulation of energy balance"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));
        parameter Modelica.Fluid.Types.Dynamics massDynamics=energyDynamics
        "Formulation of mass balance"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));

        // Initialization
        parameter Medium1.AbsolutePressure p1_start = Medium1.p_default
        "Start value of pressure"
          annotation(Dialog(tab = "Initialization", group = "Medium 1"));
        parameter Medium1.Temperature T1_start = Medium1.T_default
        "Start value of temperature"
          annotation(Dialog(tab = "Initialization", group = "Medium 1"));
        parameter Medium1.MassFraction X1_start[Medium1.nX] = Medium1.X_default
        "Start value of mass fractions m_i/m"
          annotation (Dialog(tab="Initialization", group = "Medium 1", enable=Medium1.nXi > 0));
        parameter Medium1.ExtraProperty C1_start[Medium1.nC](
             quantity=Medium1.extraPropertiesNames)=fill(0, Medium1.nC)
        "Start value of trace substances"
          annotation (Dialog(tab="Initialization", group = "Medium 1", enable=Medium1.nC > 0));
        parameter Medium1.ExtraProperty C1_nominal[Medium1.nC](
             quantity=Medium1.extraPropertiesNames) = fill(1E-2, Medium1.nC)
        "Nominal value of trace substances. (Set to typical order of magnitude.)"
         annotation (Dialog(tab="Initialization", group = "Medium 1", enable=Medium1.nC > 0));

        parameter Medium2.AbsolutePressure p2_start = Medium2.p_default
        "Start value of pressure"
          annotation(Dialog(tab = "Initialization", group = "Medium 2"));
        parameter Medium2.Temperature T2_start = Medium2.T_default
        "Start value of temperature"
          annotation(Dialog(tab = "Initialization", group = "Medium 2"));
        parameter Medium2.MassFraction X2_start[Medium2.nX] = Medium2.X_default
        "Start value of mass fractions m_i/m"
          annotation (Dialog(tab="Initialization", group = "Medium 2", enable=Medium2.nXi > 0));
        parameter Medium2.ExtraProperty C2_start[Medium2.nC](
             quantity=Medium2.extraPropertiesNames)=fill(0, Medium2.nC)
        "Start value of trace substances"
          annotation (Dialog(tab="Initialization", group = "Medium 2", enable=Medium2.nC > 0));
        parameter Medium2.ExtraProperty C2_nominal[Medium2.nC](
             quantity=Medium2.extraPropertiesNames) = fill(1E-2, Medium2.nC)
        "Nominal value of trace substances. (Set to typical order of magnitude.)"
         annotation (Dialog(tab="Initialization", group = "Medium 2", enable=Medium2.nC > 0));

    protected
        parameter Medium1.ThermodynamicState sta1_nominal=Medium1.setState_pTX(
            T=Medium1.T_default, p=Medium1.p_default, X=Medium1.X_default);
        parameter Modelica.SIunits.Density rho1_nominal=Medium1.density(sta1_nominal)
        "Density, used to compute fluid volume";
        parameter Medium2.ThermodynamicState sta2_nominal=Medium2.setState_pTX(
            T=Medium2.T_default, p=Medium2.p_default, X=Medium2.X_default);
        parameter Modelica.SIunits.Density rho2_nominal=Medium2.density(sta2_nominal)
        "Density, used to compute fluid volume";

        parameter Medium1.ThermodynamicState sta1_start=Medium1.setState_pTX(
            T=T1_start, p=p1_start, X=X1_start);
        parameter Modelica.SIunits.SpecificEnthalpy h1_outflow_start = Medium1.specificEnthalpy(sta1_start)
        "Start value for outflowing enthalpy";
        parameter Medium2.ThermodynamicState sta2_start=Medium2.setState_pTX(
            T=T2_start, p=p2_start, X=X2_start);
        parameter Modelica.SIunits.SpecificEnthalpy h2_outflow_start = Medium2.specificEnthalpy(sta2_start)
        "Start value for outflowing enthalpy";

    public
        FixedResistances.FixedResistanceDpM preDro1(
          redeclare package Medium = Medium1,
          final use_dh=false,
          final m_flow_nominal=m1_flow_nominal,
          final deltaM=deltaM1,
          final allowFlowReversal=allowFlowReversal1,
          final m_flow_small=m1_flow_small,
          final show_T=false,
          final show_V_flow=show_V_flow,
          final from_dp=from_dp1,
          final linearized=linearizeFlowResistance1,
          final homotopyInitialization=homotopyInitialization,
          final dp_nominal=dp1_nominal,
          final dh=1,
          final ReC=4000) "Pressure drop model for fluid 1"
          annotation (Placement(transformation(extent={{-80,70},{-60,90}})));

        FixedResistances.FixedResistanceDpM preDro2(
          redeclare package Medium = Medium2,
          final use_dh=false,
          final m_flow_nominal=m2_flow_nominal,
          final deltaM=deltaM2,
          final allowFlowReversal=allowFlowReversal2,
          final m_flow_small=m2_flow_small,
          final show_T=false,
          final show_V_flow=show_V_flow,
          final from_dp=from_dp2,
          final linearized=linearizeFlowResistance2,
          final homotopyInitialization=homotopyInitialization,
          final dp_nominal=dp2_nominal,
          final dh=1,
          final ReC=4000) "Pressure drop model for fluid 2"
          annotation (Placement(transformation(extent={{80,-90},{60,-70}})));

      equation
        connect(vol1.ports[2], port_b1) annotation (Line(
            points={{2,70},{20,70},{20,60},{100,60}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(vol2.ports[2], port_b2) annotation (Line(
            points={{2,-70},{-30,-70},{-30,-60},{-100,-60}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(port_a1, preDro1.port_a) annotation (Line(
            points={{-100,60},{-90,60},{-90,80},{-80,80}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(preDro1.port_b, vol1.ports[1]) annotation (Line(
            points={{-60,80},{-2,80},{-2,70}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(port_a2, preDro2.port_a) annotation (Line(
            points={{100,-60},{90,-60},{90,-80},{80,-80}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(preDro2.port_b, vol2.ports[1]) annotation (Line(
            points={{60,-80},{2,-80},{2,-70}},
            color={0,127,255},
            smooth=Smooth.None));
        annotation (
          Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics),
          Documentation(info="<html>
<p>
This component transports two fluid streams between four ports. 
It provides the basic model for implementing a dynamic heat exchanger.
It is used by 
<a href=\"modelica://Buildings.Fluid.HeatExchangers.BaseClasses.HexElement\">
Buildings.Fluid.HeatExchangers.BaseClasses.HexElement</a>
The variable names follow the conventions used in 
<a href=\"modelica://Modelica.Fluid.HeatExchangers.BasicHX\">
</p>Modelica.Fluid.HeatExchangers.BasicHX</a>.
</html>",       revisions="<html>
<ul>
<li>
July 29, 2011, by Michael Wetter:
<ul>
<li>
Changed values of 
<code>h_outflow_a1_start</code>,
<code>h_outflow_b1_start</code>,
<code>h_outflow_a2_start</code> and
<code>h_outflow_b2_start</code>, and 
declared them as final.
</li>
<li>
Set nominal values for <code>vol1.C</code> and <code>vol2.C</code>.
</li>
</ul>
</li>
<li>
July 11, 2011, by Michael Wetter:<br>
Changed parameterization of fluid volume so that steady-state balance is
used when <code>tau = 0</code>.
</li>
<li>
March 25, 2011, by Michael Wetter:<br>
Added homotopy operator.
</li>
<li>
April 13, 2009, by Michael Wetter:<br>
Added model to compute flow friction.
</li>
<li>
September 10, 2008 by Michael Wetter:<br>
Added <code>stateSelect=StateSelect.always</code> for temperature of volume 1.
</li>
<li>
Changed temperature sensor from Celsius to Kelvin.
Unit conversion should be made during output
processing.
<li>
August 5, 2008, by Michael Wetter:<br>
Replaced instances of <code>Delays.DelayFirstOrder</code> with instances of
<code>MixingVolumes.MixingVolume</code>. This allows to extract liquid for a condensing cooling
coil model.
</li>
<li>
March 25, 2008, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics={
              Rectangle(
                extent={{-70,80},{70,-80}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-99,64},{102,54}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-99,-56},{102,-66}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid)}));
      end FourPortHeatMassExchanger;

      model StaticTwoPortHeatMassExchanger
      "Partial model transporting fluid between two ports without storing mass or energy"
        extends Buildings.Fluid.Interfaces.PartialTwoPortInterface(
        showDesignFlowDirection = false,
        final show_T=true);
        extends Buildings.Fluid.Interfaces.TwoPortFlowResistanceParameters(
          final computeFlowResistance=(abs(dp_nominal) > Modelica.Constants.eps));
        import Modelica.Constants;
        input Modelica.SIunits.HeatFlowRate Q_flow
        "Heat transfered into the medium";
        input Medium.MassFlowRate mXi_flow[Medium.nXi]
        "Mass flow rates of independent substances added to the medium";
        constant Boolean sensibleOnly "Set to true if sensible exchange only";
        // Outputs that are needed in models that extend this model
        Modelica.Blocks.Interfaces.RealOutput hOut(unit="J/kg")
        "Leaving temperature of the component";
        Modelica.Blocks.Interfaces.RealOutput XiOut[Medium.nXi](unit="1")
        "Leaving species concentration of the component";
        Modelica.Blocks.Interfaces.RealOutput COut[Medium.nC](unit="1")
        "Leaving trace substances of the component";
        constant Boolean use_safeDivision=true
        "Set to true to improve numerical robustness";
    protected
        Real m_flowInv(unit="s/kg") "Regularization of 1/m_flow";
        final parameter Real k(unit="")=if computeFlowResistance
         then abs(m_flow_nominal)/sqrt(abs(dp_nominal)) else 0
        "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
        final parameter Real kLin(unit="") = if computeFlowResistance
         then abs(m_flow_nominal/dp_nominal) else 0;
      equation
        // Regularization of m_flow around the origin to avoid a division by zero
      /*  m_flowInv = smooth(2, if (abs(port_a.m_flow) > m_flow_small/1E3) then 
      1/port_a.m_flow
      else 
      Buildings.Utilities.Math.Functions.inverseXRegularized(x=port_a.m_flow, delta=m_flow_small/1E3));
 */
       if use_safeDivision then
          m_flowInv = Buildings.Utilities.Math.Functions.inverseXRegularized(x=port_a.m_flow, delta=m_flow_small/1E3);
       else
           m_flowInv = 1/port_a.m_flow;
       end if;
       if allowFlowReversal then
      /* This formulation fails to simulate in Buildings.Fluid.MixingVolumes.Examples.MixingVolumePrescribedHeatFlowRate. See also Dynasim ticket 13596
   if (port_a.m_flow >= 0) then
     hOut =  port_b.h_outflow;
     XiOut = port_b.Xi_outflow;
     COut =  port_b.C_outflow;
    else
     hOut =  port_a.h_outflow;
     XiOut = port_a.Xi_outflow;
     COut =  port_a.C_outflow;
    end if;
*/
         hOut = smooth(0, if (port_a.m_flow >= 0) then
            port_b.h_outflow else
            port_a.h_outflow);
         XiOut = smooth(0, if (port_a.m_flow >= 0) then
            port_b.Xi_outflow else
            port_a.Xi_outflow);
         COut = smooth(0, if (port_a.m_flow >= 0) then
            port_b.C_outflow else
            port_a.C_outflow);

       else
         hOut =  port_b.h_outflow;
         XiOut = port_b.Xi_outflow;
         COut =  port_b.C_outflow;
       end if;
        //////////////////////////////////////////////////////////////////////////////////////////
        // Energy balance and mass balance
        if sensibleOnly then
          // Mass balance
          port_a.m_flow = -port_b.m_flow;
          // Energy balance
          port_b.h_outflow = inStream(port_a.h_outflow) + Q_flow * m_flowInv;
          port_a.h_outflow = inStream(port_b.h_outflow) - Q_flow * m_flowInv;
          // Transport of species
          port_a.Xi_outflow = inStream(port_b.Xi_outflow);
          port_b.Xi_outflow = inStream(port_a.Xi_outflow);
          // Transport of trace substances
          port_a.C_outflow = inStream(port_b.C_outflow);
          port_b.C_outflow = inStream(port_a.C_outflow);
        else
          // Mass balance (no storage)
          port_a.m_flow + port_b.m_flow = -sum(mXi_flow);
          // Energy balance.
          // This equation is approximate since m_flow = port_a.m_flow is used for the mass flow rate
          // at both ports. Since mXi_flow << m_flow, the error is small.
          port_b.h_outflow = inStream(port_a.h_outflow) + Q_flow * m_flowInv;
          port_a.h_outflow = inStream(port_b.h_outflow) - Q_flow * m_flowInv;
          // Transport of species
          for i in 1:Medium.nXi loop
            port_b.Xi_outflow[i] = inStream(port_a.Xi_outflow[i]) + mXi_flow[i] * m_flowInv;
            port_a.Xi_outflow[i] = inStream(port_b.Xi_outflow[i]) - mXi_flow[i] * m_flowInv;
          end for;
          // Transport of trace substances
          for i in 1:Medium.nC loop
            port_a.m_flow*port_a.C_outflow[i] = -port_b.m_flow*inStream(port_b.C_outflow[i]);
            port_b.m_flow*port_b.C_outflow[i] = -port_a.m_flow*inStream(port_a.C_outflow[i]);
          end for;
        end if; // sensibleOnly
        //////////////////////////////////////////////////////////////////////////////////////////
        // Pressure drop calculation
        if computeFlowResistance then
          if linearizeFlowResistance then
            m_flow = kLin*dp;
          else
            if homotopyInitialization then
              if from_dp then
                 m_flow = homotopy(actual=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(
                                          dp=dp,
                                          k=k,
                                          m_flow_turbulent=deltaM * m_flow_nominal),
                                          simplified=m_flow_nominal*dp/dp_nominal);
               else
                 dp = homotopy(actual=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(
                                          m_flow=m_flow,
                                          k=k,
                                          m_flow_turbulent=deltaM * m_flow_nominal),
                                          simplified=dp_nominal*m_flow/m_flow_nominal);
              end if; // from_dp
            else // do not use homotopy
              if from_dp then
                m_flow = Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(
                                          dp=dp,
                                          k=k,
                                          m_flow_turbulent=deltaM * m_flow_nominal);
              else
                dp = Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(
                                          m_flow=m_flow,
                                          k=k,
                                          m_flow_turbulent=deltaM * m_flow_nominal);
              end if; // from_dp
            end if; // homotopyInitialization
          end if; // linearized
        else // do not compute flow resistance
          dp = 0;
        end if; // computeFlowResistance
        annotation (
          preferedView="info",
          Diagram(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics),
          Documentation(info="<html>
<p>
This component transports fluid between its two ports, without
storing mass or energy. It is based on 
<a href=\"modelica://Modelica.Fluid.Interfaces.PartialTwoPortTransport\">
Modelica.Fluid.Interfaces.PartialTwoPortTransport</a> but it does
use a different implementation for handling reverse flow because
in this component, mass flow rate can be added or removed from
the medium.
</p>
<p>
If <code>dp_nominal &gt; Modelica.Constants.eps</code>, this component computes
pressure drop due to flow friction.
The pressure drop is defined by a quadratic function that goes through
the point <code>(m_flow_nominal, dp_nominal)</code>. At <code>|m_flow| &lt; deltaM * m_flow_nominal</code>,
the pressure drop vs. flow relation is linearized.
If the parameter <code>linearizeFlowResistance</code> is set to true,
then the whole pressure drop vs. flow resistance curve is linearized.
</p>
<h4>Implementation</h4>
<p>
This model uses inputs and constants that need to be set by models
that extend or instantiate this model.
The following inputs need to be assigned:
<ul>
<li>
<code>Q_flow</code>, which is the heat flow rate added to the medium.
</li>
<li>
<code>mXi_flow</code>, which is the species mass flow rate added to the medium.
</li>
</ul>
</p>
<p>
Set the constant <code>sensibleOnly=true</code> if the model that extends
or instantiates this model sets <code>mXi_flow = zeros(Medium.nXi)</code>.
</p>
</html>",       revisions="<html>
<ul>
<li>
August 19, 2011, by Michael Wetter:<br>
Changed assignment of <code>hOut</code>, <code>XiOut</code> and
<code>COut</code> to declare that it is not differentiable.
</li>
<li>
August 4, 2011, by Michael Wetter:<br>
Moved linearized pressure drop equation from the function body to the equation
section. With the previous implementation, 
the symbolic processor may not rearrange the equations, which can lead 
to coupled equations instead of an explicit solution.
</li>
<li>
March 29, 2011, by Michael Wetter:<br>
Changed energy and mass balance to avoid a division by zero if <code>m_flow=0</code>.
</li>
<li>
March 27, 2011, by Michael Wetter:<br>
Added <code>homotopy</code> operator.
</li>
<li>
August 19, 2010, by Michael Wetter:<br>
Fixed bug in energy and moisture balance that affected results if a component
adds or removes moisture to the air stream. 
In the old implementation, the enthalpy and species
outflow at <code>port_b</code> was multiplied with the mass flow rate at 
<code>port_a</code>. The old implementation led to small errors that were proportional
to the amount of moisture change. For example, if the moisture added by the component
was <code>0.005 kg/kg</code>, then the error was <code>0.5%</code>.
Also, the results for forward flow and reverse flow differed by this amount.
With the new implementation, the energy and moisture balance is exact.
</li>
<li>
March 22, 2010, by Michael Wetter:<br>
Added constant <code>sensibleOnly</code> to 
simplify species balance equation.
</li>
<li>
April 10, 2009, by Michael Wetter:<br>
Added model to compute flow friction.
</li>
<li>
April 22, 2008, by Michael Wetter:<br>
Revised to add mass balance.
</li>
<li>
March 17, 2008, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics));
      end StaticTwoPortHeatMassExchanger;

      model StaticFourPortHeatMassExchanger
      "Partial model transporting two fluid streams between four ports without storing mass or energy"
        extends Buildings.Fluid.Interfaces.PartialFourPortInterface;
        extends Buildings.Fluid.Interfaces.FourPortFlowResistanceParameters(
         final computeFlowResistance1=(dp1_nominal > Modelica.Constants.eps),
         final computeFlowResistance2=(dp2_nominal > Modelica.Constants.eps));
        import Modelica.Constants;
        input Modelica.SIunits.HeatFlowRate Q1_flow
        "Heat transfered into the medium 1";
        input Medium1.MassFlowRate mXi1_flow[Medium1.nXi]
        "Mass flow rates of independent substances added to the medium 1";
        input Modelica.SIunits.HeatFlowRate Q2_flow
        "Heat transfered into the medium 2";
        input Medium2.MassFlowRate mXi2_flow[Medium2.nXi]
        "Mass flow rates of independent substances added to the medium 2";
        constant Boolean sensibleOnly1
        "Set to true if sensible exchange only for medium 1";
        constant Boolean sensibleOnly2
        "Set to true if sensible exchange only for medium 2";
    protected
        Buildings.Fluid.Interfaces.StaticTwoPortHeatMassExchanger bal1(
          final sensibleOnly = sensibleOnly1,
          redeclare final package Medium=Medium1,
          final m_flow_nominal = m1_flow_nominal,
          final dp_nominal = dp1_nominal,
          final allowFlowReversal = allowFlowReversal1,
          final m_flow_small = m1_flow_small,
          final homotopyInitialization = homotopyInitialization,
          final show_V_flow = false,
          final from_dp = from_dp1,
          final linearizeFlowResistance = linearizeFlowResistance1,
          final deltaM = deltaM1,
          final Q_flow = Q1_flow,
          final mXi_flow = mXi1_flow)
        "Model for heat, mass, species, trace substance and pressure balance of stream 1";
        Buildings.Fluid.Interfaces.StaticTwoPortHeatMassExchanger bal2(
          final sensibleOnly = sensibleOnly2,
          redeclare final package Medium=Medium2,
          final m_flow_nominal = m2_flow_nominal,
          final dp_nominal = dp2_nominal,
          final allowFlowReversal = allowFlowReversal2,
          final m_flow_small = m2_flow_small,
          final homotopyInitialization = homotopyInitialization,
          final show_V_flow = false,
          final from_dp = from_dp2,
          final linearizeFlowResistance = linearizeFlowResistance2,
          final deltaM = deltaM2,
          final Q_flow = Q2_flow,
          final mXi_flow = mXi2_flow)
        "Model for heat, mass, species, trace substance and pressure balance of stream 2";
      equation
        connect(bal1.port_a, port_a1);
        connect(bal1.port_b, port_b1);
        connect(bal2.port_a, port_a2);
        connect(bal2.port_b, port_b2);
        annotation (
          preferedView="info",
          Diagram(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics),
          Documentation(info="<html>
<p>
This component transports two fluid streams between four ports, without
storing mass or energy. It is similar to
<a href=\"modelica://Buildings.Fluid.Interfaces.StaticTwoPortHeatMassExchanger\">
Buildings.Fluid.Interfaces.StaticTwoPortHeatMassExchanger</a>,
but it has four ports instead of two.
</p>
<p>
If <code>dp<i>N</i>_nominal &gt; Modelica.Constants.eps</code>, 
where <code><i>N</i></code> denotes the fluid <i>1</i> or <i>2</i>,
then the model computes
pressure drop due to flow friction in the respective fluid stream.
The pressure drop is defined by a quadratic function that goes through
the point <code>(m<i>N</i>_flow_nominal, dp<i>N</i>_nominal)</code>. 
At <code>|m<i>N</i>_flow| &lt; deltaM<i>N</i> * m<i>N</i>_flow_nominal</code>,
the pressure drop vs. flow relation is linearized.
If the parameter <code>linearizeFlowResistance<i>N</i></code> is set to true,
then the whole pressure drop vs. flow resistance curve is linearized.
</p>


</p>
<h4>Implementation</h4>
<p>
This model uses inputs and constants that need to be set by models
that extend or instantiate this model.
The following inputs need to be assigned, where <code><i>N</i></code> denotes <code>1</code> or
<code>2</code>:
<ul>
<li>
<code>Q<i>N</i>_flow</code>, which is the heat flow rate added to the medium <i>N</i>.
</li>
<li>
<code>mXi<i>N</i>_flow</code>, which is the species mass flow rate added to the medium <i>N</i>.
</li>
</ul>
</p>
<p>
Set the constant <code>sensibleOnly<i>N</i>=true</code> if the model that extends
or instantiates this model sets <code>mXi<i>N</i>_flow = zeros(Medium.nXi<i>N</i>)</code>.
</p>
<p>
     Note that the model does not implement <code>0 = Q1_flow + Q2_flow</code> or
     <code>0 = mXi1_flow + mXi2_flow</code>. If there is no heat or mass transfer
     with the environment, then a model that extends this model needs to provide these 
     equations.
</p>
</p>
</html>",       revisions="<html>
<ul>
<li>
March 29, 2011, by Michael Wetter:<br>
Changed energy and mass balance to avoid a division by zero if <code>m_flow=0</code>.
</li>
<li>
March 27, 2011, by Michael Wetter:<br>
Added <code>homotopy</code> operator.
</li>
<li>
August 19, 2010, by Michael Wetter:<br>
Fixed bug in energy and moisture balance that affected results if a component
adds or removes moisture to the air stream. 
In the old implementation, the enthalpy and species
outflow at <code>port_b</code> was multiplied with the mass flow rate at 
<code>port_a</code>. The old implementation led to small errors that were proportional
to the amount of moisture change. For example, if the moisture added by the component
was <code>0.005 kg/kg</code>, then the error was <code>0.5%</code>.
Also, the results for forward flow and reverse flow differed by this amount.
With the new implementation, the energy and moisture balance is exact.
</li>
<li>
March 22, 2010, by Michael Wetter:<br>
Added constants <code>sensibleOnly1</code> and
<code>sensibleOnly2</code> to 
simplify species balance equations.
</li>
<li>
April 13, 2009, by Michael Wetter:<br>
Added model to compute flow friction.
</li>
<li>
March 25, 2008, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics={
              Rectangle(
                extent={{-70,80},{70,-80}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-100,65},{101,55}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-100,-55},{101,-65}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid)}));
      end StaticFourPortHeatMassExchanger;

      partial model PartialTwoPortInterface
      "Partial model transporting fluid between two ports without storing mass or energy"
        import Modelica.Constants;
        extends Modelica.Fluid.Interfaces.PartialTwoPort(
          port_a(p(start=Medium.p_default,
                   nominal=Medium.p_default)),
          port_b(p(start=Medium.p_default,
                 nominal=Medium.p_default)));

        parameter Medium.MassFlowRate m_flow_nominal "Nominal mass flow rate"
          annotation(Dialog(group = "Nominal condition"));
        parameter Medium.MassFlowRate m_flow_small(min=0) = 1E-4*abs(m_flow_nominal)
        "Small mass flow rate for regularization of zero flow"
          annotation(Dialog(tab = "Advanced"));
        parameter Boolean homotopyInitialization = true
        "= true, use homotopy method"
          annotation(Evaluate=true, Dialog(tab="Advanced"));

        // Diagnostics
         parameter Boolean show_V_flow = false
        "= true, if volume flow rate at inflowing port is computed"
          annotation(Dialog(tab="Advanced",group="Diagnostics"));
         parameter Boolean show_T = false
        "= true, if actual temperature at port is computed (may lead to events)"
          annotation(Dialog(tab="Advanced",group="Diagnostics"));

        Modelica.SIunits.VolumeFlowRate V_flow=
            m_flow/Medium.density(sta_a) if show_V_flow
        "Volume flow rate at inflowing port (positive when flow from port_a to port_b)";

        Medium.MassFlowRate m_flow(start=0) = port_a.m_flow
        "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";
        Modelica.SIunits.Pressure dp(start=0, displayUnit="Pa") = port_a.p - port_b.p
        "Pressure difference between port_a and port_b";

        Medium.ThermodynamicState sta_a=if homotopyInitialization then
            Medium.setState_phX(port_a.p,
                                homotopy(actual=actualStream(port_a.h_outflow),
                                         simplified=inStream(port_a.h_outflow)),
                                homotopy(actual=actualStream(port_a.Xi_outflow),
                                         simplified=inStream(port_a.Xi_outflow)))
          else
            Medium.setState_phX(port_a.p,
                                actualStream(port_a.h_outflow),
                                actualStream(port_a.Xi_outflow)) if
               show_T "Medium properties in port_a";

        Medium.ThermodynamicState sta_b=if homotopyInitialization then
            Medium.setState_phX(port_b.p,
                                homotopy(actual=actualStream(port_b.h_outflow),
                                         simplified=port_b.h_outflow),
                                homotopy(actual=actualStream(port_b.Xi_outflow),
                                  simplified=port_b.Xi_outflow))
          else
            Medium.setState_phX(port_b.p,
                                actualStream(port_b.h_outflow),
                                actualStream(port_b.Xi_outflow)) if
                show_T "Medium properties in port_b";

        annotation (
          preferedView="info",
          Diagram(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics),
          Documentation(info="<html>
<p>
This component defines the interface for models that 
transports a fluid between two ports. It is similar to 
<a href=\"Modelica://Modelica.Fluid.Interfaces.PartialTwoPortTransport\">
Modelica.Fluid.Interfaces.PartialTwoPortTransport</a>, but it does not 
include the species balance 
<pre>
  port_b.Xi_outflow = inStream(port_a.Xi_outflow);
</pre>
Thus, it can be used as a base class for a heat <i>and</i> mass transfer component
</p>
<p>
The model is used by other models in this package that add heat transfer,
mass transfer and pressure drop equations. See for example
<a href=\"modelica://Buildings.Fluid.Interfaces.StaticTwoPortHeatMassExchanger\">
Buildings.Fluid.Interfaces.StaticTwoPortHeatMassExchanger</a>.
</p>
</html>",       revisions="<html>
<ul>
<li>
March 27, 2011 by Michael Wetter:<br>
Added <code>homotopy</code> operator.
</li>
<li>
March 21, 2010 by Michael Wetter:<br>
Changed pressure start value from <code>system.p_start</code>
to <code>Medium.p_default</code> since HVAC models may have water and 
air, which are typically at different pressures.
</li>
<li>
September 19, 2008 by Michael Wetter:<br>
Added equations for the mass balance of extra species flow,
i.e., <code>C</code> and <code>mC_flow</code>.
</li>
<li>
March 11, 2008, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
      end PartialTwoPortInterface;

      partial model PartialFourPortInterface
      "Partial model transporting fluid between two ports without storing mass or energy"
        import Modelica.Constants;
        extends Buildings.Fluid.Interfaces.FourPort(
          port_a1(
            m_flow(min = if allowFlowReversal1 then -Constants.inf else 0)),
          port_b1(
            m_flow(max = if allowFlowReversal1 then +Constants.inf else 0)),
          port_a2(
            m_flow(min = if allowFlowReversal2 then -Constants.inf else 0)),
          port_b2(
            m_flow(max = if allowFlowReversal2 then +Constants.inf else 0)));

        parameter Modelica.SIunits.MassFlowRate m1_flow_nominal(min=0)
        "Nominal mass flow rate"
          annotation(Dialog(group = "Nominal condition"));
        parameter Modelica.SIunits.MassFlowRate m2_flow_nominal(min=0)
        "Nominal mass flow rate"
          annotation(Dialog(group = "Nominal condition"));

        parameter Medium1.MassFlowRate m1_flow_small(min=0) = 1E-4*abs(m1_flow_nominal)
        "Small mass flow rate for regularization of zero flow"
          annotation(Dialog(tab = "Advanced"));
        parameter Medium2.MassFlowRate m2_flow_small(min=0) = 1E-4*abs(m2_flow_nominal)
        "Small mass flow rate for regularization of zero flow"
          annotation(Dialog(tab = "Advanced"));
        parameter Boolean homotopyInitialization = true
        "= true, use homotopy method"
          annotation(Evaluate=true, Dialog(tab="Advanced"));

        // Diagnostics
        parameter Boolean show_V_flow = false
        "= true, if volume flow rate at inflowing port is computed"
          annotation(Dialog(tab="Advanced",group="Diagnostics"));
        parameter Boolean show_T = false
        "= true, if actual temperature at port is computed (may lead to events)"
          annotation(Dialog(tab="Advanced",group="Diagnostics"));

    public
        Modelica.SIunits.VolumeFlowRate V1_flow=m1_flow/Medium.density(sta_a1) if
              show_V_flow
        "Volume flow rate at inflowing port (positive when flow from port_a1 to port_b1)";
        Modelica.SIunits.VolumeFlowRate V2_flow=m2_flow/Medium.density(sta_a2) if
              show_V_flow
        "Volume flow rate at inflowing port (positive when flow from port_a2 to port_b2)";

        Medium1.MassFlowRate m1_flow(start=0) = port_a1.m_flow
        "Mass flow rate from port_a1 to port_b1 (m1_flow > 0 is design flow direction)";
        Modelica.SIunits.Pressure dp1(start=0, displayUnit="Pa") = port_a1.p - port_b1.p
        "Pressure difference between port_a1 and port_b1";
        Medium2.MassFlowRate m2_flow(start=0) = port_a2.m_flow
        "Mass flow rate from port_a2 to port_b2 (m2_flow > 0 is design flow direction)";
        Modelica.SIunits.Pressure dp2(start=0, displayUnit="Pa") = port_a2.p - port_b2.p
        "Pressure difference between port_a2 and port_b2";

        Medium1.ThermodynamicState sta_a1=if homotopyInitialization then
            Medium1.setState_phX(port_a1.p,
               homotopy(actual=actualStream(port_a1.h_outflow),
                        simplified=inStream(port_a1.h_outflow)),
               homotopy(actual=actualStream(port_a1.Xi_outflow),
                        simplified=inStream(port_a1.Xi_outflow)))
          else
            Medium1.setState_phX(port_a1.p,
                                 actualStream(port_a1.h_outflow),
                                 actualStream(port_a1.Xi_outflow)) if
               show_T "Medium properties in port_a1";

        Medium1.ThermodynamicState sta_b1=if homotopyInitialization then
            Medium1.setState_phX(port_b1.p,
                homotopy(actual=actualStream(port_b1.h_outflow),
                         simplified=port_b1.h_outflow),
                homotopy(actual=actualStream(port_b1.Xi_outflow),
                         simplified=port_b1.Xi_outflow))
          else
            Medium1.setState_phX(port_b1.p,
                                 actualStream(port_b1.h_outflow),
                                 actualStream(port_b1.Xi_outflow)) if
               show_T "Medium properties in port_b1";

        Medium2.ThermodynamicState sta_a2=if homotopyInitialization then
            Medium2.setState_phX(port_b2.p,
                homotopy(actual=actualStream(port_a2.h_outflow),
                         simplified=inStream(port_a2.h_outflow)),
                homotopy(actual=actualStream(port_a2.Xi_outflow),
                         simplified=inStream(port_a2.Xi_outflow)))
          else
            Medium2.setState_phX(port_a2.p,
                                 actualStream(port_a2.h_outflow),
                                 actualStream(port_a2.Xi_outflow)) if
               show_T "Medium properties in port_a2";

        Medium2.ThermodynamicState sta_b2=if homotopyInitialization then
            Medium2.setState_phX(port_b2.p,
                homotopy(actual=actualStream(port_b2.h_outflow),
                         simplified=port_b2.h_outflow),
                homotopy(actual=actualStream(port_b2.Xi_outflow),
                         simplified=port_b2.Xi_outflow))
          else
            Medium2.setState_phX(port_b2.p,
                                 actualStream(port_b2.h_outflow),
                                 actualStream(port_b2.Xi_outflow)) if
               show_T "Medium properties in port_b2";

    protected
        Medium1.ThermodynamicState state_a1_inflow=
          Medium1.setState_phX(port_a1.p, inStream(port_a1.h_outflow), inStream(port_a1.Xi_outflow))
        "state for medium inflowing through port_a1";
        Medium1.ThermodynamicState state_b1_inflow=
          Medium1.setState_phX(port_b1.p, inStream(port_b1.h_outflow), inStream(port_b1.Xi_outflow))
        "state for medium inflowing through port_b1";
        Medium2.ThermodynamicState state_a2_inflow=
          Medium2.setState_phX(port_a2.p, inStream(port_a2.h_outflow), inStream(port_a2.Xi_outflow))
        "state for medium inflowing through port_a2";
        Medium2.ThermodynamicState state_b2_inflow=
          Medium2.setState_phX(port_b2.p, inStream(port_b2.h_outflow), inStream(port_b2.Xi_outflow))
        "state for medium inflowing through port_b2";

        annotation (
        preferedView="info",
          Diagram(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics),
          Documentation(info="<html>
<p>
This component defines the interface for models that 
transport two fluid streams between four ports. 
It is similar to 
<a href=\"modelica://Buildings.Fluid.Interfaces.PartialTwoPortInterface\">
Buildings.Fluid.Interfaces.PartialTwoPortInterface</a>,
but it has four ports instead of two.
<p>
The model is used by other models in this package that add heat transfer,
mass transfer and pressure drop equations.
</p>
</html>",       revisions="<html>
<ul>
<li>
March 27, 2011 by Michael Wetter:<br>
Added <code>homotopy</code> operator.
</li>
<li>
March 21, 2010 by Michael Wetter:<br>
Changed pressure start value from <code>system.p_start</code>
to <code>Medium.p_default</code> since HVAC models may have water and 
air, which are typically at different pressures.
</li>
<li>
September 19, 2008 by Michael Wetter:<br>
Added equations for the mass balance of extra species flow,
i.e., <code>C</code> and <code>mC_flow</code>.
</li>
<li>
April 28, 2008, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
      end PartialFourPortInterface;

      model LumpedVolume "Lumped volume with mass and energy balance"

      //  outer Modelica.Fluid.System system "System properties";
        extends Buildings.Fluid.Interfaces.LumpedVolumeDeclarations;
        // Port definitions
        parameter Integer nPorts=0 "Number of ports"
          annotation(Evaluate=true, Dialog(connectorSizing=true, tab="General",group="Ports"));
        Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b ports[nPorts](
            redeclare each package Medium = Medium) "Fluid inlets and outlets"
          annotation (Placement(transformation(extent={{-40,-10},{40,10}},
            origin={0,-100})));

        // Set nominal attributes where literal values can be used.
        Medium.BaseProperties medium(
          preferredMediumStates= not (energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState),
          p(start=p_start,
            nominal=Medium.p_default,
            stateSelect=if not (massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)
                           then StateSelect.prefer else StateSelect.default),
          h(start=Medium.specificEnthalpy_pTX(p_start, T_start, X_start)),
          T(start=T_start,
            nominal=Medium.T_default,
            stateSelect=if (not (energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState))
                           then StateSelect.prefer else StateSelect.default),
          Xi(start=X_start[1:Medium.nXi],
             nominal=Medium.X_default[1:Medium.nXi],
             stateSelect=if (not (substanceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState))
                           then StateSelect.prefer else StateSelect.default),
          d(start=rho_nominal)) "Medium properties";

        Modelica.SIunits.Energy U "Internal energy of fluid";
        Modelica.SIunits.Mass m "Mass of fluid";
        Modelica.SIunits.Mass[Medium.nXi] mXi
        "Masses of independent components in the fluid";
        Modelica.SIunits.Mass[Medium.nC] mC
        "Masses of trace substances in the fluid";
        // C need to be added here because unlike for Xi, which has medium.Xi,
        // there is no variable medium.C
        Medium.ExtraProperty C[Medium.nC](nominal=C_nominal)
        "Trace substance mixture content";

        Modelica.SIunits.MassFlowRate mb_flow "Mass flows across boundaries";
        Modelica.SIunits.MassFlowRate[Medium.nXi] mbXi_flow
        "Substance mass flows across boundaries";
        Medium.ExtraPropertyFlowRate[Medium.nC] mbC_flow
        "Trace substance mass flows across boundaries";
        Modelica.SIunits.EnthalpyFlowRate Hb_flow
        "Enthalpy flow across boundaries or energy source/sink";

        // Inputs that need to be defined by an extending class
        input Modelica.SIunits.Volume fluidVolume "Volume";
        input Modelica.SIunits.HeatFlowRate Q_flow
        "Net heat input into component other than through the fluid ports";
        input Modelica.SIunits.MassFlowRate[Medium.nXi] mXi_flow
        "Net substance mass flow rate into the component other than through the fluid ports";

        // Outputs that are needed in models that extend this model
        Modelica.Blocks.Interfaces.RealOutput hOut(unit="J/kg")
        "Leaving temperature of the component";
        Modelica.Blocks.Interfaces.RealOutput XiOut[Medium.nXi](unit="1")
        "Leaving species concentration of the component";
        Modelica.Blocks.Interfaces.RealOutput COut[Medium.nC](unit="1")
        "Leaving trace substances of the component";
    protected
        parameter Boolean initialize_p = not Medium.singleState
        "= true to set up initial equations for pressure";

        Medium.EnthalpyFlowRate ports_H_flow[nPorts];
        Medium.MassFlowRate ports_mXi_flow[nPorts,Medium.nXi];
        Medium.ExtraPropertyFlowRate ports_mC_flow[nPorts,Medium.nC];

        parameter Modelica.SIunits.Density rho_nominal=Medium.density(
         Medium.setState_pTX(
           T=T_start,
           p=p_start,
           X=X_start[1:Medium.nXi])) "Density, used to compute fluid mass"
        annotation (Evaluate=true);

      equation
        // Total quantities
        m = fluidVolume*medium.d;
        mXi = m*medium.Xi;
        U = m*medium.u;
        mC = m*C;

        hOut = medium.h;
        XiOut = medium.Xi;
        COut = C;

        for i in 1:nPorts loop
          ports_H_flow[i]     = ports[i].m_flow * actualStream(ports[i].h_outflow)
          "Enthalpy flow";
          ports_mXi_flow[i,:] = ports[i].m_flow * actualStream(ports[i].Xi_outflow)
          "Component mass flow";
          ports_mC_flow[i,:]  = ports[i].m_flow * actualStream(ports[i].C_outflow)
          "Trace substance mass flow";
        end for;

        for i in 1:Medium.nXi loop
          mbXi_flow[i] = sum(ports_mXi_flow[:,i]);
        end for;

        for i in 1:Medium.nC loop
          mbC_flow[i]  = sum(ports_mC_flow[:,i]);
        end for;

        mb_flow = sum(ports.m_flow);
        Hb_flow = sum(ports_H_flow);

        // Energy and mass balances
        if energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
          0 = Hb_flow + Q_flow;
        else
          der(U) = Hb_flow + Q_flow;
        end if;

        if massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
          0 = mb_flow + sum(mXi_flow);
        else
          der(m) = mb_flow + sum(mXi_flow);
        end if;

        if substanceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
          zeros(Medium.nXi) = mbXi_flow + mXi_flow;
        else
          der(mXi) = mbXi_flow + mXi_flow;
        end if;

        if traceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
          zeros(Medium.nC)  = mbC_flow;
        else
          der(mC)  = mbC_flow;
        end if;

        // Properties of outgoing flows
        for i in 1:nPorts loop
            ports[i].p          = medium.p;
            ports[i].h_outflow  = medium.h;
            ports[i].Xi_outflow = medium.Xi;
            ports[i].C_outflow  = C;
        end for;
      initial equation
        // Make sure that if energyDynamics is SteadyState, then
        // massDynamics is also SteadyState.
        // Otherwise, the system of ordinary differential equations may be inconsistent.
        if energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
          assert(massDynamics == energyDynamics, "
         If 'massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState', then it is 
         required that 'energyDynamics==Modelica.Fluid.Types.Dynamics.SteadyState'.
         Otherwise, the system of equations may not be consistent.
         You need to select other parameter values.");
        end if;

        // initialization of balances
        if energyDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial then
      //    if use_T_start then
            medium.T = T_start;
      //    else
      //      medium.h = h_start;
      //    end if;
        else
          if energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
      //      if use_T_start then
              der(medium.T) = 0;
      //      else
      //        der(medium.h) = 0;
      //      end if;
          end if;
        end if;

        if massDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial then
          if initialize_p then
            medium.p = p_start;
          end if;
        else
          if massDynamics == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
            if initialize_p then
              der(medium.p) = 0;
            end if;
          end if;
        end if;

        if substanceDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial then
          medium.Xi = X_start[1:Medium.nXi];
        else
          if substanceDynamics == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
            der(medium.Xi) = zeros(Medium.nXi);
          end if;
        end if;

        if traceDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial then
          C = C_start[1:Medium.nC];
        else
          if traceDynamics == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
            der(C) = zeros(Medium.nC);
          end if;
        end if;

        annotation (
          Documentation(info="<html>
<p>
Basic model for an ideally mixed fluid volume with the ability to store mass and energy.
</p>
<h4>Implementation</h4>
<p>
When extending or instantiating this model, the following inputs need to be assigned:
<ul>
<li>
<code>fluidVolume</code>, which is the actual volume occupied by the fluid.
For most components, this can be set to a parameter. However, for components such as 
expansion vessels, the fluid volume can change in time.
</li>
<li>
<code>Q_flow</code>, which is the sensible plus latent heat flow rate added to the medium.
</li>
<li>
<code>mXi_flow</code>, which is the species mass flow rate added to the medium.
</li>
</ul>
</p>
<p>
The model can be used as a dynamic model or as a steady-state model.
However, for a steady-state model with exactly two fluid ports connected, 
the model
<a href=\"modelica://Buildings.Fluid.Interfaces.StaticTwoPortHeatMassExchanger\">
Buildings.Fluid.Interfaces.StaticTwoPortHeatMassExchanger</a>
provides a more efficient implementation.
</p>
<p>
For models that instantiates this model, see
<a href=\"modelica://Buildings.Fluid.MixingVolumes.MixingVolume\">
Buildings.Fluid.MixingVolumes.MixingVolume</a> and
<a href=\"modelica://Buildings.Fluid.Storage.ExpansionVessel\">
Buildings.Fluid.Storage.ExpansionVessel</a>.
</p>
</html>",       revisions="<html>
<ul>
<li>
July 31, 2011 by Michael Wetter:<br>
Added test to stop model translation if the setting for
<code>energyBalance</code> and <code>massBalance</code>
can lead to inconsistent equations.
</li>
<li>
July 26, 2011 by Michael Wetter:<br>
Removed the option to use <code>h_start</code>, as this
is not needed for building simulation. 
Also removed the reference to <code>Modelica.Fluid.System</code>.
Moved parameters and medium to 
<a href=\"Buildings.Fluid.Interfaces.LumpedVolumeDeclarations\">
Buildings.Fluid.Interfaces.LumpedVolumeDeclarations</a>.
<li>
July 14, 2011 by Michael Wetter:<br>
Added start value for medium density.
</li>
<li>
March 29, 2011 by Michael Wetter:<br>
Changed default value for <code>substanceDynamics</code> and
<code>traceDynamics</code> from <code>energyDynamics</code>
to <code>massDynamics</code>.
</li>
<li>
September 28, 2010 by Michael Wetter:<br>
Changed array index for nominal value of <code>Xi</code>.
<li>
September 13, 2010 by Michael Wetter:<br>
Set nominal attributes for medium based on default medium values.
</li>
<li>
July 30, 2010 by Michael Wetter:<br>
Added parameter <code>C_nominal</code> which is used as the nominal attribute for <code>C</code>.
Without this value, the ODE solver gives wrong results for concentrations around 1E-7.
</li>
<li>
March 21, 2010 by Michael Wetter:<br>
Changed pressure start value from <code>system.p_start</code>
to <code>Medium.p_default</code> since HVAC models may have water and 
air, which are typically at different pressures.
</li>
<li><i>February 6, 2010</i> by Michael Wetter:<br>
Added to <code>Medium.BaseProperties</code> the initialization 
<code>X(start=X_start[1:Medium.nX])</code>. Previously, the initialization
was only done for <code>Xi</code> but not for <code>X</code>, which caused the
medium to be initialized to <code>reference_X</code>, ignoring the value of <code>X_start</code>.
</li>
<li><i>October 12, 2009</i> by Michael Wetter:<br>
Implemented first version in <code>Buildings</code> library, based on model from
<code>Modelica.Fluid 1.0</code>.
</li>
</ul>
</html>"),Diagram(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{
                  100,100}}),
                  graphics));
      end LumpedVolume;

      record TwoPortFlowResistanceParameters
      "Parameters for flow resistance for models with two ports"

        parameter Boolean computeFlowResistance = true
        "=true, compute flow resistance. Set to false to assume no friction"
          annotation (Evaluate=true, Dialog(tab="Flow resistance"));

        parameter Boolean from_dp = false
        "= true, use m_flow = f(dp) else dp = f(m_flow)"
          annotation (Evaluate=true, Dialog(enable = computeFlowResistance,
                      tab="Flow resistance"));
        parameter Modelica.SIunits.Pressure dp_nominal(min=0, displayUnit="Pa")
        "Pressure"                                  annotation(Dialog(group = "Nominal condition"));
        parameter Boolean linearizeFlowResistance = false
        "= true, use linear relation between m_flow and dp for any flow rate"
          annotation(Dialog(enable = computeFlowResistance,
                     tab="Flow resistance"));
        parameter Real deltaM = 0.1
        "Fraction of nominal flow rate where flow transitions to laminar"
          annotation(Dialog(enable = computeFlowResistance, tab="Flow resistance"));

      annotation (preferedView="info",
      Documentation(info="<html>
This class contains parameters that are used to
compute the pressure drop in models that have one fluid stream.
Note that the nominal mass flow rate is not declared here because
the model 
<a href=\"modelica://Buildings.Fluid.Interfaces.PartialTwoPortInterface\">
PartialTwoPortInterface</a>
already declares it.
</html>",
      revisions="<html>
<ul>
<li>
April 13, 2009, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
      end TwoPortFlowResistanceParameters;

      record FourPortFlowResistanceParameters
      "Parameters for flow resistance for models with four ports"

        parameter Boolean computeFlowResistance1 = true
        "=true, compute flow resistance. Set to false to assume no friction"
          annotation (Evaluate=true, Dialog(tab="Flow resistance", group="Medium 1"));

        parameter Boolean from_dp1 = false
        "= true, use m_flow = f(dp) else dp = f(m_flow)"
          annotation (Evaluate=true, Dialog(enable = computeFlowResistance1,
                      tab="Flow resistance", group="Medium 1"));
        parameter Modelica.SIunits.Pressure dp1_nominal(min=0, displayUnit="Pa")
        "Pressure"   annotation(Dialog(group = "Nominal condition"));
        parameter Boolean linearizeFlowResistance1 = false
        "= true, use linear relation between m_flow and dp for any flow rate"
          annotation(Dialog(enable = computeFlowResistance1,
                     tab="Flow resistance", group="Medium 1"));
        parameter Real deltaM1 = 0.1
        "Fraction of nominal flow rate where flow transitions to laminar"
          annotation(Dialog(enable = computeFlowResistance1,
                            tab="Flow resistance", group="Medium 1"));
        parameter Boolean computeFlowResistance2 = true
        "=true, compute flow resistance. Set to false to assume no friction"
          annotation (Evaluate=true, Dialog(tab="Flow resistance", group="Medium 2"));

        parameter Boolean from_dp2 = false
        "= true, use m_flow = f(dp) else dp = f(m_flow)"
          annotation (Evaluate=true, Dialog(enable = computeFlowResistance2,
                      tab="Flow resistance", group="Medium 2"));
        parameter Modelica.SIunits.Pressure dp2_nominal(min=0, displayUnit="Pa")
        "Pressure"   annotation(Dialog(group = "Nominal condition"));
        parameter Boolean linearizeFlowResistance2 = false
        "= true, use linear relation between m_flow and dp for any flow rate"
          annotation(Dialog(enable = computeFlowResistance2,
                     tab="Flow resistance", group="Medium 2"));
        parameter Real deltaM2 = 0.1
        "Fraction of nominal flow rate where flow transitions to laminar"
          annotation(Dialog(enable = computeFlowResistance2,
                            tab="Flow resistance", group="Medium 2"));
      annotation (preferedView="info",
      Documentation(info="<html>
This class contains parameters that are used to
compute the pressure drop in components that have two fluid streams.
Note that the nominal mass flow rate is not declared here because
the model 
<a href=\"modelica://Buildings.Fluid.Interfaces.PartialFourPortInterface\">
PartialFourPortInterface</a>
already declares it.
</html>",
      revisions="<html>
<ul>
<li>
April 13, 2009, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
      end FourPortFlowResistanceParameters;

      record LumpedVolumeDeclarations "Declarations for lumped volumes"
        replaceable package Medium =
          Modelica.Media.Interfaces.PartialMedium "Medium in the component"
            annotation (choicesAllMatching = true);

        // Assumptions
        parameter Modelica.Fluid.Types.Dynamics energyDynamics=Modelica.Fluid.Types.Dynamics.DynamicFreeInitial
        "Formulation of energy balance"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));
        parameter Modelica.Fluid.Types.Dynamics massDynamics=energyDynamics
        "Formulation of mass balance"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));
        final parameter Modelica.Fluid.Types.Dynamics substanceDynamics=energyDynamics
        "Formulation of substance balance"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));
        final parameter Modelica.Fluid.Types.Dynamics traceDynamics=energyDynamics
        "Formulation of trace substance balance"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));

        // Initialization
        parameter Medium.AbsolutePressure p_start = Medium.p_default
        "Start value of pressure"
          annotation(Dialog(tab = "Initialization"));
      //  parameter Boolean use_T_start = true "= true, use T_start, otherwise h_start"
       //   annotation(Dialog(tab = "Initialization"), Evaluate=true);
        parameter Medium.Temperature T_start=Medium.T_default
        "Start value of temperature"
          annotation(Dialog(tab = "Initialization"));
      //  parameter Medium.SpecificEnthalpy h_start=
      //    if use_T_start then Medium.specificEnthalpy_pTX(p_start, T_start, X_start) else Medium.h_default
      //    "Start value of specific enthalpy"
      //    annotation(Dialog(tab = "Initialization", enable = not use_T_start));
        parameter Medium.MassFraction X_start[Medium.nX] = Medium.X_default
        "Start value of mass fractions m_i/m"
          annotation (Dialog(tab="Initialization", enable=Medium.nXi > 0));
        parameter Medium.ExtraProperty C_start[Medium.nC](
             quantity=Medium.extraPropertiesNames)=fill(0, Medium.nC)
        "Start value of trace substances"
          annotation (Dialog(tab="Initialization", enable=Medium.nC > 0));
        parameter Medium.ExtraProperty C_nominal[Medium.nC](
             quantity=Medium.extraPropertiesNames) = fill(1E-2, Medium.nC)
        "Nominal value of trace substances. (Set to typical order of magnitude.)"
         annotation (Dialog(tab="Initialization", enable=Medium.nC > 0));

      annotation (preferedView="info",
      Documentation(info="<html>
<p>
This class contains parameters and medium properties
that are used in the lumped  volume model, and in models that extend the 
lumped volume model.
</p>
<p>
These parameters are used by
<a href=\"modelica://Buildings.Fluid.Interfaces.LumpedVolume\">
Buildings.Fluid.Interfaces.LumpedVolume</a>,
<a href=\"modelica://Buildings.Fluid.MixingVolumes.MixingVolume\">
Buildings.Fluid.MixingVolumes.MixingVolume</a>,
<a href=\"modelica://Buildings.Rooms.MixedAir\">
Buildings.Rooms.MixedAir</a>, and by
<a href=\"modelica://Buildings.Rooms.BaseClasses.MixedAir\">
Buildings.Rooms.BaseClasses.MixedAir</a>.
</p>
</html>",
      revisions="<html>
<ul>
<li>
August 2, 2011, by Michael Wetter:<br>
Set <code>substanceDynamics</code> and <code>traceDynamics<code> to final
and equal to <code>energyDynamics</code>, 
as there is no need to make them different from <code>energyDynamics</code>.
</li>
<li>
August 1, 2011, by Michael Wetter:<br>
Changed default value for <code>energyDynamics</code> to
<code>Modelica.Fluid.Types.Dynamics.DynamicFreeInitial</code> because
<code>Modelica.Fluid.Types.Dynamics.SteadyStateInitial</code> leads
to high order DAE that Dymola cannot reduce.
</li>
<li>
July 31, 2011, by Michael Wetter:<br>
Changed default value for <code>energyDynamics</code> to
<code>Modelica.Fluid.Types.Dynamics.SteadyStateInitial</code>.
</li>
<li>
April 13, 2009, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
      end LumpedVolumeDeclarations;
    annotation (preferedView="info", Documentation(info="<html>
This package contains basic classes that are used to build
component models that change the state of the
fluid. The classes are not directly usable, but can
be extended when building a new model.
</html>"));
    end Interfaces;
  annotation (
  preferedView="info", Documentation(info="<html>
This package contains components for fluid flow systems such as
pumps, valves and sensors. For other fluid flow models, see 
<a href=\"Modelica:Modelica.Fluid\">Modelica.Fluid</a>.
</html>"));
  end Fluid;

  package HeatTransfer "Package with heat transfer models"
    extends Modelica.Icons.Package;

    package Conduction "Package with models for heat conduction"
      extends Modelica.Icons.VariantsPackage;

      model SingleLayer "Model for single layer heat conductance"
        extends Buildings.HeatTransfer.Conduction.BaseClasses.PartialConductor(
         final R=if (material.R == 0) then material.x/material.k/A else material.R/A);
         // if material.R == 0, then the material specifies material.k, and this model specifies x
         // For resistances, material.k need not be specified, and hence we use material.R
        // The value T[:].start is used by the solver when finding initial states
        // that satisfy dT/dt=0, which requires solving a system of nonlinear equations
        // if the convection coefficient is a function of temperature.
        Modelica.SIunits.Temperature T[nSta](start=
           {T_a_start+(T_b_start-T_a_start) * UA *
              sum(1/(if (k==1 or k==nSta+1) then UAnSta2 else UAnSta) for k in 1:i) for i in 1:nSta},
            each nominal = 300) "Temperature at the states";
        Modelica.SIunits.HeatFlowRate Q_flow[nSta+1]
        "Heat flow rate from state i to i+1";

        replaceable parameter Data.BaseClasses.Material material
        "Material from Data.Solids or Data.Resistances"
          annotation (choicesAllMatching=true);

        parameter Boolean steadyStateInitial=false
        "=true initializes dT(0)/dt=0, false initializes T(0) at fixed temperature using T_a_start and T_b_start"
              annotation (Dialog(group="Initialization"), Evaluate=true);
        parameter Modelica.SIunits.Temperature T_a_start=293.15
        "Initial temperature at port_a, used if steadyStateInitial = false"
          annotation (Dialog(group="Initialization", enable=not steadyStateInitial));
        parameter Modelica.SIunits.Temperature T_b_start=293.15
        "Initial temperature at port_b, used if steadyStateInitial = false"
          annotation (Dialog(group="Initialization", enable=not steadyStateInitial));
    protected
        parameter Modelica.SIunits.HeatCapacity C = A*material.x*material.d*material.c/material.nSta
        "Heat capacity associated with the temperature state";
        // nodes at surface have only 1/2 the layer thickness
      //  final parameter Modelica.SIunits.ThermalConductance G[nSta+1](each fixed=false)
       //   "Thermal conductance of layer between the states";
        Modelica.SIunits.TemperatureSlope der_T[nSta]
        "Time derivative of temperature (= der(T))";
        final parameter Integer nSta(min=1) = material.nSta
        "Number of state variables";
        final parameter Modelica.SIunits.ThermalConductance UAnSta = UA*nSta
        "Thermal conductance between nodes";
        final parameter Modelica.SIunits.ThermalConductance UAnSta2 = 2*UAnSta
        "Thermal conductance between nodes and surface boundary";
      initial equation
       // G={UA*nSta * (if (i==1 or i==nSta+1) then 2 else 1) for i in 1:nSta+1};
        // The initialization is only done for materials that store energy.
        if not material.steadyState then
          if steadyStateInitial then
            der_T = zeros(nSta);
          else
            for i in 1:nSta loop
              T[i] = T_a_start+(T_b_start-T_a_start) * UA *
                sum(1/(if (k==1 or k==nSta+1) then UAnSta2 else UAnSta) for k in 1:i);
            end for;
            end if;
         end if;

      equation
          port_a.Q_flow = +Q_flow[1];
          port_b.Q_flow = -Q_flow[nSta+1];

          port_a.T-T[1] = Q_flow[1]/UAnSta2;
          T[nSta] -port_b.T = Q_flow[nSta+1]/UAnSta2;
          for i in 2:nSta loop
             // Q_flow[i] is heat flowing from (i-1) to (i)
             T[i-1]-T[i] = Q_flow[i]/UAnSta;
          end for;
          if material.steadyState then
            der_T = zeros(nSta);
            for i in 2:nSta+1 loop
              Q_flow[i] = Q_flow[1];
            end for;
            else
              for i in 1:nSta loop
                der(T[i]) = (Q_flow[i]-Q_flow[i+1])/C;
                der_T[i] = der(T[i]);
              end for;
          end if;
        annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics), Icon(coordinateSystem(
                preserveAspectRatio=true, extent={{-100,-100},{100,100}}), graphics={
              Rectangle(
                extent={{-94,4},{92,-4}},
                lineColor={0,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{12,8},{14,8},{16,4},{18,-2},{18,-6},{16,-12},{10,-16},{6,-20},
                    {-2,-22},{-6,-18},{-12,-12},{-14,-2},{-12,4},{-10,8},{-8,10},{-6,
                    12},{-2,14},{2,14},{8,12},{12,8}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-6,-16},{2,-18},{8,-16},{14,-14},{10,-16},{6,-20},{-2,-22},{
                    -8,-20},{-12,-12},{-14,-2},{-12,4},{-10,8},{-8,10},{-10,0},{-10,-8},
                    {-6,-16}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-60,54},{-42,-60}},
                lineColor={0,0,0},
                fillColor={192,192,192},
                fillPattern=FillPattern.Backward),
              Text(
                extent={{-100,-74},{6,-92}},
                lineColor={0,0,255},
                textString="%x"),
              Rectangle(
                extent={{44,54},{62,-60}},
                lineColor={0,0,0},
                fillColor={192,192,192},
                fillPattern=FillPattern.Backward),
              Text(
                extent={{8,-68},{86,-98}},
                lineColor={0,0,255},
                textString="%nSta")}),
      defaultComponentName="lay",
          Documentation(info="<html>
This is a model of a heat conductor for a single material
that computes transient or steady-state heat conductions.
</p>
<p>
If the material is a record that extends
<a href=\"modelica://Buildings.HeatTransfer.Data.Solids\">
Buildings.HeatTransfer.Data.Solids</a> and its
specific heat capacity (as defined by the record <code>material.c</code>)
is non-zero, then this model computes <i>transient</i> heat conduction, i.e., it
computes a numerical approximation to the solution of the heat equation
</p>
<p align=\"center\" style=\"font-style:italic;\">
   &rho; c (&part; T(u,t) &frasl; &part;t) = 
    k (&part;&sup2; T(u,t) &frasl; &part;u&sup2;),
</p>
<p>
where 
<i>&rho;</i>
is the mass density,
<i>c</i>
is the specific heat capacity per unit mass,
<i>T</i>
is the temperature at location <i>u</i> and time <i>t</i> and
<i>k</i> is the heat conductivity. 
At the locations <i>u=0</i> and <i>u=x</i>, where <i>x</i> is the
material thickness, the temperature and heat flow rate is equal to the 
temperature and heat flow rate of the heat heat ports.
</p>
<p>
To spatially discretize the heat equation, the construction is 
divided into compartments with <code>material.nSta &ge; 1</code> state variables. 
The state variables are connected to each other through thermal conductors. 
There is also a thermal conductor
between the surfaces and the outermost state variables. Thus, to obtain
the surface temperature, use <code>port_a.T</code> (or <code>port_b.T</code>)
and not the variable <code>T[1]</code>.
Each compartment has the same material properties.
To build multi-layer constructions,
use
<a href=\"Buildings.HeatTransfer.Conduction.MultiLayer\">
Buildings.HeatTransfer.Conduction.MultiLayer</a> instead of this model.
</p>
<p>
If <code>material.c=0</code>, or if the material extends
<a href=\"modelica://Buildings.HeatTransfer.Data.Resistances\">
Buildings.HeatTransfer.Data.Resistances</a>, 
then steady-state heat conduction is computed. In this situation, the heat
flow between its heat ports is
</p>
<p align=\"center\" style=\"font-style:italic;\">
   Q = A &nbsp; k &frasl; x &nbsp; (T<sub>a</sub>-T<sub>b</sub>),
</p></p>
<p>
where
<i>A</i> is the cross sectional area,
<i>x</i> is the layer thickness,
<i>T<sub>a</sub></i> is the temperature at port a and
<i>T<sub>b</sub></i> is the temperature at port b.
</p>
</html>",
      revisions="<html>
<ul>
<li>
March 6 2010, by Michael Wetter:<br>
Changed implementation to allow steady-state and transient heat conduction
depending on the specific heat capacity of the material. This allows using the
same model in composite constructions in which some layers are
computed steady-state and other transient.
</li><li>
February 5 2009, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
      end SingleLayer;

      model MultiLayer
      "Model for heat conductance through a solid with multiple material layers"
        extends Buildings.HeatTransfer.Conduction.BaseClasses.PartialConductor(
         final R=sum(lay[:].R));
        Modelica.SIunits.Temperature T[sum(nSta)](each nominal = 300)
        "Temperature at the states";
        Modelica.SIunits.HeatFlowRate Q_flow[sum(nSta)+nLay]
        "Heat flow rate from state i to i+1";
        extends
        Buildings.HeatTransfer.Conduction.BaseClasses.PartialConstruction;

    protected
        Buildings.HeatTransfer.Conduction.SingleLayer[nLay] lay(
         each final A=A,
         material = layers.material,
         T_a_start = _T_a_start,
         T_b_start = _T_b_start,
         each steadyStateInitial = steadyStateInitial) "Material layer"
          annotation (Placement(transformation(extent={{-20,-10},{0,10}})));

    protected
        parameter Modelica.SIunits.Temperature _T_a_start[nLay](fixed=false)
        "Initial temperature at port_a of respective layer, used if steadyStateInitial = false";
        parameter Modelica.SIunits.Temperature _T_b_start[nLay](fixed=false)
        "Initial temperature at port_b of respective layer, used if steadyStateInitial = false";

      initial equation
        for i in 1:nLay loop
          _T_a_start[i] = T_b_start+(T_a_start-T_b_start) * 1/R * sum(lay[k].R for k in i:nLay);
          _T_b_start[i] =  T_a_start+(T_b_start-T_a_start) * 1/R * sum(lay[k].R for k in 1:i);
        end for;

      equation
        // This section assigns the temperatures and heat flow rates of the layer models to
        // an array that makes plotting the results easier.
        for i in 1:nLay loop
          for j in 1:nSta[i] loop
            T[sum(nSta[k] for k in 1:(i-1)) +j] = lay[i].T[j];
          end for;
          for j in 1:nSta[i]+1 loop
            Q_flow[sum(nSta[k] for k in 1:i-1)+(i-1)+j] = lay[i].Q_flow[j];
          end for;
        end for;
        connect(port_a, lay[1].port_a) annotation (Line(
            points={{-100,5.55112e-16},{-60,5.55112e-16},{-60,6.10623e-16},{-20,
                6.10623e-16}},
            color={191,0,0},
            smooth=Smooth.None));
        for i in 1:nLay-1 loop
        connect(lay[i].port_b, lay[i+1].port_a) annotation (Line(
            points={{5.55112e-16,6.10623e-16},{20,6.10623e-16},{20,-20},{-40,-20},{
                  -40,6.10623e-16},{-20,6.10623e-16}},
            color={191,0,0},
            smooth=Smooth.None));
        end for;
        connect(lay[nLay].port_b, port_b) annotation (Line(
            points={{5.55112e-16,6.10623e-16},{49,6.10623e-16},{49,5.55112e-16},{100,
                5.55112e-16}},
            color={191,0,0},
            smooth=Smooth.None));

        annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics), Icon(coordinateSystem(
                preserveAspectRatio=true, extent={{-100,-100},{100,100}}), graphics={
              Rectangle(
                extent={{-90,2},{92,-4}},
                lineColor={0,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-36,12},{-34,12},{-32,8},{-30,2},{-30,-2},{-32,-8},{-38,-12},
                    {-42,-16},{-50,-18},{-54,-14},{-60,-8},{-62,2},{-60,8},{-58,12},{
                    -56,14},{-54,16},{-50,18},{-46,18},{-40,16},{-36,12}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-54,-12},{-46,-14},{-40,-12},{-34,-10},{-38,-12},{-42,-16},{
                    -50,-18},{-56,-16},{-60,-8},{-62,2},{-60,8},{-58,12},{-56,14},{-58,
                    4},{-58,-4},{-54,-12}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-80,50},{-68,-52}},
                lineColor={0,0,0},
                fillColor={192,192,192},
                fillPattern=FillPattern.Backward),
              Polygon(
                points={{50,10},{52,10},{54,6},{56,0},{56,-4},{54,-10},{48,-14},{44,-18},
                    {36,-20},{32,-16},{26,-10},{24,0},{26,6},{28,10},{30,12},{32,14},
                    {36,16},{40,16},{46,14},{50,10}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{32,-14},{40,-16},{46,-14},{52,-12},{48,-14},{44,-18},{36,-20},
                    {30,-18},{26,-10},{24,0},{26,6},{28,10},{30,12},{28,2},{28,-6},{
                    32,-14}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-20,50},{-8,-52}},
                lineColor={0,0,0},
                fillColor={192,192,192},
                fillPattern=FillPattern.Backward),
              Rectangle(
                extent={{4,50},{16,-52}},
                lineColor={0,0,0},
                fillColor={95,95,95},
                fillPattern=FillPattern.Forward),
              Rectangle(
                extent={{64,48},{76,-54}},
                lineColor={0,0,0},
                fillColor={95,95,95},
                fillPattern=FillPattern.Forward)}),
          defaultComponentName="heaCon",
          Documentation(info="<html>
This is a model of a heat conductor with multiple material layers and energy storage.
The construction has at least one material layer, and each layer has
at least one temperature node. The layers are modeled using an instance of 
<a href=\"Buildings.HeatTransfer.Conduction.SingleLayer\">
Buildings.HeatTransfer.Conduction.SingleLayer</a>.
</p>
The construction material is defined by a record of the package
<a href=\"modelica://Buildings.HeatTransfer.Data.OpaqueConstructions\">
Buildings.HeatTransfer.Data.OpaqueConstructions</a>.
This record allows specifying materials that store energy, and material
that are a thermal conductor only with no heat storage.
</p>
<p>
To obtain the surface temperature of the construction, use <code>port_a.T</code> (or <code>port_b.T</code>)
and not the variable <code>T[1]</code> because there is a thermal resistance between the surface
and the temperature state.
</p>
</html>",       revisions="<html>
<ul>
<li>
March 6 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
      end MultiLayer;

      package BaseClasses
      "Package with base classes for Buildings.HeatTransfer.Conduction"
        extends Modelica.Icons.BasesPackage;

        partial model PartialConductor "Partial model for heat conductor"
          extends Buildings.BaseClasses.BaseIcon;
          parameter Modelica.SIunits.Area A "Heat transfer area";
          final parameter Modelica.SIunits.CoefficientOfHeatTransfer U = UA/A
          "U-value (without surface heat transfer coefficients)";
          final parameter Modelica.SIunits.ThermalConductance UA = 1/R
          "Thermal conductance of construction (without surface heat transfer coefficients)";
          parameter Modelica.SIunits.ThermalResistance R
          "Thermal resistance of construction";
          Modelica.SIunits.TemperatureDifference dT "port_a.T - port_b.T";
      public
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_a
          "Heat port at surface a"   annotation (Placement(transformation(extent={{-110,-10},
                    {-90,10}}, rotation=0)));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b port_b
          "Heat port at surface b"   annotation (Placement(transformation(extent={{90,-10},{
                    110,10}}, rotation=0)));
        equation
          dT = port_a.T - port_b.T;
          annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                    -100},{100,100}}), graphics), Icon(coordinateSystem(
                  preserveAspectRatio=true, extent={{-100,-100},{100,100}}), graphics),
            Documentation(info="<html>
Partial model for single layer and multi layer heat conductors.
The heat conductor can be steady-state or transient.
</html>",         revisions="<html>
<ul>
<li>
March 6 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end PartialConductor;

        model PartialConstruction "Partial model for multi-layer constructions"
          extends Buildings.BaseClasses.BaseIcon;
          parameter Modelica.SIunits.Area A "Heat transfer area";

          replaceable parameter
          Buildings.HeatTransfer.Data.OpaqueConstructions.Generic
            layers "Construction definition from Data.OpaqueConstructions"
            annotation (Evaluate=true, choicesAllMatching=true, Placement(transformation(extent={{60,60},
                    {80,80}})));

          final parameter Integer nLay(min=1, fixed=true) = layers.nLay
          "Number of layers";
          final parameter Integer nSta[nLay](min=1)={layers.material[i].nSta for i in 1:nLay}
          "Number of states"    annotation(Evaluate=true);
          parameter Boolean steadyStateInitial=false
          "=true initializes dT(0)/dt=0, false initializes T(0) at fixed temperature using T_a_start and T_b_start"
                annotation (Dialog(group="Initialization"), Evaluate=true);
          parameter Modelica.SIunits.Temperature T_a_start=293.15
          "Initial temperature at port_a, used if steadyStateInitial = false"
            annotation (Dialog(group="Initialization", enable=not steadyStateInitial));
          parameter Modelica.SIunits.Temperature T_b_start=293.15
          "Initial temperature at port_b, used if steadyStateInitial = false"
            annotation (Dialog(group="Initialization", enable=not steadyStateInitial));

          annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                    -100},{100,100}}), graphics), Icon(coordinateSystem(
                  preserveAspectRatio=true, extent={{-100,-100},{100,100}}), graphics),
            Documentation(info="<html>
Partial model for constructions and multi-layer heat conductors.
</html>",         revisions="<html>
<ul>
<li>
March 6 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end PartialConstruction;
      annotation (preferedView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.HeatTransfer.Conduction\">Buildings.HeatTransfer.Conduction</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (Documentation(info="<html>
<p>
This package provides component models to compute heat conduction.
</p>
</html>"));
    end Conduction;

    package Convection "Package with models for convective heat transfer"
      extends Modelica.Icons.VariantsPackage;

      model Exterior "Model for a exterior (outside) convective heat transfer"
        extends Buildings.HeatTransfer.Convection.BaseClasses.PartialConvection;

        parameter Buildings.HeatTransfer.Types.ExteriorConvection conMod=
          Buildings.HeatTransfer.Types.ExteriorConvection.TemperatureWind
        "Convective heat transfer model"
        annotation(Evaluate=true);
        parameter Buildings.HeatTransfer.Types.SurfaceRoughness roughness=
          Buildings.HeatTransfer.Types.SurfaceRoughness.Medium
        "Surface roughness"
          annotation (Dialog(enable=(conMod <> Buildings.HeatTransfer.Types.InteriorConvection.Fixed)));
        parameter Modelica.SIunits.Angle azi "Surface azimuth";

        Modelica.Blocks.Interfaces.RealInput v(unit="m/s") "Wind speed"
          annotation (Placement(transformation(extent={{-140,80},{-100,120}})));
        Modelica.Blocks.Interfaces.RealInput dir(unit="rad", displayUnit="deg",
           min=0, max=2*Modelica.Constants.pi)
        "Wind direction (0=wind from North)"
          annotation (Placement(transformation(extent={{-140,30},{-100,70}})));
        Modelica.SIunits.CoefficientOfHeatTransfer hF
        "Convective heat transfer coefficient due to forced convection";
        Modelica.SIunits.HeatFlux qN_flow
        "Convective heat flux from solid -> fluid due to natural convection";
        Modelica.SIunits.HeatFlux qF_flow
        "Convective heat flux from solid -> fluid due to forced convection";
    protected
         parameter Real R(fixed=false) "Surface roughness";
         Real W(min=0.5, max=1) "Wind direction modifier";
      initial equation
        if (roughness == Buildings.HeatTransfer.Types.SurfaceRoughness.VeryRough) then
          R=2.17;
        elseif (roughness == Buildings.HeatTransfer.Types.SurfaceRoughness.Rough) then
          R=1.67;
        elseif (roughness == Buildings.HeatTransfer.Types.SurfaceRoughness.Medium) then
          R=1.52;
        elseif (roughness == Buildings.HeatTransfer.Types.SurfaceRoughness.MediumSmooth) then
          R=1.13;
        elseif (roughness == Buildings.HeatTransfer.Types.SurfaceRoughness.Smooth) then
          R=1.11;
        elseif (roughness == Buildings.HeatTransfer.Types.SurfaceRoughness.VerySmooth) then
          R=1.00;
        else
          R=0;
        end if;
      equation
        if (conMod == Buildings.HeatTransfer.Types.ExteriorConvection.Fixed) then
          qN_flow = hFixed * dT;
          W = 1;
          hF = 0;
          qF_flow = 0;
        else
          // Even if hCon is a step function with a step at zero,
          // the product hCon*dT is differentiable at zero with
          // a continuous first derivative
          if isCeiling then
             qN_flow = Buildings.HeatTransfer.Convection.Functions.HeatFlux.ceiling(
                                                                                   dT=dT);
          elseif isFloor then
             qN_flow = Buildings.HeatTransfer.Convection.Functions.HeatFlux.floor(
                                                                                 dT=dT);
          else
             qN_flow = Buildings.HeatTransfer.Convection.Functions.HeatFlux.wall(
                                                                                dT=dT);
          end if;
          // Forced convection
          W = Buildings.HeatTransfer.Convection.Functions.windDirectionModifier(
                                                                     azi=azi, dir=dir);
          hF = 2.537 * W * R * 2 / A^(0.25) *
               Buildings.Utilities.Math.Functions.regNonZeroPower(x=v, n=0.5, delta=0.5);
          qF_flow = hF*dT;
        end if;
        q_flow = qN_flow + qF_flow;

        annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                  {100,100}}),       graphics), Icon(coordinateSystem(
                preserveAspectRatio=true, extent={{-100,-100},{100,100}}), graphics={
              Rectangle(
                extent={{-100,100},{100,-100}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-90,80},{-60,-80}},
                lineColor={0,0,0},
                fillColor={192,192,192},
                fillPattern=FillPattern.Backward),
              Line(points={{100,0},{100,0}}, color={0,127,255}),
              Line(points={{100,0},{100,0}}, color={0,127,255}),
              Line(points={{100,0},{100,0}}, color={0,127,255}),
              Text(
                extent={{-35,42},{-5,20}},
                lineColor={255,0,0},
                textString="Q_flow"),
              Line(points={{-60,20},{76,20}}, color={191,0,0}),
              Line(points={{-60,-20},{76,-20}}, color={191,0,0}),
              Line(points={{-34,80},{-34,-80}}, color={0,127,255}),
              Line(points={{6,80},{6,-80}}, color={0,127,255}),
              Line(points={{40,80},{40,-80}}, color={0,127,255}),
              Line(points={{76,80},{76,-80}}, color={0,127,255}),
              Line(points={{-34,-80},{-44,-60}}, color={0,127,255}),
              Line(points={{-34,-80},{-24,-60}}, color={0,127,255}),
              Line(points={{6,-80},{-4,-60}}, color={0,127,255}),
              Line(points={{6,-80},{16,-60}}, color={0,127,255}),
              Line(points={{40,-80},{30,-60}}, color={0,127,255}),
              Line(points={{40,-80},{50,-60}}, color={0,127,255}),
              Line(points={{76,-80},{66,-60}}, color={0,127,255}),
              Line(points={{76,-80},{86,-60}}, color={0,127,255}),
              Line(points={{56,-30},{76,-20}}, color={191,0,0}),
              Line(points={{56,-10},{76,-20}}, color={191,0,0}),
              Line(points={{56,10},{76,20}}, color={191,0,0}),
              Line(points={{56,30},{76,20}}, color={191,0,0}),
                                               Text(
                extent={{-102,128},{-64,98}},
                lineColor={0,0,127},
                textString="v"),               Text(
                extent={{-100,64},{-62,34}},
                lineColor={0,0,127},
                textString="dir")}),
          defaultComponentName="con",
          Documentation(info="<html>
This is a model for a convective heat transfer for exterior, outside-facing surfaces.
The parameter <code>conMod</code> determines the model that is used to compute
the heat transfer coefficient:
</p>
<p>
<ol>
<li><p>If <code>conMod=
<a href=\"modelica://Buildings.HeatTransfer.Types.ExteriorConvection\">
Buildings.HeatTransfer.Types.ExteriorConvection.Fixed</a>
</code>, then
the convective heat transfer coefficient is set to the value specified by the parameter
<code>hFixed</code>.
</p>
</li>
<li>
<p>
If <code>conMod=
<a href=\"modelica://Buildings.HeatTransfer.Types.ExteriorConvection\">
Buildings.HeatTransfer.Types.ExteriorConvection.TemperatureWind</a>
</code>,
then the convective heat transfer coefficient is
computed based on wind speed, wind direction and temperature difference.
</p>
<p>
The total convection coefficient <i>h<sub>t</sub></i> is the sum of the 
temperature-driven free convection coefficient <i>h<sub>n</sub></i>
and the wind-driven forced convection coefficient <i>h<sub>f</sub></i>,
<p align=\"center\" style=\"font-style:italic;\">
 h<sub>t</sub> = h<sub>n</sub> + h<sub>f</sub>
</p>
The free convection coefficient <i>h<sub>n</sub></i> is computed in the same way as in 
<a href=\"modelica://Buildings.HeatTransfer.Convection.Interior\">
Buildings.HeatTransfer.Convection.Interior</a>.
The forced convection coefficient <i>h<sub>f</i> 
is computed based on a correlation by Sparrow, Ramsey, and Mass
(1979), which is 
<p align=\"center\" style=\"font-style:italic;\">
 h<sub>f</sub> = 2.537 W R &radic;( P v &frasl; A )
</p>
<p>
where <i>W=1</i> for windward surfaces and 
<i>W=0.5</i> for leeward surfaces, with leeward defined as greater than 100 degrees
from normal incidence,
<i>R</i> is a surface roughness multiplier,
<i>P</i> is the perimeter of the surface and
<i>A</i> is the area of the surface.
This is the same equation as implemented in EnergyPlus 6.0.
</p>
<p>
We make the simplified assumption that the surface is square, and hence we set
<p align=\"center\" style=\"font-style:italic;\">
 h<sub>f</sub> = 2.537 W R &radic;( 4 v &frasl; &radic;(A) )
</p>
<p>
The surface roughness is specified by the parameter <code>surfaceRoughness</code>
which has to be set to a type of
<a href=\"modelica://Buildings.HeatTransfer.Types.SurfaceRoughness\">
Buildings.HeatTransfer.Types.SurfaceRoughness</a>.The coefficients for the surface roughness are
</p>
<p>
<table border=\"1\">
<tr>
<th>Roughness index</th>
<th><i>R</i></th>
<th>Example material</th>
</tr>
<tr><td>VeryRough</td>   <td>2.17</td>  <td>Stucco</td></tr>
<tr><td>Rough</td>        <td>1.67</td>  <td>Brick</td></tr>
<tr><td>MediumRough</td> <td>1.52</td>  <td>Concrete</td></tr>
<tr><td>MediumSmooth</td><td>1.13</td>  <td>Clear pine</td></tr>
<tr><td>Smooth</td>       <td>1.11</td>  <td>Smooth plaster</td></tr>
<tr><td>VerySmooth</td>  <td>1.00</td>  <td>Glass</td></tr>
</tr>
</table>
</p>
</li>
</ol>
<h4>References</h4>
<p>
Sparrow, E. M., J. W. Ramsey, and E. A. Mass. 1979. Effect of Finite Width on Heat Transfer 
and Fluid Flow about an Inclined Rectangular Plate. Journal of Heat Transfer, Vol. 101, p.
204.
</p>
<p>
Walton, G. N. 1981. Passive Solar Extension of the Building Loads Analysis and System
Thermodynamics (BLAST) Program, Technical Report, United States Army Construction
Engineering Research Laboratory, Champaign, IL.
</p>
</html>",       revisions="<html>
<ul>
<li>
November 29, 2011, by Michael Wetter:<br>
Fixed error in assignment of wind-based convection coefficient. 
The old implementation did not take into account the surface roughness.
Bug fix is due to feedback from Tobias Klingbeil (Fraunhofer ISE).
</li>
<li>
March 10 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
      end Exterior;

      model Interior
      "Model for a interior (room-side) convective heat transfer"
        extends Buildings.HeatTransfer.Convection.BaseClasses.PartialConvection;

        parameter Buildings.HeatTransfer.Types.InteriorConvection conMod=
          Buildings.HeatTransfer.Types.InteriorConvection.Fixed
        "Convective heat transfer model"
        annotation(Evaluate=true);
        parameter Boolean homotopyInitialization = true
        "= true, use homotopy method"
          annotation(Evaluate=true, Dialog(tab="Advanced"));
    protected
        constant Modelica.SIunits.Temperature dT0 = 2
        "Initial temperature used in homotopy method";
      equation
        if (conMod == Buildings.HeatTransfer.Types.InteriorConvection.Fixed) then
          q_flow = hFixed * dT;
        else
          // Even if hCon is a step function with a step at zero,
          // the product hCon*dT is differentiable at zero with
          // a continuous first derivative
          if homotopyInitialization then
            if isCeiling then
               q_flow = homotopy(actual=Buildings.HeatTransfer.Convection.Functions.HeatFlux.ceiling(dT=dT),
                          simplified=dT/dT0*Buildings.HeatTransfer.Convection.Functions.HeatFlux.ceiling(dT=dT0));
            elseif isFloor then
               q_flow = homotopy(actual=Buildings.HeatTransfer.Convection.Functions.HeatFlux.floor(dT=dT),
                          simplified=dT/dT0*Buildings.HeatTransfer.Convection.Functions.HeatFlux.floor(dT=dT0));
            else
               q_flow = homotopy(actual=Buildings.HeatTransfer.Convection.Functions.HeatFlux.wall(dT=dT),
                          simplified=dT/dT0*Buildings.HeatTransfer.Convection.Functions.HeatFlux.wall(dT=dT0));
            end if;
          else
            if isCeiling then
               q_flow = Buildings.HeatTransfer.Convection.Functions.HeatFlux.ceiling(dT=dT);
            elseif isFloor then
               q_flow = Buildings.HeatTransfer.Convection.Functions.HeatFlux.floor(dT=dT);
            else
               q_flow = Buildings.HeatTransfer.Convection.Functions.HeatFlux.wall(dT=dT);
            end if;
          end if;

        end if;

        annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                  {100,100}}),       graphics), Icon(coordinateSystem(
                preserveAspectRatio=true, extent={{-100,-100},{100,100}}), graphics={
              Rectangle(
                extent={{-100,100},{100,-100}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-90,80},{-60,-80}},
                lineColor={0,0,0},
                fillColor={192,192,192},
                fillPattern=FillPattern.Backward),
              Line(points={{100,0},{100,0}}, color={0,127,255}),
              Line(points={{100,0},{100,0}}, color={0,127,255}),
              Line(points={{100,0},{100,0}}, color={0,127,255}),
              Text(
                extent={{-35,42},{-5,20}},
                lineColor={255,0,0},
                textString="Q_flow"),
              Line(points={{-60,20},{76,20}}, color={191,0,0}),
              Line(points={{-60,-20},{76,-20}}, color={191,0,0}),
              Line(points={{-34,80},{-34,-80}}, color={0,127,255}),
              Line(points={{6,80},{6,-80}}, color={0,127,255}),
              Line(points={{40,80},{40,-80}}, color={0,127,255}),
              Line(points={{76,80},{76,-80}}, color={0,127,255}),
              Line(points={{-34,-80},{-44,-60}}, color={0,127,255}),
              Line(points={{-34,-80},{-24,-60}}, color={0,127,255}),
              Line(points={{6,-80},{-4,-60}}, color={0,127,255}),
              Line(points={{6,-80},{16,-60}}, color={0,127,255}),
              Line(points={{40,-80},{30,-60}}, color={0,127,255}),
              Line(points={{40,-80},{50,-60}}, color={0,127,255}),
              Line(points={{76,-80},{66,-60}}, color={0,127,255}),
              Line(points={{76,-80},{86,-60}}, color={0,127,255}),
              Line(points={{56,-30},{76,-20}}, color={191,0,0}),
              Line(points={{56,-10},{76,-20}}, color={191,0,0}),
              Line(points={{56,10},{76,20}}, color={191,0,0}),
              Line(points={{56,30},{76,20}}, color={191,0,0})}),
          defaultComponentName="con",
          Documentation(info="<html>
This is a model for a convective heat transfer for interior, room-facing surfaces.
The parameter <code>conMod</code> determines the model that is used to compute
the heat transfer coefficient:
</p>
<p>
<ol>
<li><p>If <code>conMod=<a href=\"modelica://Buildings.HeatTransfer.Types.InteriorConvection\">
Buildings.HeatTransfer.Types.InteriorConvection.Fixed</a></code>, then
the convective heat transfer coefficient is set to the value specified by the parameter
<code>hFixed</code>.
</p>
</li>
</li>
<p>
If <code>conMod=<a href=\"modelica://Buildings.HeatTransfer.Types.InteriorConvection\">
Buildings.HeatTransfer.Types.InteriorConvection.Temperature</a></code>, then
the convective heat tranfer coefficient is a function of the temperature difference.
The convective heat flux is computed using
</p>
<ol>
<li>
for floors the function 
<a href=\"modelica://Buildings.HeatTransfer.Convection.Functions.ConvectiveHeatFlux.floor\">
Buildings.HeatTransfer.Functions.Convection.ConvectiveHeatFlux.floor</a>
</li>
<li>
for ceilings the function
<a href=\"modelica://Buildings.HeatTransfer.Functions.Convection.ConvectiveHeatFlux.ceiling\">
Buildings.HeatTransfer.Functions.Convection.ConvectiveHeatFlux.ceiling</a>
</li>
<li>
for walls the function
<a href=\"modelica://Buildings.HeatTransfer.Functions.Convection.ConvectiveHeatFlux.wall\">
Buildings.HeatTransfer.Functions.Convection.ConvectiveHeatFlux.wall</a>
</li>
</ol>
</li>
</html>",       revisions="<html>
<ul>
<li>
April 2, 2011 by Michael Wetter:<br>
Added <code>homotopy</code> operator.
</li>
<li>
March 10 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
      end Interior;

      package Functions "Functions for convective heat transfer"

        package HeatFlux "Correlations for convective heat flux"

          function wall "Free convection, wall"
            extends
            Buildings.HeatTransfer.Convection.Functions.HeatFlux.BaseClasses.PartialHeatFlux;
          algorithm
            q_flow := noEvent(smooth(1, if (dT > 0) then 1.3*dT^1.3333 else -1.3*(-dT)^1.3333));

          annotation (smoothOrder=1,
          Documentation(info=
          "<html>
This function computes the buoyancy-driven convective heat transfer coefficient 
for a wall as
<code>h=1.3*|dT|^0.3333</code>,
where <code>dT</code> is the solid temperature minus the fluid temperature.
The convective convective heat flux is then
<code>q_flow = h * dT</code>.
</html>", revisions="<html>
<ul>
<li>
March 10 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
          end wall;

          function floor "Free convection, floor"
            extends
            Buildings.HeatTransfer.Convection.Functions.HeatFlux.BaseClasses.PartialHeatFlux;

          algorithm
            q_flow  := noEvent(smooth(1, if (dT>0) then 1.51*dT^1.3333 else -0.76*(-dT)^1.3333));
          annotation(smoothOrder=1,
                        Documentation(info=
          "<html>
This function computes the buoyancy-driven convective heat transfer coefficient 
for a floor as
<code>h=k*|dT|^0.3333</code>,
where 
<code>k=1.51</code> if the floor is warmer than the fluid,
or <code>k=0.76</code> otherwise, and where
<code>dT</code> is the solid temperature minus the fluid temperature.
The convective convective heat flux is then
<code>q_flow = h * dT</code>.
</html>", revisions="<html>
<ul>
<li>
March 10 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
          end floor;

          function ceiling "Free convection, ceiling"
            extends
            Buildings.HeatTransfer.Convection.Functions.HeatFlux.BaseClasses.PartialHeatFlux;

          algorithm
             q_flow  := noEvent(smooth(1, if (dT>0) then 0.76*dT^1.3333 else -1.51*(-dT)^1.3333));
          annotation(smoothOrder=1,
                      Documentation(info=
          "<html>
This function computes the buoyancy-driven convective heat transfer coefficient 
for a ceiling as
<code>h=k*|dT|^0.3333</code>,
where 
<code>k=1.51</code> if the fluid is warmer than the ceiling,
or <code>k=0.76</code> otherwise, and where
<code>dT</code> is the solid temperature minus the fluid temperature.
The convective convective heat flux is then
<code>q_flow = h * dT</code>.
</html>", revisions="<html>
<ul>
<li>
March 10 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
          end ceiling;

          function raleigh
          "Raleigh number with smooth transition to lower limit"
           input Modelica.SIunits.Length x "Layer thickness";
           input Modelica.SIunits.Density rho "Mass density";
           input Modelica.SIunits.SpecificHeatCapacity c_p
            "Specific heat capacity";
           input Modelica.SIunits.DynamicViscosity mu "Dynamic viscosity";
           input Modelica.SIunits.ThermalConductivity k "Thermal conductivity";
           input Modelica.SIunits.Temperature T_a "Temperature of surface a";
           input Modelica.SIunits.Temperature T_b "Temperature of surface b";
           input Real Ra_min "Minimum value for Raleigh number";
           output Real Ra "Raleigh number";
        protected
           Modelica.SIunits.TemperatureDifference dT "Temperature difference";
          algorithm
            dT :=abs(T_a - T_b);
            Ra := rho^2*x^3*Modelica.Constants.g_n*c_p*dT/((T_a+T_b)/2*mu*k);
            Ra := Buildings.Utilities.Math.Functions.smoothMax(x1=Ra, x2=Ra_min, deltaX=Ra_min/10);
          annotation (smoothOrder=1,
          Documentation(info="<html>
This function returns the Raleigh number.
The parameter <code>RaMin</code> is used to transition
to a lower limit for the Raleigh number.
This is helpful to avoid a Raleigh number of zero or
to avoid an expression for a convection coefficient that
has an infinite derivative near zero, i.e., if <i>h=f(Ra<sup>(1/2)</sup>)</i>.
</html>", revisions="<html>
<ul>
<li>
August 18 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
          end raleigh;

          package BaseClasses
          "Base classes for convective heat transfer coefficients"
            extends Modelica.Icons.BasesPackage;

            partial function PartialHeatFlux
            "Partial function for convective heat flux"
             input Modelica.SIunits.TemperatureDifference dT
              "Temperature difference solid minus fluid";
             output Modelica.SIunits.HeatFlux q_flow
              "Convective heat flux from solid to fluid";
            annotation (Documentation(info=
                                         "<html>
Partial function that is used to implement the convective heat flux
as <code>q_flow = f(dT)</code>,
where <code>dT</code> is the solid temperature minus the fluid temperature.
</html>",           revisions="<html>
<ul>
<li>
March 10 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
            end PartialHeatFlux;
          annotation (preferedView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.HeatTransfer.Convection.Functions.HeatFlux\">Buildings.HeatTransfer.Convection.Functions.HeatFlux</a>.
</p>
</html>"));
          end BaseClasses;
          annotation (Documentation(info="<html>
This package contains functions for the convective heat transfer.
Input into the functions is the temperature difference between 
the solid and the fluid. 
The functions compute the convective heat flux, rather than the 
convective heat transfer coefficient.
The reason is that the convective heat transfer coefficient
is not differentiable around zero for certain flow configurations,
such as buoyancy driven flow at a horizontal surface. However, the
product of convective heat transfer coefficient times temperature 
difference is differentiable around zero.
</html>",         revisions="<html>
<ul>
<li>
March 8 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end HeatFlux;

        function windDirectionModifier
        "Wind direction modifier that is used to compute the wind-driven convective heat transfer coefficient"
          input Modelica.SIunits.Angle azi "Surface azimuth";
          input Modelica.SIunits.Angle dir(min=0, max=2*Modelica.Constants.pi)
          "Wind direction (0=wind from North)";
          output Real W "Wind direction modifier";
      protected
          constant Modelica.SIunits.Angle lee = Modelica.SIunits.Conversions.from_deg(100);
          constant Real cosLee = Modelica.Math.cos(lee);
        algorithm
        // The wind direction is defined in TMY3 as dir=0 if from North, and 0 <= dir < 2*pi
        // Hence, we subtract pi to redefine dir=0 as wind coming from the south.
        // This simplifies the implementation since a surface azimuth is defined as azi=0
        // if the surface is south-facing
          W:=Buildings.Utilities.Math.Functions.spliceFunction(
            pos=0.5,
            neg=1,
            x=cosLee-Modelica.Math.cos(azi+Modelica.Constants.pi-dir),
            deltax=0.05);
            annotation (
        smoothOrder=1,
        Documentation(info="<html>
<p>
Function that outputs <i>1</i> if the incidence angle is below 100 degrees, and
<i>0.5</i> otherwise.
The implementation is once continuously differentiable in its input arguments.
</p>
<p>
See 
<a href=\"modelica://Buildings.HeatTransfer.Examples.ExteriorConvection\">
Buildings.HeatTransfer.Examples.ExteriorConvection</a>
for an example that uses this function.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 30, 2011, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end windDirectionModifier;
        annotation (Documentation(revisions="<html>
<ul>
<li>
March 8 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>",       info="<html>
This package contains functions that are used in the
package 
<a href=\"modelica://Buildings.HeatTransfer\">
Buildings.HeatTransfer</a>.
</html>"));
      end Functions;

      package BaseClasses
      "Package with base classes for Buildings.HeatTransfer.Convection"
        extends Modelica.Icons.BasesPackage;

        partial model PartialConvection "Partial model for heat convection"
          extends Buildings.BaseClasses.BaseIcon;
          parameter Modelica.SIunits.Area A "Heat transfer area";
          parameter Modelica.SIunits.CoefficientOfHeatTransfer hFixed=3
          "Constant convection coefficient";
          Modelica.SIunits.HeatFlowRate Q_flow
          "Heat flow rate from solid -> fluid";
          Modelica.SIunits.HeatFlux q_flow
          "Convective heat flux from solid -> fluid";
          Modelica.SIunits.TemperatureDifference dT(start=0)
          "= solid.T - fluid.T";
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a solid
                                      annotation (Placement(transformation(extent={{-110,
                    -10},{-90,10}},      rotation=0)));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b fluid
                                      annotation (Placement(transformation(extent={{90,-10},
                    {110,10}},         rotation=0)));

          parameter Modelica.SIunits.Angle til(displayUnit="deg")
          "Surface tilt"
            annotation (Dialog(enable= not (conMod == Buildings.HeatTransfer.Types.InteriorConvection.fixed)));

      protected
          final parameter Real cosTil=Modelica.Math.cos(til)
          "Cosine of window tilt"
            annotation (Evaluate=true);
          final parameter Real sinTil=Modelica.Math.sin(til)
          "Sine of window tilt"
            annotation (Evaluate=true);
          final parameter Boolean isCeiling = abs(sinTil) < 10E-10 and cosTil > 0
          "Flag, true if the surface is a ceiling"
            annotation (Evaluate=true);
          final parameter Boolean isFloor = abs(sinTil) < 10E-10 and cosTil < 0
          "Flag, true if the surface is a floor"
            annotation (Evaluate=true);

        equation
          dT = solid.T - fluid.T;
          solid.Q_flow = Q_flow;
          fluid.Q_flow = -Q_flow;
          Q_flow = A*q_flow;
          annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                    -100},{100,100}}), graphics), Icon(coordinateSystem(
                  preserveAspectRatio=true, extent={{-100,-100},{100,100}}), graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-90,80},{-60,-80}},
                  lineColor={0,0,0},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Backward),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Text(
                  extent={{-35,42},{-5,20}},
                  lineColor={255,0,0},
                  textString="Q_flow"),
                Line(points={{-60,20},{76,20}}, color={191,0,0}),
                Line(points={{-60,-20},{76,-20}}, color={191,0,0}),
                Line(points={{-34,80},{-34,-80}}, color={0,127,255}),
                Line(points={{6,80},{6,-80}}, color={0,127,255}),
                Line(points={{40,80},{40,-80}}, color={0,127,255}),
                Line(points={{76,80},{76,-80}}, color={0,127,255}),
                Line(points={{-34,-80},{-44,-60}}, color={0,127,255}),
                Line(points={{-34,-80},{-24,-60}}, color={0,127,255}),
                Line(points={{6,-80},{-4,-60}}, color={0,127,255}),
                Line(points={{6,-80},{16,-60}}, color={0,127,255}),
                Line(points={{40,-80},{30,-60}}, color={0,127,255}),
                Line(points={{40,-80},{50,-60}}, color={0,127,255}),
                Line(points={{76,-80},{66,-60}}, color={0,127,255}),
                Line(points={{76,-80},{86,-60}}, color={0,127,255}),
                Line(points={{56,-30},{76,-20}}, color={191,0,0}),
                Line(points={{56,-10},{76,-20}}, color={191,0,0}),
                Line(points={{56,10},{76,20}}, color={191,0,0}),
                Line(points={{56,30},{76,20}}, color={191,0,0})}),
            Documentation(info="<html>
Partial model for a convective heat transfer model.
</html>",         revisions="<html>
<ul>
<li>
March 8 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end PartialConvection;
      annotation (preferedView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.HeatTransfer.Convection\">Buildings.HeatTransfer.Convection</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (Documentation(info="<html>
<p>
This package provides component models to compute heat convection.
</p>
</html>"));
    end Convection;

    package Radiosity "Package with models for radiosity transfer"
      extends Modelica.Icons.VariantsPackage;

      model OutdoorRadiosity
      "Model for the outdoor radiosity that strikes the window"
        parameter Modelica.SIunits.Area A "Area of receiving surface";
        parameter Real F_sky(min=0, max=1)
        "View factor from receiving surface to sky";
        parameter Boolean linearize=false
        "Set to true to linearize emissive power"
          annotation (Evaluate=true);
        parameter Modelica.SIunits.Temperature T0=293.15
        "Temperature used to linearize radiative heat transfer"
          annotation (Dialog(enable=linearize), Evaluate=true);
        output Modelica.SIunits.HeatFlux jSky "Radiosity flux of the clear sky";
        output Real TRad4(unit="K4")
        "4th power of the mean outdoor temperature";
        output Modelica.SIunits.Temperature TRad "Mean outdoor temperature";
        Modelica.Blocks.Interfaces.RealInput f_clr(min=0, max=1)
        "Fraction of sky that is clear"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort
        "Heat port for outside air temperature"
          annotation (Placement(transformation(extent={{-120,40},{-80,80}})));

        Buildings.HeatTransfer.Interfaces.RadiosityOutflow JOut
        "Radiosity that flows out of component"
        annotation (Placement(transformation(
                extent={{100,-10},{120,10}}), iconTransformation(extent={{100,-10},{120,
                  10}})));
    protected
       final parameter Real T03(min=0, unit="K3")=T0^3
        "3rd power of temperature T0"
       annotation(Evaluate=true);
       final parameter Real T05(min=0, unit="K5")=T0^5
        "5th power of temperature T0"
       annotation(Evaluate=true);
      equation
        jSky = 5.31E-13 * (if linearize then T05*heatPort.T else heatPort.T^6);
        TRad4 = (((1-F_sky) + (1-f_clr)*F_sky) *
               (if linearize then T03*heatPort.T else heatPort.T^4)
               + f_clr*F_sky*jSky/Modelica.Constants.sigma);
        JOut = -A * Modelica.Constants.sigma * TRad4;
        TRad = if linearize then TRad4/T03 else TRad4^(1/4);
        heatPort.Q_flow = 0;
        annotation (Diagram(graphics), Icon(graphics={
              Text(
                extent={{-84,110},{-42,68}},
                lineColor={0,0,127},
                textString="TOut"),
              Text(
                extent={{-84,20},{-40,-20}},
                lineColor={0,0,127},
                textString="f_clr"),
              Text(
                extent={{64,16},{94,-12}},
                lineColor={0,0,127},
                textString="J"),
              Line(
                points={{6,-36},{28,-8},{20,-8},{28,-8},{28,-16},{28,-16}},
                color={127,0,0},
                smooth=Smooth.None),
              Line(
                points={{6,-36},{42,-36},{34,-30},{42,-36},{36,-42}},
                color={127,0,0},
                smooth=Smooth.None),
              Line(
                points={{6,28},{28,0},{20,0},{28,0},{28,8},{28,8}},
                color={127,0,0},
                smooth=Smooth.None),
              Line(
                points={{6,28},{42,28},{34,34},{42,28},{36,22}},
                color={127,0,0},
                smooth=Smooth.None),
              Line(
                points={{6,28},{28,56},{20,56},{28,56},{28,48},{28,48}},
                color={127,0,0},
                smooth=Smooth.None),
              Rectangle(
                extent={{4,74},{-34,-42}},
                fillColor={85,170,255},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Rectangle(
                extent={{-34,-42},{66,-60}},
                pattern=LinePattern.None,
                fillColor={0,127,0},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,0}),           Text(
              extent={{-150,142},{150,102}},
              textString="%name",
              lineColor={0,0,255})}),
      defaultComponentName="radOut",
      Documentation(info="<html>
Model for the infrared radiosity balance of the outdoor environment.
The computation is according to TARCOG 2006.
</p>
<h4>References</h4>
<p>
TARCOG 2006: Carli, Inc., TARCOG: Mathematical models for calculation
of thermal performance of glazing systems with our without
shading devices, Technical Report, Oct. 17, 2006.
</html>",       revisions="<html>
<ul>
<li>
August 18 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
      end OutdoorRadiosity;

      block RadiositySplitter
      "Splits the incoming radiosity into two flows based on an input signal"
        extends Modelica.Blocks.Interfaces.BlockIcon;

        Interfaces.RadiosityInflow JIn
          annotation (Placement(transformation(extent={{-120,50},{-100,70}})));
        Modelica.Blocks.Interfaces.RealInput u(min=0, max=1)
        "u times incoming radiosity"
          annotation (Placement(
              transformation(extent={{-140,-80},{-100,-40}}), iconTransformation(
                extent={{-140,-80},{-100,-40}})));
        Interfaces.RadiosityOutflow JOut_1
          annotation (Placement(transformation(extent={{100,50},{120,70}})));

        Interfaces.RadiosityOutflow JOut_2 "(1-u) times incoming radiosity"
          annotation (Placement(transformation(extent={{100,-70},{120,-50}})));
      equation
        JOut_1 = - u    * JIn;
        JOut_2 = - (1-u)* JIn;
        annotation (
      defaultComponentName="radSpl",
          Documentation(info="
<html>
<p>
This blocks splits the incoming radiosity into two fluxes according to
<p align=\"center\" style=\"font-style:italic;\">
  J<sub>Out,1</sub> = - u J<sub>In</sub>,<br>
  J<sub>Out,2</sub> = - (1-u)  J<sub>In</sub>.
</p>
The minus sign on the left hand side is because <i>J<sub>In</sub></i>
and <i>J<sub>Out</sub></i> are flow variables.
</p>
<p>
This block may be used to split the radiosity flux into a fraction that 
strikes the shaded part of a window, and a fraction that strikes the
non-shaded part.
</p>
</html>
",       revisions="<html>
<ul>
<li>
October 23 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}},
          grid={2,2}), graphics={
          Line(points={{-100,60},{-40,60},{-30,40}}, color={0,0,127}),
          Line(points={{-100,-60},{-40,-60},{-30,-40}}, color={0,0,127}),
          Line(points={{50,0},{100,0}}, color={0,0,127}),
          Line(points={{-30,0},{30,0}}, color={0,0,0}),
          Line(points={{-15,25.99},{15,-25.99}}, color={0,0,0}),
          Line(points={{-15,-25.99},{15,25.99}}, color={0,0,0}),
          Ellipse(extent={{-50,50},{50,-50}}, lineColor={0,0,127}),
          Line(points={{102,60},{42,60},{32,40}},    color={0,0,255}),
          Line(points={{102,-60},{42,-60},{32,-40}},    color={0,0,255})}),
          Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}},
          grid={2,2}), graphics={
          Rectangle(
            extent={{-100,-100},{100,100}},
            lineColor={0,0,255},
            fillColor={255,255,255},
            fillPattern=FillPattern.Solid),
          Line(points={{-100,60},{-40,60},{-30,40}}, color={0,0,255}),
          Line(points={{-100,-60},{-40,-60},{-30,-40}}, color={0,0,255}),
          Line(points={{50,0},{100,0}}, color={0,0,255}),
          Line(points={{-30,0},{30,0}}, color={0,0,0}),
          Line(points={{-15,25.99},{15,-25.99}}, color={0,0,0}),
          Line(points={{-15,-25.99},{15,25.99}}, color={0,0,0}),
          Ellipse(extent={{-50,50},{50,-50}}, lineColor={0,0,255}),
          Line(points={{100,60},{40,60},{30,40}},    color={0,0,255}),
          Line(points={{100,-60},{40,-60},{30,-40}},    color={0,0,255})}));
      end RadiositySplitter;

      package BaseClasses
      "Package with base classes for Buildings.HeatTransfer.Radiosity"
        extends Modelica.Icons.BasesPackage;

        partial block RadiosityTwoSurfaces
        "Model for the radiosity balance of a device with two surfaces"
          extends Buildings.BaseClasses.BaseIcon;
          parameter Modelica.SIunits.Area A "Surface area";

          Buildings.HeatTransfer.Interfaces.RadiosityInflow JIn_a(start=A*0.8*Modelica.Constants.sigma*293.15^4)
          "Incoming radiosity at surface a"
            annotation (Placement(transformation(extent={{-120,30},{-100,50}})));
          Buildings.HeatTransfer.Interfaces.RadiosityInflow JIn_b(start=A*0.8*Modelica.Constants.sigma*293.15^4)
          "Incoming radiosity at surface b"
            annotation (Placement(transformation(extent={{120,-50},{100,-30}})));
          Buildings.HeatTransfer.Interfaces.RadiosityOutflow JOut_a
          "Outgoing radiosity at surface a"
            annotation (Placement(transformation(extent={{-100,-50},{-120,-30}})));
          Buildings.HeatTransfer.Interfaces.RadiosityOutflow JOut_b
          "Outgoing radiosity at surface b"
            annotation (Placement(transformation(extent={{100,30},{120,50}})));

          annotation (Diagram(graphics), Icon(graphics),
                   Documentation(info="<html>
Partial model for a device with two surfaces.
</html>",         revisions="<html>
<ul>
<li>
February 3, by Michael Wetter:<br>
Corrected bug in start value of radiosity port.
</li>
<li>
August 19 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end RadiosityTwoSurfaces;

        model ParametersTwoSurfaces
        "Parameters that are used to model two surfaces with the same area"
          parameter Modelica.SIunits.Emissivity absIR_a
          "Infrared absorptivity of surface a";
          parameter Modelica.SIunits.Emissivity absIR_b
          "Infrared absorptivity of surface b";
          parameter Modelica.SIunits.ReflectionCoefficient rhoIR_a
          "Infrared reflectivity of surface a";
          parameter Modelica.SIunits.ReflectionCoefficient rhoIR_b
          "Infrared reflectivity of surface b";
          parameter Modelica.SIunits.TransmissionCoefficient tauIR
          "Infrared transmissivity of glass pane";
          parameter Boolean linearize = false
          "Set to true to linearize emissive power"
          annotation (Evaluate=true);
          parameter Modelica.SIunits.Temperature T0=293.15
          "Temperature used to linearize radiative heat transfer"
            annotation (Dialog(enable=linearize), Evaluate=true);
      protected
         final parameter Real T03(min=0, unit="K3")=T0^3
          "3rd power of temperature T0"
         annotation(Evaluate=true);

        initial equation
            assert(abs(1-absIR_a-rhoIR_a-tauIR) < Modelica.Constants.eps,
            "Absorptivity, reflectivity and transmissivity of surface a do not add up to one. Check parameters.");
            assert(abs(1-absIR_b-rhoIR_b-tauIR) < Modelica.Constants.eps,
            "Absorptivity, reflectivity and transmissivity of surface b do not add up to one. Check parameters.");

        annotation (
        Documentation(
        info="<html>
<p>
Parameters that are used for classes with two surfaces.
</p>
</html>",
        revisions="<html>
<ul>
<li>
August 23, 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end ParametersTwoSurfaces;
      annotation (preferedView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.HeatTransfer.Radiosity\">Buildings.HeatTransfer.Radiosity</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (Documentation(info="<html>
<p>
This package provides component models for the
infrared radiative heat exchange of window assemblies.
The models are according to TARCOG 2006.
</p>
<h4>References</h4>
<p>
TARCOG 2006: Carli, Inc., TARCOG: Mathematical models for calculation
of thermal performance of glazing systems with our without
shading devices, Technical Report, Oct. 17, 2006.
</p>
</html>"));
    end Radiosity;

    package Sources "Thermal sources"
    extends Modelica.Icons.SourcesPackage;

      model PrescribedTemperature
      "Variable temperature boundary condition in Kelvin"

        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b port annotation (Placement(transformation(extent={{90,
                  -10},{110,10}}, rotation=0)));
        Modelica.Blocks.Interfaces.RealInput T annotation (Placement(transformation(
                extent={{-140,-20},{-100,20}}, rotation=0)));
      equation
        port.T = T;
        annotation (
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={
              Rectangle(
                extent={{-100,100},{100,-100}},
                lineColor={0,0,0},
                pattern=LinePattern.None,
                fillColor={159,159,223},
                fillPattern=FillPattern.Backward),
              Line(
                points={{-102,0},{64,0}},
                color={191,0,0},
                thickness=0.5),
              Text(
                extent={{0,0},{-100,-100}},
                lineColor={0,0,0},
                textString="K"),
              Text(
                extent={{-150,150},{150,110}},
                textString="%name",
                lineColor={0,0,255}),
              Polygon(
                points={{50,-20},{50,20},{90,0},{50,-20}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid)}),
          Documentation(info="<HTML>
<p>
This model represents a variable temperature boundary condition.
The temperature in [K] is given as input signal <b>T</b>
to the model. The effect is that an instance of this model acts as
an infinite reservoir able to absorb or generate as much energy
as required to keep the temperature at the specified value.
</p>
</HTML>
"),       Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={
              Rectangle(
                extent={{-100,100},{100,-100}},
                lineColor={0,0,0},
                pattern=LinePattern.None,
                fillColor={159,159,223},
                fillPattern=FillPattern.Backward),
              Text(
                extent={{0,0},{-100,-100}},
                lineColor={0,0,0},
                textString="K"),
              Line(
                points={{-102,0},{64,0}},
                color={191,0,0},
                thickness=0.5),
              Polygon(
                points={{52,-20},{52,20},{90,0},{52,-20}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid)}));
      end PrescribedTemperature;

      model PrescribedHeatFlow "Prescribed heat flow boundary condition"
        Modelica.Blocks.Interfaces.RealInput Q_flow
              annotation (Placement(transformation(
              origin={-100,0},
              extent={{20,-20},{-20,20}},
              rotation=180)));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b port annotation (Placement(transformation(extent={{90,
                  -10},{110,10}}, rotation=0)));
      equation
        port.Q_flow = -Q_flow;
        annotation (
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={
              Line(
                points={{-60,-20},{40,-20}},
                color={191,0,0},
                thickness=0.5),
              Line(
                points={{-60,20},{40,20}},
                color={191,0,0},
                thickness=0.5),
              Line(
                points={{-80,0},{-60,-20}},
                color={191,0,0},
                thickness=0.5),
              Line(
                points={{-80,0},{-60,20}},
                color={191,0,0},
                thickness=0.5),
              Polygon(
                points={{40,0},{40,40},{70,20},{40,0}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{40,-40},{40,0},{70,-20},{40,-40}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{70,40},{90,-40}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-150,100},{150,60}},
                textString="%name",
                lineColor={0,0,255})}),
          Documentation(info="<HTML>
<p>
This model allows a specified amount of heat flow rate to be \"injected\"
into a thermal system at a given port.  The amount of heat
is given by the input signal Q_flow into the model. The heat flows into the
component to which the component PrescribedHeatFlow is connected,
if the input signal is positive.
</p>
<p>
This model is identical to
<a href=\"modelica:Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow\">
Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow</a>, except that
the parameters <code>alpha</code> and <code>T_ref</code> have
been deleted as these can cause division by zero in some fluid flow models.
</p>
</HTML>
",    revisions="<html>
<ul>
<li>
March 29 2011, by Michael Wetter:<br>
First implementation based on <a href=\"modelica:Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow\">
Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow</a>.
</li>
</ul>
</html>"),       Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                  {100,100}}), graphics={
              Line(
                points={{-60,-20},{68,-20}},
                color={191,0,0},
                thickness=0.5),
              Line(
                points={{-60,20},{68,20}},
                color={191,0,0},
                thickness=0.5),
              Line(
                points={{-80,0},{-60,-20}},
                color={191,0,0},
                thickness=0.5),
              Line(
                points={{-80,0},{-60,20}},
                color={191,0,0},
                thickness=0.5),
              Polygon(
                points={{60,0},{60,40},{90,20},{60,0}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{60,-40},{60,0},{90,-20},{60,-40}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid)}));
      end PrescribedHeatFlow;
      annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                -100},{100,100}}), graphics),   Documentation(info="<html>
This package is identical to
<a href=\"modelica:Modelica.Thermal.HeatTransfer.Sources\">
Modelica.Thermal.HeatTransfer.Sources</a>, except that
the parameters <code>alpha</code> and <code>T_ref</code> have
been deleted in the models
<a href=\"modelica:Modelica.Thermal.HeatTransfer.Sources.FixedHeatFlow\">
Modelica.Thermal.HeatTransfer.Sources.FixedHeatFlow</a> and
<a href=\"modelica:Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow\">
Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow</a>
 as these can cause division by zero in some fluid flow models.
</html>"));
    end Sources;

    package Windows "Package with models for windows"
      extends Modelica.Icons.VariantsPackage;

      model Window "Model for a window"

        parameter Buildings.HeatTransfer.Data.GlazingSystems.Generic glaSys
        "Glazing system"
          annotation (Evaluate=true, choicesAllMatching=true, Placement(transformation(extent={{150,174},
                  {170,194}})));
        parameter Modelica.SIunits.Area A "Heat transfer area";
        parameter Real fFra(min=0, max=1)=0.1 "Fraction of frame";
        final parameter Modelica.SIunits.Area AFra = fFra*A "Frame area";
        final parameter Modelica.SIunits.Area AGla = A-AFra "Glass area";
        parameter Boolean linearize=false
        "Set to true to linearize emissive power";
        parameter Modelica.SIunits.Angle til(displayUnit="deg") "Surface tilt";

        Interfaces.RadiosityOutflow JOutUns_a
        "Outgoing radiosity that connects to unshaded part of glass at exterior side"
          annotation (Placement(transformation(extent={{-200,70},{-220,90}})));
        Interfaces.RadiosityInflow JInUns_a
        "Incoming radiosity that connects to unshaded part of glass at exterior side"
          annotation (Placement(transformation(extent={{-220,110},{-200,130}})));
        Interfaces.RadiosityOutflow JOutSha_a if haveShade
        "Outgoing radiosity that connects to shaded part of glass at exterior side"
          annotation (Placement(transformation(extent={{-200,-110},{-220,-90}})));
        Interfaces.RadiosityInflow JInSha_a if haveShade
        "Incoming radiosity that connects to shaded part of glass at exterior side"
          annotation (Placement(transformation(extent={{-220,-70},{-200,-50}})));

        Interfaces.RadiosityOutflow JOutUns_b
        "Outgoing radiosity that connects to unshaded part of glass at room-side"
          annotation (Placement(transformation(extent={{200,110},{220,130}})));
        Interfaces.RadiosityInflow JInUns_b
        "Incoming radiosity that connects to unshaded part of glass at room-side"
          annotation (Placement(transformation(extent={{220,70},{200,90}})));
        Interfaces.RadiosityOutflow JOutSha_b if haveShade
        "Outgoing radiosity that connects to shaded part of glass at room-side"
          annotation (Placement(transformation(extent={{200,-70},{220,-50}})));
        Interfaces.RadiosityInflow JInSha_b if haveShade
        "Incoming radiosity that connects to shaded part of glass at room-side"
          annotation (Placement(transformation(extent={{220,-110},{200,-90}})));

        Buildings.HeatTransfer.Windows.BaseClasses.CenterOfGlass glaUns(
          final glaSys=glaSys,
          final A=AGla,
          final til=til,
          final linearize=linearize) "Model for unshaded center of glass"
          annotation (Placement(transformation(extent={{-10,10},{10,30}})));

        Buildings.HeatTransfer.Windows.BaseClasses.CenterOfGlass glaSha(
          final glaSys=glaSys,
          final A=AGla,
          final til=til,
          final linearize=linearize) if haveShade
        "Model for shaded center of glass"
          annotation (Placement(transformation(extent={{-10,-30},{10,-10}})));

        Modelica.Thermal.HeatTransfer.Components.ThermalConductor frame(G=AFra*
              glaSys.UFra) "Thermal conductance of frame"
          annotation (Placement(transformation(extent={{-10,-170},{10,-150}})));

        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a glaUns_a
        "Heat port at unshaded glass of exterior-facing surface"
                                                          annotation (Placement(transformation(extent={{-210,10},
                  {-190,30}},rotation=0)));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b glaUns_b
        "Heat port at unshaded glass of room-facing surface"
                                                      annotation (Placement(transformation(extent={{190,10},
                  {210,30}},rotation=0)));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a glaSha_a if haveShade
        "Heat port at shaded glass of exterior-facing surface"
          annotation (Placement(transformation(extent={{-210, -30}, {-190,-10}}, rotation=0)));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b glaSha_b if haveShade
        "Heat port at shaded glass of room-facing surface"
        annotation (Placement(transformation(extent={{190,-30}, {210,-10}}, rotation=0)));

        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a fra_a
        "Heat port at frame of exterior-facing surface"                                     annotation (Placement(transformation(extent={{-210,
                  -170},{-190,-150}},
                             rotation=0)));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b fra_b
        "Heat port at frame of room-facing surface"                                         annotation (Placement(transformation(extent={{192,
                  -170},{212,-150}},
                            rotation=0)));
        Modelica.Blocks.Interfaces.RealInput uSha(min=0, max=1) if
             haveShade
        "Control signal for the shading device. 0: unshaded; 1: fully shaded (removed if no shade is present)"
          annotation (Placement(transformation(extent={{-240,140},{-200,180}})));

        Modelica.Blocks.Interfaces.RealInput QAbsUns_flow[glaSys.nLay](each unit="W",
            each quantity="Power")
        "Solar radiation absorbed by unshaded part of glass" annotation (Placement(
              transformation(
              extent={{-20,-20},{20,20}},
              rotation=90,
              origin={-80,-220}), iconTransformation(
              extent={{-20,-20},{20,20}},
              rotation=90,
              origin={-80,-220})));
        Modelica.Blocks.Interfaces.RealInput QAbsSha_flow[glaSys.nLay](each unit="W",
            each quantity="Power") if haveShade
        "Solar radiation absorbed by shaded part of glass"
                                              annotation (Placement(transformation(
              extent={{-20,-20},{20,20}},
              rotation=90,
              origin={60,-220}), iconTransformation(
              extent={{-20,-20},{20,20}},
              rotation=90,
              origin={80,-220})));

    protected
        final parameter Boolean haveShade = glaSys.haveExteriorShade or glaSys.haveInteriorShade
        "Parameter, equal to true if the window has a shade"
          annotation(Evaluate=true);

        BaseClasses.ShadingSignal shaSig(final haveShade=glaSys.haveExteriorShade or glaSys.haveInteriorShade)
        "Block to constrain the shading control signal to be strictly within (0, 1) if a shade is present"
          annotation (Placement(transformation(extent={{-60,150},{-40,170}})));

      equation
        connect(frame.port_a, fra_a) annotation (Line(
            points={{-10,-160},{-200,-160}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(frame.port_b, fra_b)  annotation (Line(
            points={{10,-160},{202,-160}},
            color={191,0,0},
            smooth=Smooth.None));

        connect(glaUns.glass_a, glaUns_a)
                                        annotation (Line(
            points={{-10,20},{-200,20}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(glaUns.glass_b, glaUns_b)
                                        annotation (Line(
            points={{10,20},{200,20}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(shaSig.yCom, glaUns.u) annotation (Line(
            points={{-39,154},{-20,154},{-20,28},{-11,28}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(shaSig.y, glaSha.u) annotation (Line(
            points={{-39,160},{-24,160},{-24,-12},{-11,-12}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(shaSig.u, uSha)
                             annotation (Line(
            points={{-62,160},{-220,160}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(glaSha.glass_a, glaSha_a) annotation (Line(
            points={{-10,-20},{-200,-20}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(glaSha.glass_b, glaSha_b) annotation (Line(
            points={{10,-20},{200,-20}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(JInUns_a, glaUns.JIn_a) annotation (Line(
            points={{-210,120},{-40,120},{-40,24},{-11,24}},
            color={0,0,0},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(glaUns.JOut_a, JOutUns_a) annotation (Line(
            points={{-11,16},{-46,16},{-46,80},{-210,80}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(glaUns.JOut_b, JOutUns_b) annotation (Line(
            points={{11,24},{170,24},{170,120},{210,120}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(JInUns_b, glaUns.JIn_b) annotation (Line(
            points={{210,80},{176,80},{176,16},{11,16}},
            color={0,0,0},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(JInSha_a, glaSha.JIn_a) annotation (Line(
            points={{-210,-60},{-46,-60},{-46,-16},{-11,-16}},
            color={0,0,0},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(glaSha.JOut_a, JOutSha_a) annotation (Line(
            points={{-11,-24},{-42,-24},{-42,-100},{-210,-100}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(glaSha.JOut_b, JOutSha_b) annotation (Line(
            points={{11,-16},{176,-16},{176,-60},{210,-60}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(JInSha_b, glaSha.JIn_b) annotation (Line(
            points={{210,-100},{172,-100},{172,-24},{11,-24}},
            color={0,0,0},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(glaUns.QAbs_flow, QAbsUns_flow) annotation (Line(
            points={{6.10623e-16,9},{6.10623e-16,0},{-80,0},{-80,-220}},
            color={0,0,127},
            smooth=Smooth.None));

        connect(glaSha.QAbs_flow,QAbsSha_flow)  annotation (Line(
            points={{6.10623e-16,-31},{6.10623e-16,-60},{60,-60},{60,-220}},
            color={0,0,127},
            smooth=Smooth.None));

        annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-200,
                  -200},{200,200}},
              initialScale=0.1),     graphics), Icon(coordinateSystem(
                preserveAspectRatio=true, extent={{-200,-200},{200,200}},
              initialScale=0.1),                                           graphics={
              Polygon(
                visible=  glaSys.haveInteriorShade,
                points={{48,160},{48,60},{116,-4},{116,96},{48,160}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillPattern=FillPattern.CrossDiag,
                fillColor={215,215,215}),
              Line(
                points={{-74,-88},{28,-88}},
                color={0,0,0},
                smooth=Smooth.None),
              Polygon(
                points={{28,160},{28,-88},{90,-152},{90,96},{28,160}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-184,176},{-134,140}},
                lineColor={0,0,127},
                textString="uSha"),            Text(
                extent={{-60,238},{38,190}},
                lineColor={0,0,255},
                textString="%name"),
              Polygon(
                points={{38,138},{38,-84},{78,-124},{78,96},{38,138}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={170,213,255},
                fillPattern=FillPattern.Solid),
              Line(
                points={{-102,160},{48,160}},
                color={0,0,0},
                smooth=Smooth.None),
              Line(
                points={{-12,-152},{90,-152}},
                color={0,0,0},
                smooth=Smooth.None),
              Polygon(
                points={{-20,160},{-20,-88},{42,-152},{42,96},{-20,160}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-10,138},{-10,-84},{30,-124},{30,96},{-10,138}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={170,213,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-74,160},{-74,-88},{-12,-152},{-12,96},{-74,160}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-64,136},{-64,-86},{-24,-126},{-24,94},{-64,136}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={170,213,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                visible=  glaSys.haveExteriorShade,
                points={{-102,160},{-102,60},{-34,-4},{-34,96},{-102,160}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillPattern=FillPattern.CrossDiag,
                fillColor={215,215,215}),
              Line(
                points={{-34,96},{116,96}},
                color={0,0,0},
                smooth=Smooth.None),
              Line(
                visible=  glaSys.haveExteriorShade,
                points={{-198,-160},{-60,-160}},
                color={160,0,0},
                smooth=Smooth.None),
              Line(
                visible=  glaSys.haveExteriorShade,
                points={{84,-160},{200,-160}},
                color={160,0,0},
                smooth=Smooth.None),
              Line(
                visible=  glaSys.haveExteriorShade,
                points={{56,20},{198,20}},
                color={160,0,0},
                smooth=Smooth.None),
              Line(
                visible=  glaSys.haveExteriorShade,
                points={{-200,20},{-56,20}},
                color={160,0,0},
                smooth=Smooth.None), Ellipse(
                extent={{-226,234},{-164,170}},
                lineColor={255,255,0},
                fillColor={255,213,170},
                fillPattern=FillPattern.Sphere),
              Line(
                visible=  glaSys.haveExteriorShade,
                points={{-198,-20},{-44,-20}},
                color={160,0,0},
                smooth=Smooth.None),
              Line(
                visible=  glaSys.haveExteriorShade,
                points={{56,-20},{198,-20}},
                color={160,0,0},
                smooth=Smooth.None),
              Line(
                visible=  glaSys.haveExteriorShade,
                points={{-60,-100},{-60,-160}},
                color={160,0,0},
                smooth=Smooth.None),
              Line(
                visible=  glaSys.haveExteriorShade,
                points={{84,-118},{84,-160}},
                color={160,0,0},
                smooth=Smooth.None),
              Text(
                extent={{36,-162},{126,-202}},
                lineColor={0,0,127},
                textString="QAbsSha"),
              Text(
                visible=  haveShade,
                extent={{-124,-164},{-34,-204}},
                lineColor={0,0,127},
                textString="QAbsUns")}),
          defaultComponentName="win",
          Documentation(info="<html>
<h4>Overview</h4>
This is a model for a window system. The equations are similar to the
equations used in the Window 5 model and described in TARCOG 2006. 
The model computes 
the heat balance from the exterior surface to 
the room-facing surface for a window system.
The window system can have
an exterior or an interior shade, but not both, or it can
have no shade.
The convective heat transfer between the window system and the outside air
or the room is <em>not</em> computed by this model. 
They can be computed using the models
<a href=\"modelica://Buildings.HeatTransfer.Windows.ExteriorHeatTransfer\">
Buildings.HeatTransfer.Windows.ExteriorHeatTransfer</a>
and
<a href=\"modelica://Buildings.HeatTransfer.Windows.InteriorHeatTransfer\">
Buildings.HeatTransfer.Windows.InteriorHeatTransfer</a>.
</p>
<h4>Parameters</h4>
<p>
This model takes as the parameter <code>glaSys</code> a data record 
from the package
<a href=\"modelica://Buildings.HeatTransfer.Data.GlazingSystems\">
Buildings.HeatTransfer.Data.GlazingSystems</a>.
This data record specifies the properties of the glasses, 
the gas fills, the frame and of
the shades, if any shade is present.
Whether a shade is present or not is determined by the parameters
<code>glaSys.haveExteriorShade</code> and
<code>glaSys.haveInteriorShade</code>. 
</p>
<p>
The parameter <code>linearize</code> can be used
to linearize the model equations.
<h4>Ports</h4>
<p>
If a shade is present, then the input port <code>u</code> is used 
to determine the
shade position. Set <code>u=0</code> to have the window in the 
unshaded mode,
and set <code>u=1</code> to have the window shade completely deployed. 
Any intermediate value is possible.
If no shade is present, then this port will be removed.
</p>
<p>
For the heat ports, the suffix <code>_a</code> is used for the exterior, outside-facing side
of the window, and the suffix <code>_b</code> is used for the interior, room-facing surface
of the window.
Each side has heat ports that connect to the glass, to the frame, and, optionally, to the 
shade. If no shade is present, then the heat port to the shade will be removed.
</p>
<h4>Description of the Physics</h4>
<p>
The model has three main submodels that implement the relevant
heat balances: 
<ol>
<li>
The model <code>frame</code> computes heat conduction
through the frame.
</li>
<li>
The model <code>glaUns</code> computes the heat balance of the part of the
window that is unshaded. For example, if <code>u=0.2</code>, then this model accounts for
the 80% of the window that is not behind the shade or blind.
</li>
<li>
The model <code>glaSha</code> computes the heat balance of the part of the
window that is shaded. For example, if <code>u=0.2</code>, then this model accounts for
the 20% of the window that is behind the shade or blind.
If the parameter <code>glaSys</code> specifies that the window has no exterior
and no interior shade, then the model <code>glaSha</code> will be removed.
</li>
</p>
<p>
The models <code>glaUns</code> and <code>glaSha</code> 
compute the solar radiation that is absorbed by each 
glass pane and the solar radiation that is transitted 
through the window as a function of the solar incidence angle.
They then compute a heat balance that takes into account heat conduction through the glass,
heat convection through the gas layer,
and infrared radiation from the exterior and the room through the glass and gas layers.
The infrared radiative heat exchange is computed using a radiosity balance.
Heat conduction through the frame is computed using a heat flow path that is parallel to the 
glazing system, i.e., there is no heat exchange between the frame 
and the glazing layer.
</p>
<h4>References</h4>
<p>
TARCOG 2006: Carli, Inc., TARCOG: Mathematical models for calculation
of thermal performance of glazing systems with our without
shading devices, Technical Report, Oct. 17, 2006.
</p>
</html>",       revisions="<html>
<ul>
<li>
March 10 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
      end Window;

      model ExteriorHeatTransfer
      "Model for heat convection at the exterior surface of a window that may have a shading device"
        extends BaseClasses.PartialConvection(final thisSideHasShade=haveExteriorShade);
        Modelica.Blocks.Interfaces.RealInput vWin "Wind speed"
          annotation (Placement(transformation(extent={{-140,20},{-100,60}}),
              iconTransformation(extent={{-116,32},{-100,48}})));
        Buildings.HeatTransfer.Windows.BaseClasses.ExteriorConvectionCoefficient
          conCoeGla(                                          final A=AGla)
        "Model for the outside convective heat transfer coefficient of the glass"
          annotation (Placement(transformation(extent={{-84,40},{-64,60}})));
        Buildings.HeatTransfer.Windows.BaseClasses.ExteriorConvectionCoefficient
          conCoeFra(                                          final A=AFra)
        "Model for the outside convective heat transfer coefficient of the frame"
          annotation (Placement(transformation(extent={{-20,-80},{0,-60}})));
       Radiosity.OutdoorRadiosity radOut(
         final A=AGla, F_sky=F_sky,
          linearize=linearizeRadiation) "Outdoor radiosity"
          annotation (Placement(transformation(extent={{-72,-70},{-52,-50}})));
       Modelica.Blocks.Interfaces.RealInput f_clr(min=0, max=1)
        "Fraction of sky that is clear"
          annotation (Placement(transformation(extent={{-140,-80},{-100,-40}}),
              iconTransformation(extent={{-116,-88},{-100,-72}})));
        parameter Real F_sky(min=0, max=1)
        "View factor from receiving surface to sky";
      equation
        assert(-1E-10<F_sky and 1.00001 > F_sky,
               "View factor to sky is out of range. F_sky = " + String(F_sky)
               + "\n   Check parameters.");

        connect(vWin, conCoeGla.v)
                                 annotation (Line(
            points={{-120,40},{-90,40},{-90,50},{-86,50}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(vWin, conCoeFra.v) annotation (Line(
            points={{-120,40},{-90,40},{-90,-70},{-22,-70}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(conCoeFra.GCon, conFra.Gc) annotation (Line(
            points={{1,-70},{40,-70},{40,-78}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(conCoeGla.GCon, proSha.u1) annotation (Line(
            points={{-63,50},{-56,50},{-56,36},{-52,36}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(conCoeGla.GCon, proUns.u2) annotation (Line(
            points={{-63,50},{8,50},{8,74},{18,74}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(radOut.f_clr,f_clr)  annotation (Line(
            points={{-74,-60},{-120,-60}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(radOut.JOut, radShaOut.JIn) annotation (Line(
            points={{-51,-60},{-46,-60},{-46,-34},{-41,-34}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(air, radOut.heatPort) annotation (Line(
            points={{-100,5.55112e-16},{-90,5.55112e-16},{-90,0},{-80,0},{-80,-54},{
                -72,-54}},
            color={191,0,0},
            smooth=Smooth.None));
        annotation (Diagram(graphics), Icon(graphics={
              Text(
                extent={{-94,48},{-52,32}},
                lineColor={0,0,127},
                textString="vWind"), Ellipse(
                extent={{-110,110},{-90,90}},
                lineColor={255,255,0},
                fillColor={255,213,170},
                fillPattern=FillPattern.Sphere),
              Text(
                extent={{-94,-72},{-52,-88}},
                lineColor={0,0,127},
                textString="f_clr")}),
      defaultComponentName="extHeaTra",
                 Documentation(info="<html>
<p>
Model for the convective heat transfer between a window shade, a window surface
and the room air.
This model is applicable for the outside-facing surface of a window system and 
can be used with the model
<a href=\"modelica://Buildings.HeatTransfer.Windows.Window\">
Buildings.HeatTransfer.Windows.Window</a>.
</p>
<p>
This model adds the convective heat transfer coefficient to its base model.
</p>
</html>",       revisions="<html>
<ul>
<li>
October 25 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
      end ExteriorHeatTransfer;

      model InteriorHeatTransfer
      "Model for heat convection at the interior surface of a window that may have a shading device"
        extends BaseClasses.PartialConvection(final thisSideHasShade=haveInteriorShade);
        Buildings.HeatTransfer.Windows.BaseClasses.InteriorConvectionCoefficient
          conCoeGla(                                          final A=AGla)
        "Model for the inside convective heat transfer coefficient of the glass"
          annotation (Placement(transformation(extent={{-90,40},{-70,60}})));
        Buildings.HeatTransfer.Windows.BaseClasses.InteriorConvectionCoefficient
          conCoeFra(                                          final A=AFra)
        "Model for the inside convective heat transfer coefficient of the frame"
          annotation (Placement(transformation(extent={{-20,-80},{0,-60}})));

        Interfaces.RadiosityInflow JInRoo
        "Incoming radiosity of window construction"
          annotation (Placement(transformation(extent={{-110,-90},{-90,-70}})));
        Interfaces.RadiosityOutflow JOutRoo
        "Outgoing radiosity of window construction"
          annotation (Placement(transformation(extent={{-94,-50},{-114,-30}})));

        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a sha if
            windowHasShade "Heat port to shade"
          annotation (Placement(transformation(extent={{-42,-110},{-22,-90}})));
      equation
        connect(conCoeFra.GCon, conFra.Gc) annotation (Line(
            points={{1,-70},{40,-70},{40,-78}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(conCoeGla.GCon, proUns.u2) annotation (Line(
            points={{-69,50},{8,50},{8,74},{18,74}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(conCoeGla.GCon, proSha.u1) annotation (Line(
            points={{-69,50},{-56,50},{-56,36},{-52,36}},
            color={0,0,127},
            smooth=Smooth.None));

        connect(JInRoo, radShaOut.JIn) annotation (Line(
            points={{-100,-80},{-72,-80},{-72,-34},{-41,-34}},
            color={0,0,0},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(JInUns, JOutRoo) annotation (Line(
            points={{110,60},{20,60},{20,4},{-76,4},{-76,-40},{-104,-40}},
            color={0,0,0},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(shade.JOut_air, JOutRoo) annotation (Line(
            points={{-1,-28},{-8,-28},{-8,-54},{-68,-54},{-68,-40},{-104,-40}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(shade.sha, sha) annotation (Line(
            points={{7.4,-29.8},{7.4,-84},{-32,-84},{-32,-100}},
            color={191,0,0},
            smooth=Smooth.None));
        annotation (Diagram(graphics),
      defaultComponentName="intHeaTra",
      Documentation(info="<html>
<p>
Model for the convective heat transfer between a window shade, a window surface
and the room air.
This model is applicable for the room-facing surface of a window system and 
can be used with the model
<a href=\"modelica://Buildings.HeatTransfer.Windows.Window\">
Buildings.HeatTransfer.Windows.Window</a>.
</p>
<p>
This model adds the convective heat transfer coefficient to its base model.
</p>
</html>",       revisions="<html>
<ul>
<li>
October 25 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),Icon(graphics));
      end InteriorHeatTransfer;

      package BaseClasses
      "Package with base classes for Buildings.HeatTransfer.Windows"
        extends Modelica.Icons.BasesPackage;

        model Shade
        "Model for infrared radiative heat balance of a layer that may or may not have a shade"

          parameter Modelica.SIunits.Area A "Heat transfer area";
          parameter Modelica.SIunits.Emissivity absIR_air
          "Infrared absorptivity of surface that faces air";
          parameter Modelica.SIunits.Emissivity absIR_glass
          "Infrared absorptivity of surface that faces glass";
          parameter Modelica.SIunits.TransmissionCoefficient tauIR_air
          "Infrared transmissivity of shade for radiation coming from the exterior or the room";
          parameter Modelica.SIunits.TransmissionCoefficient tauIR_glass
          "Infrared transmissivity of shade for radiation coming from the glass";
          parameter Boolean thisSideHasShade
          "Set to true if this side of the window has a shade";
          final parameter Modelica.SIunits.ReflectionCoefficient rhoIR_air=1-absIR_air-tauIR_air
          "Infrared reflectivity of surface that faces air";
          final parameter Modelica.SIunits.ReflectionCoefficient rhoIR_glass=1-absIR_glass-tauIR_glass
          "Infrared reflectivity of surface that faces glass";
          parameter Boolean linearize = false
          "Set to true to linearize emissive power"
          annotation (Evaluate=true);
          parameter Boolean homotopyInitialization = true
          "= true, use homotopy method"
            annotation(Evaluate=true, Dialog(tab="Advanced"));

          parameter Modelica.SIunits.Temperature T0=293.15
          "Temperature used to linearize radiative heat transfer"
            annotation (Dialog(enable=linearize), Evaluate=true);

          parameter Real k(min=0, max=1)=1
          "Coefficient used to scale convection between shade and glass";
          Modelica.Blocks.Interfaces.RealInput u
          "Input connector, used to scale the surface area to take into account an operable shading device"
            annotation (Placement(transformation(extent={{-140,60},{-100,100}}),
                iconTransformation(extent={{-120,70},{-100,90}})));

          Modelica.Blocks.Interfaces.RealInput Gc
          "Signal representing the convective thermal conductance in [W/K]"
            annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=0,
                origin={-120,30}), iconTransformation(extent={{-10,-10},{10,10}},
                  origin={-110,40})));
          Modelica.Blocks.Interfaces.RealInput QAbs_flow(unit="W", quantity="Power")
          "Solar radiation absorbed by shade"
            annotation (Placement(transformation(
                origin={0,-120},
                extent={{-20,-20},{20,20}},
                rotation=90), iconTransformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={0,-110})));

          Interfaces.RadiosityInflow JIn_air(start=A*0.8*Modelica.Constants.sigma*293.15^4)
          "Incoming radiosity at the air-side surface of the shade"
            annotation (Placement(transformation(extent={{-120,-50},{-100,-30}})));
          Interfaces.RadiosityInflow JIn_glass(start=A*0.8*Modelica.Constants.sigma*293.15^4)
          "Incoming radiosity at the glass-side surface of the shade"
            annotation (Placement(transformation(extent={{120,-90},{100,-70}})));
          Interfaces.RadiosityOutflow JOut_air
          "Outgoing radiosity at the air-side surface of the shade"
            annotation (Placement(transformation(extent={{-100,-90},{-120,-70}})));
          Interfaces.RadiosityOutflow JOut_glass
          "Outgoing radiosity at the glass-side surface of the shade"
            annotation (Placement(transformation(extent={{100,-50},{120,-30}})));

          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a air
          "Port that connects to the air (room or outside)"          annotation (Placement(transformation(extent={{-110,
                    -10},{-90,10}},
                               rotation=0)));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b glass
          "Heat port that connects to shaded part of glass"
            annotation (Placement(transformation(extent={{84,-10},{104,10}},
                                                                           rotation=0),
                iconTransformation(extent={{84,-10},{104,10}})));
         Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a sha(T(start=293.15))
          "Heat port to shade"
             annotation (Placement(transformation(extent={{-50,-110},{-30,-90}},
                               rotation=0), iconTransformation(extent={{-36,-108},{-16,-88}})));
      protected
         final parameter Real T03(min=0, unit="K3")=T0^3
          "3rd power of temperature T0"
         annotation(Evaluate=true);
         Real T4(min=1E8, start=293.15^4, nominal=1E10, unit="K4")
          "4th power of temperature";
         Modelica.SIunits.RadiantPower E_air
          "Emissive power of surface that faces air";
         Modelica.SIunits.RadiantPower E_glass
          "Emissive power of surface that faces glass";
        equation
          if thisSideHasShade then
          // Radiosities that are outgoing from the surface, which are
          // equal to the infrared absorptivity plus the reflected incoming
          // radiosity plus the radiosity that is transmitted from the
          // other surface.
            if linearize then
              T4 = T03 * sha.T;
            else
              if homotopyInitialization then
         T4 = homotopy(actual=(sha.T)^4, simplified=T03 * sha.T);
              else
         T4 = (sha.T)^4;
              end if;
            end if;

            E_air   = u * A * absIR_air   * Modelica.Constants.sigma * T4;
            E_glass = u * A * absIR_glass * Modelica.Constants.sigma * T4;
            // Radiosity outgoing from shade towards air side and glass side
            JOut_air   = - E_air   - tauIR_glass * JIn_glass - rhoIR_air*JIn_air;
            JOut_glass = - E_glass - tauIR_air   * JIn_air   - rhoIR_glass*JIn_glass;
            // Heat balance of shade
            // The term 2*Gc is to combine the parallel convective heat transfer resistances,
            // see figure in info section.
            QAbs_flow + absIR_air*JIn_air + absIR_glass*JIn_glass
              = -Gc*(2*(air.T-sha.T)+k*(glass.T-sha.T))+E_air+E_glass;
            // Convective heat flow at air node
            air.Q_flow   = Gc*(2*(air.T-sha.T) + (air.T-glass.T));
            // Convective heat flow at glass node
            glass.Q_flow = Gc*((glass.T-air.T)+k*(glass.T-sha.T));
          else
            air.Q_flow   = Gc*(air.T-glass.T);
            glass.Q_flow = -air.Q_flow;
            sha.T = (air.T+glass.T)/2;
            T4 = T03 * T0;
            E_air = 0;
            E_glass = 0;
            JOut_air = -JIn_glass;
            JOut_glass = -JIn_air;
          end if;

          annotation (Diagram(graphics),
            Icon(graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                                                Text(
                extent={{-100,132},{100,102}},
                textString="%name",
                lineColor={0,0,255}),
                Polygon(
                  points={{-20,54},{-20,46},{20,58},{20,66},{-20,54}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,14},{-20,6},{20,18},{20,26},{-20,14}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,34},{-20,26},{20,38},{20,46},{-20,34}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,-26},{-20,-34},{20,-22},{20,-14},{-20,-26}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,-6},{-20,-14},{20,-2},{20,6},{-20,-6}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,-66},{-20,-74},{20,-62},{20,-54},{-20,-66}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,-46},{-20,-54},{20,-42},{20,-34},{-20,-46}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{14,-82},{48,-100}},
                  lineColor={0,0,127},
                  textString="QAbs"),
                Rectangle(
                  extent={{-2,90},{2,-80}},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None,
                  lineColor={0,0,0}),
                Rectangle(
                  extent={{-40,94},{40,80}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-102,90},{-68,72}},
                  lineColor={0,0,127},
                  textString="u"),
                Text(
                  extent={{-100,52},{-66,34}},
                  lineColor={0,0,127},
                  textString="Gc"),
                Rectangle(
                  extent={{88,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Solid)}),
            Documentation(info="<html>
<p>
Model for the convective and the infrared radiative heat balance 
of a shade that is in the outside or the room-side of a window.
</p>
<p>
The input port <code>QAbs_flow</code> needs to be connected to the solar radiation 
that is absorbed by the shade.
</p>
<p>
The convective heat balance is based on the model described by Wright (2008), which can
be shown as a convective heat resistance model as follows:
</p>
<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/HeatTransfer/Windows/BaseClasses/convection.png\" border=\"1\"/>
</p>
<p>
Wright (2008) reports that if the shading layer is far enough from the window,
the boundary layers associated with each surface will not interfere with
each other. In this case, it is reasonable to consider each surface on an 
individual basis by setting the convective heat transfer coefficient shown in grey to zero,
and setting the black depicted convective heat transfer coefficients
to <i>h=4 W/m<sup>2</sup> K</i>.
In the here implemented model, the grey depicted convective heat transfer coefficient
is set set to <i>h' = k &nbsp; h</i>, where <i>0 &le; k &le; 1</i> is a parameter.
</p>
<h4>References</h4>
<ul>
<li>
Jon L. Wright.<br>
Calculating Center-Glass Performance Indices
of Glazing Systems with Shading Devices.<br>
<i>ASHRAE Transactions</i>, SL-08-020. 2008.
</li>
</ul>
</html>",         revisions="<html>
<ul>
<li>
April 2, 2011 by Michael Wetter:<br>
Added <code>homotopy</code> operator.
</li>
<li>
February 3, by Michael Wetter:<br>
Corrected bug in start value of radiosity port and in heat balance of shade.
</li>
<li>
January 28 2011, by Michael Wetter:<br>
Fixed computation of convective heat balance between air, shade and glass.
</li>
<li>
November 3 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end Shade;

        partial model PartialConvection
        "Partial model for heat convection between a possibly shaded window that can be outside or inside the room"
          parameter Modelica.SIunits.Area A
          "Heat transfer area of frame and window";
          parameter Real fFra
          "Fraction of window frame divided by total window area";
          final parameter Modelica.SIunits.Area AFra = fFra * A "Frame area";
          final parameter Modelica.SIunits.Area AGla = A-AFra "Glass area";

          parameter Modelica.SIunits.Emissivity absIRSha_air
          "Infrared absorptivity of shade surface that faces air"
                annotation (Dialog(group="Shading"));
          parameter Modelica.SIunits.Emissivity absIRSha_glass
          "Infrared absorptivity of shade surface that faces glass"
            annotation (Dialog(group="Shading"));

          parameter Modelica.SIunits.TransmissionCoefficient tauIRSha_air
          "Infrared transmissivity of shade for radiation coming from the exterior or the room"
            annotation (Dialog(group="Shading"));
          parameter Modelica.SIunits.TransmissionCoefficient tauIRSha_glass
          "Infrared transmissivity of shade for radiation coming from the glass"
            annotation (Dialog(group="Shading"));

          parameter Boolean linearizeRadiation
          "Set to true to linearize emissive power";

          parameter Boolean haveExteriorShade
          "Set to true if window has exterior shade (at surface a)"
            annotation (Dialog(group="Shading"));
          parameter Boolean haveInteriorShade
          "Set to true if window has interior shade (at surface b)"
            annotation (Dialog(group="Shading"));

          final parameter Boolean windowHasShade = haveExteriorShade or haveInteriorShade
          "Set to true if window system has a shade"
            annotation (Dialog(group="Shading"), Evaluate=true);
          parameter Boolean thisSideHasShade
          "Set to true if this side of the model has a shade"
            annotation (Dialog(group="Shading"), Evaluate=true);

          Modelica.Blocks.Interfaces.RealInput uSha if windowHasShade
          "Input connector, used to scale the surface area to take into account an operable shading device, 0: unshaded; 1: fully shaded"
            annotation (Placement(transformation(extent={{-140,60},{-100,100}}),
                iconTransformation(extent={{-116,72},{-100,88}})));

          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a air
          "Port that connects to the air (room or outside)"          annotation (Placement(transformation(extent={{-110,-10},
                    {-90,10}}, rotation=0)));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b glaUns
          "Heat port that connects to unshaded part of glass"
              annotation (Placement(transformation(extent={{90,10},{110,30}},  rotation=0)));

          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b glaSha if windowHasShade
          "Heat port that connects to shaded part of glass"
            annotation (Placement(transformation(extent={{90,-30},{110,-10}},      rotation=0)));

          Modelica.Thermal.HeatTransfer.Components.Convection conWinUns
          "Convection from unshaded part of window to outside or room air"
            annotation (Placement(transformation(extent={{60,0},{40,20}})));

          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a frame
          "Heat port at window frame"    annotation (Placement(transformation(extent={{60,-110},
                    {80,-90}}, rotation=0)));
          Modelica.Thermal.HeatTransfer.Components.Convection conFra
          "Convective heat transfer between air and frame"
            annotation (Placement(transformation(extent={{50,-98},{30,-78}})));

      protected
          Modelica.Blocks.Math.Product proUns
          "Product for unshaded part of window"
            annotation (Placement(transformation(extent={{20,70},{40,90}})));

          Modelica.Blocks.Math.Product proSha if windowHasShade
          "Product for shaded part of window"
            annotation (Placement(transformation(extent={{-50,20},{-30,40}})));

      public
          ShadingSignal shaSig(haveShade=windowHasShade)
          "Conversion for shading signal"
            annotation (Placement(transformation(extent={{-90,70},{-70,90}})));
          Shade shade(
            final thisSideHasShade = thisSideHasShade,
            final A=AGla,
            final linearize=linearizeRadiation,
            final absIR_air=if thisSideHasShade then absIRSha_air else 0,
            final absIR_glass=if thisSideHasShade then absIRSha_glass else 0,
            final tauIR_air=if thisSideHasShade then tauIRSha_air else 1,
            final tauIR_glass=if thisSideHasShade then tauIRSha_glass else 1) if
               windowHasShade "Heat balance of shade"
            annotation (Placement(transformation(extent={{0,-30},{20,-10}})));
          Interfaces.RadiosityOutflow JOutUns
          "Outgoing radiosity that connects to unshaded part of glass"
            annotation (Placement(transformation(extent={{100,70},{120,90}})));
          Interfaces.RadiosityInflow JInUns
          "Incoming radiosity that connects to unshaded part of glass"
            annotation (Placement(transformation(extent={{120,50},{100,70}})));
      public
          Interfaces.RadiosityOutflow JOutSha if windowHasShade
          "Outgoing radiosity that connects to shaded part of glass"
            annotation (Placement(transformation(extent={{100,-70},{120,-50}})));
          Interfaces.RadiosityInflow JInSha if windowHasShade
          "Incoming radiosity that connects to shaded part of glass"
            annotation (Placement(transformation(extent={{120,-90},{100,-70}})));
      protected
          Radiosity.RadiositySplitter radShaOut
          "Radiosity that strikes shading device"
            annotation (Placement(transformation(extent={{-40,-50},{-20,-30}})));

      public
          Modelica.Blocks.Interfaces.RealInput QAbs_flow(unit="W", quantity="Power") if windowHasShade
          "Solar radiation absorbed by shade"
            annotation (Placement(transformation(
                origin={0,-120},
                extent={{-20,-20},{20,20}},
                rotation=90), iconTransformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={0,-110})));
        initial equation
          assert(( thisSideHasShade and windowHasShade)  or (not thisSideHasShade),
            "Parameters \"thisSideHasShade\" and \"windowHasShade\" are not consistent. Check parameters");

        equation
          connect(conWinUns.fluid, air)
                                     annotation (Line(
              points={{40,10},{-80,10},{-80,5.55112e-16},{-100,5.55112e-16}},
              color={191,0,0},
              smooth=Smooth.None));

          connect(conFra.fluid, air) annotation (Line(
              points={{30,-88},{-80,-88},{-80,5.55112e-16},{-100,5.55112e-16}},
              color={191,0,0},
              smooth=Smooth.None));

          connect(conFra.solid, frame) annotation (Line(
              points={{50,-88},{70,-88},{70,-100}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(glaUns, conWinUns.solid) annotation (Line(
              points={{100,20},{76,20},{76,10},{60,10}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(proUns.y, conWinUns.Gc) annotation (Line(
              points={{41,80},{50,80},{50,20}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(uSha, shaSig.u)
                               annotation (Line(
              points={{-120,80},{-92,80}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(proSha.u2, shaSig.y) annotation (Line(
              points={{-52,24},{-60,24},{-60,80},{-69,80}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(shaSig.yCom, proUns.u1) annotation (Line(
              points={{-69,74},{-50,74},{-50,86},{18,86}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(shade.Gc, proSha.y) annotation (Line(
              points={{-1,-16},{-20,-16},{-20,30},{-29,30}},
              color={0,0,127},
              pattern=LinePattern.None,
              smooth=Smooth.None));
          connect(shade.air, air) annotation (Line(
              points={{-5.55112e-16,-20},{-70,-20},{-70,5.55112e-16},{-100,5.55112e-16}},
              color={191,0,0},
              pattern=LinePattern.None,
              smooth=Smooth.None));
          connect(shade.glass, glaSha) annotation (Line(
              points={{19.4,-20},{100,-20}},
              color={191,0,0},
              pattern=LinePattern.None,
              smooth=Smooth.None));
          connect(radShaOut.JOut_2,JOutUns)  annotation (Line(
              points={{-19,-46},{90,-46},{90,80},{110,80}},
              color={0,127,0},
              smooth=Smooth.None));
          connect(shade.JOut_glass,JOutSha)  annotation (Line(
              points={{21,-24},{80,-24},{80,-60},{110,-60}},
              color={0,127,0},
              smooth=Smooth.None));
          connect(shade.JIn_glass,JInSha)  annotation (Line(
              points={{21,-28},{70,-28},{70,-80},{110,-80}},
              color={0,0,0},
              pattern=LinePattern.None,
              smooth=Smooth.None));
          connect(shaSig.y,radShaOut. u) annotation (Line(
              points={{-69,80},{-60,80},{-60,-46},{-42,-46}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(radShaOut.JOut_1, shade.JIn_air) annotation (Line(
              points={{-19,-34},{-12,-34},{-12,-24},{-1,-24}},
              color={0,127,0},
              smooth=Smooth.None));
          connect(shade.u, shaSig.y) annotation (Line(
              points={{-1,-12},{-60,-12},{-60,80},{-69,80}},
              color={0,0,127},
              smooth=Smooth.None));

          connect(shade.QAbs_flow, QAbs_flow) annotation (Line(
              points={{10,-31},{10,-94},{0,-94},{0,-120},{1.11022e-15,-120}},
              color={0,0,127},
              smooth=Smooth.None));
            annotation (Dialog(group="Shading"),
                      Diagram(graphics),
            Icon(graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-90,2},{84,-2}},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Text(
                  extent={{-94,88},{-86,74}},
                  lineColor={0,0,127},
                  textString="u"),              Text(
                extent={{-160,144},{140,104}},
                textString="%name",
                lineColor={0,0,255}),
                Polygon(
                  points={{-20,48},{-20,40},{20,52},{20,60},{-20,48}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,8},{-20,0},{20,12},{20,20},{-20,8}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,28},{-20,20},{20,32},{20,40},{-20,28}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,-32},{-20,-40},{20,-28},{20,-20},{-20,-32}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,-12},{-20,-20},{20,-8},{20,0},{-20,-12}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,-72},{-20,-80},{20,-68},{20,-60},{-20,-72}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-20,-52},{-20,-60},{20,-48},{20,-40},{-20,-52}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-2,94},{2,-86}},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None,
                  lineColor={0,0,0}),
                Rectangle(
                  extent={{56,72},{84,-74}},
                  lineColor={0,0,0},
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.Dash),
                Rectangle(
                  extent={{56,-74},{84,-90}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-20,86},{84,72}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-72,-82},{-6,-100}},
                  lineColor={0,0,127},
                  textString="QAbsSha")}),
            Documentation(info="<html>
<p>
Partial model for heat convection of a window surface with or without shade,
that is outside or inside the room. 
</p>
<p>
Convective heat transfer is modeled between the heat port <code>air</code> 
and the shade, if present, the glass and the frame.
If the parameter <code>haveShade</code> is set to <code>true</code>, then a shade 
is present and the input port <code>QAbs_flow</code> needs to be connected to 
a model that computes the solar radiation that is absorbed by the shade.
If <code>haveShade=true</code>, then the model <code>shade</code> and the 
connectors <code>QAbs_flow</code>, <code>glaSha</code>, 
<code>JInSha</code> and <code>JOutSha</code> are removed.
This allows using the model as a base class for windows with inside shade, outside shade, or no shade.</p>
</html>",         revisions="<html>
<ul>
<li>
August 25 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end PartialConvection;

        model GlassLayer "Model for a glass layer of a window assembly"
          extends
          Buildings.HeatTransfer.Radiosity.BaseClasses.RadiosityTwoSurfaces;
          extends
          Buildings.HeatTransfer.Radiosity.BaseClasses.ParametersTwoSurfaces(
            final rhoIR_a=1-absIR_a-tauIR,
            final rhoIR_b=1-absIR_b-tauIR);
          parameter Modelica.SIunits.Length x "Material thickness";
          parameter Modelica.SIunits.ThermalConductivity k
          "Thermal conductivity";
          parameter Modelica.SIunits.Area A "Heat transfer area";
          parameter Modelica.SIunits.Emissivity absIR_a
          "Infrared absorptivity of surface a (usually room-facing surface)";
          parameter Modelica.SIunits.Emissivity absIR_b
          "Infrared absorptivity of surface b (usually outside-facing surface)";
          parameter Modelica.SIunits.Emissivity tauIR
          "Infrared transmittance of glass";

          Modelica.Blocks.Interfaces.RealInput u
          "Input connector, used to scale the surface area to take into account an operable shading device"
            annotation (Placement(transformation(extent={{-140,50},{-100,90}}),
                iconTransformation(extent={{-120,70},{-100,90}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_a(T(start=293.15, nominal=293.15))
          "Heat port at surface a"
            annotation (Placement(transformation(extent={{-110,-10},
                    {-90,10}}, rotation=0)));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b port_b(T(start=293.15, nominal=293.15))
          "Heat port at surface b"
            annotation (Placement(transformation(extent={{90,-10},{
                    110,10}}, rotation=0)));
          Modelica.Blocks.Interfaces.RealInput QAbs_flow(unit="W", quantity="Power")
          "Solar radiation absorbed by glass"   annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={0,-120}),iconTransformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={0,-110})));
          parameter Boolean linearize=false
          "Set to true to linearize emissive power";
          parameter Boolean homotopyInitialization = true
          "= true, use homotopy method"
            annotation(Evaluate=true, Dialog(tab="Advanced"));
      protected
         Real T4_a(min=1E8, unit="K4", start=293.15^4, nominal=1E10)
          "4th power of temperature at surface a";
         Real T4_b(min=1E8, unit="K4", start=293.15^4, nominal=1E10)
          "4th power of temperature at surface b";
         Modelica.SIunits.HeatFlowRate E_a(min=0, nominal=1E2)
          "Emissive power of surface a";
         Modelica.SIunits.HeatFlowRate E_b(min=0, nominal=1E2)
          "Emissive power of surface b";
         final parameter Modelica.SIunits.ThermalResistance R = x/2/k/A
          "Thermal resistance from surface of glass to center of glass";
        equation
          // Heat balance of surface node
          // These equations are from Window 6 Technical report, (2.1-14) to (2.1-17)
          0 = port_a.Q_flow + port_b.Q_flow + QAbs_flow + JIn_a  + JIn_b + JOut_a + JOut_b;
          //port_b.T-port_a.T = R/u * (2*port_b.Q_flow+QAbs_flow);
          u * (port_b.T-port_a.T) = 2*R * (-port_a.Q_flow-QAbs_flow/2-(absIR_a*JIn_a-E_a));
          // Radiosity balance
          if linearize then
            T4_a = T03 * port_a.T;
            T4_b = T03 * port_b.T;
          else
            if homotopyInitialization then
              T4_a = homotopy(actual=port_a.T^4, simplified=T03*port_a.T);
              T4_b = homotopy(actual=port_b.T^4, simplified=T03*port_b.T);
            else
              T4_a = port_a.T^4;
              T4_b = port_b.T^4;
            end if;
          end if;
          // Emissive power
          E_a = u * A * absIR_a * Modelica.Constants.sigma * T4_a;
          E_b = u * A * absIR_b * Modelica.Constants.sigma * T4_b;
          // Radiosities that are outgoing from the surface, which are
          // equal to the infrared absorptivity plus the reflected incoming
          // radiosity plus the radiosity that is transmitted from the
          // other surface.
          -JOut_a = E_a + rhoIR_a * JIn_a + tauIR * JIn_b;
          -JOut_b = E_b + rhoIR_b * JIn_b + tauIR * JIn_a;
          annotation (Diagram(graphics),
            Icon(graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-90,2},{92,-4}},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Rectangle(
                  extent={{-4,2},{4,-100}},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Text(
                  extent={{8,-70},{60,-98}},
                  lineColor={0,0,127},
                  textString="QAbs"),
                Text(
                  extent={{-96,88},{-64,70}},
                  lineColor={0,0,127},
                  textString="u")}),
            Documentation(info="<html>
Model of a single layer of window glass. The input port <code>QAbs_flow</code>
needs to be connected to the solar radiation that is absorbed
by the glass pane.
The model computes the heat conduction between the two glass surfaces.
The heat flow <code>QAbs_flow</code> is added at the center of the glass.
The model also computes the infrared radiative heat balance using an instance
of the model
<a href=\"Buildings.HeatTransfer.Radiosity.WindowPane\">
Buildings.HeatTransfer.Radiosity.WindowPane</a>.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 2, 2011 by Michael Wetter:<br>
Added <code>homotopy</code> operator.
</li>
<li>
August 18 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end GlassLayer;

        model CenterOfGlass
        "Model for center of glass of a window construction"
          extends
          Buildings.HeatTransfer.Radiosity.BaseClasses.RadiosityTwoSurfaces;
          parameter Modelica.SIunits.Area A "Heat transfer area";
          parameter Modelica.SIunits.Angle til(displayUnit="deg")
          "Surface tilt (only 90 degrees=vertical is implemented)";

          parameter Buildings.HeatTransfer.Data.GlazingSystems.Generic glaSys
          "Glazing system"
            annotation (Evaluate=true, HideResult=true, choicesAllMatching=true, Placement(transformation(extent={{60,60},
                    {80,80}})));

          Modelica.Blocks.Interfaces.RealInput u
          "Input connector, used to scale the surface area to take into account an operable shading device"
            annotation (Placement(transformation(extent={{-140,60},{-100,100}}),
                iconTransformation(extent={{-120,70},{-100,90}})));

          Buildings.HeatTransfer.Windows.BaseClasses.GlassLayer[glaSys.nLay] glass(
            each final A=A,
            final x[:]=glaSys.glass.x,
            final k[:]=glaSys.glass.k,
            final absIR_a[:]=glaSys.glass.absIR_a,
            final absIR_b[:]=glaSys.glass.absIR_a,
            final tauIR[:]=glaSys.glass.tauIR,
            each final linearize=linearize) "Window glass layer"
            annotation (Placement(transformation(extent={{-20,-10},{0,10}})));
          Buildings.HeatTransfer.Windows.BaseClasses.GasConvection gas[glaSys.nLay-1](
            each final A=A,
            final gas[:]=glaSys.gas,
            each final til=til,
            each linearize=linearize) "Window gas layer"
            annotation (Placement(transformation(extent={{20,10},{40,30}})));

          // Note that the interior shade is flipped horizontally. Hence, surfaces a and b are exchanged,
          // i.e., surface a faces the room, while surface b faces the window

          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a glass_a
          "Heat port connected to the outside facing surface of the glass"
            annotation (Placement(transformation(extent={{-110,-10},{-90,10}}, rotation=0)));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b glass_b
          "Heat port connected to the room-facing surface of the glass"
            annotation (Placement(transformation(extent={{90,-10},{110,10}},rotation=0)));

          parameter Boolean linearize=false
          "Set to true to linearize emissive power";
          Modelica.Blocks.Interfaces.RealInput QAbs_flow[size(glass, 1)](each unit="W", each
              quantity =                                                                              "Power")
          "Solar radiation absorbed by glass"   annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={0,-120}), iconTransformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={0,-110})));
        equation
          for i in 1:glaSys.nLay-1 loop
            connect(glass[i].port_b, gas[i].port_a)                        annotation (Line(
              points={{5.55112e-16,6.10623e-16},{0,0},{10,0},{10,20},{20,20}},
              color={191,0,0},
              smooth=Smooth.None));
            connect(gas[i].port_b, glass[i+1].port_a)                         annotation (Line(
              points={{40,20},{52,20},{52,36},{-40,36},{-40,0},{-20,0},{-20,6.10623e-16}},
              color={191,0,0},
              smooth=Smooth.None));

            connect(glass[i].JOut_b, glass[i+1].JIn_a)
            annotation (Line(
              points={{1,4},{8,4},{8,-24},{-30,-24},{-30,4},{-21,4}},
              color={0,127,0},
              smooth=Smooth.None));
            connect(glass[i].JIn_b, glass[i+1].JOut_a)
            annotation (Line(
              points={{1,-4},{6,-4},{6,-20},{-28,-20},{-28,-4},{-21,-4}},
              color={0,0,0},
              pattern=LinePattern.None,
              smooth=Smooth.None));

            connect(u, gas[i].u)   annotation (Line(
              points={{-120,80},{-86,80},{-86,44},{-8,44},{-8,28},{19,28}},
              color={0,0,127},
              smooth=Smooth.None));

          end for;

          for i in 1:glaSys.nLay loop
            connect(u, glass[i].u)  annotation (Line(
              points={{-120,80},{-86,80},{-86,44},{-48,44},{-48,8},{-21,8}},
              color={0,0,127},
              smooth=Smooth.None));
          end for;

          connect(glass_b, glass[glaSys.nLay].port_b) annotation (Line(
              points={{100,5.55112e-16},{100,5.55112e-16},{0,0}},
              color={191,0,0},
              smooth=Smooth.None));

          connect(glass_a, glass[1].port_a) annotation (Line(
              points={{-100,5.55112e-16},{-71,5.55112e-16},{-71,6.10623e-16},{-20,
                  6.10623e-16}},
              color={191,0,0},
              smooth=Smooth.None));

          connect(JIn_a, glass[1].JIn_a) annotation (Line(
              points={{-110,40},{-60,40},{-60,4},{-21,4}},
              color={0,0,0},
              pattern=LinePattern.None,
              smooth=Smooth.None));
          connect(glass[1].JOut_a, JOut_a) annotation (Line(
              points={{-21,-4},{-60,-4},{-60,-40},{-110,-40}},
              color={0,127,0},
              smooth=Smooth.None));
          connect(glass[glaSys.nLay].JOut_b, JOut_b) annotation (Line(
              points={{1,4},{80,4},{80,40},{110,40}},
              color={0,127,0},
              smooth=Smooth.None));
          connect(JIn_b, glass[glaSys.nLay].JIn_b) annotation (Line(
              points={{110,-40},{80,-40},{80,-4},{1,-4}},
              color={0,0,0},
              pattern=LinePattern.None,
              smooth=Smooth.None));
          connect(glass.QAbs_flow, QAbs_flow) annotation (Line(
              points={{-10,-11},{-10,-60},{1.11022e-15,-60},{1.11022e-15,-120}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}),       graphics={Text(
                  extent={{-82,100},{-32,86}},
                  lineColor={0,0,255},
                  textString="outside"),
                                       Ellipse(
                  extent={{-108,110},{-88,90}},
                  lineColor={255,255,0},
                  fillColor={255,213,170},
                  fillPattern=FillPattern.Sphere),
                                                 Text(
                  extent={{44,98},{94,84}},
                  lineColor={0,0,255},
                  textString="room-side")}),      Icon(coordinateSystem(
                  preserveAspectRatio=true, extent={{-100,-100},{100,100}}), graphics={
                Rectangle(
                  extent={{-90,2},{92,-4}},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Rectangle(
                  extent={{-56,50},{-44,-52}},
                  lineColor={0,0,0},
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-8,50},{4,-52}},
                  lineColor={0,0,0},
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{42,50},{54,-52}},
                  lineColor={0,0,0},
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Solid),       Text(
                  extent={{-90,86},{-78,74}},
                  lineColor={0,0,127},
                  textString="u")}),
            Documentation(info="<html>
This is a model for the heat transfer through the center of the glass.
The properties of the glazing system is defined by the parameter
<code>glaSys</code>. 
The model contains these main component models:
<ul>
<li>
the models <code>extSha</code> and <code>intSha</code>
for the heat balance of the shade, modeled using
<a href=\"modelica://Buildings.HeatTransfer.Windows.BaseClasses.Shade\"</a>
Buildings.HeatTransfer.Windows.BaseClasses.Shade</a>.
</li>
<li>
an array of models <code>glass</code> for the heat conduction and the 
infrared radiative heat balance of the glass layers.
There can be an arbitrary number of glass layers, which are all modeled using 
instances of
<a href=\"modelica://Buildings.HeatTransfer.Windows.BaseClasses.GlassLayer\">
Buildings.HeatTransfer.Windows.BaseClasses.GlassLayer</a>.
</li>
<li>
an array of models <code>gas</code> for the gas layers. There is one model of a
gas layer between each window panes. The gas layers are modeled using instances of
<a href=\"modelica://Buildings.HeatTransfer.Windows.BaseClasses.GasConvection\">
Buildings.HeatTransfer.Windows.BaseClasses.GasConvection</a>.
</li>
</ul>
Note that this model does <em>not</em> compute heat conduction through the frame and
it does <em>not</em> model the convective heat transfer at the exterior and interior
surface. These models are implemented in 
<a href=\"modelica://Buildings.HeatTransfer.Windows.Window\">
Buildings.HeatTransfer.Windows.Window</a>, 
<a href=\"modelica://Buildings.HeatTransfer.Windows.ExteriorHeatTransfer\">
Buildings.HeatTransfer.Windows.ExteriorHeatTransfer</a>, and
<a href=\"modelica://Buildings.HeatTransfer.Windows.InteriorHeatTransfer\">
Buildings.HeatTransfer.Windows.InteriorHeatTransfer</a>
</html>",         revisions="<html>
<ul>
<li>
Sep. 3 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end CenterOfGlass;

        model GasConvection
        "Model for heat convection through gas in a window assembly"
          extends Modelica.Thermal.HeatTransfer.Interfaces.Element1D(
             port_a(T(start=293.15)),
             port_b(T(start=293.15)));
          extends Buildings.BaseClasses.BaseIcon;
          parameter Buildings.HeatTransfer.Data.Gases.Generic gas
          "Thermophysical properties of gas fill"
           annotation(choicesAllMatching=true);
          parameter Modelica.SIunits.Area A "Heat transfer area";
          parameter Modelica.SIunits.Area h(min=0) = sqrt(A) "Height of window";

          parameter Modelica.SIunits.Angle til(displayUnit="deg")
          "Surface tilt (only 0, 90 and 180 degrees are implemented)";
          parameter Boolean linearize=false
          "Set to true to linearize emissive power";

          Modelica.Blocks.Interfaces.RealInput u
          "Input connector, used to scale the surface area to take into account an operable shading device"
            annotation (Placement(transformation(extent={{-140,50},{-100,90}}),
                iconTransformation(extent={{-120,70},{-100,90}})));

          parameter Modelica.SIunits.Temperature T0 = 293.15
          "Temperature used to compute thermophysical properties";
          Modelica.SIunits.CoefficientOfHeatTransfer hCon(min=0, start=3)
          "Convective heat transfer coefficient";
          Modelica.SIunits.HeatFlux q_flow "Convective heat flux";
          Real Nu(min=0) "Nusselt number";
          Real Ra(min=0) "Raleigh number";
      protected
          Modelica.SIunits.Temperature T_a
          "Temperature used for thermophysical properties at port_a";
          Modelica.SIunits.Temperature T_b
          "Temperature used for thermophysical properties at port_b";
          Modelica.SIunits.Temperature T_m
          "Temperature used for thermophysical properties";

          Real deltaNu(min=0.01) = 0.1
          "Small value for Nusselt number, used for smoothing";
          Real deltaRa(min=0.01) = 100
          "Small value for Raleigh number, used for smoothing";
          final parameter Real cosTil=Modelica.Math.cos(til)
          "Cosine of window tilt"
            annotation (Evaluate=true);
          final parameter Real sinTil=Modelica.Math.sin(til)
          "Sine of window tilt"
            annotation (Evaluate=true);
          final parameter Boolean isVertical = abs(cosTil) < 10E-10
          "Flag, true if the window is in a wall"
            annotation (Evaluate=true);
          final parameter Boolean isHorizontal = abs(sinTil) < 10E-10
          "Flag, true if the window is horizontal"
            annotation (Evaluate=true);
          // Quantities that are only used in linearized model

          parameter Modelica.SIunits.CoefficientOfHeatTransfer hCon0(fixed=false)
          "Convective heat transfer coefficient";
          parameter Real Nu0(fixed=false, min=0) "Nusselt number";
          parameter Real Ra0(fixed=false, min=0) "Raleigh number";
          parameter Boolean homotopyInitialization = true
          "= true, use homotopy method"
            annotation(Evaluate=true, Dialog(tab="Advanced"));

        initial equation
          assert(isVertical or isHorizontal, "Only vertical and horizontal windows are implemented.");
        initial equation
          // Computations that are used in the linearized model only
          Ra0 = Buildings.HeatTransfer.Convection.Functions.HeatFlux.raleigh(
            x=gas.x,
            rho=Buildings.HeatTransfer.Data.Gases.density(gas, T0),
            c_p=Buildings.HeatTransfer.Data.Gases.specificHeatCapacity(gas, T0),
            mu=Buildings.HeatTransfer.Data.Gases.dynamicViscosity(gas, T0),
            k=Buildings.HeatTransfer.Data.Gases.thermalConductivity(gas, T0),
            T_a=T0-5,
            T_b=T0+5,
            Ra_min=100);
          (Nu0, hCon0) = Buildings.HeatTransfer.Windows.BaseClasses.convectionVerticalCavity(
                    gas=gas, Ra=Ra0, T_m=T0, dT=10, h=h, deltaNu=deltaNu, deltaRa=deltaRa);

        equation
          T_a = port_a.T;
          T_b = port_b.T;
          T_m = (port_a.T+port_b.T)/2;
          if linearize then
            Ra=Ra0;
            Nu=Nu0;
            hCon=hCon0;
            q_flow = hCon0 * dT;
          else
            Ra = Buildings.HeatTransfer.Convection.Functions.HeatFlux.raleigh(
              x=gas.x,
              rho=Buildings.HeatTransfer.Data.Gases.density(gas, T_m),
              c_p=Buildings.HeatTransfer.Data.Gases.specificHeatCapacity(gas, T_m),
              mu=Buildings.HeatTransfer.Data.Gases.dynamicViscosity(gas, T_m),
              k=Buildings.HeatTransfer.Data.Gases.thermalConductivity(gas, T_m),
              T_a=T_a,
              T_b=T_b,
              Ra_min=100);
            if isVertical then
               (Nu, hCon, q_flow) = Buildings.HeatTransfer.Windows.BaseClasses.convectionVerticalCavity(
                      gas=gas, Ra=Ra, T_m=T_m, dT=dT, h=h, deltaNu=deltaNu, deltaRa=deltaRa);
            elseif isHorizontal then
               (Nu, hCon, q_flow) = Buildings.HeatTransfer.Windows.BaseClasses.convectionHorizontalCavity(
                      gas=gas, Ra=Ra, T_m=T_m, dT=dT, til=til, sinTil=sinTil, cosTil=cosTil,
                      h=h, deltaNu=deltaNu, deltaRa=deltaRa);

            else
               Nu = 0;
               hCon=0;
               q_flow=0;
            end if; // isVertical or isHorizontal
          end if; // linearize
          if homotopyInitialization then
            Q_flow = u*A*homotopy(actual=q_flow,
                                  simplified=hCon0*dT);
          else
            Q_flow = u*A*q_flow;
          end if;
          annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}),       graphics), Icon(coordinateSystem(
                  preserveAspectRatio=true, extent={{-100,-100},{100,100}}),
               graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-90,78},{-76,-80}},
                  fillColor={85,170,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Text(
                  extent={{-51,42},{-21,20}},
                  lineColor={127,0,0},
                  textString="Q_flow"),
                Line(points={{-68,20},{68,20}}, color={191,0,0}),
                Line(points={{-68,-20},{68,-20}}, color={191,0,0}),
                Line(points={{-56,80},{-56,-80}}, color={0,127,255}),
                Line(points={{-16,80},{-16,-80}},
                                              color={0,127,255}),
                Line(points={{18,80},{18,-80}}, color={0,127,255}),
                Line(points={{54,80},{54,-80}}, color={0,127,255}),
                Line(points={{-56,-80},{-66,-60}}, color={0,127,255}),
                Line(points={{-56,-80},{-46,-60}}, color={0,127,255}),
                Line(points={{-16,-80},{-26,-60}},
                                                color={0,127,255}),
                Line(points={{-16,-80},{-6,-60}},
                                                color={0,127,255}),
                Line(points={{18,-80},{8,-60}},  color={0,127,255}),
                Line(points={{18,-80},{28,-60}}, color={0,127,255}),
                Line(points={{54,-80},{44,-60}}, color={0,127,255}),
                Line(points={{54,-80},{64,-60}}, color={0,127,255}),
                Line(points={{48,-30},{68,-20}}, color={191,0,0}),
                Line(points={{48,-10},{68,-20}}, color={191,0,0}),
                Line(points={{48,10},{68,20}}, color={191,0,0}),
                Line(points={{48,30},{68,20}}, color={191,0,0}),
                Rectangle(
                  extent={{76,80},{90,-78}},
                  fillColor={85,170,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Text(
                  extent={{-100,86},{-86,76}},
                  lineColor={0,0,127},
                  textString="u")}),
            Documentation(info="<html>
Model for convective heat tranfer in a single layer of window gas.
Currently, the model only implements equations for vertical windows
and for horizontal windows.
The computation is according to TARCOG 2006,
except that this implementation computes the convection coefficient
as a function that is differentiable in the temperatures.
<p>
To use this model, set the parameter <code>til</code>
to a value defined in 
<a href=\"modelica://Buildings.HeatTransfer.Types.Tilt\">
Buildings.HeatTransfer.Types.Tilt</a>.
</p>
</p>
<p>
If the parameter <code>linearize</code> is set to <code>true</code>,
then all equations are linearized.
</p>
<h4>References</h4>
<p>
TARCOG 2006: Carli, Inc., TARCOG: Mathematical models for calculation
of thermal performance of glazing systems with our without
shading devices, Technical Report, Oct. 17, 2006.
</html>",         revisions="<html>
<ul>
<li>
April 2, 2011 by Michael Wetter:<br>
Added <code>homotopy</code> operator.
</li>
<li>
August 18 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end GasConvection;

        block ShadingSignal
        "Converts the shading signal to be strictly bigger than 0 and smaller than 1"
          extends Modelica.Blocks.Interfaces.SO;
          parameter Boolean haveShade "Set to true if a shade is present"
            annotation (Evaluate=true);
          Modelica.Blocks.Interfaces.RealInput u if haveShade
          "Shading control signal, 0: unshaded; 1: fully shaded"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}},
                rotation=0), iconTransformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput yCom "1-u"
            annotation (Placement(transformation(extent={{100,-70},{120,-50}},
                rotation=0), iconTransformation(extent={{100,-70},{120,-50}})));
      protected
          constant Real y0 = 1E-6
          "Smallest allowed value for y if a shade is present";
          constant Real k = 1-2*y0 "Gain for shading signal";
          Modelica.Blocks.Interfaces.RealInput u_in_internal
          "Needed to connect to conditional connector";
        equation
          connect(u, u_in_internal);
          if not haveShade then
            u_in_internal = 0;
          end if;
          if haveShade then
            y = y0 + k *  u_in_internal;
            yCom = 1-y;
          else
            y = 0;
            yCom = 1;
          end if;
          annotation (Diagram(graphics), Icon(graphics={
                Text(
                  extent={{-92,22},{-50,-22}},
                  lineColor={0,0,127},
                  textString="u"),
                Text(
                  extent={{48,22},{90,-22}},
                  lineColor={0,0,127},
                  textString="u'"),
                Text(
                  extent={{-14,-40},{92,-80}},
                  lineColor={0,0,127},
                  textString="1-u'")}),
                   Documentation(info="<html>
This model changes the shading control signal to avoid a singularity 
in the window model if the input signal is zero or one.
Since the window heat balance multiplies the area of the window by <code>u</code>
or by <code>1-u</code> (if a shade is present), the heat balance can be singular
for <code>u=0</code> or for <code>u=1</code>.
This model avoids this singularity by slightly changing the control signal.
</html>",         revisions="<html>
<ul>
<li>
October 28 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end ShadingSignal;

        model ExteriorConvectionCoefficient
        "Model for the heat transfer coefficient at the outside of the window"
          extends Modelica.Blocks.Interfaces.BlockIcon;
          parameter Modelica.SIunits.Area A "Heat transfer area";

          Modelica.Blocks.Interfaces.RealOutput GCon(unit="W/K")
          "Convective thermal conductance"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          Modelica.Blocks.Interfaces.RealInput v(unit="m/s") "Wind speed"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

        equation
          GCon = A*(4+4*Buildings.Utilities.Math.Functions.smoothMax(v, -v, 0.1));
          annotation (Diagram(graphics), Icon(graphics={
                Text(
                  extent={{-92,22},{-50,-22}},
                  lineColor={0,0,127},
                  textString="v"),
                Text(
                  extent={{40,26},{92,-20}},
                  lineColor={0,0,127},
                  textString="GCon")}),
                   Documentation(info="<html>
Model for the convective heat transfer coefficient at the outside of a window.
The computation is according to TARCOG 2006, which specifies the convection
coefficient as
<p align=\"center\" style=\"font-style:italic;\">
  h = 4+4 v
</p>
where <i>v</i> is the wind speed in <i>m/s</i> and
<i>h</i> is the convective heat transfer coefficient in <i>W/(m2*K)</i>.
</p>
<h4>References</h4>
<p>
TARCOG 2006: Carli, Inc., TARCOG: Mathematical models for calculation
of thermal performance of glazing systems with our without
shading devices, Technical Report, Oct. 17, 2006.
</html>",         revisions="<html>
<ul>
<li>
August 19 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end ExteriorConvectionCoefficient;

        model InteriorConvectionCoefficient
        "Model for the heat transfer coefficient at the inside of the window"
          extends Modelica.Blocks.Interfaces.BlockIcon;
          parameter Modelica.SIunits.Area A "Heat transfer area";

          Modelica.Blocks.Interfaces.RealOutput GCon(unit="W/K")
          "Convective thermal conductance"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

        equation
          GCon = 4*A;
          annotation (Diagram(graphics), Icon(graphics={
                Text(
                  extent={{40,26},{92,-20}},
                  lineColor={0,0,127},
                  textString="GCon")}),
                   Documentation(info="<html>
Model for the convective heat transfer coefficient at the room-facing surface of a window.
The computation is according to TARCOG 2006, which specifies the convection
coefficient as
<p align=\"center\" style=\"font-style:italic;\">
  h = 4 W &frasl; (m<sup>2</sup> K).
</i>
</p>
<h4>References</h4>
<p>
TARCOG 2006: Carli, Inc., TARCOG: Mathematical models for calculation
of thermal performance of glazing systems with our without
shading devices, Technical Report, Oct. 17, 2006.
</html>",         revisions="<html>
<ul>
<li>
August 19 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end InteriorConvectionCoefficient;

        partial block PartialRadiation
        "Partial model for variables and data used in radiation calculation"
          extends Modelica.Blocks.Interfaces.BlockIcon;
          extends Buildings.HeatTransfer.Windows.BaseClasses.RadiationBaseData;

          ////////////////// Parameters that are not used by RadiationData
          parameter Boolean haveExteriorShade
          "Set to true if window has an exterior shade";
          parameter Boolean haveInteriorShade
          "Set to true if window has an interior shade";
          parameter Modelica.SIunits.Area AWin "Area of window";

          ////////////////// Derived parameters
          final parameter Boolean haveShade=haveExteriorShade or haveInteriorShade
          "Set to true if window has a shade"   annotation (Evaluate=true);
          final parameter
          Buildings.HeatTransfer.Windows.BaseClasses.RadiationData
            radDat(
            final N=N,
            final tauGlaSol=tauGlaSol,
            final rhoGlaSol_a=rhoGlaSol_a,
            final rhoGlaSol_b=rhoGlaSol_b,
            final tauShaSol_a=tauShaSol_a,
            final tauShaSol_b=tauShaSol_b,
            final rhoShaSol_a=rhoShaSol_a,
            final rhoShaSol_b=rhoShaSol_b)
          "Optical properties of window for different irradiation angles"   annotation (
             Evaluate=true, Placement(transformation(extent={{60,20},{80,40}})));
          Modelica.Blocks.Interfaces.RealInput uSha(min=0, max=1) if haveShade
          "Control signal for shading (0: unshaded; 1: fully shaded)"   annotation (
              Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={0,-120}),iconTransformation(
                extent={{-16,-16},{16,16}},
                rotation=90,
                origin={-2,-116})));
          Modelica.Blocks.Interfaces.RealInput HDif(quantity="RadiantEnergyFluenceRate",
              unit="W/m2") "Diffussive solar radiation" annotation (Placement(
                transformation(extent={{-140,60},{-100,100}}),iconTransformation(extent=
                   {{-130,65},{-100,95}})));
          Modelica.Blocks.Interfaces.RealInput incAng(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") "Incident angle" annotation (Placement(transformation(
                  extent={{-140,-20},{-100,20}}), iconTransformation(extent={{-130,-25},
                    {-100,5}})));
          Modelica.Blocks.Interfaces.RealInput HDir(quantity="RadiantEnergyFluenceRate",
              unit="W/m2") "Direct solar radiation" annotation (Placement(
                transformation(extent={{-140,20},{-100,60}}),iconTransformation(extent=
                    {{-130,25},{-100,55}})));

      protected
          Modelica.Blocks.Interfaces.RealInput uSha_internal(min=0, max=1)
          "Control signal for shading (0: unshaded; 1: fully shaded)";
        initial equation
          /* Current model assumes that the window only has either an interior or exterior shade.
     Warn user if it has an interior and exterior shade. 
     Allowing both shades at the same time would require rewriting part of the model. */
          assert(not (haveExteriorShade and haveInteriorShade),
            "Window radiation model does not support an exterior and interior shade at the same time.");
        equation
          // Connect statement for conditionally removed connector uSha
          connect(uSha, uSha_internal);
          if (not haveShade) then
            uSha_internal = 0;
          end if;
          annotation (
            Documentation(info="<html>
The model calculates solar absorbance on the window. 
The calculations follow the description in Wetter (2004), Appendix A.4.3.

<h4>References</h4>
<ul>
<li>
Michael Wetter.<br>
<a href=\"http://simulationresearch.lbl.gov/wetter/download/mwdiss.pdf\">
Simulation-based Building Energy Optimization</a>.<br>
Dissertation. University of California at Berkeley. 2004.
</li>
</ul>
</html>",         revisions="<html>
<ul>
<li>
February 2, 2010, by Michael Wetter:<br>
Made connector <code>uSha</code> a conditional connector.
</li>
<li>
December 16, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"),  Diagram(graphics),
            Icon(graphics={
                Text(
                  extent={{-92,0},{-62,-20}},
                  lineColor={0,0,127},
                  textString="incAng"),
                Text(
                  extent={{-94,84},{-70,70}},
                  lineColor={0,0,127},
                  textString="HDif"),
                Text(
                  extent={{-96,42},{-62,30}},
                  lineColor={0,0,127},
                  textString="HDir"),
                Text(
                  extent={{-32,-82},{22,-94}},
                  lineColor={0,0,127},
                  textString="uSha"),
                Polygon(
                  points={{-46,66},{-46,-10},{-6,-50},{-6,22},{-46,66}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{18,64},{18,-12},{58,-52},{58,20},{18,64}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={170,213,255},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-28,2},{-18,10},{-8,0},{2,10},{12,0},{22,10},{32,-2},{40,4},
                      {34,4},{38,-2},{40,4},{38,4}},
                  color={255,128,0},
                  smooth=Smooth.None),
                Polygon(
                  points={{38,-2},{34,4},{40,4},{38,-2}},
                  lineColor={255,128,0},
                  smooth=Smooth.None,
                  fillColor={255,128,0},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{38,-4},{46,-14},{58,-4},{66,-14},{66,-14},{76,-4},{86,-16},{
                      94,-10},{88,-10},{92,-16},{94,-10},{92,-10}},
                  color={255,128,0},
                  smooth=Smooth.None),
                Polygon(
                  points={{92,-16},{88,-10},{94,-10},{92,-16}},
                  lineColor={255,128,0},
                  smooth=Smooth.None,
                  fillColor={255,128,0},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-26,8},{-30,14},{-24,14},{-26,8}},
                  lineColor={255,128,0},
                  smooth=Smooth.None,
                  fillColor={255,128,0},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-80,20},{-72,10},{-60,20},{-52,10},{-52,10},{-42,20},{-32,8},
                      {-24,14},{-30,14},{-26,8},{-24,14},{-26,14}},
                  color={255,128,0},
                  smooth=Smooth.None)}));
        end PartialRadiation;

        block AbsorbedRadiation "Absorbed radiation by window"
          extends Buildings.HeatTransfer.Windows.BaseClasses.PartialRadiation;

          Modelica.Blocks.Interfaces.RealInput HRoo(quantity="RadiantEnergyFluenceRate",
              unit="W/m2") "Diffussive radiation from room " annotation (Placement(
                transformation(extent={{-140,-100},{-100,-60}}),iconTransformation(
                  extent={{-130,-91},{-100,-61}})));

          Modelica.Blocks.Interfaces.RealOutput QAbsExtSha_flow(final quantity="Power",
              final unit="W")
          "Absorbed interior and exterior radiation by exterior shading device"
            annotation (Placement(transformation(extent={{100,70},{120,90}}),
                iconTransformation(extent={{100,70},{120,90}})));
          Modelica.Blocks.Interfaces.RealOutput QAbsIntSha_flow(final quantity="Power",
              final unit="W")
          "Absorbed interior and exterior radiation by interior shading device"
            annotation (Placement(transformation(extent={{100,-90},{120,-70}}),
                iconTransformation(extent={{100,-90},{120,-70}})));
          Modelica.Blocks.Interfaces.RealOutput QAbsGlaUns_flow[N](each quantity=
                "Power", each final unit="W")
          "Absorbed interior and exterior radiation by unshaded part of glass"
            annotation (Placement(transformation(extent={{100,30},{120,50}}),
                iconTransformation(extent={{100,30},{120,50}})));
          Modelica.Blocks.Interfaces.RealOutput QAbsGlaSha_flow[N](each quantity=
                "Power", each final unit="W")
          "Absorbed interior and exterior radiation by shaded part of glass"
            annotation (Placement(transformation(extent={{100,-50},{120,-30}}),
                iconTransformation(extent={{100,-50},{120,-30}})));

          output Modelica.SIunits.Power absRad[2, N + 2] "Absorbed interior and exterior radiation. 
      (absRad[2,1]: exterior shading device, 
      absRad[1,2 to N+1]: glass (unshaded part),
      absRad[2,2 to N+1]: glass (shaded part),   
      absRad[2,N+2]: interior shading device)";

      protected
          Integer k=1;
          Real x;
          final parameter Integer NDIR=radDat.NDIR;
          final parameter Integer HEM=radDat.HEM;
          constant Integer NoShade=1;
          constant Integer Shade=2;
          constant Integer Interior=1;
          constant Integer Exterior=2;
          final parameter Real coeAbsEx[2, radDat.N, radDat.HEM + 2](fixed=false);
          final parameter Real coeRefExtPan1[radDat.HEM + 2](fixed=false)
          "Reflectivity of pane 1";
          final parameter Real coeAbsIn[2, radDat.N](fixed=false);
          final parameter Real coeAbsDevExtIrrIntSha[radDat.HEM + 2](fixed=false)
          "Absorptivity of interior shading device for exterior radiation";
          final parameter Real coeAbsDevExtIrrExtSha=1 - radDat.traRefShaDev[1, 1] -
              radDat.traRefShaDev[2, 1]
          "Absorptivity of exterior shading device for exterior radiation";
          final parameter Real coeAbsDevIntIrrIntSha=radDat.devAbsIntIrrIntSha
          "Absorptivity of interior shading device for interior radiation";
          final parameter Real coeAbsDevIntIrrExtSha=1 - radDat.winTraRefIntIrrExtSha[1]
               - radDat.winTraRefIntIrrExtSha[2]
          "Absorptivity of exterior shading device for interior radiation";
          Real tmpNoSha;
          Real tmpSha;
          Real incAng2;

        initial algorithm
          //**************************************************************
          // Assign coefficients.
          // Data dimension changes from Orginal ([1 : HEM]) to New ([2 : HEM+1])
          // with 2 dummy variable for interpolation.
          //**************************************************************
          // Glass
          for i in 1:N loop
            for j in 1:HEM loop
              // Properties for glass without shading
              coeAbsEx[NoShade, i, j + 1] := radDat.absExtIrrNoSha[i, j];
              coeAbsIn[NoShade, i] := radDat.absIntIrrNoSha[i];
              // Properties for glass with shading
              if haveInteriorShade then
                coeAbsEx[Shade, i, j + 1] := radDat.absExtIrrIntSha[i, j];
                coeAbsIn[Shade, i] := radDat.absIntIrrIntSha[i];
              elseif haveExteriorShade then
                coeAbsEx[Shade, i, j + 1] := radDat.absExtIrrExtSha[i, j];
                coeAbsIn[Shade, i] := radDat.absIntIrrExtSha[i];
              else
                // No Shade
                coeAbsEx[Shade, i, j + 1] := 0.0;
                coeAbsIn[Shade, i] := 0.0;
              end if;
            end for;
            // Dummy variables at 1 and HEM+2
            for k in NoShade:Shade loop
              coeAbsEx[k, i, 1] := coeAbsEx[k, i, 2];
              coeAbsEx[k, i, HEM + 2] := coeAbsEx[k, i, HEM + 1];
            end for;
          end for;

          // Glass Pane 1: Reflectivity
          for j in 1:HEM loop
            coeRefExtPan1[j + 1] := radDat.traRef[2, 1, N, j];
          end for;

          // Interior shades
          for j in 1:HEM loop
            coeAbsDevExtIrrIntSha[j + 1] := radDat.devAbsExtIrrIntShaDev[j];
          end for;

          // Dummy variables at 1 and HEM+2
          coeRefExtPan1[1] := coeRefExtPan1[2];
          coeRefExtPan1[HEM + 2] := coeRefExtPan1[HEM + 1];
          coeAbsDevExtIrrIntSha[1] := coeAbsDevExtIrrIntSha[2];
          coeAbsDevExtIrrIntSha[HEM + 2] := coeAbsDevExtIrrIntSha[HEM + 1];

        algorithm
          absRad[NoShade, 1] := 0.0;
          absRad[NoShade, N + 2] := 0.0;
          absRad[Shade, 1] := 0.0;
          absRad[Shade, N + 2] := 0.0;

          //**************************************************************
          // Glass: absorbed diffusive radiation from exterior and interior sources
          //**************************************************************
          for i in 1:N loop
            absRad[NoShade, i + 1] := AWin*(1 - uSha_internal)*(HDif*coeAbsEx[NoShade,
              i, HEM + 1] + HRoo*coeAbsIn[NoShade, i]);
            absRad[Shade, i + 1] := AWin*uSha_internal*(HDif*coeAbsEx[Shade, i, HEM + 1]
               + HRoo*coeAbsIn[Shade, i]);
          end for;

          //**************************************************************
          // Shading device: absorbed radiation from exterior source
          //**************************************************************
          // Exterior Shading Device:
          // direct radiation: 1. direct absorption;
          // diffusive radiation: 1. direct absorption 2. absorption from back reflection
          if haveExteriorShade then
            absRad[Shade, 1] := AWin*uSha_internal*coeAbsDevExtIrrExtSha*(HDif + HDir
               + HDif*radDat.traRefShaDev[1, 1]*radDat.traRef[2, 1, N, HEM]);
            // Interior Shading Device: diffusive radiation from both interior and exterior
          elseif haveInteriorShade then
            absRad[Shade, N + 2] := AWin*uSha_internal*(HDif*radDat.devAbsExtIrrIntShaDev[
              HEM] + HRoo*coeAbsDevIntIrrIntSha);
          end if;

          //**************************************************************
          // Glass, Device: add absorbed direct radiation from exterior sources
          //**************************************************************
          // Use min() instead of if() to avoid event
          incAng2 := min(incAng, 0.5*Modelica.Constants.pi);

          x := 2*(NDIR - 1)*abs(incAng2)/Modelica.Constants.pi
          "x=(index-1)*incAng/(0.5pi), 0<=x<=NDIR";
          x := x + 2;

          for i in 1:N loop
            // Glass without shading: Add absorbed direct radiation
            tmpNoSha :=
              Buildings.HeatTransfer.Windows.BaseClasses.smoothInterpolation({
              coeAbsEx[NoShade, i, k] for k in 1:(HEM + 2)}, x);
            absRad[NoShade, i + 1] := absRad[NoShade, i + 1] + AWin*HDir*(1 -
              uSha_internal)*tmpNoSha;

            // Glass with shading: add absorbed direct radiation
            tmpSha :=
              Buildings.HeatTransfer.Windows.BaseClasses.smoothInterpolation({
              coeAbsEx[Shade, i, k] for k in 1:(HEM + 2)}, x);
            absRad[Shade, i + 1] := absRad[Shade, i + 1] + AWin*HDir*uSha_internal*
              tmpSha;
          end for;

          // Interior shading device: add absorbed direct radiation
          if haveInteriorShade then
            tmpSha :=
              Buildings.HeatTransfer.Windows.BaseClasses.smoothInterpolation({
              coeAbsDevExtIrrIntSha[k] for k in 1:(HEM + 2)}, x);
            absRad[Shade, N + 2] := absRad[Shade, N + 2] + AWin*HDir*uSha_internal*
              tmpSha;
          end if;

          // Exterior shading device: add absorbed reflection of direct radiation from exterior source
          if haveExteriorShade then
            tmpNoSha :=
              Buildings.HeatTransfer.Windows.BaseClasses.smoothInterpolation({
              coeRefExtPan1[k] for k in 1:(HEM + 2)}, x);
            absRad[Shade, 1] := absRad[Shade, 1] + AWin*HDir*uSha_internal*
              coeAbsDevExtIrrExtSha*tmpNoSha;
          end if;

          // Assign quantities to output connectors
          QAbsExtSha_flow := absRad[2, 1];
          QAbsIntSha_flow := absRad[2, N + 2];
          QAbsGlaUns_flow[:] := absRad[1, 2:N + 1];
          QAbsGlaSha_flow[:] := absRad[2, 2:N + 1];
          annotation (
            Documentation(info="<html>
The model calculates absorbed solar radiation on the window. 
The calculations follow the description in Wetter (2004), Appendix A.4.3.
</p>
<p>
The absorbed radiation by exterior shades includes:</p>
<ol>
<li>
the directly absorbed exterior radiation: <code>AWin*uSha*(HDir+HDif)*(1-tau-rho)</code>
</li>
<li>
the indirectly absorbed exterior radiantion from reflection (angular part): <code>AWin*uSha*HDir*tau*rho(IncAng)*(1-tau-rho)</code>
</li>
<li>
the indirectly absorbed of exterior irradiantion from reflection (diffusive part): <code>AWin*uSha*HDif*tau*rho(HEM)*(1-tau-rho)</code>
</li>
<li>
the absorbed interior radiation is neglected.
</li>
</ol>
The output is <code>absRad[2, 1]</code>
</p>
<p>
The absorbed radiation by interior shades includes:</p>
<ol>
<li>
the absorbed exterior radiation (angular part): <code>AWin*uSha*HDir*alpha(IncAng)</code>
</li>
<li>
the absorbed exterior radiation (diffusive part): <code>AWin*uSha*HDif*alpha(HEM)</code>
</li>
<li>
the absorbed interior radiation (diffusive part): <code>AWin*uSha*HRoo*(1-tau-rho)</code>
</li>
</ol>
The output is <code>absRad[2, N+2]</code>
</p>
<p>
The absorbed radiation by glass includes:</p>
<ol>
<li>
the absorbed radiation by unshaded part (diffusive part): <code>AWin*(1-uSha)*(HDif*alphaEx(HEM)+HRoo*alphaIn(HEM))</code>
</li>
<li>
the absorbed radiation by unshaded part (angular part from exterior source): <code>AWin*(1-uSha)*HDir*alphaEx(IncAng)</code>
</li>
<li>
the absorbed radiaiton by shaded part (diffusive part): <code>AWin*uSha*(HDif*alphaExSha(HEM)+HRoo*alphaInSha(HEM))</code>
</li>
<li>
the absorbed radiation by shaded part (angular part from exterior source): <code>AWin*uSha*HDir*alphaExSha(IncAng)</code>
</li>
</ol>
The output is <code>absRad[1, 2:N+1] = Part1 + Part2; absRad[2, 2:N+1] = Part3 + Part4</code>
</p>

<h4>References</h4>
<ul>
<li>
Michael Wetter.<br>
<a href=\"http://simulationresearch.lbl.gov/wetter/download/mwdiss.pdf\">
Simulation-based Building Energy Optimization</a>.<br>
Dissertation. University of California at Berkeley. 2004.
</li>
</ul>
</html>",         revisions="<html>
<ul>
<li>
March 4, 2011, by Wangda Zuo:<br>
Remove the if-statement and integer function that can trigger events.
</li>
<li>
February 2, 2010, by Michael Wetter:<br>
Made connector <code>uSha</code> a conditional connector.
</li>
<li>
December 15, 2010, by Wangda Zuo:<br>
Separate transmittance and absorbance.
</li>
<li>
December 12, 2010, by Michael Wetter:<br>
Replaced record 
<a href=\"modelica://Buildings.HeatTransfer.Data.GlazingSystems\">
Buildings.HeatTransfer.Data.GlazingSystems</a> with the
parameters used by this model.
This was needed to integrate the radiation model into the room model.
</li>
<li>
December 10, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"),  Diagram(graphics),
            Icon(graphics={
                Text(
                  extent={{26,86},{102,74}},
                  lineColor={0,0,127},
                  textString="QAbsExtSha"),
                Text(
                  extent={{-101,-73},{-54,-82}},
                  lineColor={0,0,127},
                  textString="HRoo"),
                Text(
                  extent={{24,-68},{102,-80}},
                  lineColor={0,0,127},
                  textString="QAbsIntSha"),
                Text(
                  extent={{34,46},{94,32}},
                  lineColor={0,0,127},
                  textString="QAbsGlaUns"),
                Text(
                  extent={{30,-32},{104,-44}},
                  lineColor={0,0,127},
                  textString="QAbsGlaSha")}));
        end AbsorbedRadiation;

        block TransmittedRadiation "Transmitted radiation through window"
          extends Buildings.HeatTransfer.Windows.BaseClasses.PartialRadiation;
          Modelica.Blocks.Interfaces.RealOutput QTra_flow(final quantity="Power",
              final unit="W")
          "Transmitted exterior radiation through the window. (1: no shade; 2: shade)"
            annotation (Placement(transformation(extent={{100,-10},{120,10}}),
                iconTransformation(extent={{100,-10},{120,10}})));
          final parameter Real traCoeRoo(fixed=false)
          "Transmitivity of the window glass for interior radiation without shading";

          output Modelica.SIunits.Power QTraUns_flow
          "Transmitted solar radiation through unshaded part of window";
          output Modelica.SIunits.Power QTraSha_flow
          "Transmitted solar radiation through shaded part of window";

      protected
          Integer k=1;
          Real x;
          final parameter Integer NDIR=radDat.NDIR;
          final parameter Integer HEM=radDat.HEM;
          constant Integer NoShade=1;
          constant Integer Shade=2;
          constant Integer Interior=1;
          constant Integer Exterior=2;
          final parameter Real coeTraWinExtIrr[2, radDat.HEM + 2](fixed=false);
          Real tmpNoSha;
          Real tmpSha;
          Real incAng2;

        initial algorithm
          //**************************************************************
          // Assign coefficients.
          // Data dimension from Orginal ([1 : HEM]) to New ([2 : HEM+1])
          // with 2 dummy variable for interpolation.
          //**************************************************************
          // Glass
          for j in 1:HEM loop
            // Properties for glass without shading
            coeTraWinExtIrr[NoShade, j + 1] := radDat.traRef[1, 1, N, j];
            // Properties for glass with shading
            if haveInteriorShade then
              coeTraWinExtIrr[Shade, j + 1] := radDat.winTraExtIrrIntSha[j];
            elseif haveExteriorShade then
              coeTraWinExtIrr[Shade, j + 1] := radDat.winTraExtIrrExtSha[j];
            else
              // No Shade
              coeTraWinExtIrr[Shade, j + 1] := 0.0;
            end if;
          end for;
          // Dummy variables at 1 and HEM+2
          for k in NoShade:Shade loop
            coeTraWinExtIrr[k, 1] := coeTraWinExtIrr[k, 2];
            coeTraWinExtIrr[k, HEM + 2] := coeTraWinExtIrr[k, HEM + 1];
          end for;

          //**************************************************************
          // Glass: transmissivity for interior irradiation
          //**************************************************************
          traCoeRoo := radDat.traRef[1, N, 1, HEM];

        equation

          //**************************************************************
          // Window: transmitted radiation for diffusive radiation from exterior sources
          //**************************************************************
        algorithm
          QTraUns_flow := AWin*HDif*(1 - uSha_internal)*coeTraWinExtIrr[NoShade, HEM +
            1];
          QTraSha_flow := AWin*HDif*uSha_internal*coeTraWinExtIrr[Shade, HEM + 1];

          //**************************************************************
          // Glass, Device: add absorbed radiation (angular part) from exterior sources
          //**************************************************************
          // Use min() instead of if() to avoid event
          incAng2 := min(incAng, 0.5*Modelica.Constants.pi);
          x := 2*(NDIR - 1)*abs(incAng2)/Modelica.Constants.pi
          "x=(index-1)*incAng/(0.5pi), 0<=x<=NDIR-1";
          x := x + 2;

          // Window unshaded parts: add transmitted radiation for angular radiation
          tmpNoSha :=
            Buildings.HeatTransfer.Windows.BaseClasses.smoothInterpolation({
            coeTraWinExtIrr[NoShade, k] for k in 1:(HEM + 2)}, x);
          QTraUns_flow := QTraUns_flow + AWin*HDir*(1 - uSha_internal)*tmpNoSha;

          // Window shaded parts: add transmitted radiation for angular radiation
          tmpSha := Buildings.HeatTransfer.Windows.BaseClasses.smoothInterpolation(
            {coeTraWinExtIrr[Shade, k] for k in 1:(HEM + 2)}, x);
          QTraSha_flow := QTraSha_flow + AWin*HDir*uSha_internal*tmpSha;

          // Assign quantities to output connectors
          QTra_flow := QTraUns_flow + QTraSha_flow;
          annotation (
            Documentation(info="<html>
The model calculates solar radiation through the window. 
The calculations follow the description in Wetter (2004), Appendix A.4.3.
</p>
<p>
The transmitted exterior radiation for window system includes:</p>
<ol>
<li>
the transmitted diffusive radiation on unshaded part: <code>AWin*(1-uSha)*HDif*tau(HEM)</code>
</li>
<li>
the transmitted direct radiation on no shade part: <code>AWin*(1-uSha)*HDir*tau(IncAng)</code>
</li>
<li>
the transmitted diffusive radiation on shaded part: <code>AWin*uSha*HDif*tauSha(HEM)</code>
</li>
<li>
the transmitted direct radiation on shaded part: <code>AWin*uSha*HDir*tauSha(IncAng);</code>
</li>
</ol>
The output is <code>QTra_flow = Part1 + Part2 + Part3 + Part4</code>
</p>

<h4>References</h4>
<ul>
<li>
Michael Wetter.<br>
<a href=\"http://simulationresearch.lbl.gov/wetter/download/mwdiss.pdf\">
Simulation-based Building Energy Optimization</a>.<br>
Dissertation. University of California at Berkeley. 2004.
</li>
</ul>
</html>",         revisions="<html>
<ul>
<li>
March 4, 2011, by Wangda Zuo:<br>
Remove the if-statement and integer function that can trigger events.
</li>
<li>
February 2, 2010, by Michael Wetter:<br>
Made connector <code>uSha</code> a conditional connector.
</li>
<li>
December 15, 2010, by Wangda Zuo:<br>
Separate transmittance and absorbance models from the window radiation model.
</li>
<li>
December 12, 2010, by Michael Wetter:<br>
Replaced record 
<a href=\"modelica://Buildings.HeatTransfer.Data.GlazingSystems\">
Buildings.HeatTransfer.Data.GlazingSystems</a> with the
parameters used by this model.
This was needed to integrate the radiation model into the room model.
</li>
<li>
December 10, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"),  Diagram(graphics),
            Icon(graphics={Text(
                  extent={{-32,-80},{22,-96}},
                  lineColor={0,0,127},
                  textString="uSha"), Text(
                  extent={{44,8},{110,-6}},
                  lineColor={0,0,127},
                  textString="QTra")}));
        end TransmittedRadiation;

        block WindowRadiation "Calculation radiation for window"

          extends Buildings.HeatTransfer.Windows.BaseClasses.PartialRadiation;

          Modelica.Blocks.Interfaces.RealInput HRoo(quantity="RadiantEnergyFluenceRate",
              unit="W/m2") "Diffussive radiation from room " annotation (Placement(
                transformation(extent={{-140,-100},{-100,-60}}),iconTransformation(
                  extent={{-130,-91},{-100,-61}})));
          Modelica.Blocks.Interfaces.RealOutput QTra_flow(final quantity="Power",
              final unit="W")
          "Transmitted exterior radiation through the window. (1: no shade; 2: shade)"
            annotation (Placement(transformation(extent={{100,-90},{120,-70}}),
                iconTransformation(extent={{100,-90},{120,-70}})));

          Modelica.Blocks.Interfaces.RealOutput QAbsExtSha_flow(final quantity="Power",
              final unit="W")
          "Absorbed interior and exterior radiation by exterior shading device"
            annotation (Placement(transformation(extent={{100,80},{120,100}}),
                iconTransformation(extent={{100,80},{120,100}})));
          Modelica.Blocks.Interfaces.RealOutput QAbsIntSha_flow(final quantity="Power",
              final unit="W")
          "Absorbed interior and exterior radiation by interior shading device"
            annotation (Placement(transformation(extent={{100,-40},{120,-20}}),
                iconTransformation(extent={{100,-40},{120,-20}})));
          Modelica.Blocks.Interfaces.RealOutput QAbsGlaUns_flow[N](each quantity=
                "Power", each final unit="W")
          "Absorbed interior and exterior radiation by unshaded part of glass"
            annotation (Placement(transformation(extent={{100,40},{120,60}}),
                iconTransformation(extent={{100,40},{120,60}})));
          Modelica.Blocks.Interfaces.RealOutput QAbsGlaSha_flow[N](each quantity=
                "Power", each final unit="W")
          "Absorbed interior and exterior radiation by shaded part of glass"
            annotation (Placement(transformation(extent={{100,0},{120,20}}),
                iconTransformation(extent={{100,0},{120,20}})));

          Buildings.HeatTransfer.Windows.BaseClasses.TransmittedRadiation tra(
            final N=N,
            final tauGlaSol=tauGlaSol,
            final rhoGlaSol_a=rhoGlaSol_a,
            final rhoGlaSol_b=rhoGlaSol_b,
            final tauShaSol_a=tauShaSol_a,
            final rhoShaSol_a=rhoShaSol_a,
            final rhoShaSol_b=rhoShaSol_b,
            final haveExteriorShade=haveExteriorShade,
            final haveInteriorShade=haveInteriorShade,
            final AWin=AWin,
            final tauShaSol_b=tauShaSol_b)
            annotation (Placement(transformation(extent={{-40,40},{-20,60}})));
          Buildings.HeatTransfer.Windows.BaseClasses.AbsorbedRadiation abs(
            final N=N,
            final tauGlaSol=tauGlaSol,
            final rhoGlaSol_a=rhoGlaSol_a,
            final rhoGlaSol_b=rhoGlaSol_b,
            final tauShaSol_a=tauShaSol_a,
            final tauShaSol_b=tauShaSol_b,
            final rhoShaSol_a=rhoShaSol_a,
            final rhoShaSol_b=rhoShaSol_b,
            final haveExteriorShade=haveExteriorShade,
            final haveInteriorShade=haveInteriorShade,
            final AWin=AWin)
            annotation (Placement(transformation(extent={{-40,-40},{-20,-20}})));
      protected
          final parameter Boolean noShade = not (haveExteriorShade or haveInteriorShade)
          "Flag, true if the window has a shade";
        equation
          if noShade then
            assert(uSha_internal < 1E-6, "Window has no shade, but control signal is non-zero.\n"
               + "  Received uSha_internal = " + String(uSha_internal));
          end if;
          connect(HDif, tra.HDif) annotation (Line(
              points={{-120,80},{-80,80},{-80,58},{-41.5,58}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(HDif, abs.HDif) annotation (Line(
              points={{-120,80},{-80,80},{-80,-22},{-41.5,-22}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(HDir, tra.HDir) annotation (Line(
              points={{-120,40},{-74,40},{-74,54},{-41.5,54}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(HDir, abs.HDir) annotation (Line(
              points={{-120,40},{-74,40},{-74,-26},{-41.5,-26}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(incAng, tra.incAng) annotation (Line(
              points={{-120,1.11022e-15},{-68,1.11022e-15},{-68,49},{-41.5,49}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(incAng, abs.incAng) annotation (Line(
              points={{-120,1.11022e-15},{-68,1.11022e-15},{-68,-31},{-41.5,-31}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(HRoo, abs.HRoo) annotation (Line(
              points={{-120,-80},{-54,-80},{-54,-37.6},{-41.5,-37.6}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(tra.uSha, uSha) annotation (Line(
              points={{-30.2,38.4},{-30.2,24},{1.11022e-15,24},{1.11022e-15,-120}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(abs.uSha, uSha) annotation (Line(
              points={{-30.2,-41.6},{-30.2,-48},{1.11022e-15,-48},{1.11022e-15,-120}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(tra.QTra_flow, QTra_flow) annotation (Line(
              points={{-19,50},{12,50},{12,-80},{110,-80}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(abs.QAbsIntSha_flow, QAbsIntSha_flow) annotation (Line(
              points={{-19,-38},{80,-38},{80,-30},{110,-30}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(abs.QAbsGlaSha_flow, QAbsGlaSha_flow) annotation (Line(
              points={{-19,-34},{72,-34},{72,10},{110,10}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(abs.QAbsGlaUns_flow, QAbsGlaUns_flow) annotation (Line(
              points={{-19,-26},{52,-26},{52,50},{110,50}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(abs.QAbsExtSha_flow, QAbsExtSha_flow) annotation (Line(
              points={{-19,-22},{36,-22},{36,90},{110,90}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (
            Documentation(info="<html>
The model calculates solar radiation through the window. 
The calculations follow the description in Wetter (2004), Appendix A.4.3.
</p>
<p>
The absorbed radiation by exterior shades includes:</p>
<ol>
<li>
the directly absorbed exterior radiation: <code>AWin*uSha*(HDir+HDif)*(1-tau-rho)</code>
</li>
<li>
the indirectly absorbed exterior radiantion from reflection (angular part): <code>AWin*uSha*HDir*tau*rho(IncAng)*(1-tau-rho)</code>
</li>
<li>
the indirectly absorbed of exterior irradiantion from reflection (diffusive part): <code>AWin*uSha*HDif*tau*rho(HEM)*(1-tau-rho)</code>
</li>
<li>
the absorbed interior radiation is neglected.
</li>
</ol>
The output is <code>absRad[2, 1]</code>
</p>
<p>
The absorbed radiation by interior shades includes:</p>
<ol>
<li>
the absorbed exterior radiation (angular part): <code>AWin*uSha*HDir*alpha(IncAng)</code>
</li>
<li>
the absorbed exterior radiation (diffusive part): <code>AWin*uSha*HDif*alpha(HEM)</code>
</li>
<li>
the absorbed interior radiation (diffusive part): <code>AWin*uSha*HRoo*(1-tau-rho)</code>
</li>
</ol>
The output is <code>absRad[2, N+2]</code>
</p>
<p>
The absorbed radiation by glass includes:</p>
<ol>
<li>
the absorbed radiation by unshaded part (diffusive part): <code>AWin*(1-uSha)*(HDif*alphaEx(HEM)+HRoo*alphaIn(HEM))</code>
</li>
<li>
the absorbed radiation by unshaded part (angualr part from exterior source): <code>AWin*(1-uSha)*HDir*alphaEx(IncAng)</code>
</li>
<li>
the absorbed radiaiton by shaded part (diffusive part): <code>AWin*uSha*(HDif*alphaExSha(HEM)+HRoo*alphaInSha(HEM))</code>
</li>
<li>
the absorbed radiation by shaded part (angular part from exterior source): <code>AWin*uSha*HDir*alphaExSha(IncAng)</code>
</li>
</ol>
The output is <code>absRad[1, 2:N+1] = Part1 + Part2; absRad[2, 2:N+1] = Part3 + Part4</code>
</p>
<p>
The transmitted exterior radiation for window system includes:</p>
<ol>
<li>
the transmitted diffusive radiation on unshaded part: <code>AWin*(1-uSha)*HDif*tau(HEM)</code>
</li>
<li>
the transmitted direct radiation on no shade part: <code>AWin*(1-uSha)*HDir*tau(IncAng)</code>
</li>
<li>
the transmitted diffusive radiation on shaded part: <code>AWin*uSha*HDif*tauSha(HEM)</code>
</li>
<li>
the transmitted direct radiation on shaded part: <code>AWin*uSha*HDir*tauSha(IncAng);</code>
</li>
</ol>
The output is <code>QTra_flow = Part1 + Part2 + Part3 + Part4</code>
</p>

<h4>References</h4>
<ul>
<li>
Michael Wetter.<br>
<a href=\"http://simulationresearch.lbl.gov/wetter/download/mwdiss.pdf\">
Simulation-based Building Energy Optimization</a>.<br>
Dissertation. University of California at Berkeley. 2004.
</li>
</ul>
</html>",         revisions="<html>
<ul>
<li>
February 2, 2010, by Michael Wetter:<br>
Made connector <code>uSha</code> a conditional connector.
</li>
<li>
January 4, 2011, by Michael Wetter:<br>
Added assert statement to check that <code>uSha=0</code> if no shade is present.
This is needed to avoid wrong results in the room model.
</li>
<li>
December 15, 2010, by Wangda Zuo:<br>
Revise the model by separating transmittance and absorbance.
</li>
<li>
December 12, 2010, by Michael Wetter:<br>
Replaced record 
<a href=\"modelica://Buildings.HeatTransfer.Data.GlazingSystems\">
Buildings.HeatTransfer.Data.GlazingSystems</a> with the
parameters used by this model.
This was needed to integrate the radiation model into the room model.
</li>
<li>
December 10, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"),  Diagram(graphics),
            Icon(graphics={
                Text(
                  extent={{0,86},{90,72}},
                  lineColor={0,0,127},
                  textString="QAbsExtSha"),
                Text(
                  extent={{-32,-80},{22,-96}},
                  lineColor={0,0,127},
                  textString="uSha"),
                Text(
                  extent={{-4,-22},{92,-36}},
                  lineColor={0,0,127},
                  textString="QAbsIntSha"),
                Text(
                  extent={{2,58},{94,44}},
                  lineColor={0,0,127},
                  textString="QAbsGlaUns"),
                Text(
                  extent={{-2,20},{92,6}},
                  lineColor={0,0,127},
                  textString="QAbsGlaSha"),
                Text(
                  extent={{18,-78},{92,-94}},
                  lineColor={0,0,127},
                  textString="QTra"),
                Text(
                  extent={{-110,-64},{-26,-86}},
                  lineColor={0,0,127},
                  textString="HRoo")}));
        end WindowRadiation;

        partial record RadiationBaseData
        "Define base parameters for window radiation calculation"

          parameter Integer N(min=1) "Number of glass layers"
            annotation (Dialog(group="Glass"));

          parameter Modelica.SIunits.TransmissionCoefficient tauGlaSol[N]
          "Solar transmissivity of glass"   annotation (Dialog(group="Glass"));
          parameter Modelica.SIunits.ReflectionCoefficient rhoGlaSol_a[N]
          "Solar reflectivity of glass at surface a (facing outside)"
            annotation (Dialog(group="Glass"));
          parameter Modelica.SIunits.ReflectionCoefficient rhoGlaSol_b[N]
          "Solar reflectivity of glass at surface b (facing room-side)"
            annotation (Dialog(group="Glass"));

          parameter Modelica.SIunits.TransmissionCoefficient tauShaSol_a
          "Solar transmissivity of shade for irradiation from air-side"
            annotation (Dialog(group="Shade"));
          parameter Modelica.SIunits.TransmissionCoefficient tauShaSol_b
          "Solar transmissivity of shade for irradiation from glass-side"
            annotation (Dialog(group="Shade"));
          parameter Modelica.SIunits.ReflectionCoefficient rhoShaSol_a
          "Solar reflectivity of shade for irradiation from air-side"
            annotation (Dialog(group="Shade"));
          parameter Modelica.SIunits.ReflectionCoefficient rhoShaSol_b
          "Solar reflectivity of shade for irradiation from glass-side"
            annotation (Dialog(group="Shade"));

          annotation (Documentation(info="<html>
Record that defines base parameter for window radiation calculation.
</html>",         revisions="<html>
<ul>
<li>
December 16, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"));
        end RadiationBaseData;

        record RadiationData "Radiation property of a window"
          extends Modelica.Icons.Record;
          extends Buildings.HeatTransfer.Windows.BaseClasses.RadiationBaseData;
          final parameter Real glass[3, N]={tauGlaSol,rhoGlaSol_a,rhoGlaSol_b}
          "Glass solar transmissivity, solar reflectivity at surface a and b, at normal incident angle";
          final parameter Real traRefShaDev[2, 2]={{tauShaSol_a,tauShaSol_b},{rhoShaSol_a,
              rhoShaSol_b}} "Shading device property";
          final parameter Integer NDIR=10 "Number of incident angles";
          final parameter Integer HEM=NDIR + 1
          "Index of hemispherical integration";
          final parameter Modelica.SIunits.Angle psi[NDIR]=
              Buildings.HeatTransfer.Windows.Functions.getAngle(NDIR)
          "Incident angles used for solar radiation calculation";
          final parameter Real layer[3, N, HEM]=
              Buildings.HeatTransfer.Windows.Functions.glassProperty(
              N,
              HEM,
              glass,
              psi) "Angular and hemispherical transmissivity, front (outside-facing) and back (room facing) reflectivity 
      of each glass pane";
          final parameter Real traRef[3, N, N, HEM]=
              Buildings.HeatTransfer.Windows.Functions.getGlassTR(
              N,
              HEM,
              layer) "Angular and hemispherical transmissivity, front (outside-facing) and back (room facing) reflectivity 
      between glass panes for exterior or interior irradiation without shading";
          final parameter Real absExtIrrNoSha[N, HEM]=
              Buildings.HeatTransfer.Windows.Functions.glassAbsExteriorIrradiationNoShading(
              traRef,
              N,
              HEM) "Angular and hemispherical absorptivity of each glass pane 
      for exterior irradiation without shading";
          final parameter Real absIntIrrNoSha[N]=
              Buildings.HeatTransfer.Windows.Functions.glassAbsInterirorIrradiationNoShading(
              traRef,
              N,
              HEM) "Hemispherical absorptivity of each glass pane 
      for interior irradiation without shading";
          final parameter Real winTraExtIrrExtSha[HEM]=
              Buildings.HeatTransfer.Windows.Functions.winTExteriorIrradiatrionExteriorShading(
              traRef,
              traRefShaDev,
              N,
              HEM) "Angular and hemispherical transmissivity of a window system (glass + exterior shading device) 
     for exterior irradiation";
          final parameter Real absExtIrrExtSha[N, HEM]=
              Buildings.HeatTransfer.Windows.Functions.glassAbsExteriorIrradiationExteriorShading(
              absExtIrrNoSha,
              traRef,
              traRefShaDev,
              N,
              HEM) "Angular and hemispherical absorptivity of each glass pane 
      for exterior irradiation with exterior shading";
          final parameter Real winTraExtIrrIntSha[HEM]=
              Buildings.HeatTransfer.Windows.Functions.winTExteriorIrradiationInteriorShading(
              traRef,
              traRefShaDev,
              N,
              HEM) "Angular and hemispherical transmissivity of a window system (glass and interior shading device) 
      for exterior irradiation";
          final parameter Real absExtIrrIntSha[N, HEM]=
              Buildings.HeatTransfer.Windows.Functions.glassAbsExteriorIrradiationInteriorShading(
              absExtIrrNoSha,
              traRef,
              traRefShaDev,
              N,
              HEM) "Angular and hemispherical absorptivity of each glass layer
     for exterior irradiation with interior shading";
          final parameter Real devAbsExtIrrIntShaDev[HEM]=
              Buildings.HeatTransfer.Windows.Functions.devAbsExteriorIrradiationInteriorShading(
              traRef,
              traRefShaDev,
              N,
              HEM) "Angular and hemispherical absorptivity of an interior shading device 
      for exterior irradiation";
          final parameter Real winTraRefIntIrrExtSha[3]=
              Buildings.HeatTransfer.Windows.Functions.winTRInteriorIrradiationExteriorShading(
              traRef,
              traRefShaDev,
              N,
              HEM) "Hemisperical transmissivity and reflectivity of a window system (glass and exterior shadig device) 
      for interior irradiation. traRefIntIrrExtSha[1]: transmissivity, 
      traRefIntIrrExtSha[2]: Back reflectivity; traRefIntIrrExtSha[3]: dummy value";
          final parameter Real absIntIrrExtSha[N]=
              Buildings.HeatTransfer.Windows.Functions.glassAbsInteriorIrradiationExteriorShading(
              absIntIrrNoSha,
              traRef,
              traRefShaDev,
              N,
              HEM) "Hemispherical absorptivity of each glass pane 
      for interior irradiation with exterior shading";
          final parameter Real absIntIrrIntSha[N]=
              Buildings.HeatTransfer.Windows.Functions.glassAbsInteriorIrradiationInteriorShading(
              absIntIrrNoSha,
              traRef,
              traRefShaDev,
              N,
              HEM) "Hemispherical absorptivity of each glass pane 
      for interior irradiation with interior shading";
          final parameter Real winTraRefIntIrrIntSha[3]=
              Buildings.HeatTransfer.Windows.Functions.winTRInteriorIrradiationInteriorShading(
              traRef,
              traRefShaDev,
              N,
              HEM) "Hemisperical transmissivity and back reflectivity of a window system (glass and interior shadig device) 
      for interior irradiation";
          final parameter Real devAbsIntIrrIntSha=
              Buildings.HeatTransfer.Windows.Functions.devAbsInteriorIrradiationInteriorShading(
              traRef,
              traRefShaDev,
              N,
              HEM)
          "Hemiperical absorptivity of an interior shading device for interior irradiation";
          annotation (Documentation(info="<html>
Record that computes the solar radiation data for glazing system.
</html>",         revisions="<html>
<ul>
<li>
December 12, 2010, by Michael Wetter:<br>
Replaced record 
<a href=\"modelica://Buildings.HeatTransfer.Data.GlazingSystems\">
Buildings.HeatTransfer.Data.GlazingSystems</a> with the
parameters used by this model.
This was needed to integrate the radiation model into the room model.
</li>
<li>
December 10, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"));
        end RadiationData;

        function convectionVerticalCavity "Free convection in vertical cavity"
          input Buildings.HeatTransfer.Data.Gases.Generic gas
          "Thermophysical properties of gas fill"
           annotation(choicesAllMatching=true);
          input Real Ra(min=0) "Raleigh number";
          input Modelica.SIunits.Temperature T_m
          "Temperature used for thermophysical properties";
          input Modelica.SIunits.TemperatureDifference dT
          "Temperature difference used to compute q_flow = h*dT";
          input Modelica.SIunits.Area h(min=0) = 1.5 "Height of window";
          input Real deltaNu(min=0.01) = 0.1
          "Small value for Nusselt number, used for smoothing";
          input Real deltaRa(min=0.01) = 1E3
          "Small value for Raleigh number, used for smoothing";
          output Real Nu(min=0) "Nusselt number";
          output Modelica.SIunits.CoefficientOfHeatTransfer hCon(min=0)
          "Convective heat transfer coefficient";
          output Modelica.SIunits.HeatFlux q_flow "Convective heat flux";
      protected
          Real Nu_1(min=0) "Nusselt number";
          Real Nu_2(min=0) "Nusselt number";
        algorithm

          Nu_1 :=Buildings.Utilities.Math.Functions.spliceFunction(
            pos=0.0673838*Ra^(1/3),
            neg=Buildings.Utilities.Math.Functions.spliceFunction(
              pos=0.028154*Ra^(0.4134),
              neg=1 + 1.7596678E-10*Ra^(2.2984755),
              x=Ra - 1E4,
              deltax=deltaRa),
            x=Ra - 5E4,
            deltax=deltaRa);
          /*
  if ( Ra <= 1E4) then
    Nu_1 = 1 + 1.7596678E-10*Ra^(2.2984755);
  elseif ( Ra <= 5E4) then
    Nu_1 = 0.028154*Ra^(0.4134);
  else
    Nu_1 = 0.0673838*Ra^(1/3);
  end if;
  */
          Nu_2 :=0.242*(Ra/(h/gas.x))^(0.272);
          Nu :=Buildings.Utilities.Math.Functions.smoothMax(
            x1=Nu_1,
            x2=Nu_2,
            deltaX=deltaNu);
          hCon :=Nu*Buildings.HeatTransfer.Data.Gases.thermalConductivity(gas, T_m)/gas.x;
          q_flow :=hCon*dT;
            annotation (smoothOrder=1, Inline=true,
        Documentation(info="<html>
<p>
Function for convective heat transfer in vertical window cavity.
The computation is according to TARCOG 2006,
except that this implementation computes the convection coefficient
as a function that is differentiable in the temperatures.
</p>
<h4>References</h4>
<p>
TARCOG 2006: Carli, Inc., TARCOG: Mathematical models for calculation
of thermal performance of glazing systems with our without
shading devices, Technical Report, Oct. 17, 2006.
</p>
</html>",         revisions="<html>
<ul>
<li>
December 9, 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end convectionVerticalCavity;

        function convectionHorizontalCavity
        "Free convection in horizontal cavity"
          input Buildings.HeatTransfer.Data.Gases.Generic gas
          "Thermophysical properties of gas fill"
           annotation(choicesAllMatching=true);
          input Real Ra(min=0) "Raleigh number";
          input Modelica.SIunits.Temperature T_m
          "Temperature used for thermophysical properties";
          input Modelica.SIunits.TemperatureDifference dT
          "Temperature difference used to compute q_flow = h*dT";
          input Modelica.SIunits.Angle til "Window tilt";
          input Real sinTil "Sine of window tilt";
          input Real cosTil "Cosine of the window tilt";
          input Modelica.SIunits.Area h(min=0) = 1.5 "Height of window";
          input Real deltaNu(min=0.01) = 0.1
          "Small value for Nusselt number, used for smoothing";
          input Real deltaRa(min=0.01) = 1E3
          "Small value for Raleigh number, used for smoothing";
          output Real Nu(min=0) "Nusselt number";
          output Modelica.SIunits.CoefficientOfHeatTransfer hCon(min=0)
          "Convective heat transfer coefficient";
          output Modelica.SIunits.HeatFlux q_flow "Convective heat flux";
      protected
          Real Nu_1(min=0) "Nusselt number";
          Real Nu_2(min=0) "Nusselt number";
          constant Real dx=0.1 "Half-width of interval used for smoothing";
        algorithm
          if cosTil > 0 then
          Nu :=Buildings.Utilities.Math.Functions.spliceFunction(
            pos=
              Buildings.HeatTransfer.Windows.BaseClasses.nusseltHorizontalCavityReduced(
              gas=gas,
              Ra=Ra,
              T_m=T_m,
              dT=dT,
              h=h,
              sinTil=sinTil,
              deltaNu=deltaNu,
              deltaRa=deltaRa),
            neg=
              Buildings.HeatTransfer.Windows.BaseClasses.nusseltHorizontalCavityEnhanced(
              gas=gas,
              Ra=Ra,
              T_m=T_m,
              dT=dT,
              til=til,
              cosTil=abs(cosTil)),
            x=dT+dx,
            deltax=dx);
          else
            Nu :=Buildings.Utilities.Math.Functions.spliceFunction(
            pos=
              Buildings.HeatTransfer.Windows.BaseClasses.nusseltHorizontalCavityEnhanced(
              gas=gas,
              Ra=Ra,
              T_m=T_m,
              dT=dT,
              til=til,
              cosTil=abs(cosTil)),
            neg=
              Buildings.HeatTransfer.Windows.BaseClasses.nusseltHorizontalCavityReduced(
              gas=gas,
              Ra=Ra,
              T_m=T_m,
              dT=dT,
              h=h,
              sinTil=sinTil,
              deltaNu=deltaNu,
              deltaRa=deltaRa),
            x=dT-dx,
            deltax=dx);
          end if;
          hCon :=Nu*Buildings.HeatTransfer.Data.Gases.thermalConductivity(gas, T_m)/gas.x;
          q_flow :=hCon*dT;
            annotation (smoothOrder=1, Inline=true,
        Documentation(info="<html>
<p>
Function for convective heat transfer in horizontal window cavity.
The computation is according to TARCOG 2006,
except that this implementation computes the convection coefficient
as a function that is differentiable in the temperatures.
</p>
<h4>References</h4>
<p>
TARCOG 2006: Carli, Inc., TARCOG: Mathematical models for calculation
of thermal performance of glazing systems with our without
shading devices, Technical Report, Oct. 17, 2006.
</p>
</html>",         revisions="<html>
<ul>
<li>
December 9, 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end convectionHorizontalCavity;

        function nusseltHorizontalCavityEnhanced
        "Nusselt number for horizontal cavity, bottom surface warmer than top surface"
          input Buildings.HeatTransfer.Data.Gases.Generic gas
          "Thermophysical properties of gas fill"
           annotation(choicesAllMatching=true);
          input Real Ra(min=0) "Raleigh number";
          input Modelica.SIunits.Temperature T_m
          "Temperature used for thermophysical properties";
          input Modelica.SIunits.TemperatureDifference dT
          "Temperature difference used to compute q_flow = h*dT";
          input Modelica.SIunits.Angle til "Window tilt";
          input Real cosTil(min=0) "Cosine of the window tilt";
          output Real Nu(min=0) "Nusselt number";
      protected
          Real k1 "Auxiliary variable";
          Real k2 "Auxiliary variable";
          Real k11 "Auxiliary variable";
          Real k22 "Auxiliary variable";
        algorithm
          // Windows inclined from 0 to 60 deg (eqn. 3.1-42 to 3.1-43)
          k1 :=1 - 1708/Ra/cosTil;
          k2 :=(Ra*cosTil/5830)^(1/3) - 1;
          k11 :=(k1 + Buildings.Utilities.Math.Functions.smoothMax(
            x1=k1,
            x2=-k1,
            deltaX=1E-1))/2;
          k22 :=(k2 + Buildings.Utilities.Math.Functions.smoothMax(
            x1=k2,
            x2=-k2,
            deltaX=1E-1))/2;
          Nu :=1 + 1.44*k11*(1 - 1708*abs(Modelica.Math.sin(1.8*til*180/Modelica.Constants.pi))
            ^(1.6)/Ra/cosTil) + k22;
            annotation (smoothOrder=1, Inline=true,
        Documentation(info="<html>
<p>
Function for Nusselt number in horizontal window cavity.
The computation is according to TARCOG 2006,
except that this implementation computes the Nusselt number
as a function that is differentiable in the temperatures.
</p>
<h4>References</h4>
<p>
TARCOG 2006: Carli, Inc., TARCOG: Mathematical models for calculation
of thermal performance of glazing systems with our without
shading devices, Technical Report, Oct. 17, 2006.
</p>
</html>",         revisions="<html>
<ul>
<li>
December 9, 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end nusseltHorizontalCavityEnhanced;

        function nusseltHorizontalCavityReduced
        "Nusselt number for horizontal cavity, bottom surface colder than top surface"
          input Buildings.HeatTransfer.Data.Gases.Generic gas
          "Thermophysical properties of gas fill"
           annotation(choicesAllMatching=true);
          input Real Ra(min=0) "Raleigh number";
          input Modelica.SIunits.Temperature T_m
          "Temperature used for thermophysical properties";
          input Modelica.SIunits.TemperatureDifference dT
          "Temperature difference used to compute q_flow = h*dT";
          input Modelica.SIunits.Area h(min=0) = 1.5 "Height of window";
          input Real sinTil "Sine of window tilt";
          input Real deltaNu(min=0.01) = 0.1
          "Small value for Nusselt number, used for smoothing";
          input Real deltaRa(min=0.01) = 1E3
          "Small value for Raleigh number, used for smoothing";
          output Real Nu(min=0) "Nusselt number";
      protected
          Real NuVer(min=0) "Nusselt number for vertical window";
        algorithm
          NuVer :=Buildings.HeatTransfer.Windows.BaseClasses.convectionVerticalCavity(
            gas=gas,
            Ra=Ra,
            T_m=T_m,
            dT=dT,
            h=h,
            deltaNu=deltaNu,
            deltaRa=deltaRa);
          Nu :=1 + (NuVer - 1)*sinTil;

            annotation (smoothOrder=1, Inline=true,
        Documentation(info="<html>
<p>
Function for Nusselt number in horizontal window cavity.
The computation is according to TARCOG 2006,
except that this implementation computes the Nusselt number
as a function that is differentiable in the temperatures.
</p>
<h4>References</h4>
<p>
TARCOG 2006: Carli, Inc., TARCOG: Mathematical models for calculation
of thermal performance of glazing systems with our without
shading devices, Technical Report, Oct. 17, 2006.
</p>
</html>",         revisions="<html>
<ul>
<li>
December 9, 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end nusseltHorizontalCavityReduced;

        function smoothInterpolation
        "Get interpolated data without triggering events"
          input Real y[:] "Data array";
          input Real x "x value";
          output Real val "Return value";

      protected
          Integer k1;
          Integer k2;
          Real y1d;
          Real y2d;
        algorithm
          k1 := integer(x);
          k2 := k1 + 1;

          y1d := (y[k1 + 1] - y[k1 - 1])/2;
          y2d := (y[k2 + 1] - y[k2 - 1])/2;
          val := Modelica.Fluid.Utilities.cubicHermite(
            x,
            k1,
            k2,
            y[k1],
            y[k2],
            y1d,
            y2d);

          annotation (
            smoothOrder=1,
            Inline=true,
            Documentation(info="<html>
<p>
Function to interpolate within a data array without triggerring events.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 4, 2011, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"));
        end smoothInterpolation;
      annotation (preferedView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.HeatTransfer.Windows\">Buildings.HeatTransfer.Windows</a>.
</p>
</html>"));
      end BaseClasses;

      package Functions "Functions used in window radiation model"
        extends Modelica.Icons.Package;

        function devAbsExteriorIrradiationInteriorShading
        "Angular and hemispherical absorptance of a shading device for exterior irradiation with interior shading"
          import Buildings;
          extends
          Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialWindowShadingRadiation;

          output Real absExtIrrIntShaDev[HEM](each min=0, each max=1)
          "Absorptance of a shading device for exterior irradiation with interior shading";

        algorithm
          for iD in 1:HEM loop
            absExtIrrIntShaDev[iD] := traRef[TRA, 1, N, iD]*(1 - traIntShaDev -
              refIntShaDev)/(1 - refIntShaDev*traRef[Rb, N, 1, HEM])
            "Equation (A.4.91)";
          end for;

          annotation (Documentation(info="<html>
<p>
This function computes the angular and hemispherical absorptance of a shading device for exterior irradiation with interior shading.
Pane <code>1</code> is facing the outside and pane <code>N</code> is facing the room.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 29, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"));
        end devAbsExteriorIrradiationInteriorShading;

        function devAbsInteriorIrradiationInteriorShading
        "Hemiperical absorptance of a shading device for interior irradiation with interior shading"
          extends
          Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialWindowShadingRadiation;

          output Real absIntIrrIntShaDev(min=0, max=1)
          "Hemiperical absorbtance of a shading device for interior irradiation with interior shading";
      protected
          constant Real rRho=traRef[3, N, 1, HEM]*refIntShaDev
          "Part of equation (A.4.103)";
          constant Real rTau=traRef[3, N, 1, HEM]*traIntShaDev
          "Part of equation (A.4.103)";
          constant Real c=traIntShaDev*(1 - rRho/(1 - rRho)) "Equation (4.99)";

        algorithm
          absIntIrrIntShaDev := (1 - traIntShaDev - refIntShaDev)*(1 + rTau/(1 - rRho))
          "Equation (4.103)";

          annotation (Documentation(info="<html>
<p>
This function computes the hemiperical absorbtance of a shading device for interior irradiation with interior shading. 
</p>
</html>",         revisions="<html>
<ul>
<li>
August 29, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"));
        end devAbsInteriorIrradiationInteriorShading;

        function getAngle "Generate incident angles"
          input Integer NDIR "Number of incident angles";
          output Modelica.SIunits.Angle psi[NDIR] "Array of incident angles";

      protected
          constant Real deltaX=0.5*Modelica.Constants.pi/(NDIR - 1);

        algorithm
          for i in 1:NDIR loop
            psi[i] := (i - 1)*deltaX;
          end for;

          annotation (Documentation(info="<html>
<p>
This function computes discrete incident angles for the window radiation calculation. The range is from 0 to 90 degree. 
</p>
</html>",         revisions="<html>
<ul>
<li>
August 29, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"));
        end getAngle;

        function getGlassTR "Transmittance and reflectance of glass"
          extends
          Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialGlassRadiation;

          input Real layer[3, N, HEM] "Property of glass pane";
          output Real traRef[3, N, N, HEM](each min=0, each max=1)
          "Glass transmittance, front and back reflectance";

      protected
          Real traRefIntIrr[3, N, N, HEM](each min=0, each max=1)
          "temporary array for glass transmittance, front and back reflectance for interior irradiation";

        algorithm
          traRef :=
            Buildings.HeatTransfer.Windows.Functions.glassTRExteriorIrradiationNoShading(
            N,
            HEM,
            layer) "property for exterior irradiation";
          traRefIntIrr :=
            Buildings.HeatTransfer.Windows.Functions.glassTRInteriorIrradiationNoShading(
            N,
            HEM,
            layer) "property for interior irradiation";

          // Copy the property for interior irradiation to glass property
          for k in TRA:Rb loop
            for i in 1:N - 1 loop
              for j in i + 1:N loop
                for iD in 1:HEM loop
                  traRef[k, N + 1 - i, N + 1 - j, iD] := traRefIntIrr[k, N + 1 - i, N
                     + 1 - j, iD];
                end for;
              end for;
            end for;
          end for;

          annotation (Documentation(info="<html>
<p>
This function computes the angular variation of the transmittance and reflectance of each glass pane.
It accounts for the transmittance and reflectance among different panes. 
Pane <code>1</code> is facing outside and pane <code>N</code> is facing the room. 
For instance, <code>traRef[TRA, 1, N, iD]</code> means transmittance between layer <code>1</code> to <code>N</code> for exterior irradiation and 
<code>traRef[TRA, N, 1, iD]</code> means the transmittance for interior irradiation.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 29, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"));
        end getGlassTR;

        function glassAbsExteriorIrradiationExteriorShading
        "Angular and hemispherical absorptance of each glass pane for exterior irradiation with exterior shading"
          input Real absExtIrrNoSha[N, HEM](each min=0, each max=1)
          "Angular and hemispherical absorptance of each glass pane for exterior irradiation without shading";
          extends
          Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialWindowShadingRadiation;

          output Real absExtIrrExtSha[N, HEM](each min=0, each max=1)
          "Angular and hemispherical absorptance of each glass pane for exterior irradiation with exterior shading";

      protected
          Real c "Intermediate variable";

        algorithm
          for iD in 1:HEM loop
            c := traExtShaDev*(1 + traRef[Ra, 1, N, iD]*refExtShaDev/(1 - traRef[Ra, 1,
              N, HEM]*refExtShaDev));
            for i in 1:N loop
              absExtIrrExtSha[i, iD] := c*absExtIrrNoSha[i, iD];
            end for;
          end for;

          annotation (Documentation(info="<html>
<p>
This function computes angular and hemispherical absorptance of each glass pane for exterior irradiation with exterior shading.
Pane <code>1</code> is facing outside and pane <code>N</code> is facing the room. 
</p>
</html>",         revisions="<html>
<ul>
<li>
August 29, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"));
        end glassAbsExteriorIrradiationExteriorShading;

        function glassAbsExteriorIrradiationInteriorShading
        "Angular and hemispherical absorptance of each glass pane for exterior irradiation with interior shading"
          input Real absExtIrrNoSha[N, HEM](each min=0, each max=1)
          "Absorptance for exterior irradiation without shading";
          extends
          Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialWindowShadingRadiation;
          output Real absExtIrrNoShaIntSha[N, HEM](each min=0, each max=1)
          "Angular and hemispherical absorptance of each glass pane for exterior irradiation with interior shading";

      protected
          Real fac;
          Real absFro "Front (outside-facing) absorptance";
          Real absBac "Back (room-facing) absorptance";
          Integer i "Index of glass pane";

        algorithm
          for iD in 1:HEM loop
            i := 1;
            fac := traRef[TRA, 1, N, iD]*refIntShaDev/(1 - traRef[Rb, N, 1, HEM]*
              refIntShaDev) "Equation (A.4.90)";
            absBac := 1 - traRef[TRA, i, i, iD] - traRef[Rb, i, i, iD]
            "Equation (A.4.81b)";

            if N >= 2 then
              absExtIrrNoShaIntSha[i, iD] := absExtIrrNoSha[i, iD] + fac*traRef[TRA, N,
                i + 1, HEM]*absBac "Equation (A.4.90)";

              for i in 2:N - 1 loop
                fac := traRef[TRA, 1, N, iD]*refIntShaDev/(1 - traRef[Rb, N, 1, HEM]*
                  refIntShaDev) "Equation (A.4.90)";
                absFro := 1 - traRef[TRA, i, i, iD] - traRef[Ra, i, i, iD]
                "Equaiton (A.4.81a)";
                absBac := 1 - traRef[TRA, i, i, iD] - traRef[Rb, i, i, iD]
                "Equation (A.4.81b)";
                absExtIrrNoShaIntSha[i, iD] := absExtIrrNoSha[i, iD] + fac*(traRef[TRA,
                  N, i, HEM]*traRef[Rb, i - 1, 1, HEM]*absFro + traRef[TRA, N, i + 1,
                  HEM]*absBac) "Equation (A.4.90)";
              end for;

              i := N;
              fac := traRef[TRA, 1, N, iD]*refIntShaDev/(1 - traRef[Rb, N, 1, HEM]*
                refIntShaDev) "Equation (A.4.90)";
              absFro := 1 - traRef[TRA, i, i, iD] - traRef[Ra, i, i, iD]
              "Equaiton (A.4.81a)";
              absBac := 1 - traRef[TRA, i, i, iD] - traRef[Rb, i, i, iD]
              "Equation (A.4.81b)";
              absExtIrrNoShaIntSha[i, iD] := absExtIrrNoSha[i, iD] + fac*(traRef[TRA, N,
                i, HEM]*traRef[Rb, i - 1, 1, HEM]*absFro + absBac)
              "Equation (A.4.90)";

            else
              absExtIrrNoShaIntSha[i, iD] := absExtIrrNoSha[i, iD] + fac*absBac
              "Equation (A.4.90)";
            end if;
          end for;

          annotation (Documentation(info="<html>
<p>
This function computes angular and hemispherical absorptance of each glass pane for exterior irradiation with interior shading. 
Pane <code>1</code> is facing the outside and pane <code>N</code> is facing the room.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 29, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"));
        end glassAbsExteriorIrradiationInteriorShading;

        function glassAbsExteriorIrradiationNoShading
        "Angular and hemispherical absorptance of each glass pane for exterior irradiation without shading"
          extends
          Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialWindowRadiation;
          output Real[N, HEM] abs(each min=0, each max=1) "Angular and hemispherical absorptance of each glass pane for exterior irradiation without shading. 
     Indices: abs[1 to N : ] -> pane 1 to N; 
     abs[ : 1 to HEM] -> angular (1:HEM-1) and hemispherical (HEM)";

      protected
          Real af "Front (outside-facing side) absorptance of a pane";
          Real ab "Back (room-facing side) absorptance of a pane";
          Real deno1 "Denominantor";
          Real deno2 "Denominantor";
          Integer j;
          constant Real SMALL=Modelica.Constants.small "Small value";

        algorithm
          if N == 1 then
            j := 1;
            for iD in 1:HEM loop
              abs[j, iD] := 1 - traRef[TRA, j, j, iD] - traRef[Ra, j, j, iD]
              "Equation (A.4.79)";
            end for;
          else
            for iD in 1:HEM loop
              j := 1;
              af := 1 - traRef[TRA, j, j, iD] - traRef[Ra, j, j, iD]
              "Equation (A.4.81a)";
              ab := 1 - traRef[TRA, j, j, iD] - traRef[Rb, j, j, iD]
              "Equation (A.4.81b)";
              deno2 := 1 - traRef[Rb, j, 1, iD]*traRef[Ra, j + 1, N, iD];
              if deno2 < SMALL then
                abs[j, iD] := 0;
              else
                abs[j, iD] := af + ab*traRef[TRA, 1, j, iD]*traRef[Ra, j + 1, N, iD]/
                  deno2 "Equation (A.4.82) and (A.4.83b)";
              end if;

              for j in 2:N - 1 loop
                af := 1 - traRef[TRA, j, j, iD] - traRef[Ra, j, j, iD]
                "Equation (A.4.81a)";
                ab := 1 - traRef[TRA, j, j, iD] - traRef[Rb, j, j, iD]
                "Equation (A.4.81b)";
                deno1 := 1 - traRef[Ra, j, N, iD]*traRef[Rb, j - 1, 1, iD];
                deno2 := 1 - traRef[Rb, j, 1, iD]*traRef[Ra, j + 1, N, iD];
                if deno1 < SMALL or deno2 < SMALL then
                  abs[j, iD] := 0;
                else
                  abs[j, iD] := af*traRef[TRA, 1, j - 1, iD]/deno1 + ab*traRef[TRA, 1,
                    j, iD]*traRef[Ra, j + 1, N, iD]/deno2 "Equation (A.4.83b)";
                end if;
              end for;

              j := N;
              af := 1 - traRef[TRA, j, j, iD] - traRef[Ra, j, j, iD]
              "Equation (A.4.81a)";
              deno1 := 1 - traRef[Ra, j, N, iD]*traRef[Rb, j - 1, 1, iD];
              if deno1 < SMALL then
                abs[j, iD] := 0;
              else
                abs[j, iD] := af*traRef[TRA, 1, j - 1, iD]/deno1;
              end if;
            end for;
          end if;

          annotation (Documentation(info="<html>
<p>
This function computes specular and hemispherical absorptance of each glass pane for exterior irradiation without shading.
It counts the transmittance and reflectance among different panes.
Pane <code>1</code> is facing the outside and pane <code>N</code> is facing the room.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 24, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"));
        end glassAbsExteriorIrradiationNoShading;

        function glassAbsInteriorIrradiationExteriorShading
        "Hemispherical absorptance of each glass pane for interior irradiation with exterior shading"
          input Real absIntIrrNoSha[N]
          "Absorptance for interior irradiation without shading";
          extends
          Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialWindowShadingRadiation;

          output Real absIntIrrExtSha[N](each min=0, each max=1)
          "Hemispherical absorptance of each glass pane for interior irradiation with exterior shading";

      protected
          Real fac;
          Real absFro "Front absorptance";
          Real absBac "Back absorptance";
          Integer i "Pane index";

        algorithm
          fac := traRef[TRA, N, 1, HEM]*refExtShaDev/(1 - traRef[Ra, 1, N, HEM]*
            refExtShaDev);

          i := 1;
          absFro := 1 - traRef[TRA, i, i, HEM] - traRef[Ra, i, i, HEM]
          "Equaiton (A.4.81a)";
          absBac := 1 - traRef[TRA, i, i, HEM] - traRef[Rb, i, i, HEM]
          "Equation (A.4.81b)";

          if N >= 2 then
            absIntIrrExtSha[i] := absIntIrrNoSha[i] + fac*absFro + fac*traRef[TRA, 1, i,
              HEM]*traRef[Ra, i + 1, N, HEM]*absBac "Equation (A.4.94)";

            for i in 2:N - 1 loop
              absFro := 1 - traRef[TRA, i, i, HEM] - traRef[Ra, i, i, HEM]
              "Equaiton (A.4.81a)";
              absBac := 1 - traRef[TRA, i, i, HEM] - traRef[Rb, i, i, HEM]
              "Equation (A.4.81b)";
              absIntIrrExtSha[i] := absIntIrrNoSha[i] + fac*traRef[TRA, 1, i - 1, HEM]*
                absFro + fac*traRef[TRA, 1, i, HEM]*traRef[Ra, i + 1, N, HEM]*absBac
              "Equation (A.4.94)";
            end for;

            i := N;
            absFro := 1 - traRef[TRA, i, i, HEM] - traRef[Ra, i, i, HEM]
            "Equaiton (A.4.81a)";
            absIntIrrExtSha[i] := absIntIrrNoSha[i] + fac*traRef[TRA, 1, i - 1, HEM]*
              absFro "Equation (A.4.94)";
          else
            absIntIrrExtSha[i] := absIntIrrNoSha[i] + fac*absFro
            "Equation (A.4.94)";
          end if;
          annotation (Documentation(info="<html>
<p>
This function computes the hemispherical absorptance of each glass pane for interior irradiation with exterior shading. 
Pane <code>1</code> is facing the outside and pane <code>N</code> is facing the room.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 29, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"));
        end glassAbsInteriorIrradiationExteriorShading;

        function glassAbsInteriorIrradiationInteriorShading
        "Hemispherical absorptance of each glass pane for interior irradiation with interior shading"
          input Real absIntIrrNoSha[N](each min=0, each max=1)
          "Hemispherical absorptance wfor interior irradiation without interior shading";
          extends
          Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialWindowShadingRadiation;

          output Real absIntIrrIntSha[N](each min=0, each max=1)
          "Hemispherical absorbtance of each glass pane for interior irradiation with interior shading";

      protected
          constant Real rRho=traRef[Rb, N, 1, HEM]*refIntShaDev
          "Part of Equation (4.99)";
          constant Real c=traIntShaDev*(1 + rRho/(1 - rRho)) "Equation (4.99)";

        algorithm
          for i in 1:N loop
            absIntIrrIntSha[i] := c*absIntIrrNoSha[i] "Equation (A4.100a)";
          end for;

          annotation (Documentation(info="<html>
<p>
This function computes the hemispherical absorbtance of each glass pane for interior irradiation with interior shading. 
Pane <code>1</code> is facing the outside and pane <code>N</code> is facing the room.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 29, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"));
        end glassAbsInteriorIrradiationInteriorShading;

        function glassAbsInterirorIrradiationNoShading
        "Hemispherical absorptance of each glass pane for interior irradiation without shading"

          extends
          Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialWindowRadiation;

          output Real[N] absIntIrrNoSha(each min=0, each max=1)
          "Hemispherical absorptance of each glass layer for interior irradiation without shading";

      protected
          Real dTraRef[3, N, N, HEM](each min=0, each max=1)
          "Dummy transmittance and reflectance with exterior irradiation without shading";
          Real dAbs[N, HEM](each min=0, each max=1)
          "Dummy absorptance with exterior irradiation and no shading";

        algorithm
          // Reverse the data srtucture for exterior irradiation and no shading
          for i in 1:N loop
            for j in 1:N loop
              for iD in 1:HEM loop
                dTraRef[TRA, i, j, iD] := traRef[TRA, N + 1 - i, N + 1 - j, iD];
                dTraRef[Ra, i, j, iD] := traRef[Rb, N + 1 - i, N + 1 - j, iD];
                dTraRef[Rb, i, j, iD] := traRef[Ra, N + 1 - i, N + 1 - j, iD];
              end for;
            end for;
          end for;

          dAbs :=
            Buildings.HeatTransfer.Windows.Functions.glassAbsExteriorIrradiationNoShading(
            dTraRef,
            N,
            HEM) "Dummmy absorptance with exterior irradiation";

          // Only output hemispherical absorptance. Need to change order for interior irradiation.
          for i in 1:N loop
            absIntIrrNoSha[i] := dAbs[N + 1 - i, HEM];
          end for;

          annotation (Documentation(info="<html>
<p>
This function computes the hemispherical absorptance of each glass pane for interior irradiation without no shading. 
The angular irradiation is not considered since the interior irradiation (from the room) is assumed to be diffusive.
It is a reverse of the function 
<a href=\"modelica://Buildings.HeatTransfer.Windows.Functions.glassAbsInterirorIrradiationNoShading\">
Buildings.HeatTransfer.Windows.Functions.glassAbsInterirorIrradiationNoShading</a>.
</p>
</html>",         revisions="<html>
<ul>
<li>
September 7, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"));
        end glassAbsInterirorIrradiationNoShading;

        function glassProperty
        "Compute angular variation and hemispherical integration of the transmittance and reflectance for each glass pane without shading"
          extends
          Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialGlassRadiation;
          input Real glass[3, N] "Propertry of each glass pane";
          input Modelica.SIunits.Angle psi[HEM - 1] "Incident angles";

          output Real layer[3, N, HEM]
          "Transmittance, front and back reflectance";

      protected
          Integer NDIR=HEM - 1 "Number of incident angles";

          Real psi_c "cos(psi), psi is incident angle";
          Real psi_cs "cos(psi)*sin(psi)";
          Real angT "Angular variation of transmittance";
          Real angR "Angular variation of reflectance";
          Real f[3, NDIR]
          "Temporary variables for integration in hemispherical transmittance and reflectance";
          constant Real deltaX=0.5*Modelica.Constants.pi/(NDIR - 1);
          constant Real a[4, 5]={{-0.0015,3.355,-3.840,1.460,0.0288},{0.999,-0.563,
              2.043,-2.532,1.054},{-0.002,2.813,-2.341,-0.05725,0.599},{0.997,-1.868,
              6.513,-7.862,3.225}} "Coeffcients in Table A.2";
          Integer id1 "Index of coefficients for transmittance";
          Integer id2 "Index of coefficients for reflectance";

        algorithm
          // Compute specular value for angle 0 to 90 degree (psi[1] to psi[N]) and panes from 1 to N
          for i in 1:N loop
            for k in TRA:Rb loop
              layer[k, i, 1] := glass[k, i]
              "Copy the data at 0 degree (normal incidence)";
            end for;

            for j in 2:NDIR - 1 loop
              psi_c := Modelica.Math.cos(psi[j]);
              if layer[TRA, i, 1] > 0.645 then
                id1 := 1;
                id2 := 2;
              else
                id1 := 3;
                id2 := 4;
              end if;
              angT := a[id1, 1] + psi_c*(a[id1, 2] + psi_c*(a[id1, 3] + psi_c*(a[id1, 4]
                 + psi_c*a[id1, 5]))) "Equation (A.4.68a)";
              angR := a[id2, 1] + psi_c*(a[id2, 2] + psi_c*(a[id2, 3] + psi_c*(a[id2, 4]
                 + psi_c*a[id2, 5]))) - angT "Equation (A.4.68b)";
              layer[TRA, i, j] := layer[TRA, i, 1]*angT "Equation (A4.69a)";
              layer[Ra, i, j] := layer[Ra, i, 1]*(1 - angR) + angR
              "Equation (A4.69b)";
              layer[Rb, i, j] := layer[Rb, i, 1]*(1 - angR) + angR
              "Equation (A4.69b)";
            end for;

            // When incident angle is equal to 90 degree
            layer[TRA, i, NDIR] := 0;
            layer[Ra, i, NDIR] := 1.0;
            layer[Rb, i, NDIR] := 1.0;

          end for;

          // Computer hemispherical value: HEM.
          for i in 1:N loop
            for j in 1:NDIR loop
              psi_cs := Modelica.Math.cos(psi[j])*Modelica.Math.sin(psi[j]);
              for k in TRA:Rb loop
                f[k, j] := 2*layer[k, i, j]*psi_cs;
              end for;
            end for;

            for k in TRA:Rb loop
              layer[k, i, HEM] :=
                Buildings.Utilities.Math.Functions.trapezoidalIntegration(
                NDIR,
                f[k, :],
                deltaX) "Equation (A.4.70a) and (A.4.70b)";
            end for;

          end for;

          annotation (Documentation(info="<html>
<p>
This function computes the angular variation and the hemispherical integration of the transmittance and reflectance for each glass pane.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 24, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"));
        end glassProperty;

        function glassTRExteriorIrradiationNoShading
        "Transmittance and reflectance of glass panes for exterior irradiation without shading"
          extends
          Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialGlassRadiation;
          input Real layer[3, N, HEM] "Angular data of glass pane";
          output Real traRef[3, N, N, HEM](each min=0, each max=1)
          "Transmittance and reflectance of each glass pane for exterior irradiation without shading";

      protected
          Real aij "Temporary variable";
          constant Real SMALL=Modelica.Constants.small "Small value";

        algorithm
          // Property for single pane of glass or the first pane of multiple panes glass
          for iD in 1:HEM loop
            for k in TRA:Rb loop
              traRef[k, 1, 1, iD] := layer[k, 1, iD] "Equation (A.4.71)";
            end for;
          end for;

          // Property for multiple panes glass
          if N > 1 then
            for iD in 1:HEM loop
              for i in 1:N - 1 loop
                for j in i + 1:N loop
                  for k in TRA:Rb loop
                    traRef[k, j, j, iD] := layer[k, j, iD];
                  end for;

                  aij := 1 - traRef[Ra, j, j, iD]*traRef[Rb, j - 1, i, iD]
                  "Equation (A.4.77)";
                  assert(aij > -SMALL,
                    "Glass transmittance and reflectance data was not correct.\n");
                  if aij < SMALL then
                    traRef[TRA, i, j, iD] := 0;
                    traRef[Ra, i, j, iD] := 1;
                    traRef[Rb, j, i, iD] := 1;
                  else
                    aij := 1/aij;
                    traRef[TRA, i, j, iD] := aij*traRef[TRA, i, j - 1, iD]*traRef[TRA,
                      j, j, iD] "Equation (A.4.78a)";
                    traRef[Ra, i, j, iD] := traRef[Ra, i, j - 1, iD] + aij*traRef[TRA,
                      i, j - 1, iD]*traRef[TRA, i, j - 1, iD]*traRef[Ra, j, j, iD]
                    "Equation (A.4.78b)";
                    traRef[Rb, j, i, iD] := traRef[Rb, j, j, iD] + aij*traRef[TRA, j, j,
                      iD]*traRef[TRA, j, j, iD]*traRef[Rb, j - 1, i, iD]
                    "Equation (A.4.78c)";
                  end if;
                end for;
              end for;
            end for;
          end if;

          annotation (Documentation(info="<html>
<p>
This function computes the angular variation of the transmittance and reflectance of each glass pane for exteior irradiation without shading. 
It accounts for the transmittance and reflectance among different panes. 
Pane <code>1</code> is facing outside and pane <code>N</code> is facing the room. 
</p>
</html>",         revisions="<html>
<ul>
<li>
August 29, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"));
        end glassTRExteriorIrradiationNoShading;

        function glassTRInteriorIrradiationNoShading
        "Transmittance and reflectance of each glass pane for interior irradiation without shading"
          extends
          Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialGlassRadiation;
          input Real layer[3, N, HEM] "Angular data of glass pane";
          output Real traRef[3, N, N, HEM](each min=0, each max=1)
          "Glass transmittance, front and back reflectance";

      protected
          Real dLayer[3, N, HEM]
          "Dummy glass property with Pane 1 facing inside and Pane N facing outside";
          Real dTraRef[3, N, N, HEM]
          "Dummy transmittance and reflectance for exterior irradiation";

        algorithm
          // Copy the dummy glass property
          for iD in 1:HEM loop
            for j in 1:N loop
              dLayer[TRA, j, iD] := layer[TRA, N + 1 - j, iD];
              dLayer[Ra, j, iD] := layer[Rb, N + 1 - j, iD]
              "swap the front and back reflectance";
              dLayer[Rb, j, iD] := layer[Ra, N + 1 - j, iD]
              "swap the front and back reflectance";
            end for;
          end for;

          // Calculate transmittance and reflectance of dummy glass for exterior irradiation without shading
          dTraRef :=
            Buildings.HeatTransfer.Windows.Functions.glassTRExteriorIrradiationNoShading(
            N,
            HEM,
            dLayer);

          // Convert the dummy data to real glass
          for iD in 1:HEM loop
            for i in 1:N - 1 loop
              for j in i + 1:N loop
                traRef[TRA, N + 1 - i, N + 1 - j, iD] := dTraRef[TRA, i, j, iD];
                traRef[Ra, N + 1 - i, N + 1 - j, iD] := dTraRef[Rb, i, j, iD]
                "swap the front and back reflectance";
                traRef[Rb, N + 1 - i, N + 1 - j, iD] := dTraRef[Ra, i, j, iD]
                "swap the front and back reflectance";
              end for;
            end for;
          end for;

          annotation (Documentation(info="<html>
<p>
This function computes the angular variation of the transmittance and reflectance of each glass pane for interior irradiation without shading. 
It accounts for the transmittance and reflectance among different panes. 
Pane <code>1</code> is facing outside and pane <code>N</code> is facing the room. 
</p>
</html>",         revisions="<html>
<ul>
<li>
August 29, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"));
        end glassTRInteriorIrradiationNoShading;

        function winTExteriorIrradiationInteriorShading
        "Angular and hemispherical transmittance of a window system (glass and shading device) for exterior irradiation with interior shading"
          import Buildings;
          extends
          Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialWindowShadingRadiation;

          output Real traExtIrrIntSha[HEM](each min=0, each max=1)
          "Angular and hemispherical transmittance of a window system (glass and shading device) forh exterior irradiation with interior shading";

        algorithm
          for iD in 1:HEM loop
            traExtIrrIntSha[iD] := traRef[TRA, 1, N, iD]*traIntShaDev/(1 - refIntShaDev
              *traRef[Rb, N, 1, HEM]) "Equation (A.4.92)";
          end for;

          annotation (Documentation(info="<html>
<p>
This function computes the angular and hemispherical transmittance of a window system (glass and shading device) for exterior irradiation with interior shading. 
Pane <code>1</code> is facing outside and pane <code>N</code> is facing the room. 
</p>
</html>",         revisions="<html>
<ul>
<li>
August 29, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"));
        end winTExteriorIrradiationInteriorShading;

        function winTExteriorIrradiatrionExteriorShading
        "Angular and hemispherical transmittance of a window system (glass + shading device) for exterior irradiation with exterior shading"
          import Buildings;
          extends
          Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialWindowShadingRadiation;
          output Real traExtIrrExtSha[HEM](each min=0, each max=1)
          "Angular and hemispherical transmittance of a window system (glass + shading device) for exterior irradiation with exterior shading";

      protected
          Real c;

        algorithm
          for iD in 1:HEM loop
            c := traExtShaDev*(1 + traRef[Ra, 1, N, iD]*refExtShaDev/(1 - traRef[Ra, 1,
              N, HEM]*refExtShaDev)) "Equation (A.4.88a)";
            traExtIrrExtSha[iD] := c*traRef[TRA, 1, N, iD] "Equation (A.4.88c)";
          end for;

          annotation (Documentation(info="<html>
<p>
This function computes the angular and hemispherical transmittance of a window system (glass + shading device) for exterior irradiation with exterior shading. 
Pane <code>1</code> is facing outside and pane <code>N</code> is facing the room. 
</p>
</html>",         revisions="<html>
<ul>
<li>
August 29, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"));
        end winTExteriorIrradiatrionExteriorShading;

        function winTRInteriorIrradiationExteriorShading
        "Hemispherical transmittance and back reflectance of a window system (glass and shading device) for interior irradiation with exterior shading"
          extends
          Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialWindowShadingRadiation;
          output Real traRefIntIrrExtSha[3](each min=0, each max=1)
          "Hemispherical transmittance and back reflectance of a window system (glass and shading device) for interior irradiation with exterior shading";
        algorithm
          traRefIntIrrExtSha[TRA] := traRef[TRA, N, 1, HEM]*traExtShaDev/(1 -
            refExtShaDev*traRef[Ra, 1, N, HEM]) "Equation (A.4.95)";
          traRefIntIrrExtSha[Rb] := traRef[Rb, N, 1, HEM] + traRef[TRA, N, 1, HEM]*
            refExtShaDev*traRef[1, 1, N, HEM]/(1 - traRef[Ra, 1, N, HEM]*refExtShaDev)
          "Equation (A.4.97)";
          traRefIntIrrExtSha[Ra] := 0 "Dummy value";
          annotation (Documentation(info="<html>
<p>
This function computes hemispherical transmittance and back reflectance of a window for interior irradiation with exterior shading. 
Pane <code>1</code> is facing the outside and pane <code>N</code> is facing the room.
The variables are<pre>
traRefIntIrrExtSha[1]: Transmittance;
traRefIntIrrExtSha[2]: Back reflectance; 
traRefIntIrrExtSha[3]: Dummy value
</pre>
</p>
</html>",         revisions="<html>
<ul>
<li>
August 29, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"));
        end winTRInteriorIrradiationExteriorShading;

        function winTRInteriorIrradiationInteriorShading
        "Hemispherical transmittance and back reflectance of a window system (glass and shading device) for interior irradiation with interior shading"
          extends
          Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialWindowShadingRadiation;

          output Real traRefIntIrrIntSha[3](each min=0, each max=1)
          "Hemispherical transmittance and back reflectance of a window system (glass and shading device) for interior irradiation with interior shading";

      protected
          constant Real rRho=traRef[Rb, N, 1, HEM]*refIntShaDev
          "Part of Equation (A.4.99)";
          constant Real rTau=traRef[Rb, N, 1, HEM]*traIntShaDev
          "Part of Equation (A.4.105)";
          constant Real c=traIntShaDev*(1 + rRho/(1 - rRho))
          "Equation (A.4.99)";

        algorithm
          traRefIntIrrIntSha[TRA] := c*traRef[TRA, N, 1, HEM]
          "Equation (A.4.100b)";
          traRefIntIrrIntSha[Rb] := refIntShaDev + c*rTau "Equation (A.4.105)";
          traRefIntIrrIntSha[Ra] := 0 "Dummy value";

          annotation (Documentation(info="<html>
<p>
This function computes the hemispherical transmittance and back reflectance of a window system (glass and shading device) for interior irradiation with interior shading. 
Pane <code>1</code> is facing the outside and pane <code>N</code> is facing the room.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 29, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"));
        end winTRInteriorIrradiationInteriorShading;

        package BaseClasses
        "Package with base classes for Buildings.HeatTransfer.Windows.Functions"
          extends Modelica.Icons.BasesPackage;

          partial function partialGlassRadiation
          "partial function for glass radiation property"
            input Integer N(min=1) "Number of glass layers";
            input Integer HEM "Index of hemispherical integration";

        protected
            constant Integer TRA=1 "Index of Transmittance";
            constant Integer Ra=2
            "Index of front reflectance (outside facing side)";
            constant Integer Rb=3
            "Index of back reflectance (room-facing side)";

            annotation (preferedView="info",
            Documentation(info="<html>
This is a partial function that is used to implement the radiation functions for windows. It defines basic input variables and constants.
</html>",           revisions="<html>
<ul>
<li>
September 16 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"));
          end partialGlassRadiation;

          partial function partialWindowRadiation
          "partial function for window radiation property"
            input Real traRef[3, N, N, HEM](each min=0, each max=0)
            "Transmittance and reflectance with exterior irradiation and no shading";
            extends
            Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialGlassRadiation;

            annotation (preferedView="info",
            Documentation(info="<html>
This is a partial function that is used to implement the radiation functions for windows. It defines basic input variables and constants. 
</html>",           revisions="<html>
<ul>
<li>
September 16 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"));
          end partialWindowRadiation;

          partial function partialWindowShadingRadiation
          "partial function for window radiation property with shading device"
            input Real traRef[3, N, N, HEM](each min=0, each max=0)
            "Transmittance and reflectance with exterior irradiation and no shading";
            input Real traRefShaDev[2, 2](each min=0, each max=0)
            "Transmittance and reflectance of shading device";
            extends
            Buildings.HeatTransfer.Windows.Functions.BaseClasses.partialGlassRadiation;
        protected
            Real traExtShaDev=traRefShaDev[1, 1]
            "Transmittance of the exterior shading device";
            Real refExtShaDev=traRefShaDev[2, 1]
            "Reflectance of the exterior shading device";
            Real traIntShaDev=traRefShaDev[1, 2]
            "Transmittance of the interior shading device";
            Real refIntShaDev=traRefShaDev[2, 2]
            "Reflectance of the interior shading device";
            annotation (preferedView="info",
            Documentation(info="<html>
This is a partial function that is used to implement the radiation functions for windows. It defines basic input variables and parameters. 
</html>",           revisions="<html>
<ul>
<li>
September 16 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"));
          end partialWindowShadingRadiation;
        annotation (preferedView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.HeatTransfer.Windows.Functions\">Buildings.HeatTransfer.Windows.Functions</a>.
</p>
</html>"));
        end BaseClasses;
      annotation (preferedView="info", Documentation(info="<html>
<p>
This package contains functions that are used to compute 
heat transfer in the window model.
</p>
</html>"));
      end Functions;
      annotation (
    preferedView="info", Documentation(info="<html>
<p>
This package contains models for heat transfer in windows.
</p>
</html>"));
    end Windows;

    package Data "Data for heat transfer models"
        extends Modelica.Icons.MaterialPropertiesPackage;

      package Gases
      "Package with thermophysical properties for window fill gases"
          extends Modelica.Icons.MaterialPropertiesPackage;

        record Generic "Thermal properties of fill gas for windows"
            extends Modelica.Icons.Record;
            parameter Modelica.SIunits.Length x "Gas layer thickness";
            parameter Modelica.SIunits.ThermalConductivity a_k
          "Constant coefficient for thermal conductivity";
            parameter Real b_k(unit="W/(m.K2)")
          "Temperature dependent coefficient for thermal conductivity";
            parameter Modelica.SIunits.DynamicViscosity a_mu
          "Constant coefficient for dynamic viscosity";
            parameter Real b_mu(unit="N.s/(m2.K)")
          "Temperature dependent coefficient for dynamic viscosity";
            parameter Modelica.SIunits.SpecificHeatCapacity a_c
          "Constant coefficient for specific heat capacity";
            parameter Real b_c(unit="J/(kg.K2)")
          "Temperature dependent coefficient for specific heat capacity";

            parameter Modelica.SIunits.MolarMass MM
          "Molar mass (of mixture or single fluid)";

            constant Modelica.SIunits.Pressure P0 = 101325 "Normal pressure";

          annotation (defaultComponentName="gas", Documentation(info=
                         "<html>
Generic record for thermophysical properties for window
gas fills.
The implementation is according to 
<a href=\"http://www.iso.org/iso/catalogue_detail.htm?csnumber=26425\">ISO 15099:2003, 
Thermal performance of windows, doors and shading devices -- Detailed calculations</a>.
</html>",
        revisions="<html>
<ul>
<li>
August 18 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end Generic;

        record Air = Generic(a_k= 2.873E-3, b_k= 7.760E-5,
                             a_mu=3.723E-6, b_mu=4.940E-8,
                             a_c=1002.737,  b_c= 1.2324E-2,
                             MM=28.97E-3) "Thermophysical properties for air";

       function thermalConductivity
        "Function to compute the thermal conductivity of gases"
        input Buildings.HeatTransfer.Data.Gases.Generic gas
          "Record of gas data";
        input Modelica.SIunits.Temperature T "Gas temperature";
        output Modelica.SIunits.ThermalConductivity k "Thermal conductivity";
       algorithm
        k := gas.a_k + gas.b_k*T;
       end thermalConductivity;

      function density "Function to compute the mass density"
        input Buildings.HeatTransfer.Data.Gases.Generic gas
          "Record of gas data";
        input Modelica.SIunits.Temperature T "Gas temperature";
        output Modelica.SIunits.Density rho "Mass density";
      algorithm
          rho := gas.P0*gas.MM/Modelica.Constants.R/T;
      end density;

      function dynamicViscosity
        "Function to compute the dynamic viscosity for gases"
        input Buildings.HeatTransfer.Data.Gases.Generic gas
          "Record of gas data";
        input Modelica.SIunits.Temperature T "Gas temperature";
        output Modelica.SIunits.DynamicViscosity mu "Dynamic viscosity";
      algorithm
          mu := gas.a_mu + gas.b_mu*T;
      end dynamicViscosity;

      function specificHeatCapacity
        "Function to compute the specific heat capacity for gases"
        input Buildings.HeatTransfer.Data.Gases.Generic gas
          "Record of gas data";
        input Modelica.SIunits.Temperature T "Gas temperature";
        output Modelica.SIunits.SpecificHeatCapacity c_p
          "Specific heat capacity";
      algorithm
        c_p := gas.a_c + gas.b_c*T;
      end specificHeatCapacity;
        annotation (Documentation(info="<html>
Package with records for thermophysical properties for window
gas fills.
The implementation is according to 
<a href=\"http://www.iso.org/iso/catalogue_detail.htm?csnumber=26425\">ISO 15099:2003, 
Thermal performance of windows, doors and shading devices -- Detailed calculations</a>.
</html>",
        revisions="<html>
<ul>
<li>
August 18 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
      end Gases;

      package Glasses "Package with thermophysical properties for window glas"
          extends Modelica.Icons.MaterialPropertiesPackage;

        record Generic "Thermal properties of window glass"
            extends Modelica.Icons.Record;
         parameter Modelica.SIunits.Length x=0.003 "Thickness";
         parameter Modelica.SIunits.ThermalConductivity k=1
          "Thermal conductivity";
         parameter Modelica.SIunits.TransmissionCoefficient tauSol = 0.6
          "Solar transmittance";
         parameter Modelica.SIunits.ReflectionCoefficient rhoSol_a = 0.075
          "Solar reflectance of surface a (usually outside-facing surface)";
         parameter Modelica.SIunits.ReflectionCoefficient rhoSol_b = 0.075
          "Solar reflectance of surface b (usually room-facing surface)";
         parameter Modelica.SIunits.TransmissionCoefficient tauIR = 0
          "Infrared transmissivity of glass";
         parameter Modelica.SIunits.Emissivity absIR_a = 0.84
          "Infrared absorptivity of surface a (usually outside-facing surface)";
         parameter Modelica.SIunits.Emissivity absIR_b = 0.84
          "Infrared absorptivity of surface b (usually room-facing surface)";
          annotation (defaultComponentName="gla", Documentation(info=
                         "<html>
<p>
This record implements thermophysical properties for window glas.
</p>
<p>
The table below compares the data of this record with the variables used in the WINDOW 5 output file.
</p>
<p>
Note that
<ul>
<li>the surface <code>a</code> is usually the outside-facing surface, and the surface
<code>b</code> is usually the room-facing surface.
</li>
<li>by the term <i>solar</i>, we mean the whole solar spectrum.
Data in the solar spectrum are used for computing solar heat gains.
</li>
<li>by the term <i>infrared</i> (or <i>infrared</i>), we mean the infrared spectrum. 
Data in the infrared spectrum are used for thermal radiation that is emitted by surfaces that are 
around room or ambient temperature.
</li>
<li>WINDOW 5 uses spectral data in the calculation of optical properties of window systems, 
whereas the model in this library uses averages over the whole solar or infrared spectrum.
</li>
</ul>
</p>
<p>
<table border=\"1\">
<thead>
 <tr>
   <th>Buildings library variable name</th>
   <th>WINDOW 5 variable name</th>
 </tr>
</thead>
<tbody>
<tr>
  <td>tauSol</td>  <td>Tsol</td>
</tr>
<tr>
  <td>rhoSol_a</td>  <td>Rsol1</td>
</tr>
<tr>
  <td>rhoSol_b</td>  <td>Rsol2</td>
</tr>
<tr>
  <td>tauIR</td>  <td>Tir</td>
</tr>
<tr>
  <td>absIR_a</td>  <td>Abs1</td>
</tr>
<tr>
  <td>absIR_b</td>  <td>Abs2</td>
</tr>
</tbody>
</table>

</html>",
        revisions="<html>
<ul>
<li>
Sep. 3 2010, by Michael Wetter, Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"));
        end Generic;

        record ID101 =   Buildings.HeatTransfer.Data.Glasses.Generic (
            x=0.0057,
            k=1.0,
            tauSol=0.486,
            rhoSol_a=0.053,
            rhoSol_b=0.053,
            tauIR=0,
            absIR_a=0.84,
            absIR_b=0.84) "Generic Bronze Glass 5.7mm. Manufacturer: Generic.";

        record ID102 =   Buildings.HeatTransfer.Data.Glasses.Generic (
            x=0.003,
            k=1.0,
            tauSol=0.834,
            rhoSol_a=0.075,
            rhoSol_b=0.075,
            tauIR=0,
            absIR_a=0.84,
            absIR_b=0.84) "Generic Clear Glass 3.048mm. Manufacturer: Generic.";
        annotation(preferedView="info",
                  Documentation(info="<html>
This package implements thermophysical properties for window glas.
</p>
<p>
Since the infrared transmissivity is part of the Window 5 data and since
it depends on the glass thickness, the glass thickness is a parameter
that is set for all glass layers.
This configuration is different from the records fo gas properties, 
which do not yet set the value for the thickness of the gas gap.
</html>",
      revisions="<html>
<ul>
<li>
September 9, 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
      end Glasses;

      package Shades "Package with thermophysical properties for window shades"
          extends Modelica.Icons.MaterialPropertiesPackage;

        record Generic "Thermal properties of window shades"
            extends Modelica.Icons.Record;
         parameter Modelica.SIunits.TransmissionCoefficient tauSol_a=0.1
          "Solar transmissivity of shade surface a (surface that faces the outside or the room)";
         parameter Modelica.SIunits.TransmissionCoefficient tauSol_b=0.1
          "Solar transmissivity of shade surface b (surface that faces the glass)";
         parameter Modelica.SIunits.ReflectionCoefficient rhoSol_a=0.8
          "Solar reflection coefficient of shade surface a (surface that faces the outside or the room)";
         parameter Modelica.SIunits.ReflectionCoefficient rhoSol_b=0.8
          "Solar reflection coefficient of shade surface b (surface that faces the glass)";
         parameter Modelica.SIunits.Emissivity absIR_a=0.84
          "Infrared absorptivity of surface a (surface that faces the outside or the room)";
         parameter Modelica.SIunits.Emissivity absIR_b=0.84
          "Infrared absorptivity of surface b (surface that faces the glass)";
         parameter Modelica.SIunits.TransmissionCoefficient tauIR_a=0
          "Infrared transmissivity of surface a (surface that faces the outside or the room)";
         parameter Modelica.SIunits.TransmissionCoefficient tauIR_b=0
          "Infrared transmissivity of surface b (surface that faces the glass)";

          annotation (defaultComponentName="sha", Documentation(info=
                                     "<html>
Records that implements thermophysical properties for window shades.
</html>",
        revisions="<html>
<ul>
<li>
Sep. 3 2010, by Michael Wetter, Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"));
        end Generic;

        record Gray=Buildings.HeatTransfer.Data.Shades.Generic (
            tauSol_a = 0.25,
            tauSol_b = 0.25,
            rhoSol_a = 0.25,
            rhoSol_b = 0.25,
            absIR_a = 0.25,
            absIR_b = 0.25) "Gray";
      annotation (Documentation(info="<html>
Package with records that implement thermophysical properties for window shades.
</html>",
        revisions="<html>
<ul>
<li>
Sep. 3 2010, by Michael Wetter, Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"),         preferedView="info",
                  Documentation(info="<html>
This package implements thermophysical properties for window shades.
</html>"));
      end Shades;

      package GlazingSystems
      "Package with thermophysical properties for glazing systems"
          extends Modelica.Icons.MaterialPropertiesPackage;

        record Generic "Thermal properties of glazing systems"
            extends Modelica.Icons.Record;
          parameter Integer nLay(min=1, fixed=true) "Number of glass layers"
            annotation (Evaluate=true);
          parameter Boolean haveExteriorShade = false
          "Set to true if window has an exterior shade (at surface a)"
            annotation (Evaluate=true);
          parameter Boolean haveInteriorShade = false
          "Set to true if window has an interior shade (at surface b)"
            annotation (Evaluate=true);
          final parameter Boolean windowHasShade = haveExteriorShade or haveInteriorShade
          "Set to true if the window has an exterior or an interior shade";

          parameter Glasses.Generic glass[nLay]
          "Layer by layer declaration of glass layers, starting from outside to room-side"
            annotation (choicesAllMatching=true, Evaluate=true, Placement(transformation(extent={{60,60},{80,80}})));
          parameter Gases.Generic gas[nLay-1]
          "Layer by layer declaration of glass layers, starting from outside to room-side"
            annotation (choicesAllMatching=true, Evaluate=true, Placement(transformation(extent={{60,20},
                    {80,40}})));
          parameter Shades.Generic shade "Shade"
            annotation (choicesAllMatching=true, Evaluate=true,
            Dialog(enable=haveInteriorShade or haveExteriorShade));
          parameter Modelica.SIunits.CoefficientOfHeatTransfer UFra
          "U-value of frame";
          parameter Modelica.SIunits.Emissivity absIRFra=0.8
          "Infrared absorptivity of window frame";
          parameter Modelica.SIunits.Emissivity absSolFra=0.5
          "Solar absorptivity of window frame";
          final parameter Boolean haveShade = haveInteriorShade or haveExteriorShade
          "Parameter that is true if the construction has a shade";

          annotation (defaultComponentName="glaSys", Documentation(info=
                         "<html>
Generic record that implements thermophysical properties for glazing systems.
</html>",
        revisions="<html>
<ul>
<li>
Sep. 3 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end Generic;

        record SingleClear3 =
            Buildings.HeatTransfer.Data.GlazingSystems.Generic (
               glass={Glasses.ID102()},
               UFra=3,
               final nLay=1) "Single pane, clear glass 3mm";

        record DoubleClearAir13Clear =
            Buildings.HeatTransfer.Data.GlazingSystems.Generic (
            final glass={Glasses.ID101(), Glasses.ID102()},
            final gas={Gases.Air(x=0.0127)},
            UFra=1.4,
            final nLay=2)
        "Double pane, clear glass 3mm, air 12.7, clear glass 3mm";
      annotation (preferedView="info",
      Documentation(info="<html>
Package with generic records that implement thermophysical properties for glazing systems.
</html>",
        revisions="<html>
<ul>
<li>
Sep. 3 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
      end GlazingSystems;

      package Solids
      "Package with solid material, characterized by thermal conductance, density and specific heat capacity"
          extends Modelica.Icons.MaterialPropertiesPackage;

        record Generic "Thermal properties of solids with heat storage"
            extends Buildings.HeatTransfer.Data.BaseClasses.Material(final R=x/k);
          annotation (defaultComponentName="mat", Documentation(info=
           "<html>
<p>
Generic record for solid materials.
The material is characterized by its 
thermal conductivity, mass density and specific
heat capacity.
</p>
</html>",       revisions=
                "<html>
<ul>
<li>
September 9, 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end Generic;

        record Brick = Buildings.HeatTransfer.Data.Solids.Generic (
            k=0.89,
            d=1920,
            c=790) "Brick (k=0.89)";

        record Concrete = Buildings.HeatTransfer.Data.Solids.Generic (
            k=1.4,
            d=2240,
            c=840) "Concrete (k=1.4)";

        record GypsumBoard = Buildings.HeatTransfer.Data.Solids.Generic (
            k=0.16,
            d=800,
            c=1090) "Gypsum board (k=0.58)";

        record Plywood = Buildings.HeatTransfer.Data.Solids.Generic (
            k=0.12,
            d=540,
            c=1210) "Plywood (k=0.12)";
        annotation (
      Documentation(
      info="<html>
<p>
Package with records for solid materials.
The material is characterized by its 
thermal conductivity, mass density and specific
heat capacity.
</p>
</html>",
      revisions="<html>
<ul>
<li>
September 9, 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
      end Solids;

      package Resistances "Package with thermal resistances"
          extends Modelica.Icons.MaterialPropertiesPackage;

        record Generic "Thermal properties of heat resistances"
            extends Buildings.HeatTransfer.Data.BaseClasses.Material(
            final c=0,
            final d=0,
            final k=0,
            final x=0,
            final nStaRef=0,
            final nSta=1,
            final steadyState=true);

          annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}), graphics={Rectangle(
                  extent={{-100,50},{100,-100}},
                  fillColor={255,255,127},
                  fillPattern=FillPattern.Solid,
                  lineColor={0,0,255}), Text(
                  extent={{-98,-72},{96,-94}},
                  lineColor={0,0,255},
                  textString="R=%R")}),
            defaultComponentName="mat",
                      Documentation(info="<html>
Generic record for thermal properties of
heat resistances.
</html>",
        revisions="<html>
<ul>
<li>
Sep. 3 2010, by Michael Wetter, Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"));
        end Generic;

        record Carpet = Buildings.HeatTransfer.Data.Resistances.Generic (R=0.2165) "Carpet";
          annotation (Documentation(info="<html>
Package with records that implement thermal properties of
heat resistances.
</html>",
        revisions="<html>
<ul>
<li>
Sep. 3 2010, by Michael Wetter, Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"));
      end Resistances;

      package OpaqueConstructions
      "Package with opaque constructions for floors, walls, etc."
          extends Modelica.Icons.MaterialPropertiesPackage;

        record Generic "Thermal properties of opaque constructions"
          parameter Integer nLay(min=1, fixed=true) "Number of layers";
          parameter Solids.Generic material[nLay]
          "Layer by layer declaration of material, starting from outside to room-side"
            annotation (choicesAllMatching=true, Evaluate=true, Placement(transformation(extent={{60,60},{80,80}})));
         final parameter Real R(unit="m2.K/W")=sum(material[:].R)
          "Thermal resistance per unit area";

         parameter Modelica.SIunits.Emissivity absIR_a=0.9
          "Infrared absorptivity of surface a (usually outside-facing surface)";
         parameter Modelica.SIunits.Emissivity absIR_b=0.9
          "Infrared absorptivity of surface b (usually room-facing surface)";
         parameter Modelica.SIunits.Emissivity absSol_a=0.5
          "Solar absorptivity of surface a (usually outside-facing surface)";
         parameter Modelica.SIunits.Emissivity absSol_b=0.5
          "Solar absorptivity of surface b (usually room-facing surface)";
         parameter Buildings.HeatTransfer.Types.SurfaceRoughness roughness_a=
            Buildings.HeatTransfer.Types.SurfaceRoughness.Medium
          "Exterior surface roughness";

          annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                    -100},{100,100}}), graphics={
                Rectangle(
                  extent={{-100,50},{100,-100}},
                  lineColor={0,0,255},
                  fillColor={255,255,85},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-54,42},{-36,-92}},
                  lineColor={0,0,0},
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Forward),
                Rectangle(
                  extent={{4,42},{54,-92}},
                  lineColor={0,0,0},
                  fillColor={215,215,215},
                  fillPattern=FillPattern.CrossDiag),
                Text(
                  extent={{-127,113},{127,53}},
                  textString="%name",
                  lineColor={0,0,255}),
                Rectangle(
                  extent={{-36,42},{4,-92}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Backward)}),
            defaultComponentName="opaCon",
            Documentation(info="<html>
Generic record with material definitions for constructions
with one or more layers of material.
By convention, <code>layer[1]</code> is facing the outside, and the last
layer is facing the room-side.
This is the same convention as is used in EnergyPlus and in Window 6.
</p>
<p>
The parameters <code>absIR_a</code> and <code>absIR_b</code>
are used to compute infrared heat radiation (in the infrared spectrum).
The parameters <code>absSol_a</code> and <code>absSol_b</code>
are used to compute solar heat radiation (in the solar spectrum).
</p>
<p>
The parameter <code>roughness_a</code> is used if the convective heat transfer
coefficient of the exterior surface is computed based on the wind-speed, wind-direction
and temperature difference. See
<a href=\"modelica://Buildings.HeatTransfer.Convection.Exterior\">
Buildings.HeatTransfer.Convection.Exterior</a>.
</p>
</html>",       revisions=
                "<html>
<ul>
<li>
November 16, 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));

        end Generic;

        record Brick120 =
            Buildings.HeatTransfer.Data.OpaqueConstructions.Generic (material={
                Solids.Brick(x=0.12)}, final nLay=1)
        "Construction with 120mm brick";
        annotation (preferedView="info",
      Documentation(info="<html>
<p>
Package with material definitions for constructions
with one or more layers of material.
By convention, <code>layer[1]</code> is facing the outside, and the last
layer is facing the room-side.
This is the same convention as is used in EnergyPlus and in Window 6.
</p>
<p>
The parameters <code>absIR_a</code> and <code>absIR_b</code>
are used to compute infrared heat radiation (in the infrared spectrum).
The parameters <code>absSol_a</code> and <code>absSol_b</code>
are used to compute solar heat radiation (in the solar spectrum).
</p>

</html>",
      revisions="<html>
<ul>
<li>
November 16, 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
      end OpaqueConstructions;

      package OpaqueSurfaces
      "Package with thermophysical properties for opaque surfaces"
          extends Modelica.Icons.MaterialPropertiesPackage;

        record Generic "Thermal properties of opaque surfaces"
            extends Modelica.Icons.Record;
         parameter Modelica.SIunits.Area A "Area";
         parameter Modelica.SIunits.Angle til
          "Surface tilt (0: ceiling, pi/2: wall, pi: floor";
         parameter Modelica.SIunits.Emissivity absIR=0.84
          "Infrared absorptivity";
         parameter Modelica.SIunits.Emissivity absSol=0.84 "Solar absorptivity";
         final parameter Boolean isFloor=til > 2.74889125 and til < 3.53428875
          "Flag, true if construction is a floor"   annotation (Evaluate=true);

          annotation (defaultComponentName="opaSur", Documentation(info=
                         "<html>
<p>
This record implements thermophysical properties for opaque surfaces.
</p>
<p>
The parameter <code>absIR</code>
is used to compute infrared heat radiation (in the infrared spectrum).
The parameter <code>absSol</code>
is used to compute solar heat radiation (in the solar spectrum).
</p>
</html>",
        revisions="<html>
<ul>
<li>
November 16, 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end Generic;
        annotation (
      preferedView="info",
      Documentation(info="<html>
<p>
Package with records for opaque surfaces.
</p>
<p>
The parameter <code>absIR</code>
is used to compute infrared heat radiation (in the infrared spectrum).
The parameter <code>absSol</code>
is used to compute solar heat radiation (in the solar spectrum).
</p>
</html>",
        revisions="<html>
<ul>
<li>
November 16, 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
      end OpaqueSurfaces;

      package BaseClasses "Base classes for package Data"
        extends Modelica.Icons.BasesPackage;

        record Material "Thermal properties of materials w/o storage"
          extends Modelica.Icons.Record;
          parameter Modelica.SIunits.Length x "Material thickness";
          parameter Modelica.SIunits.ThermalConductivity k
          "Thermal conductivity";
          parameter Modelica.SIunits.SpecificHeatCapacity c
          "Specific heat capacity";
          parameter Modelica.SIunits.Density d "Mass density";
          parameter Real R(unit="m2.K/W")
          "Thermal resistance of a unit area of material";
          parameter Integer nStaRef(min=0) = 3
          "Number of state variables in a reference material of 0.2 m concrete";
          parameter Integer nSta(min=1)=max(1, integer(ceil(nStaReal)))
          "Actual number of state variables in material"
            annotation(Evaluate=true, Dialog(tab="Advanced"));
          parameter Boolean steadyState= (c == 0 or d == 0)
          "Flag, if true, then material is computed using steady-state heat conduction"
            annotation(Evaluate=true);
          parameter Real piRef=331.4
          "Ratio x/sqrt(alpha) for reference material of 0.2 m concrete"
            annotation (Dialog(tab="Advanced"));
          parameter Real piMat=if steadyState then piRef else x*sqrt(c*d)/sqrt(k)
          "Ratio x/sqrt(alpha)"
            annotation(Evaluate=true, Dialog(tab="Advanced"));
          parameter Real nStaReal(min=0) = nStaRef*piMat/piRef
          "Number of states as a real number"
            annotation (Dialog(tab="Advanced"));
          annotation (preferedView="info",
          Documentation(info="<html>
Base record for materials that declares the thermal properties. 
</p>
<p>
The specific heat capacity can be zero, in which case the material
will be modeled as a thermal resistor that does not store energy.
</p>
<p>
Note that the thermal resistance is in units of 
<i>m<sup>2</sup> K &frasl; W</i> and not <i>K &frasl; W</i>
because this record does not have the surface area as a parameter. 
The surface area
will be defined in the model of the construction that uses this material.
This allows use of the same material in walls, floors
and ceilings of different surface area.
</p>
</html>",
        revisions="<html>
<ul>
<li>
June 3 2010, by Michael Wetter:<br>
Implemented adaptive computation of number of states based on a reference construction of <i>0.2 m</i> concrete.
</li>
<li>
March 6 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),         Icon(graphics={
                Text(
                  extent={{-94,44},{-16,12}},
                  lineColor={0,0,0},
                  textString="x=%x"),
                Text(
                  extent={{8,40},{86,8}},
                  lineColor={0,0,0},
                  textString="k=%k"),
                Text(
                  extent={{-90,-58},{-12,-90}},
                  lineColor={0,0,0},
                  textString="R=%R"),
                Text(
                  extent={{-92,-10},{-14,-42}},
                  lineColor={0,0,0},
                  textString="U=%U"),
                Rectangle(
                  visible=(c == 0),
                  extent={{0,0},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={255,170,170},
                  fillPattern=FillPattern.Solid),
                Line(points={{-100,-50},{100,-50}}, color={0,0,0}),
                Text(
                  visible=not (c == 0),
                  extent={{8,-8},{86,-40}},
                  lineColor={0,0,0},
                  textString="d=%d"),
                Text(
                  visible=not (c == 0),
                  extent={{10,-56},{88,-88}},
                  lineColor={0,0,0},
                  textString="c=%c")}));
        end Material;
      end BaseClasses;
      annotation (Documentation(info="<html>
Package with thermal properties of solid materials.
</html>"));
    end Data;

    package Types "Package with type definitions"

      type SurfaceRoughness = enumeration(
        VeryRough "Very rough",
        Rough "Rough",
        Medium "Medium rough",
        MediumSmooth "Medium smooth",
        Smooth "Smooth",
        VerySmooth "Very smooth") "Enumeration defining the surface roughness"
      annotation (Documentation(info="<html>
<p>
This enumeration is used to define the surface roughness
which may be used to compute the convective heat transfer coefficients of 
building construction.
</p>
<p>
The surface roughness will be used to compute the
wind-driven convective heat transfer coefficient in 
<a href=\"modelica://Buildings.HeatTransfer.Convection.Exterior\">
Buildings.HeatTransfer.Convection.Exterior</a>.
The possible surface roughness are
</p>
<p>
<table border=\"1\">
<tr>
<th>Roughness index</th>
<th>Example material</th>
</tr>
<tr><td>VeryRough</td>     <td>Stucco</td></tr>
<tr><td>Rough</td>         <td>Brick</td></tr>
<tr><td>MediumRough</td>   <td>Concrete</td></tr>
<tr><td>MediumSmooth</td>  <td>Clear pine</td></tr>
<tr><td>Smooth</td>        <td>Smooth plaster</td></tr>
<tr><td>VerySmooth</td>    <td>Glass</td></tr>
</tr>
</table>

</p>
</html>"),     Evaluate=true);

      type ExteriorConvection = enumeration(
        Fixed "Fixed coefficient (a user-specified parameter is used)",
        TemperatureWind "Wind speed and temperature dependent")
      "Enumeration defining the convective heat transfer model for exterior surfaces"
      annotation (Documentation(info="<html>
<p>
This enumeration is used to set the function
that is used to compute the convective
heat transfer coefficient for exterior (outside-side facing) surfaces.</p>
</html>"),     Evaluate=true);

      type InteriorConvection = enumeration(
        Fixed "Fixed coefficient (a user-specified parameter is used)",
        Temperature "Temperature dependent")
      "Enumeration defining the convective heat transfer model for interior surfaces"
      annotation (Documentation(info="<html>
<p>
This enumeration is used to set the function
that is used to compute the convective
heat transfer coefficient for interior (room-side facing) surfaces.</p>
</html>"),     Evaluate=true);

      package Tilt "Enumeration for surface tilt"

        constant Modelica.SIunits.Angle Wall =    Modelica.Constants.pi/2
        "Tilt for wall";

        constant Modelica.SIunits.Angle Floor =   Modelica.Constants.pi
        "Tilt for floor";
        annotation(preferedView="info", Documentation(info="<html>
<p>
 Enumeration to define the tilt of a surface for the room model.
  For example, for a construction that is a floor, use
 <code>Buildings.HeatTransfer.Types.Tilt.Floor</code>.
</p>
</html>",
      revisions="<html>
<ul>
<li>
November 30, 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
      end Tilt;

      package Azimuth "Enumeration for surface azimuth"

         constant Modelica.SIunits.Angle S = 0
        "Azimuth for an exterior wall whose outer surface faces south";

         constant Modelica.SIunits.Angle E = -Modelica.Constants.pi/2
        "Azimuth for an exterior wall whose outer surface faces east";

         constant Modelica.SIunits.Angle N = Modelica.Constants.pi
        "Azimuth for an exterior wall whose outer surface faces north";

         constant Modelica.SIunits.Angle W = +Modelica.Constants.pi/2
        "Azimuth for an exterior wall whose outer surface faces west";
        annotation(preferedView="info",
        Documentation(info="<html>
<p>
 Enumeration to define the azimuth of a surface for the room model.
 For example, if an exterior wall is South oriented, i.e., its outside-facing
surface is towards South, use 
 <code>Buildings.HeatTransfer.Types.Azimuth.S</code>.
</p>
</html>",
      revisions="<html>
<ul>
<li>
November 30 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
      end Azimuth;
    annotation (preferedView="info", Documentation(info="<html>
This package contains type definitions.
</html>"));
    end Types;

    package Interfaces "Package with interfaces for heat transfer models"
      extends Modelica.Icons.InterfacesPackage;

      connector RadiosityInflow = flow input Real(min=0, unit="W", nominal=419)
      "Connector for inflowing radiosity"
        annotation(defaultComponentName = "JIn", Icon(graphics={Polygon(
              points={{-100,100},{100,0},{-100,-100},{-100,100}},
              pattern=LinePattern.None,
              smooth=Smooth.None,
              fillColor={0,127,0},
              fillPattern=FillPattern.Solid)}),
        Diagram(graphics={                    Text(
              extent={{-38,120},{38,100}},
              lineColor={0,127,0},
              fillColor={0,127,0},
              fillPattern=FillPattern.Solid,
              textString="%name"),                              Polygon(
              points={{-100,100},{100,0},{-100,-100},{-100,100}},
              pattern=LinePattern.None,
              smooth=Smooth.None,
              fillColor={0,127,0},
              fillPattern=FillPattern.Solid)}),
        Documentation(info="<html>
The nominal value is set to <i>&sigma; T<sup>4</sup> = &sigma; 293.15<sup>4</sup> = 419</i>.
</html>",
      revisions="<html>
<ul>
<li>
September 3, 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));

      connector RadiosityOutflow = flow output Real(max=0, unit="W", nominal=419)
      "Connector for outflowing radiosity"
        annotation(defaultComponentName = "JOut", Icon(graphics={Polygon(
              points={{-100,100},{100,0},{-100,-100},{-100,100}},
              smooth=Smooth.None,
              lineColor={0,127,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid)}),
        Diagram(graphics={                                       Polygon(
              points={{-100,100},{100,0},{-100,-100},{-100,100}},
              smooth=Smooth.None,
              lineColor={0,127,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid), Text(
              extent={{-42,122},{34,102}},
              lineColor={0,127,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid,
              textString="%name")}),
        Documentation(info="<html>
The nominal value is set to <i>&sigma; T<sup>4</sup> = &sigma; 293.15<sup>4</sup> = 419</i>.
</html>",
      revisions="<html>
<ul>
<li>
September 3, 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
    annotation (preferedView="info", Documentation(info="<html>
This package contains interfaces for the heat transfer models.
</html>"));
    end Interfaces;
  annotation (preferedView="info", Documentation(info="<html>
This package contains models for heat transfer elements.
</html>"));
  end HeatTransfer;

  package Media "Package with medium models"
    extends Modelica.Icons.MaterialPropertiesPackage;

    package ConstantPropertyLiquidWater
    "Package with model for liquid water with constant properties"
      extends
      Buildings.Media.ConstantPropertyLiquidWater.BaseClasses.ConstantPropertyLiquidWater;
    import SI = Modelica.SIunits;

     redeclare replaceable function extends specificInternalEnergy
      "Return specific internal energy"
      input ThermodynamicState state;
      output SpecificEnergy u "Specific internal energy";
     algorithm
       u := cv_const * (state.T-T0);
     end specificInternalEnergy;

      package BaseClasses
      "Package with base classes for Buildings.Media.ConstantPropertyLiquidWater"
        extends Modelica.Icons.BasesPackage;

        package ConstantPropertyLiquidWater
        "Water: Simple liquid water medium (incompressible, constant data)"

          import Cv = Modelica.SIunits.Conversions;
          extends Buildings.Media.Interfaces.PartialSimpleMedium(
            mediumName="SimpleLiquidWater",
            cp_const=4184,
            cv_const=4184,
            d_const=995.586,
            eta_const=1.e-3,
            lambda_const=0.598,
            a_const=1484,
            T_min=Cv.from_degC(-1),
            T_max=Cv.from_degC(130),
            T0=273.15,
            MM_const=0.018015268,
            fluidConstants=Modelica.Media.Water.simpleWaterConstants,
            ThermoStates=Modelica.Media.Interfaces.PartialMedium.Choices.IndependentVariables.T);

          annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}), graphics={Text(
                  extent={{-90,88},{90,18}},
                  lineColor={0,0,0},
                  textString="liquid"), Text(
                  extent={{-90,-22},{90,-90}},
                  lineColor={0,0,0},
                  textString="water")}),
                                    Diagram(coordinateSystem(preserveAspectRatio=false,
                  extent={{-100,-100},{100,100}}),
                                            graphics),
            Documentation(info="<html>

</html>"));
        end ConstantPropertyLiquidWater;
      annotation (preferedView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Media.ConstantPropertyLiquidWater\">Buildings.Media.ConstantPropertyLiquidWater</a>.
</p>
</html>"));
      end BaseClasses;
      annotation (preferedView="info", Documentation(info="<html>
<p>
This medium model is identical to 
<a href=\"modelica://Buildings.Media.ConstantPropertyLiquidWater\">
Buildings.Media.ConstantPropertyLiquidWater</a>, except for the following
points:
<ul>
<li>
It allows computing a compressibility of the medium.
This helps breaking algebraic loops, but the system gets stiff.
The compressibility is defined by the constant <code>kappa_const</code>.
If <code>kappa_const=0</code>, then the density is constant. Otherwise,
the density is
<p align=\"center\" style=\"font-style:italic;\">
  &rho;(p) = &rho;(p0)  ( 1 + &kappa;<sub>const</sub>  (p-p<sub>0</sub>))
</i>
This equation is implemented in the base class
<a href=\"modelica://Buildings.Media.Interfaces.PartialSimpleMedium\">
Buildings.Media.Interfaces.PartialSimpleMedium</a>.
</li>
<li>
It implements the function that computes the specific internal energy.
</li>
</p>
</html>",     revisions="<html>
<ul>
<li>
October 2, by Michael Wetter:<br>
Changed base class to 
<a href=\"modelica://Buildings.Media.Interfaces.PartialSimpleMedium\">
Buildings.Media.Interfaces.PartialSimpleMedium</a> to allow compressibility
to break algebraic equation systems (at the expense of stiffness).
</li>
<li>
September 4, 2008, by Michael Wetter:<br>
Added implementation for partial function <code>specificInternalEnergy</code>.
</li>
<li>
March 19, 2008, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
    end ConstantPropertyLiquidWater;

    package GasesPTDecoupled
    "Package with models for gases where pressure and temperature are independent of each other"
      extends Modelica.Icons.MaterialPropertiesPackage;

      package MoistAirUnsaturated
      "Package with moist air model that decouples pressure and temperature and that has no liquid water"
        extends Modelica.Media.Interfaces.PartialCondensingGases(
           final singleState = false,
           mediumName="MoistAirPTDecoupledUnsaturated",
           substanceNames={"water", "air"},
           final reducedX=true,
           reference_X={0.01,0.99},
           fluidConstants = {Modelica.Media.IdealGases.Common.FluidData.H2O,
                             Modelica.Media.IdealGases.Common.FluidData.N2});

        constant Integer Water=1
        "Index of water (in substanceNames, massFractions X, etc.)";
        constant Integer Air=2
        "Index of air (in substanceNames, massFractions X, etc.)";
        constant Real k_mair =  steam.MM/dryair.MM "ratio of molar weights";
        constant Buildings.Media.PerfectGases.Common.DataRecord dryair=
              Buildings.Media.PerfectGases.Common.SingleGasData.Air;
        constant Buildings.Media.PerfectGases.Common.DataRecord steam=
              Buildings.Media.PerfectGases.Common.SingleGasData.H2O;
        import SI = Modelica.SIunits;

        constant AbsolutePressure pStp = 101325
        "Pressure for which dStp is defined";
        constant Density dStp = 1.2 "Fluid density at pressure pStp";

        redeclare replaceable model extends BaseProperties(
          T(stateSelect=if preferredMediumStates then StateSelect.prefer else StateSelect.default),
          p(stateSelect=if preferredMediumStates then StateSelect.prefer else StateSelect.default),
          Xi(stateSelect=if preferredMediumStates then StateSelect.prefer else StateSelect.default))

          /* p, T, X = X[Water] are used as preferred states, since only then all
     other quantities can be computed in a recursive sequence. 
     If other variables are selected as states, static state selection
     is no longer possible and non-linear algebraic equations occur.
      */
          MassFraction x_water "Mass of total water/mass of dry air";
          Real phi "Relative humidity";

      protected
          constant SI.MolarMass[2] MMX = {steam.MM,dryair.MM}
          "Molar masses of components";

          //    MassFraction X_liquid "Mass fraction of liquid water";
          MassFraction X_steam "Mass fraction of steam water";
          MassFraction X_air "Mass fraction of air";
          MassFraction X_sat
          "Steam water mass fraction of saturation boundary in kg_water/kg_moistair";
          MassFraction x_sat
          "Steam water mass content of saturation boundary in kg_water/kg_dryair";
          AbsolutePressure p_steam_sat "Partial saturation pressure of steam";

        equation
          assert(T >= 200.0 and T <= 423.15, "
Temperature T is not in the allowed range
200.0 K <= (T ="     + String(T) + " K) <= 423.15 K
required from medium model \""           + mediumName + "\".");

        /*
    assert(Xi[Water] <= X_sat, "The medium model '" + mediumName + "' must not be saturated.\n"
     + "To model a saturated medium, use 'Buildings.Media.GasesPTDecoupled.MoistAir' instead of this medium.\n"
     + " T         = " + String(T) + "\n"
     + " X_sat     = " + String(X_sat) + "\n"
     + " Xi[Water] = " + String(Xi[Water]) + "\n"
     + " phi       = " + String(phi) + "\n"
     + " p         = " + String(p));
  */

          MM = 1/(Xi[Water]/MMX[Water]+(1.0-Xi[Water])/MMX[Air]);

          p_steam_sat = min(saturationPressure(T),0.999*p);
          X_sat = min(p_steam_sat * k_mair/max(100*Modelica.Constants.eps, p - p_steam_sat)*(1 - Xi[Water]), 1.0)
          "Water content at saturation with respect to actual water content";
          //    X_liquid = max(Xi[Water] - X_sat, 0.0);
          //    X_steam  = Xi[Water]-X_liquid;

          X_steam  = Xi[Water]; // There is no liquid in this medium model
          X_air    = 1-Xi[Water];

          h = specificEnthalpy_pTX(p,T,Xi);
          R = dryair.R*(1 - Xi[Water]) + steam.R*Xi[Water];

          // Equation for ideal gas, from h=u+p*v and R*T=p*v, from which follows that  u = h-R*T.
          // u = h-R*T;

          // However, in this medium, the gas law is d/dStp=p/pStp, from which follows using h=u+pv that
          // u= h-p*v = h-p/d = h-pStp/dStp
          u = h-pStp/dStp;

          //    d = p/(R*T);
          d/dStp = p/pStp;

          /* Note, u and d are computed under the assumption that the volume of the liquid
         water is neglible with respect to the volume of air and of steam
      */
          state.p = p;
          state.T = T;
          state.X = X;

          // this x_steam is water load / dry air!!!!!!!!!!!
          x_sat    = k_mair*p_steam_sat/max(100*Modelica.Constants.eps,p - p_steam_sat);
          x_water = Xi[Water]/max(X_air,100*Modelica.Constants.eps);
          phi = p/p_steam_sat*Xi[Water]/(Xi[Water] + k_mair*X_air);
        end BaseProperties;

        function Xsaturation =
          Buildings.Media.PerfectGases.MoistAir.Xsaturation
        "Steam water mass fraction of saturation boundary in kg_water/kg_moistair";

        redeclare function setState_pTX
        "Thermodynamic state as function of p, T and composition X"
            extends Buildings.Media.PerfectGases.MoistAir.setState_pTX;
        end setState_pTX;

        redeclare function setState_phX
        "Thermodynamic state as function of p, h and composition X"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        input MassFraction X[:] "Mass fractions";
        output ThermodynamicState state;
        algorithm
        state := if size(X,1) == nX then
               ThermodynamicState(p=p,T=T_phX(p,h,X),X=X) else
              ThermodynamicState(p=p,T=T_phX(p,h,cat(1,X,{1-sum(X)})), X=cat(1,X,{1-sum(X)}));
          //    ThermodynamicState(p=p,T=T_phX(p,h,X), X=cat(1,X,{1-sum(X)}));
          annotation (Documentation(info="<html>
Function to set the state for given pressure, enthalpy and species concentration.
This function needed to be reimplemented in order for the medium model to use
the implementation of <code>T_phX</code> provided by this package as opposed to the 
implementation provided by its parent package.
</html>"));
        end setState_phX;

        redeclare function setState_dTX
        "Thermodynamic state as function of d, T and composition X"
           extends Buildings.Media.PerfectGases.MoistAir.setState_dTX;
        end setState_dTX;

        redeclare function gasConstant
        "Gas constant (computation neglects liquid fraction)"
           extends Buildings.Media.PerfectGases.MoistAir.gasConstant;
        end gasConstant;

      function saturationPressureLiquid
        "Return saturation pressure of water as a function of temperature T in the range of 273.16 to 373.16 K"

        extends Modelica.Icons.Function;
        input SI.Temperature Tsat "saturation temperature";
        output SI.AbsolutePressure psat "saturation pressure";
      algorithm
        psat := 611.657*Modelica.Math.exp(17.2799 - 4102.99/(Tsat - 35.719));
        annotation(Inline=false,smoothOrder=5,derivative=Buildings.Media.GasesPTDecoupled.MoistAirUnsaturated.saturationPressureLiquid_der,
          Documentation(info="<html>
Saturation pressure of water above the triple point temperature is computed from temperature. It's range of validity is between
273.16 and 373.16 K. Outside these limits a less accurate result is returned.
</html>"));
      end saturationPressureLiquid;

      function saturationPressureLiquid_der
        "Time derivative of saturationPressureLiquid"

        extends Modelica.Icons.Function;
        input SI.Temperature Tsat "Saturation temperature";
        input Real dTsat(unit="K/s") "Saturation temperature derivative";
        output Real psat_der(unit="Pa/s") "Saturation pressure";
      algorithm
        psat_der:=611.657*Modelica.Math.exp(17.2799 - 4102.99/(Tsat - 35.719))*4102.99*dTsat/(Tsat - 35.719)/(Tsat - 35.719);

        annotation(Inline=false,smoothOrder=5,
          Documentation(info="<html>
Derivative function of <a href=Modelica:Modelica.Media.Air.MoistAir.saturationPressureLiquid>saturationPressureLiquid</a>
</html>"));
      end saturationPressureLiquid_der;

        function sublimationPressureIce =
            Buildings.Media.PerfectGases.MoistAir.sublimationPressureIce
        "Saturation curve valid for 223.16 <= T <= 273.16. Outside of these limits a (less accurate) result is returned";

      redeclare function extends saturationPressure
        "Saturation curve valid for 223.16 <= T <= 373.16 (and slightly outside with less accuracy)"

      algorithm
        psat := Buildings.Utilities.Math.Functions.spliceFunction(
                                                        saturationPressureLiquid(Tsat),sublimationPressureIce(Tsat),Tsat-273.16,1.0);
        annotation(Inline=false,smoothOrder=5);
      end saturationPressure;

       redeclare function pressure "Gas pressure"
          extends Buildings.Media.PerfectGases.MoistAir.pressure;
       end pressure;

       redeclare function temperature "Gas temperature"
          extends Buildings.Media.PerfectGases.MoistAir.temperature;
       end temperature;

       redeclare function density "Gas density"
         extends Modelica.Icons.Function;
         input ThermodynamicState state;
         output Density d "Density";
       algorithm
        d :=state.p*dStp/pStp;
       end density;

       redeclare function specificEntropy
        "Specific entropy (liquid part neglected, mixing entropy included)"
          extends Buildings.Media.PerfectGases.MoistAir.specificEntropy;
       end specificEntropy;

       redeclare function extends enthalpyOfVaporization
        "Enthalpy of vaporization of water"
       algorithm
        r0 := 2501014.5;
       end enthalpyOfVaporization;

        function HeatCapacityOfWater
        "Specific heat capacity of water (liquid only) which is constant"
          extends Modelica.Icons.Function;
          input Temperature T;
          output SpecificHeatCapacity cp_fl;
        algorithm
          cp_fl := 4186;
        end HeatCapacityOfWater;

      redeclare replaceable function extends enthalpyOfLiquid
        "Enthalpy of liquid (per unit mass of liquid) which is linear in the temperature"

      algorithm
        h := (T - 273.15)*4186;
        annotation(smoothOrder=5, derivative=der_enthalpyOfLiquid);
      end enthalpyOfLiquid;

      replaceable function der_enthalpyOfLiquid
        "Temperature derivative of enthalpy of liquid per unit mass of liquid"
        extends Modelica.Icons.Function;
        input Temperature T "temperature";
        input Real der_T "temperature derivative";
        output Real der_h "derivative of liquid enthalpy";
      algorithm
        der_h := 4186*der_T;
      end der_enthalpyOfLiquid;

      redeclare function enthalpyOfCondensingGas
        "Enthalpy of steam per unit mass of steam"
        extends Modelica.Icons.Function;

        input Temperature T "temperature";
        output SpecificEnthalpy h "steam enthalpy";
      algorithm
        h := (T-273.15) * steam.cp + Buildings.Media.GasesPTDecoupled.MoistAirUnsaturated.enthalpyOfVaporization(T);
        annotation(smoothOrder=5, derivative=der_enthalpyOfCondensingGas);
      end enthalpyOfCondensingGas;

      replaceable function der_enthalpyOfCondensingGas
        "Derivative of enthalpy of steam per unit mass of steam"
        extends Modelica.Icons.Function;
        input Temperature T "temperature";
        input Real der_T(unit="K/s") "temperature derivative";
        output Real der_h(unit="J/(kg.s)") "derivative of steam enthalpy";
      algorithm
        der_h := steam.cp*der_T;
      end der_enthalpyOfCondensingGas;

      redeclare replaceable function extends enthalpyOfGas
        "Enthalpy of gas mixture per unit mass of gas mixture"
      algorithm
        h := Buildings.Media.GasesPTDecoupled.MoistAirUnsaturated.enthalpyOfCondensingGas(T)*X[Water]
             + Buildings.Media.GasesPTDecoupled.MoistAirUnsaturated.enthalpyOfDryAir(T)*(1.0-X[Water]);
      end enthalpyOfGas;

      replaceable function enthalpyOfDryAir
        "Enthalpy of dry air per unit mass of dry air"
        extends Modelica.Icons.Function;

        input Temperature T "temperature";
        output SpecificEnthalpy h "dry air enthalpy";
      algorithm
        h := (T - 273.15)*dryair.cp;
        annotation(smoothOrder=5, derivative=der_enthalpyOfDryAir);
      end enthalpyOfDryAir;

      replaceable function der_enthalpyOfDryAir
        "Derivative of enthalpy of dry air per unit mass of dry air"
        extends Modelica.Icons.Function;
        input Temperature T "temperature";
        input Real der_T(unit="K/s") "temperature derivative";
        output Real der_h(unit="J/(kg.s)") "derivative of dry air enthalpy";
      algorithm
        der_h := dryair.cp*der_T;
      end der_enthalpyOfDryAir;

      redeclare replaceable function extends specificHeatCapacityCp
        "Specific heat capacity of gas mixture at constant pressure"
      algorithm
        cp := dryair.cp*(1-state.X[Water]) +steam.cp*state.X[Water];
          annotation(derivative=der_specificHeatCapacityCp);
      end specificHeatCapacityCp;

      replaceable function der_specificHeatCapacityCp
        "Derivative of specific heat capacity of gas mixture at constant pressure"
          input ThermodynamicState state;
          input ThermodynamicState der_state;
          output Real der_cp(unit="J/(kg.K.s)");
      algorithm
        der_cp := (steam.cp-dryair.cp)*der_state.X[Water];
      end der_specificHeatCapacityCp;

      redeclare replaceable function extends specificHeatCapacityCv
        "Specific heat capacity of gas mixture at constant volume"
      algorithm
        cv:= dryair.cv*(1-state.X[Water]) +steam.cv*state.X[Water];
          annotation(derivative=der_specificHeatCapacityCv);
      end specificHeatCapacityCv;

      replaceable function der_specificHeatCapacityCv
        "Derivative of specific heat capacity of gas mixture at constant volume"
          input ThermodynamicState state;
          input ThermodynamicState der_state;
          output Real der_cv(unit="J/(kg.K.s)");
      algorithm
        der_cv := (steam.cv-dryair.cv)*der_state.X[Water];
      end der_specificHeatCapacityCv;

      redeclare function extends dynamicViscosity
        "dynamic viscosity of dry air"
      algorithm
        eta := 1.85E-5;
      end dynamicViscosity;

      redeclare function extends thermalConductivity
        "Thermal conductivity of dry air as a polynomial in the temperature"
        import Modelica.Media.Incompressible.TableBased.Polynomials_Temp;
      algorithm
        lambda := Polynomials_Temp.evaluate({(-4.8737307422969E-008), 7.67803133753502E-005, 0.0241814385504202},
         Modelica.SIunits.Conversions.to_degC(state.T));
      end thermalConductivity;

      redeclare function extends specificEnthalpy "Specific enthalpy"
      algorithm
        h := Buildings.Media.GasesPTDecoupled.MoistAirUnsaturated.h_pTX(state.p, state.T, state.X);
      end specificEnthalpy;

      redeclare function extends specificInternalEnergy
        "Specific internal energy"
        extends Modelica.Icons.Function;
      algorithm
        u := Buildings.Media.GasesPTDecoupled.MoistAirUnsaturated.h_pTX(state.p,state.T,state.X) - pStp/dStp;
      end specificInternalEnergy;

      redeclare function extends specificGibbsEnergy "Specific Gibbs energy"
        extends Modelica.Icons.Function;
      algorithm
        g := Buildings.Media.GasesPTDecoupled.MoistAirUnsaturated.h_pTX(state.p,state.T,state.X) - state.T*specificEntropy(state);
      end specificGibbsEnergy;

      redeclare function extends specificHelmholtzEnergy
        "Specific Helmholtz energy"
        extends Modelica.Icons.Function;
      algorithm
        f := Buildings.Media.GasesPTDecoupled.MoistAirUnsaturated.h_pTX(state.p,state.T,state.X)
               - gasConstant(state)*state.T
               - state.T*Buildings.Media.GasesPTDecoupled.MoistAirUnsaturated.specificEntropy(state);
      end specificHelmholtzEnergy;

      ////////////////////////////////////////////////////////////////////////////
      function h_pTX
        "Compute specific enthalpy from pressure, temperature and mass fraction"
        extends Modelica.Icons.Function;

        input SI.Pressure p "Pressure";
        input SI.Temperature T "Temperature";
        input SI.MassFraction X[nX] "Mass fractions of moist air";
        output SI.SpecificEnthalpy h "Specific enthalpy at p, T, X";
      protected
        SI.AbsolutePressure p_steam_sat "Partial saturation pressure of steam";
        SI.MassFraction x_sat
          "steam water mass fraction of saturation boundary";
        SI.SpecificEnthalpy hDryAir "Enthalpy of dry air";
      algorithm
        p_steam_sat :=saturationPressure(T);
        x_sat    :=k_mair*p_steam_sat/(p - p_steam_sat);
      /*
  assert(X[Water]-0.001 < x_sat/(1 + x_sat), "The medium model '" + mediumName + "' must not be saturated.\n"
     + "To model a saturated medium, use 'Buildings.Media.GasesPTDecoupled.MoistAir' instead of this medium.\n"
     + " T         = " + String(T) + "\n"
     + " x_sat     = " + String(x_sat) + "\n"
     + " X[Water] = "  + String(X[Water]) + "\n"
     + " phi       = " + String(X[Water]/((x_sat)/(1+x_sat))) + "\n"
     + " p         = " + String(p));
     */
        h := (T - 273.15)*dryair.cp * (1 - X[Water]) + ((T-273.15) * steam.cp + 2501014.5) * X[Water];
        annotation(smoothOrder=5);
      end h_pTX;

      function T_phX
        "Compute temperature from specific enthalpy and mass fraction"
        extends Modelica.Icons.Function;

        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "specific enthalpy";
        input MassFraction[:] X "mass fractions of composition";
        output Temperature T "temperature";
      protected
        SI.AbsolutePressure p_steam_sat "Partial saturation pressure of steam";
        SI.MassFraction x_sat
          "steam water mass fraction of saturation boundary";
      algorithm
        T := 273.15 + (h-2501014.5 * X[Water])/(dryair.cp * (1 - X[Water])+steam.cp*X[Water]);
        // Check for saturation
        p_steam_sat :=saturationPressure(T);
        x_sat    :=k_mair*p_steam_sat/(p - p_steam_sat);
      /*  
  assert(X[Water]-0.001 < x_sat/(1 + x_sat), "The medium model '" + mediumName + "' must not be saturated.\n"
     + "To model a saturated medium, use 'Buildings.Media.GasesPTDecoupled.MoistAir' instead of this medium.\n"
     + " T         = " + String(T) + "\n"
     + " x_sat     = " + String(x_sat) + "\n"
     + " X[Water] = " + String(X[Water]) + "\n"
     + " phi       = " + String(X[Water]/((x_sat)/(1+x_sat))) + "\n"
     + " p         = " + String(p));
*/
        annotation(smoothOrder=5);
      end T_phX;

      redeclare function enthalpyOfNonCondensingGas
        "Enthalpy of non-condensing gas per unit mass"
        extends Modelica.Icons.Function;

        input Temperature T "temperature";
        output SpecificEnthalpy h "enthalpy";
      algorithm
        h := enthalpyOfDryAir(T);
        annotation(smoothOrder=5, derivative=der_enthalpyOfNonCondensingGas);
      end enthalpyOfNonCondensingGas;

      replaceable function der_enthalpyOfNonCondensingGas
        "Derivative of enthalpy of non-condensing gas per unit mass"
        extends Modelica.Icons.Function;
        input Temperature T "temperature";
        input Real der_T "temperature derivative";
        output Real der_h "derivative of steam enthalpy";
      algorithm
        der_h := der_enthalpyOfDryAir(T, der_T);
      end der_enthalpyOfNonCondensingGas;
        annotation (preferedView="info", Documentation(info="<html>
<p>
This is a medium model that is identical to 
<a href=\"modelica://Buildings.Media.GasesPTDecoupled.MoistAir\">
Buildings.Media.GasesPTDecoupled.MoistAir</a>,  but 
in this model, the air must not be saturated. If the air is saturated, 
use the medium model
<a href=\"modelica://Buildings.Media.GasesPTDecoupled.MoistAir\">
Buildings.Media.GasesPTDecoupled.MoistAir</a> instead of this one.
</p>
<p>
This medium model has been added to allow an explicit computation of
the function 
<code>T_phX</code> so that it is once differentiable in <code>h</code>
with a continuous derivative. This allows obtaining an analytic
expression for the Jacobian, and therefore simplifies the computation
of initial conditions that can be numerically challenging for 
thermo-fluid systems.
</p>
<p>
This new formulation often leads to smaller systems of nonlinear equations 
because it allows to invert the function <code>T_phX</code> analytically.
</p>
</html>",       revisions="<html>
<ul>
<li>
August 3, 2011, by Michael Wetter:<br>
Fixed bug in <code>u=h-R*T</code>, which is only valid for ideal gases. 
For this medium, the function is <code>u=h-pStd/dStp</code>.
</li>
<li>
January 27, 2010, by Michael Wetter:<br>
Fixed bug in <code>else</code> branch of function <code>setState_phX</code>
that lead to a run-time error when the constructor of this function was called.
</li>
<li>
January 22, 2010, by Michael Wetter:<br>
Added implementation of function
<a href=\"modelica://Buildings.Media.GasesPTDecoupled.MoistAirUnsaturated.enthalpyOfNonCondensingGas\">
enthalpyOfNonCondensingGas</a> and its derivative.
<li>
January 13, 2010, by Michael Wetter:<br>
Fixed implementation of derivative functions.
</li>
<li>
August 28, 2008, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
      end MoistAirUnsaturated;
    annotation (preferedView="info", Documentation(info="<html>
<p>
Medium models in this package use the gas law
<i>d/d<sub>stp</sub> = p/p<sub>stp</sub></i> where 
<i>p<sub>std</sub></i> and <i>d<sub>stp</sub></i> are constants for a reference
temperature and density instead of the ideal gas law
<i>&rho; = p &frasl;(R T)</i>.
</p>
<p>
This new formulation often leads to smaller systems of nonlinear equations 
because pressure and temperature are decoupled, at the expense of accuracy.
</p>
<p>
Note that models in this package implement the equation for the internal energy as
<p align=\"center\" style=\"font-style:italic;\">
  u = h - p<sub>stp</sub> &frasl; &rho;<sub>stp</sub>,
</p>
where 
<i>u</i> is the internal energy per unit mass,
<i>h</i> is the enthalpy per unit mass,
<i>p<sub>stp</sub></i> is the static pressure and
<i>&rho;<sub>stp</sub></i> is the mass density at standard pressure and temperature.
The reason for this implementation is that in general,
<p align=\"center\" style=\"font-style:italic;\">
  h = u + p v,
</p>
from which follows that
<p align=\"center\" style=\"font-style:italic;\">
  u = h - p v = h - p &frasl; &rho; = h - p<sub>stp</sub> &frasl; &rho;<sub>std</sub>,
</p>
because <i>p &frasl; &rho; = p<sub>stp</sub> &frasl; &rho;<sub>stp</sub></i> in this medium model.
</p>
</html>",     revisions="<html>
<ul>
<li>
March 19, 2008, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
    end GasesPTDecoupled;

    package PerfectGases "Package with models for perfect gases"
      extends Modelica.Icons.MaterialPropertiesPackage;

      package MoistAir
        extends Modelica.Media.Interfaces.PartialCondensingGases(
           mediumName="Moist air perfect gas",
           substanceNames={"water", "air"},
           final reducedX=true,
           final singleState=false,
           reference_X={0.01,0.99},
           fluidConstants = {Modelica.Media.IdealGases.Common.FluidData.H2O,
                             Modelica.Media.IdealGases.Common.FluidData.N2});

        constant Integer Water=1
        "Index of water (in substanceNames, massFractions X, etc.)";

        constant Integer Air=2
        "Index of air (in substanceNames, massFractions X, etc.)";

        constant Real k_mair =  steam.MM/dryair.MM "Ratio of molar weights";

        constant Buildings.Media.PerfectGases.Common.DataRecord dryair=
              Buildings.Media.PerfectGases.Common.SingleGasData.Air;

        constant Buildings.Media.PerfectGases.Common.DataRecord steam=
              Buildings.Media.PerfectGases.Common.SingleGasData.H2O;
        import SI = Modelica.SIunits;

          constant Modelica.SIunits.Temperature TMin = 200
        "Minimum temperature";

          constant Modelica.SIunits.Temperature TMax = 400
        "Maximum temperature";

        redeclare replaceable model extends BaseProperties(
          T(stateSelect=if preferredMediumStates then StateSelect.prefer else StateSelect.default),
          p(stateSelect=if preferredMediumStates then StateSelect.prefer else StateSelect.default),
          Xi(stateSelect=if preferredMediumStates then StateSelect.prefer else StateSelect.default))

          /* p, T, X = X[Water] are used as preferred states, since only then all
     other quantities can be computed in a recursive sequence. 
     If other variables are selected as states, static state selection
     is no longer possible and non-linear algebraic equations occur.
      */
          MassFraction x_water "Mass of total water/mass of dry air";
          Real phi "Relative humidity";

      protected
          constant SI.MolarMass[2] MMX = {steam.MM,dryair.MM}
          "Molar masses of components";

          MassFraction X_liquid "Mass fraction of liquid water";
          MassFraction X_steam "Mass fraction of steam water";
          MassFraction X_air "Mass fraction of air";
          MassFraction X_sat
          "Steam water mass fraction of saturation boundary in kg_water/kg_moistair";
          MassFraction x_sat
          "Steam water mass content of saturation boundary in kg_water/kg_dryair";
          AbsolutePressure p_steam_sat "Partial saturation pressure of steam";

        equation
          assert(T >= TMin and T <= TMax, "
Temperature T is not in the allowed range "       + String(TMin) + " <= (T ="
                     + String(T) + " K) <= " + String(TMax) + " K
required from medium model \""           + mediumName + "\".");
          MM = 1/(Xi[Water]/MMX[Water]+(1.0-Xi[Water])/MMX[Air]);

          p_steam_sat = min(saturationPressure(T),0.999*p);
          X_sat = min(p_steam_sat * k_mair/max(100*Modelica.Constants.eps, p - p_steam_sat)*(1 - Xi[Water]), 1.0)
          "Water content at saturation with respect to actual water content";
          X_liquid = max(Xi[Water] - X_sat, 0.0);
          X_steam  = Xi[Water]-X_liquid;
          X_air    = 1-Xi[Water];

          h = specificEnthalpy_pTX(p,T,Xi);
          R = dryair.R*(1 - X_steam/(1 - X_liquid)) + steam.R*X_steam/(1 - X_liquid);
          //
          u = h - R*T;
          d = p/(R*T);
          /* Note, u and d are computed under the assumption that the volume of the liquid
         water is neglible with respect to the volume of air and of steam
      */
          state.p = p;
          state.T = T;
          state.X = X;

          // this x_steam is water load / dry air!!!!!!!!!!!
          x_sat    = k_mair*p_steam_sat/max(100*Modelica.Constants.eps,p - p_steam_sat);
          x_water = Xi[Water]/max(X_air,100*Modelica.Constants.eps);
          phi = p/p_steam_sat*Xi[Water]/(Xi[Water] + k_mair*X_air);
        end BaseProperties;

        function Xsaturation = Modelica.Media.Air.MoistAir.Xsaturation
        "Steam water mass fraction of saturation boundary in kg_water/kg_moistair";

        redeclare function setState_pTX
        "Thermodynamic state as function of p, T and composition X"
            extends Modelica.Media.Air.MoistAir.setState_pTX;
        end setState_pTX;

        redeclare function setState_phX
        "Thermodynamic state as function of p, h and composition X"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        input MassFraction X[:] "Mass fractions";
        output ThermodynamicState state;
        algorithm
        state := if size(X,1) == nX then
              ThermodynamicState(p=p,T=T_phX(p,h,X),X=X) else
              ThermodynamicState(p=p,T=T_phX(p,h,X), X=cat(1,X,{1-sum(X)}));
          annotation (Documentation(info="<html>
Function to set the state for given pressure, enthalpy and species concentration.
This function needed to be reimplemented in order for the medium model to use
the implementation of <code>T_phX</code> provided by this package as opposed to the 
implementation provided by its parent package.
</html>"));
        end setState_phX;

        redeclare function setState_dTX
        "Thermodynamic state as function of d, T and composition X"
           extends Modelica.Media.Air.MoistAir.setState_dTX;
        end setState_dTX;

        redeclare function gasConstant
        "Gas constant (computation neglects liquid fraction)"
           extends Modelica.Media.Air.MoistAir.gasConstant;
        end gasConstant;

      function saturationPressureLiquid
        "Return saturation pressure of water as a function of temperature T in the range of 273.16 to 373.16 K"

        extends Modelica.Icons.Function;
        input SI.Temperature Tsat "saturation temperature";
        output SI.AbsolutePressure psat "saturation pressure";
      algorithm
        psat := 611.657*Modelica.Math.exp(17.2799 - 4102.99/(Tsat - 35.719));
        annotation(Inline=false,smoothOrder=5,derivative=saturationPressureLiquid_der,
          Documentation(info="<html>
Saturation pressure of water above the triple point temperature is computed from temperature. It's range of validity is between
273.16 and 373.16 K. Outside these limits a less accurate result is returned.
</html>"));
      end saturationPressureLiquid;

      function saturationPressureLiquid_der
        "Time derivative of saturationPressureLiquid"

        extends Modelica.Icons.Function;
        input SI.Temperature Tsat "Saturation temperature";
        input Real dTsat(unit="K/s") "Saturation temperature derivative";
        output Real psat_der(unit="Pa/s") "Saturation pressure";
      algorithm
        psat_der:=611.657*Modelica.Math.exp(17.2799 - 4102.99/(Tsat - 35.719))*4102.99*dTsat/(Tsat - 35.719)/(Tsat - 35.719);

        annotation(Inline=false,smoothOrder=5,
          Documentation(info="<html>
Derivative function of <a href=Modelica:Modelica.Media.Air.MoistAir.saturationPressureLiquid>saturationPressureLiquid</a>
</html>"));
      end saturationPressureLiquid_der;

        function sublimationPressureIce =
            Modelica.Media.Air.MoistAir.sublimationPressureIce
        "Saturation curve valid for 223.16 <= T <= 273.16. Outside of these limits a (less accurate) result is returned"
          annotation(Inline=false,smoothOrder=5,derivative=Modelica.Media.Air.MoistAir.sublimationPressureIce_der);

      redeclare function extends saturationPressure
        "Saturation curve valid for 223.16 <= T <= 373.16 (and slightly outside with less accuracy)"

      algorithm
        psat := Buildings.Utilities.Math.Functions.spliceFunction(
                                                        saturationPressureLiquid(Tsat),sublimationPressureIce(Tsat),Tsat-273.16,1.0);
        annotation(Inline=false,smoothOrder=5);
      end saturationPressure;

       redeclare function pressure "Gas pressure"
          extends Modelica.Media.Air.MoistAir.pressure;
       end pressure;

       redeclare function temperature "Gas temperature"
          extends Modelica.Media.Air.MoistAir.temperature;
       end temperature;

       redeclare function density "Gas density"
          extends Modelica.Media.Air.MoistAir.density;
       end density;

       redeclare function specificEntropy
        "Specific entropy (liquid part neglected, mixing entropy included)"
          extends Modelica.Media.Air.MoistAir.specificEntropy;
       end specificEntropy;

       redeclare function extends enthalpyOfVaporization
        "Enthalpy of vaporization of water"
       algorithm
        r0 := 2501014.5;
       end enthalpyOfVaporization;

      redeclare replaceable function extends enthalpyOfLiquid
        "Enthalpy of liquid (per unit mass of liquid) which is linear in the temperature"

      algorithm
        h := (T - 273.15)*4186;
        annotation(smoothOrder=5, derivative=der_enthalpyOfLiquid);
      end enthalpyOfLiquid;

      replaceable function der_enthalpyOfLiquid
        "Temperature derivative of enthalpy of liquid per unit mass of liquid"
        extends Modelica.Icons.Function;
        input Temperature T "temperature";
        input Real der_T "temperature derivative";
        output Real der_h "derivative of liquid enthalpy";
      algorithm
        der_h := 4186*der_T;
      end der_enthalpyOfLiquid;

      redeclare function enthalpyOfCondensingGas
        "Enthalpy of steam per unit mass of steam"
        extends Modelica.Icons.Function;

        input Temperature T "temperature";
        output SpecificEnthalpy h "steam enthalpy";
      algorithm
        h := (T-273.15) * steam.cp + enthalpyOfVaporization(T);
        annotation(smoothOrder=5, derivative=der_enthalpyOfCondensingGas);
      end enthalpyOfCondensingGas;

      replaceable function der_enthalpyOfCondensingGas
        "Derivative of enthalpy of steam per unit mass of steam"
        extends Modelica.Icons.Function;
        input Temperature T "temperature";
        input Real der_T "temperature derivative";
        output Real der_h "derivative of steam enthalpy";
      algorithm
        der_h := steam.cp*der_T;
      end der_enthalpyOfCondensingGas;

      redeclare function enthalpyOfNonCondensingGas
        "Enthalpy of non-condensing gas per unit mass of steam"
        extends Modelica.Icons.Function;

        input Temperature T "temperature";
        output SpecificEnthalpy h "enthalpy";
      algorithm
        h := enthalpyOfDryAir(T);
        annotation(smoothOrder=5, derivative=der_enthalpyOfNonCondensingGas);
      end enthalpyOfNonCondensingGas;

      replaceable function der_enthalpyOfNonCondensingGas
        "Derivative of enthalpy of non-condensing gas per unit mass of steam"
        extends Modelica.Icons.Function;
        input Temperature T "temperature";
        input Real der_T "temperature derivative";
        output Real der_h "derivative of steam enthalpy";
      algorithm
        der_h := der_enthalpyOfDryAir(T, der_T);
      end der_enthalpyOfNonCondensingGas;

      redeclare replaceable function extends enthalpyOfGas
        "Enthalpy of gas mixture per unit mass of gas mixture"
      algorithm
        h := enthalpyOfCondensingGas(T)*X[Water]
             + enthalpyOfDryAir(T)*(1.0-X[Water]);
      end enthalpyOfGas;

      replaceable function enthalpyOfDryAir
        "Enthalpy of dry air per unit mass of dry air"
        extends Modelica.Icons.Function;

        input Temperature T "temperature";
        output SpecificEnthalpy h "dry air enthalpy";
      algorithm
        h := (T - 273.15)*dryair.cp;
        annotation(smoothOrder=5, derivative=der_enthalpyOfDryAir);
      end enthalpyOfDryAir;

      replaceable function der_enthalpyOfDryAir
        "Derivative of enthalpy of dry air per unit mass of dry air"
        extends Modelica.Icons.Function;
        input Temperature T "temperature";
        input Real der_T "temperature derivative";
        output Real der_h "derivative of dry air enthalpy";
      algorithm
        der_h := dryair.cp*der_T;
      end der_enthalpyOfDryAir;

      redeclare replaceable function extends specificHeatCapacityCp
        "Specific heat capacity of gas mixture at constant pressure"
      algorithm
        cp := dryair.cp*(1-state.X[Water]) +steam.cp*state.X[Water];
        annotation(smoothOrder=5);
      end specificHeatCapacityCp;

      redeclare replaceable function extends specificHeatCapacityCv
        "Specific heat capacity of gas mixture at constant volume"
      algorithm
        cv:= dryair.cv*(1-state.X[Water]) +steam.cv*state.X[Water];
        annotation(smoothOrder=5);
      end specificHeatCapacityCv;

      redeclare function extends dynamicViscosity
        "dynamic viscosity of dry air"
      algorithm
        eta := 1.85E-5;
      end dynamicViscosity;

      redeclare function extends thermalConductivity
        "Thermal conductivity of dry air as a polynomial in the temperature"
      algorithm
        lambda := Modelica.Media.Incompressible.TableBased.Polynomials_Temp.evaluate(
                     {(-4.8737307422969E-008), 7.67803133753502E-005, 0.0241814385504202},
                     Modelica.SIunits.Conversions.to_degC(state.T));
      end thermalConductivity;

      function h_pTX
        "Compute specific enthalpy from pressure, temperature and mass fraction"
        extends Modelica.Icons.Function;
        input SI.Pressure p "Pressure";
        input SI.Temperature T "Temperature";
        input SI.MassFraction X[:] "Mass fractions of moist air";
        output SI.SpecificEnthalpy h "Specific enthalpy at p, T, X";

      protected
        SI.AbsolutePressure p_steam_sat "Partial saturation pressure of steam";
        SI.MassFraction x_sat
          "steam water mass fraction of saturation boundary";
        SI.MassFraction X_liquid "mass fraction of liquid water";
        SI.MassFraction X_steam "mass fraction of steam water";
        SI.MassFraction X_air "mass fraction of air";
        SI.SpecificEnthalpy hDryAir "Enthalpy of dry air";
      algorithm
        p_steam_sat :=saturationPressure(T);
        x_sat    :=k_mair*p_steam_sat/(p - p_steam_sat);
        X_liquid :=max(X[Water] - x_sat/(1 + x_sat), 0.0);
        X_steam  :=X[Water] - X_liquid;
        X_air    :=1 - X[Water];

      /* THIS DOES NOT WORK --------------------------    
  h := enthalpyOfDryAir(T) * X_air + 
       Modelica.Media.Air.MoistAir.enthalpyOfCondensingGas(T) * X_steam + enthalpyOfLiquid(T)*X_liquid;
--------------------------------- */

      /* THIS WORKS!!!! +++++++++++++++++++++
  h := (T - 273.15)*dryair.cp * X_air + 
       Modelica.Media.Air.MoistAir.enthalpyOfCondensingGas(T) * X_steam + enthalpyOfLiquid(T)*X_liquid;
 +++++++++++++++++++++*/

        hDryAir := (T - 273.15)*dryair.cp;
        h := hDryAir * X_air +
             ((T-273.15) * steam.cp + 2501014.5) * X_steam +
             (T - 273.15)*4186*X_liquid;
        annotation(Inline=false,smoothOrder=1);
      end h_pTX;

      redeclare function extends specificEnthalpy "Specific enthalpy"
      algorithm
        h := h_pTX(state.p, state.T, state.X);
      end specificEnthalpy;

      redeclare function extends specificInternalEnergy
        "Specific internal energy"
        extends Modelica.Icons.Function;
      algorithm
        u := h_pTX(state.p,state.T,state.X) - gasConstant(state)*state.T;
      end specificInternalEnergy;

      redeclare function extends specificGibbsEnergy "Specific Gibbs energy"
        extends Modelica.Icons.Function;
      algorithm
        g := h_pTX(state.p,state.T,state.X) - state.T*specificEntropy(state);
      end specificGibbsEnergy;

      redeclare function extends specificHelmholtzEnergy
        "Specific Helmholtz energy"
        extends Modelica.Icons.Function;
      algorithm
        f := h_pTX(state.p,state.T,state.X) - gasConstant(state)*state.T - state.T*specificEntropy(state);
      end specificHelmholtzEnergy;

      function T_phX
        "Compute temperature from specific enthalpy and mass fraction"
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        input MassFraction X[:] "Mass fractions of composition";
        output Temperature T "Temperature";

      protected
      package Internal
          "Solve h(data,T) for T with given h (use only indirectly via temperature_phX)"
        extends Modelica.Media.Common.OneNonLinearEquation;

        redeclare record extends f_nonlinear_Data
            "Data to be passed to non-linear function"
          extends Modelica.Media.IdealGases.Common.DataRecord;
        end f_nonlinear_Data;

        redeclare function extends f_nonlinear
        algorithm
            y := h_pTX(p,x,X);
        end f_nonlinear;

        // Dummy definition has to be added for current Dymola
        redeclare function extends solve
        end solve;
      end Internal;
      protected
      constant Modelica.Media.IdealGases.Common.DataRecord steam=
                    Modelica.Media.IdealGases.Common.SingleGasesData.H2O;
      protected
       SI.AbsolutePressure p_steam_sat "Partial saturation pressure of steam";
       SI.MassFraction x_sat "steam water mass fraction of saturation boundary";

      algorithm
        T := 273.15 + (h - 2501014.5 * X[Water])/((1 - X[Water])*dryair.cp + X[Water] *
           Buildings.Media.PerfectGases.Common.SingleGasData.H2O.cp);
        // check for saturation
        p_steam_sat :=saturationPressure(T);
        x_sat    :=k_mair*p_steam_sat/(p - p_steam_sat);
        // If the state is in the fog region, then the above equation is not valid, and
        // T is computed by inverting h_pTX(), which is much more costly.
        // For Buildings.Fluid.HeatExchangers.Examples.WetEffectivenessNTUPControl, the
        // computation above reduces the computing time by about a factor of 2.
        if (X[Water] > x_sat/(1 + x_sat)) then
           T := Internal.solve(h, TMin, TMax, p, X[1:nXi], steam);
        end if;
          annotation (Documentation(info="<html>
Temperature is computed from pressure, specific enthalpy and composition via numerical inversion of function <a href=Modelica:Modelica.Media.Air.MoistAir.h_pTX>h_pTX</a>.
</html>"));
      end T_phX;
        annotation (preferedView="info", Documentation(info="<html>
<p>
This is a medium model that is similar to 
<a href=\"Modelica:Modelica.Media.Air.MoistAir\">
Modelica.Media.Air.MoistAir</a> but it is a perfect gas, i.e., 
it has a constant specific heat capacity.
</p>
</html>",       revisions="<html>
<ul>
<li>
February 22, 2010, by Michael Wetter:<br>
Changed <code>T_phX</code> to first compute <code>T</code> 
in closed form assuming no saturation. Then, a check is done to determine
whether the state is in the fog region. If the state is in the fog region,
then <code>Internal.solve</code> is called. This new implementation
can lead to significantly shorter computing
time in models that frequently call <code>T_phX</code>.
</li>
<li>
January 27, 2010, by Michael Wetter:<br>
Fixed bug that lead to run-time error in <code>T_phX</code>.
</li>
<li>
January 13, 2010, by Michael Wetter:<br>
Added function <code>enthalpyOfNonCondensingGas</code> and its derivative.
</li>
<li>
January 13, 2010, by Michael Wetter:<br>
Fixed implementation of derivative functions.
</li>
<li>
October 12, 2009, by Michael Wetter:<br>
Added annotation for analytic derivative for functions
<code>saturationPressureLiquid</code> and <code>sublimationPressureIce</code>.
<li>
August 28, 2008, by Michael Wetter:<br>
Referenced <code>spliceFunction</code> from package 
<a href=\"modelica://Buildings.Utilities.Math\">Buildings.Utilities.Math</a>
to avoid duplicate code.
</li>
<li>
May 8, 2008, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
      end MoistAir;

      package Common "Package with common data for perfect gases"
        extends Modelica.Icons.MaterialPropertiesPackage;

        record DataRecord
        "Coefficient data record for properties of perfect gases"
          extends Modelica.Icons.Record;

          String name "Name of ideal gas";
          Modelica.SIunits.MolarMass MM "Molar mass";
          Modelica.SIunits.SpecificHeatCapacity R "Gas constant";
          Modelica.SIunits.SpecificHeatCapacity cp
          "Specific heat capacity at constant pressure";
          Modelica.SIunits.SpecificHeatCapacity cv = cp - R
          "Specific heat capacity at constant volume";
          annotation (
        defaultComponentName="gas",
        Documentation(preferedView="info", info="<html>
<p>
This data record contains the coefficients for perfect gases.
</p>
</html>"),         revisions=
                "<html>
<ul>
<li>
May 12, 2008 by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>");
        end DataRecord;

        package SingleGasData "Package with data records for single gases"
          extends Modelica.Icons.MaterialPropertiesPackage;

         constant PerfectGases.Common.DataRecord Air(
           name = Modelica.Media.IdealGases.Common.SingleGasesData.Air.name,
           R =    Modelica.Media.IdealGases.Common.SingleGasesData.Air.R,
           MM =   Modelica.Media.IdealGases.Common.SingleGasesData.Air.MM,
           cp =   1006);

        constant PerfectGases.Common.DataRecord H2O(
           name = Modelica.Media.IdealGases.Common.SingleGasesData.H2O.name,
           R =    Modelica.Media.IdealGases.Common.SingleGasesData.H2O.R,
           MM =   Modelica.Media.IdealGases.Common.SingleGasesData.H2O.MM,
           cp =   1860);
          annotation (Documentation(preferedView="info", info="<html>
<p>
This package contains the coefficients for perfect gases.
</p>
</html>"),         revisions="<html>
<ul>
<li>
May 12, 2008 by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>");
        end SingleGasData;
      annotation (preferedView="info", Documentation(info="<html>
<p>
This package contains records that are used to model perfect gases.
</p>
</html>"));
      end Common;
    annotation (preferedView="info", Documentation(info="<html>
<p>
This package contains models of <i>thermally perfect</i> gases.
</p>
<p>
A medium is called thermally perfect if
<ul>
<li>
it is in thermodynamic equilibrium,
</li><li>
it is chemically not reacting, and
</li><li>
internal energy and enthalpy are functions of temperature only.
</li>
</ul>
<p>
In addition, the gases in this package are <i>calorically perfect</i>, i.e., the
specific heat capacities at constant pressure <i>c<sub>p</sub></i>
and constant volume <i>c<sub>v</sub></i> are both constant (Bower 1998).
</p>
<p>
For dry and moist air media that also have a constant density, see
<a href=\"modelica://Buildings.Media.GasesConstantDensity\">
Buildings.Media.GasesConstantDensity</a>.
</p>
<h4>References</h4>
<p>
Bower, William B. <i>A primer in fluid mechanics: Dynamics of flows in one
space dimension</i>. CRC Press. 1998.
</p>
</html>"));
    end PerfectGases;

    package Interfaces "Package with partial medium models"
      extends Modelica.Icons.InterfacesPackage;

      partial package PartialSimpleMedium
      "Medium model with linear dependency of u, h from temperature. Most other quantities are constant."

        extends Modelica.Media.Interfaces.PartialPureSubstance(
              ThermoStates=Choices.IndependentVariables.pT,
              final singleState=constantDensity,
              reference_p=p0,
              p_default=p0);

        import SI = Modelica.SIunits;
        constant SpecificHeatCapacity cp_const
        "Constant specific heat capacity at constant pressure";
        constant SpecificHeatCapacity cv_const
        "Constant specific heat capacity at constant volume";
        constant Density d_const "Constant density";
        constant DynamicViscosity eta_const "Constant dynamic viscosity";
        constant ThermalConductivity lambda_const
        "Constant thermal conductivity";
        constant VelocityOfSound a_const "Constant velocity of sound";
        constant Temperature T_min "Minimum temperature valid for medium model";
        constant Temperature T_max "Maximum temperature valid for medium model";
        constant Temperature T0=reference_T "Zero enthalpy temperature";
        constant MolarMass MM_const "Molar mass";

        constant FluidConstants[nS] fluidConstants "fluid constants";

        redeclare record extends ThermodynamicState "Thermodynamic state"
          AbsolutePressure p "Absolute pressure of medium";
          Temperature T "Temperature of medium";
        end ThermodynamicState;

        // Compressibility of water (used to break algebraic loops)
        constant Real kappa_const(unit="1/Pa") = 0
        "Compressibility factor at constant temperature";
        constant Modelica.SIunits.AbsolutePressure p0 = 3E5
        "Reference pressure for compressibility and default medium pressure";

    protected
        constant Boolean constantDensity = (kappa_const <= 1E-20)
        "Flag, true if density is modeled as a constant";

    public
        redeclare replaceable model extends BaseProperties
        equation
              assert(T >= T_min and T <= T_max, "
Temperature T (= "         + String(T) + " K) is not
in the allowed range ("         + String(T_min) + " K <= T <= " + String(T_max)
                 + " K)
required from medium model \""         + mediumName + "\".
");

              // h = cp_const*(T-T0);
          h = specificEnthalpy_pTX(p,T,X);
          u = cv_const*(T-T0);
          // original equation d = d_const;
          d = if constantDensity then d_const else d_const * (1+kappa_const*(p-p0));
         // d = d_const * (1+kT*(T-T0)/T0); "this gives large coupled equations"
          R = 0;
          MM = MM_const;
          state.T = T;
          state.p = p;
              annotation (Documentation(info="<html>
<p>
This is the most simple incompressible medium model, where
specific enthalpy h and specific internal energy u are only
a function of temperature T and all other provided medium
quantities are assumed to be constant.
</p>
</html>"));
        end BaseProperties;

        redeclare function setState_pTX
        "Return thermodynamic state from p, T, and X or Xi"
          extends Modelica.Icons.Function;
          input AbsolutePressure p "Pressure";
          input Temperature T "Temperature";
          input MassFraction X[:]=reference_X "Mass fractions";
          output ThermodynamicState state "thermodynamic state record";
        algorithm
          state := ThermodynamicState(p=p,T=T);
        end setState_pTX;

        redeclare function setState_phX
        "Return thermodynamic state from p, h, and X or Xi"
          extends Modelica.Icons.Function;
          input AbsolutePressure p "Pressure";
          input SpecificEnthalpy h "Specific enthalpy";
          input MassFraction X[:]=reference_X "Mass fractions";
          output ThermodynamicState state "thermodynamic state record";
        algorithm
          state := ThermodynamicState(p=p,T=temperature_phX(p, h, X));
        end setState_phX;

        redeclare replaceable function setState_psX
        "Return thermodynamic state from p, s, and X or Xi"
          extends Modelica.Icons.Function;
          input AbsolutePressure p "Pressure";
          input SpecificEntropy s "Specific entropy";
          input MassFraction X[:]=reference_X "Mass fractions";
          output ThermodynamicState state "thermodynamic state record";
        algorithm
          state := ThermodynamicState(p=p,T=Modelica.Math.exp(s/cp_const + Modelica.Math.log(T0)))
          "here the incompressible limit is used, with cp as heat capacity";
        end setState_psX;

        redeclare function setState_dTX
        "Return thermodynamic state from d, T, and X or Xi"
          extends Modelica.Icons.Function;
          input Density d "density";
          input Temperature T "Temperature";
          input MassFraction X[:]=reference_X "Mass fractions";
          output ThermodynamicState state "thermodynamic state record";
        algorithm
          assert(false,"pressure can not be computed from temperature and density for an incompressible fluid!");
        end setState_dTX;

            redeclare function extends setSmoothState
        "Return thermodynamic state so that it smoothly approximates: if x > 0 then state_a else state_b"
            algorithm
        state := ThermodynamicState(p=Modelica.Media.Common.smoothStep(
                  x,
                  state_a.p,
                  state_b.p,
                  x_small), T=Modelica.Media.Common.smoothStep(
                  x,
                  state_a.T,
                  state_b.T,
                  x_small));
            end setSmoothState;

        redeclare function extends dynamicViscosity "Return dynamic viscosity"

        algorithm
          eta := eta_const;
        end dynamicViscosity;

        redeclare function extends thermalConductivity
        "Return thermal conductivity"

        algorithm
          lambda := lambda_const;
        end thermalConductivity;

        redeclare function extends pressure "Return pressure"

        algorithm
          p := state.p;
        end pressure;

        redeclare function extends temperature "Return temperature"

        algorithm
          T := state.T;
        end temperature;

        redeclare function extends density "Return density"

        algorithm
          d := if constantDensity then d_const else d_const * (1+kappa_const*(state.p-p0));
        end density;

        redeclare function extends specificEnthalpy "Return specific enthalpy"

        algorithm
          h := cp_const*(state.T-T0);
        end specificEnthalpy;

        redeclare function extends specificHeatCapacityCp
        "Return specific heat capacity at constant pressure"

        algorithm
          cp := cp_const;
        end specificHeatCapacityCp;

        redeclare function extends specificHeatCapacityCv
        "Return specific heat capacity at constant volume"

        algorithm
          cv := cv_const;
        end specificHeatCapacityCv;

        redeclare function extends isentropicExponent
        "Return isentropic exponent"

        algorithm
          gamma := cp_const/cv_const;
        end isentropicExponent;

        redeclare function extends velocityOfSound "Return velocity of sound "

        algorithm
          a := a_const;
        end velocityOfSound;

        redeclare function specificEnthalpy_pTX
        "Return specific enthalpy from p, T, and X or Xi"
          extends Modelica.Icons.Function;
          input AbsolutePressure p "Pressure";
          input Temperature T "Temperature";
          input MassFraction X[nX] "Mass fractions";
          output SpecificEnthalpy h "Specific enthalpy";
        algorithm
          h := cp_const*(T-T0);
        end specificEnthalpy_pTX;

        redeclare function temperature_phX
        "Return temperature from p, h, and X or Xi"
          extends Modelica.Icons.Function;
          input AbsolutePressure p "Pressure";
          input SpecificEnthalpy h "Specific enthalpy";
          input MassFraction X[nX] "Mass fractions";
          output Temperature T "Temperature";
        algorithm
          T := T0 + h/cp_const;
        end temperature_phX;

        redeclare function density_phX "Return density from p, h, and X or Xi"
          extends Modelica.Icons.Function;
          input AbsolutePressure p "Pressure";
          input SpecificEnthalpy h "Specific enthalpy";
          input MassFraction X[nX] "Mass fractions";
          output Density d "density";
        algorithm
          d := density(setState_phX(p,h,X));
        end density_phX;

        annotation (Documentation(info="<html>
This medium model is identical to 
<a href=\"modelica://Modelica.Media.Interfaces.PartialSimpleMedium\">
Modelica.Media.Interfaces.PartialSimpleMedium</a>, but it allows
to define a compressibility of the medium.
This helps breaking algebraic loops, but the system gets stiff.
The compressibility is defined by the constant <code>kappa_const</code>.
If <code>kappa_const=0</code>, then the density is constant. Otherwise,
the density is
<pre>
  rho(p) = rho(p0) * ( 1 + kappa_const * (p-p0))
</pre>

</html>",       revisions="<html>
<ul>
<li>
September 16, 2010, by Michael Wetter:<br>
Removed the <code>stateSelect</code> assignment in <pre>
BaseProperties(
    T(stateSelect=if preferredMediumStates then StateSelect.prefer else
                       StateSelect.default),
    p(stateSelect=if preferredMediumStates then StateSelect.prefer else
                       StateSelect.default))
</pre>
as this is now handled in the model
<a href=\"modelica://Buildings.Fluid.MixingVolumes.MixingVolume\">
Buildings.Fluid.MixingVolumes.MixingVolume</a>. The reason for this change is
that the assignment is different for steady-state and dynamic balance.
In the previous implementation, this assignment can cause steady-state models to 
be differentiated in order to obtain <code>T</code> as a state. This resulted
in some cases in large coupled systems of equations that can be avoided
if the <code>stateSelect</code> is not set to <code>StateSelect.prefer</code>
for steady-state models.
</li>
<li>
August 3, 2011, by Michael Wetter:<br>
Fixed bug in function <code>density</code>, which always returned <code>d_const</code>, regardless
of the constant <code>constantDensity</code>.
</li>
<li>
August 1, 2011, by Michael Wetter:<br>
Fixed bug in assignment of <code>singleState</code>.
</li>
<li>
September 13, 2010, by Michael Wetter:<br>
Set default values and reference pressure.
</li>
<li>
February 18, 2010, by Michael Wetter:<br>
In <a href=\"modelica://Buildings.Media.Interfaces.PartialSimpleMedium.setState_psX\">
setState_psX</a>, replaced
<code>reference_T</code> with <code>T0</code> because enthalpy is defined as zero at <code>T0</code>.
</li>
<li>
October 2, 2009, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
      end PartialSimpleMedium;
    annotation (preferedView="info", Documentation(info="<html>
<p>
This package contains partial medium models that are used
to fix a bug in 
<a href=\"Modelica:Modelica.Media.Interfaces.PartialSimpleIdealGasMedium.specificEnthalpy\">
Modelica.Media.Interfaces.PartialSimpleIdealGasMedium.specificEnthalpy</a>.
See
<a href=\"modelica://Buildings.Media.Interfaces.PartialSimpleIdealGasMedium\">
Buildings.Media.Interfaces.PartialSimpleIdealGasMedium</a>
for details.
</p>
</html>"));
    end Interfaces;
    annotation (preferedView="info", Documentation(info="<html>
This package contains different implementations for
various media.
The media models in this package are
compatible with 
<a href=\"Modelica:Modelica.Media\">
Modelica.Media</a> 
but the implementation is in general simpler, which often 
leads to easier numerical problems and better convergence of the
models.
Due to the simplifications, the media model of this package
are generally accurate for a smaller temperature range than the 
models in <a href=\"Modelica:Modelica.Media\">
Modelica.Media</a>, but the smaller temperature range may often be 
sufficient for building HVAC applications. 
</html>"));
  end Media;

  package Rooms "Package with models for rooms"
    extends Modelica.Icons.Package;

    model MixedAir "Model of a room in which the air is completely mixed"
      extends Buildings.Fluid.Interfaces.LumpedVolumeDeclarations;
      extends Buildings.Rooms.BaseClasses.ConstructionRecords;
      parameter Integer nPorts=0 "Number of ports" annotation (Evaluate=true,
          Dialog(
          connectorSizing=true,
          tab="General",
          group="Ports"));
      Buildings.Rooms.BaseClasses.MixedAir air(
        final nConExt=nConExt,
        final nConExtWin=nConExtWin,
        final nConPar=nConPar,
        final nConBou=nConBou,
        final nSurBou=nSurBou,
        final datConExt=datConExt,
        final datConExtWin=datConExtWin,
        final datConPar=datConPar,
        final datConBou=datConBou,
        final surBou=surBou,
        redeclare final package Medium = Medium,
        final V=V,
        nPorts=nPorts,
        final energyDynamics=energyDynamics,
        final massDynamics=massDynamics,
        final p_start=p_start,
        final T_start=T_start,
        final X_start=X_start,
        final C_start=C_start,
        final AFlo=AFlo,
        final hRoo=hRoo,
        final linearizeRadiation=linearizeRadiation,
        final conMod=intConMod,
        final hFixed=hIntFixed,
        final m_flow_nominal=m_flow_nominal,
        tauGlaSol={0.6 for i in 1:NConExtWin}) "Air volume"
        annotation (Placement(transformation(extent={{-140,40},{-120,60}})));
      Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b ports[nPorts](
          redeclare each package Medium = Medium) "Fluid inlets and outlets"
        annotation (Placement(transformation(
            extent={{-40,-10},{40,10}},
            origin={-200,-60},
            rotation=90), iconTransformation(
            extent={{-40,-10},{40,10}},
            rotation=90,
            origin={-150,-100})));
      parameter Modelica.SIunits.Angle lat "Latitude";
      final parameter Modelica.SIunits.Volume V=AFlo*hRoo "Volume";
      parameter Modelica.SIunits.Area AFlo "Floor area";
      parameter Modelica.SIunits.Length hRoo "Average room height";
      Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heaPorAir
      "Heat port to air volume"   annotation (Placement(transformation(extent={{-10,
                10},{10,30}}), iconTransformation(extent={{-20,-10},{0,10}})));
      Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heaPorRad
      "Heat port for radiative heat gain and radiative temperature"   annotation (
          Placement(transformation(extent={{-10,-20},{10,0}}), iconTransformation(
              extent={{-20,-48},{0,-28}})));
      ////////////////////////////////////////////////////////////////////////
      // Constructions
      Constructions.Construction conExt[NConExt](
        A=datConExt.A,
        til=datConExt.til,
        final layers={datConExt[i].layers for i in 1:NConExt},
        steadyStateInitial=datConExt.steadyStateInitial,
        T_a_start=datConExt.T_a_start,
        T_b_start=datConExt.T_b_start) if haveConExt
      "Heat conduction through exterior construction that have no window"
        annotation (Placement(transformation(extent={{66,102},{20,148}})));
      Constructions.ConstructionWithWindow conExtWin[NConExtWin](
        A=datConExtWin.A,
        til=datConExtWin.til,
        final layers={datConExtWin[i].layers for i in 1:NConExtWin},
        steadyStateInitial=datConExtWin.steadyStateInitial,
        T_a_start=datConExtWin.T_a_start,
        T_b_start=datConExtWin.T_b_start,
        AWin=datConExtWin.AWin,
        fFra=datConExtWin.fFra,
        glaSys=datConExtWin.glaSys) if haveConExtWin
      "Heat conduction through exterior construction that have a window"
        annotation (Placement(transformation(extent={{56,46},{26,76}})));
      Constructions.Construction conPar[NConPar](
        A=datConPar.A,
        til=datConPar.til,
        final layers={datConPar[i].layers for i in 1:NConPar},
        steadyStateInitial=datConPar.steadyStateInitial,
        T_a_start=datConPar.T_a_start,
        T_b_start=datConPar.T_b_start) if haveConPar
      "Heat conduction through partitions that have both sides inside the thermal zone"
        annotation (Placement(transformation(extent={{40,-102},{2,-64}})));
      Constructions.Construction conBou[NConBou](
        A=datConBou.A,
        til=datConBou.til,
        final layers={datConBou[i].layers for i in 1:NConBou},
        steadyStateInitial=datConBou.steadyStateInitial,
        T_a_start=datConBou.T_a_start,
        T_b_start=datConBou.T_b_start) if haveConBou
      "Heat conduction through opaque constructions that have the boundary conditions of the other side exposed"
        annotation (Placement(transformation(extent={{38,-154},{-2,-114}})));
      parameter Boolean linearizeRadiation=true
      "Set to true to linearize emissive power";
      ////////////////////////////////////////////////////////////////////////
      // Convection
      parameter Buildings.HeatTransfer.Types.InteriorConvection intConMod=Buildings.HeatTransfer.Types.InteriorConvection.Temperature
      "Convective heat transfer model for room-facing surfaces of opaque constructions"
        annotation (Dialog(group="Convective heat transfer"));
      parameter Modelica.SIunits.CoefficientOfHeatTransfer hIntFixed=3.0
      "Constant convection coefficient for room-facing surfaces of opaque constructions"
        annotation (Dialog(group="Convective heat transfer", enable=(conMod ==
              Buildings.HeatTransfer.Types.InteriorConvection.Fixed)));
      parameter Buildings.HeatTransfer.Types.ExteriorConvection extConMod=Buildings.HeatTransfer.Types.ExteriorConvection.TemperatureWind
      "Convective heat transfer model for exterior facing surfaces of opaque constructions"
        annotation (Dialog(group="Convective heat transfer"));
      parameter Modelica.SIunits.CoefficientOfHeatTransfer hExtFixed=10.0
      "Constant convection coefficient for exterior facing surfaces of opaque constructions"
        annotation (Dialog(group="Convective heat transfer", enable=(conMod ==
              Buildings.HeatTransfer.Types.ExteriorConvection.Fixed)));
      parameter Modelica.SIunits.MassFlowRate m_flow_nominal(min=0) = V*1.2/3600
      "Nominal mass flow rate"   annotation (Dialog(group="Nominal condition"));
      ////////////////////////////////////////////////////////////////////////
      // Models for boundary conditions
      Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a surf_conBou[nConBou] if
        haveConBou "Heat port at surface b of construction conBou" annotation (
          Placement(transformation(extent={{50,-190},{70,-170}}),
            iconTransformation(extent={{50,-170},{70,-150}})));
      Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a surf_surBou[nSurBou] if
        haveSurBou "Heat port of surface that is connected to the room air"
        annotation (Placement(transformation(extent={{-70,-150},{-50,-130}}),
            iconTransformation(extent={{-48,-150},{-28,-130}})));
      Modelica.Blocks.Interfaces.RealInput uSha[nConExtWin](each min=0, each max=1) if
           haveShade
      "Control signal for the shading device (removed if no shade is present)"
        annotation (Placement(transformation(extent={{-240,160},{-200,200}}),
            iconTransformation(extent={{-240,140},{-200,180}})));
      Modelica.Blocks.Interfaces.RealInput qGai_flow[3](unit="W/m2")
      "Radiant, convective and latent heat input into room (positive if heat gain)"
        annotation (Placement(transformation(extent={{-240,80},{-200,120}})));
      // Reassign the tilt since a construction that is declared as a ceiling of the
      // room model has an exterior-facing surface that is a floor
      BaseClasses.ExteriorBoundaryConditions bouConExt(
        final nCon=nConExt,
        final AOpa=datConExt.A,
        final lat=lat,
        final til=datConExt.til,
        final azi=datConExt.azi,
        linearizeRadiation=linearizeRadiation,
        final conMod=extConMod,
        final hFixed=hExtFixed,
        final absIR=datConExt.layers.absIR_a,
        final absSol=datConExt.layers.absSol_a) if haveConExt
      "Exterior boundary conditions for constructions without a window"
        annotation (Placement(transformation(extent={{116,116},{146,146}})));
      // Reassign the tilt since a construction that is declared as a ceiling of the
      // room model has an exterior-facing surface that is a floor
      BaseClasses.ExteriorBoundaryConditionsWithWindow bouConExtWin(
        final nCon=nConExtWin,
        final lat=lat,
        final til=datConExtWin.til,
        final azi=datConExtWin.azi,
        final AOpa=datConExtWin.AOpa,
        final AWin=datConExtWin.AWin,
        final fFra=datConExtWin.fFra,
        linearizeRadiation=linearizeRadiation,
        final conMod=extConMod,
        final hFixed=hExtFixed,
        final absIR=datConExtWin.layers.absIR_a,
        final absIRSha_air={datConExtWin[i].glaSys.shade.absIR_a for i in 1:
            nConExtWin},
        final absIRSha_glass={datConExtWin[i].glaSys.shade.absIR_b for i in 1:
            nConExtWin},
        final tauIRSha_air={datConExtWin[i].glaSys.shade.tauIR_a for i in 1:
            nConExtWin},
        final tauIRSha_glass={datConExtWin[i].glaSys.shade.tauIR_b for i in 1:
            nConExtWin},
        final absIRFra={datConExtWin[i].glaSys.absIRFra for i in 1:nConExtWin},
        final haveExteriorShade={datConExtWin[i].glaSys.haveExteriorShade for i in
            1:nConExtWin},
        final haveInteriorShade={datConExtWin[i].glaSys.haveInteriorShade for i in
            1:nConExtWin},
        final absSol=datConExtWin.layers.absSol_a,
        final absSolFra=datConExtWin.glaSys.absSolFra) if haveConExtWin
      "Exterior boundary conditions for constructions with a window"
        annotation (Placement(transformation(extent={{116,46},{146,76}})));
      HeatTransfer.Windows.BaseClasses.WindowRadiation conExtWinRad[NConExtWin](
        final AWin=(1 .- datConExtWin.fFra) .* datConExtWin.AWin,
        final N=datConExtWin.glaSys.nLay,
        final tauGlaSol=datConExtWin.glaSys.glass.tauSol,
        final rhoGlaSol_a=datConExtWin.glaSys.glass.rhoSol_a,
        final rhoGlaSol_b=datConExtWin.glaSys.glass.rhoSol_b,
        final tauShaSol_a=datConExtWin.glaSys.shade.tauSol_a,
        final tauShaSol_b=datConExtWin.glaSys.shade.tauSol_b,
        final rhoShaSol_a=datConExtWin.glaSys.shade.rhoSol_a,
        final rhoShaSol_b=datConExtWin.glaSys.shade.rhoSol_b,
        final haveExteriorShade=datConExtWin.glaSys.haveExteriorShade,
        final haveInteriorShade=datConExtWin.glaSys.haveInteriorShade) if
        haveConExtWin "Model for solar radiation through shades and window"
        annotation (Placement(transformation(extent={{40,-20},{60,0}})));
      BoundaryConditions.WeatherData.Bus weaBus annotation (Placement(
            transformation(extent={{170,170},{190,190}}), iconTransformation(extent=
               {{166,166},{192,192}})));
  protected
      final parameter Boolean haveShade=datConExtWin[1].glaSys.haveExteriorShade
           or datConExtWin[1].glaSys.haveInteriorShade
      "Set to true if the windows have a shade";
    equation
      connect(air.conExtWin, conExtWin.opa_b) annotation (Line(
          points={{-122,56},{-56,56},{-56,71},{25.9,71}},
          color={191,0,0},
          smooth=Smooth.None));
      connect(air.conPar_b, conPar.opa_b) annotation (Line(
          points={{-121.933,46.6667},{-42,46.6667},{-42,-70},{1.87333,-70},{1.87333,
              -70.3333}},
          color={191,0,0},
          smooth=Smooth.None));
      connect(air.conPar_a, conPar.opa_a) annotation (Line(
          points={{-121.933,48},{-40,48},{-40,-54},{40,-54},{40,-70.3333}},
          color={191,0,0},
          smooth=Smooth.None));
      connect(conBou.opa_a, surf_conBou) annotation (Line(
          points={{38,-120.667},{60,-120.667},{60,-180}},
          color={191,0,0},
          smooth=Smooth.None));
      connect(air.conBou, conBou.opa_b) annotation (Line(
          points={{-121.933,44.6667},{-52,44.6667},{-52,-120.667},{-2.13333,
              -120.667}},
          color={191,0,0},
          smooth=Smooth.None));
      connect(surf_surBou, air.conSurBou) annotation (Line(
          points={{-60,-140},{-60,42.6667},{-121.967,42.6667}},
          color={191,0,0},
          smooth=Smooth.None));
      connect(uSha, air.uSha) annotation (Line(
          points={{-220,180},{-160,180},{-160,56.0667},{-138.667,56.0667}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(qGai_flow, air.qGai_flow) annotation (Line(
          points={{-220,100},{-180,100},{-180,53.3333},{-138.667,53.3333}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(air.JOutUns, conExtWin.JInUns_b) annotation (Line(
          points={{-121.667,55.3333},{-5.7915,55.3333},{-5.7915,60},{25.5,60}},
          color={0,127,0},
          smooth=Smooth.None));
      connect(conExtWin.JOutUns_b, air.JInUns) annotation (Line(
          points={{25.5,62},{-8,62},{-8,54.8},{-121.733,54.8}},
          color={0,127,0},
          smooth=Smooth.None));
      connect(air.JOutSha, conExtWin.JInSha_b) annotation (Line(
          points={{-121.667,52},{4,52},{4,51},{25.5,51}},
          color={0,127,0},
          smooth=Smooth.None));
      connect(conExtWin.JOutSha_b, air.JInSha) annotation (Line(
          points={{25.5,53},{0,53},{0,51.3333},{-121.667,51.3333}},
          color={0,127,0},
          smooth=Smooth.None));
      connect(air.glaUns, conExtWin.glaUns_b) annotation (Line(
          points={{-121.933,54},{-121.933,40},{16,40},{16,57},{26,57}},
          color={191,0,0},
          smooth=Smooth.None));
      connect(conExtWin.glaSha_b, air.glaSha) annotation (Line(
          points={{26,55},{-4,55},{-4,52.6667},{-121.933,52.6667}},
          color={191,0,0},
          smooth=Smooth.None));
      connect(air.conExtWinFra, conExtWin.fra_b) annotation (Line(
          points={{-121.933,50},{-38,50},{-38,48},{25.9,48}},
          color={191,0,0},
          smooth=Smooth.None));
      connect(uSha, conExtWin.uSha) annotation (Line(
          points={{-220,180},{86,180},{86,64},{57,64}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(uSha, bouConExtWin.uSha) annotation (Line(
          points={{-220,180},{100,180},{100,66},{115,66}},
          color={0,0,127},
          pattern=LinePattern.None,
          smooth=Smooth.None));
      connect(bouConExtWin.opa_a, conExtWin.opa_a) annotation (Line(
          points={{116,71},{56,71}},
          color={191,0,0},
          pattern=LinePattern.None,
          smooth=Smooth.None));
      connect(conExtWin.JInUns_a, bouConExtWin.JOutUns) annotation (Line(
          points={{56.5,62},{94,62},{94,60},{115.5,60}},
          color={0,0,0},
          pattern=LinePattern.None,
          smooth=Smooth.None));
      connect(bouConExtWin.JInUns, conExtWin.JOutUns_a) annotation (Line(
          points={{115.5,62},{78,62},{78,60},{56.5,60}},
          color={0,0,0},
          pattern=LinePattern.None,
          smooth=Smooth.None));
      connect(conExtWin.glaUns_a, bouConExtWin.glaUns) annotation (Line(
          points={{56,57},{80,57},{80,57},{116,57}},
          color={191,0,0},
          pattern=LinePattern.None,
          smooth=Smooth.None));
      connect(bouConExtWin.glaSha, conExtWin.glaSha_a) annotation (Line(
          points={{116,55},{88,55},{88,55},{56,55}},
          color={191,0,0},
          pattern=LinePattern.None,
          smooth=Smooth.None));
      connect(conExtWin.JInSha_a, bouConExtWin.JOutSha) annotation (Line(
          points={{56.5,53},{86,53},{86,51},{115.5,51}},
          color={0,0,0},
          pattern=LinePattern.None,
          smooth=Smooth.None));
      connect(bouConExtWin.JInSha, conExtWin.JOutSha_a) annotation (Line(
          points={{115.5,53},{84,53},{84,51},{56.5,51}},
          color={0,0,0},
          pattern=LinePattern.None,
          smooth=Smooth.None));
      connect(conExtWin.fra_a, bouConExtWin.fra) annotation (Line(
          points={{56,48},{116,48}},
          color={191,0,0},
          pattern=LinePattern.None,
          smooth=Smooth.None));
      connect(conExt.opa_b, air.conExt) annotation (Line(
          points={{19.8467,140.333},{-106,140.333},{-106,60},{-122,60},{-122,
              57.3333}},
          color={191,0,0},
          smooth=Smooth.None));
      connect(conExt.opa_a, bouConExt.opa_a) annotation (Line(
          points={{66,140.333},{86,141},{116,141}},
          color={191,0,0},
          smooth=Smooth.None));
      connect(weaBus, bouConExtWin.weaBus) annotation (Line(
          points={{180,180},{180,62.05},{142.15,62.05}},
          color={255,204,51},
          thickness=0.5,
          smooth=Smooth.None));
      connect(weaBus, bouConExt.weaBus) annotation (Line(
          points={{180,180},{180,130},{142.15,130},{142.15,132.05}},
          color={255,204,51},
          thickness=0.5,
          smooth=Smooth.None));
      connect(ports, air.ports) annotation (Line(
          points={{-200,-60},{-130,-60},{-130,42.0667}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(bouConExtWin.QAbsSolSha_flow, conExtWinRad.QAbsExtSha_flow)
        annotation (Line(
          points={{115,64},{100,64},{100,-1},{61,-1}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(bouConExtWin.inc, conExtWinRad.incAng) annotation (Line(
          points={{146.5,70},{154,70},{154,18},{20,18},{20,-11},{38.5,-11}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(bouConExtWin.HDir, conExtWinRad.HDir) annotation (Line(
          points={{146.5,67},{152,67},{152,16},{22,16},{22,-6},{38.5,-6}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(bouConExtWin.HDif, conExtWinRad.HDif) annotation (Line(
          points={{146.5,64},{150,64},{150,14},{24,14},{24,-2},{38.5,-2}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(uSha, conExtWinRad.uSha) annotation (Line(
          points={{-220,180},{-160,180},{-160,-36},{49.8,-36},{49.8,-21.6}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(air.HOutConExtWin, conExtWinRad.HRoo) annotation (Line(
          points={{-136.667,41.6667},{-136.667,-17.6},{38.5,-17.6}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(conExtWinRad.QTra_flow, air.JInConExtWin) annotation (Line(
          points={{61,-18},{72,-18},{72,-38},{-152,-38},{-152,46.6667},{-138.667,
              46.6667}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(conExtWinRad.QAbsIntSha_flow, air.QAbsSolSha_flow) annotation (Line(
          points={{61,-13},{76,-13},{76,-40},{-154,-40},{-154,43.3333},{-138.667,
              43.3333}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(conExtWin.QAbsSha_flow, conExtWinRad.QAbsGlaSha_flow) annotation (
          Line(
          points={{37,45},{37,40},{76,40},{76,-9},{61,-9}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(conExtWinRad.QAbsGlaUns_flow, conExtWin.QAbsUns_flow) annotation (
          Line(
          points={{61,-5},{74,-5},{74,38},{45,38},{45,45}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(air.heaPorAir, heaPorAir) annotation (Line(
          points={{-138,50},{-164,50},{-164,20},{5.55112e-16,20}},
          color={191,0,0},
          smooth=Smooth.None));
      connect(air.heaPorRad, heaPorRad) annotation (Line(
          points={{-138,48.6667},{-166,48.6667},{-166,-10},{5.55112e-16,-10}},
          color={191,0,0},
          smooth=Smooth.None));
      annotation (
        Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-200,-200},{200,
                200}}), graphics),
        Icon(coordinateSystem(preserveAspectRatio=true, extent={{-200,-200},{200,
                200}}), graphics={
            Text(
              extent={{-104,210},{84,242}},
              lineColor={0,0,255},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid,
              textString="%name"),
            Text(
              extent={{-214,114},{-138,82}},
              lineColor={0,0,127},
              textString="q"),
            Text(
              extent={{-212,176},{-136,144}},
              lineColor={0,0,127},
              textString="u"),
            Text(
              extent={{-14,-160},{44,-186}},
              lineColor={0,0,0},
              fillColor={61,61,61},
              fillPattern=FillPattern.Solid,
              textString="boundary"),
            Rectangle(
              extent={{-160,-160},{160,160}},
              lineColor={95,95,95},
              fillColor={95,95,95},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{-140,138},{140,-140}},
              pattern=LinePattern.None,
              lineColor={117,148,176},
              fillColor={170,213,255},
              fillPattern=FillPattern.Sphere),
            Rectangle(
              extent={{140,70},{160,-70}},
              lineColor={95,95,95},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{146,70},{154,-70}},
              lineColor={95,95,95},
              fillColor={170,213,255},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-60,12},{-22,-10}},
              lineColor={0,0,0},
              fillColor={61,61,61},
              fillPattern=FillPattern.Solid,
              textString="air"),
            Text(
              extent={{-72,-22},{-22,-50}},
              lineColor={0,0,0},
              fillColor={61,61,61},
              fillPattern=FillPattern.Solid,
              textString="radiation"),
            Text(
              extent={{-104,-124},{-54,-152}},
              lineColor={0,0,0},
              fillColor={61,61,61},
              fillPattern=FillPattern.Solid,
              textString="surface")}),
        preferedView="info",
        defaultComponentName="roo",
        Documentation(info="<html>
<p>The package <b>Buildings.Rooms</b> contains models for heat transfer 
through the building envelope.</p>
<p>The model <a href=\"modelica:Buildings.Rooms.MixedAir\">Buildings.Rooms.MixedAir</a> is 
a model of a room with completely mixed air.
The room can have any number of constructions and surfaces that participate in the 
heat exchange through convection, conduction, infrared radiation and solar radiation.</p>
<h4>Physical description</h4>
<p>
A description of the model assumptions and the implemention and validation of this room model can be found in 
<a href=\"#WetterEtAl2011\">Wetter et al. (2011)</a>.
The room models the following physical processes:
<ol>
<li>
Transient or steady-state heat conduction through opaque surfaces, using
the model
<a href=\"modelica://Buildings.HeatTransfer.Conduction.MultiLayer\">
Buildings.HeatTransfer.Conduction.MultiLayer</a>
</li>
<li>
Heat transfer through glazing system, taking into account
solar radiation, infrared radiation, heat conduction and heat convection.
The solar radiation is modeled using
<a href=\"modelica://Buildings.HeatTransfer.Windows.BaseClasses.WindowRadiation\">
Buildings.HeatTransfer.Windows.BaseClasses.WindowRadiation</a>.
The overall heat transfer is modeled using the model
<a href=\"modelica://Buildings.HeatTransfer.Windows.Window\">
Buildings.HeatTransfer.Windows.Window</a>
for the glass assembly, the models
<a href=\"modelica://Buildings.HeatTransfer.Windows.ExteriorHeatTransfer\">
Buildings.HeatTransfer.Windows.ExteriorHeatTransfer</a>
and
<a href=\"modelica://Buildings.HeatTransfer.Windows.InteriorHeatTransfer\">
Buildings.HeatTransfer.Windows.InteriorHeatTransfer</a>
for the exterior and interior heat transfer.
</li>
<li>
Convective heat transfer between the room air and room-facing surfaces using
either a temperature-dependent heat transfer coefficient,
or using a constant heat transfer coefficient, as described in
<a href=\"modelica://Buildings.HeatTransfer.Convection.Interior\">
Buildings.HeatTransfer.Convection.Interior</a>.
</li>
<li>
Convective heat transfer between the outside air and outside-facing surfaces using
either a wind-speed, wind-direction and temperature-dependent heat transfer coefficient,
or using a constant heat transfer coefficient, as described in
<a href=\"modelica://Buildings.HeatTransfer.Convection.Exterior\">
Buildings.HeatTransfer.Convection.Exterior</a>.
</li>
<li>
Solar and infrared heat transfer between the room enclosing surfaces,
and temperature, pressure and species changes inside the room volume.
These effects are modeled and described in 
<a href=\"modelica://Buildings.Rooms.BaseClasses.MixedAir\">
Buildings.Rooms.BaseClasses.MixedAir</a>
which consists of several sub-models.
</li>
</ol>
</p>
<h4>Model instantiation</h4>
<p>The next paragraphs describe how to instantiate a room model.
To instantiate a room model, 
<ol>
<li>
make an instance of the room model in your model,
</li>
<li>
make instances of constructions from the package 
<a href=\"modelica://Buildings.HeatTransfer.Data.OpaqueConstructions\">
Buildings.HeatTransfer.Data.OpaqueConstructions</a> to model opaque constructions such as walls, floors,
ceilings and roofs,
</li>
<li>
make an instance of constructions from the package 
<a href=\"modelica://Buildings.HeatTransfer.Data.GlazingSystems\">
Buildings.HeatTransfer.Data.GlazingSystems</a> to model glazing systems, and
</li>
<li>
enter the parameters of the room. 
</li>
</ol>
Entering parameters may be easiest in a textual editor. 

In the here presented example, we assume we made several instances
of data records for the construction material by dragging them from 
the package <a href=\"modelica://Buildings.HeatTransfer.Data\">
Buildings.HeatTransfer.Data</a> to create the following list of declarations:
<pre>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-family:'Courier New,courier';\">  </span><span style=\" font-family:'Courier New,courier'; color:#ff0000;\">Buildings.HeatTransfer.Data.OpaqueConstructions.Insulation100Concrete200</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">    matLayExt </span><span style=\" font-family:'Courier New,courier'; color:#006400;\">\"Construction material for exterior walls\"</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">    </span><span style=\" font-family:'Courier New,courier'; color:#0000ff;\">annotation </span><span style=\" font-family:'Courier New,courier';\">(Placement(transformation(extent={{-60,140},{-40,160}})));</span></p>
<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:'Courier New,courier';\"></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">  </span><span style=\" font-family:'Courier New,courier'; color:#ff0000;\">Buildings.HeatTransfer.Data.OpaqueConstructions.Brick120</span><span style=\" font-family:'Courier New,courier';\"> matLayPar </span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier'; color:#006400;\">    \"Construction material for partition walls\"</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">    </span><span style=\" font-family:'Courier New,courier'; color:#0000ff;\">annotation </span><span style=\" font-family:'Courier New,courier';\">(Placement(transformation(extent={{-20,140},{0,160}})));</span></p>
<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:'Courier New,courier';\"></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">  </span><span style=\" font-family:'Courier New,courier'; color:#ff0000;\">Buildings.HeatTransfer.Data.OpaqueConstructions.Generic</span><span style=\" font-family:'Courier New,courier';\"> matLayRoo(</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">        material={</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">          </span><span style=\" font-family:'Courier New,courier'; color:#ff0000;\">HeatTransfer.Data.Solids.InsulationBoard</span><span style=\" font-family:'Courier New,courier';\">(x=0.2),</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">          </span><span style=\" font-family:'Courier New,courier'; color:#ff0000;\">HeatTransfer.Data.Solids.Concrete</span><span style=\" font-family:'Courier New,courier';\">(x=0.2)},</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">        </span><span style=\" font-family:'Courier New,courier'; color:#0000ff;\">final </span><span style=\" font-family:'Courier New,courier';\">nLay=2) </span><span style=\" font-family:'Courier New,courier'; color:#006400;\">\"Construction material for roof\"</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">    </span><span style=\" font-family:'Courier New,courier'; color:#0000ff;\">annotation </span><span style=\" font-family:'Courier New,courier';\">(Placement(transformation(extent={{20,140},{40,160}})));</span></p>
<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:'Courier New,courier';\"></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">  </span><span style=\" font-family:'Courier New,courier'; color:#ff0000;\">Buildings.HeatTransfer.Data.OpaqueConstructions.Generic</span><span style=\" font-family:'Courier New,courier';\"> matLayFlo(</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">        material={</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">          </span><span style=\" font-family:'Courier New,courier'; color:#ff0000;\">HeatTransfer.Data.Solids.Concrete</span><span style=\" font-family:'Courier New,courier';\">(x=0.2),</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">          </span><span style=\" font-family:'Courier New,courier'; color:#ff0000;\">HeatTransfer.Data.Solids.InsulationBoard</span><span style=\" font-family:'Courier New,courier';\">(x=0.1),</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">    </span><span style=\" font-family:'Courier New,courier'; color:#000000;\">      </span><span style=\" font-family:'Courier New,courier';\">HeatTransfer.Data.Solids.Concrete(x=0.05)</span><span style=\" font-family:'Courier New,courier'; color:#000000;\">}</span><span style=\" font-family:'Courier New,courier';\">,</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">        </span><span style=\" font-family:'Courier New,courier'; color:#0000ff;\">final </span><span style=\" font-family:'Courier New,courier';\">nLay=3) </span><span style=\" font-family:'Courier New,courier'; color:#006400;\">\"Construction material for floor\"</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">    </span><span style=\" font-family:'Courier New,courier'; color:#0000ff;\">annotation </span><span style=\" font-family:'Courier New,courier';\">(Placement(transformation(extent={{60,140},{80,160}})));</span></p>
<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:'Courier New,courier';\"></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">  </span><span style=\" font-family:'Courier New,courier'; color:#ff0000;\">Buildings.HeatTransfer.Data.GlazingSystems.DoubleClearAir13Clear</span><span style=\" font-family:'Courier New,courier';\"> glaSys(</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">    UFra=2,</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">    shade=</span><span style=\" font-family:'Courier New,courier'; color:#ff0000;\">Buildings.HeatTransfer.Data.Shades.Gray</span><span style=\" font-family:'Courier New,courier';\">(),</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">    haveExteriorShade=false,</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">    haveInteriorShade=true) </span><span style=\" font-family:'Courier New,courier'; color:#006400;\">\"Data record for the glazing system\"</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">    </span><span style=\" font-family:'Courier New,courier'; color:#0000ff;\">annotation </span><span style=\" font-family:'Courier New,courier';\">(Placement(transformation(extent={{100,140},{120,160}})));</span></p>
<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:'Courier New,courier';\"></p>

</pre>
<p>
Note that construction layers are assembled from the outside to the room-side. Thus, the construction
<code>matLayRoo</code> has an exterior insulation. This constructions can then be used in the room model.
</p>
<p>
Before we explain how to declare and parametrize a room model, 
we explain the different models that can be used to compute heat transfer through the room enclosing surfaces
and constructions. The room model 
<a href=\"modelica://Buildings.Rooms.MixedAir\">Buildings.Rooms.MixedAir</a> contains the constructions shown
in the table below. 
The first row of the table lists the name of the data record that is used by the user
to assign the model parameters. 
The second row lists the name of the instance of the model that simulates the equations.
The third column provides a reference to the class definition that implements the equations.
The forth column describes the main applicability of the model.
</p>
<p>
<table border=\"1\">
<tr>
<th>Record name</th>
<th>Model instance name</th>
<th>Class name</th>
<th>Description of the model</th></tr>
<tr>
<td>
datConExt
</td>
<td>
modConExt
</td>
<td>
<a href=\"modelica://Buildings.Rooms.Constructions.Construction\">Buildings.Rooms.Constructions.Construction</a>
</td>
<td>
Exterior constructions that have no window.
</td>
</tr>
<tr>
<td>
datConExtWin
</td>
<td>
modConExtWin
</td>
<td>
<a href=\"modelica://Buildings.Rooms.Constructions.ConstructionWithWindow\">Buildings.Rooms.Constructions.ConstructionWithWindow</a>
</td>
<td>
Exterior constructions that have a window. Each construction of this type needs to have one window.
Within the same room, all windows can either have a shade or have no shade. 
Individual windows within the same room can have either an interior shade or an exterior shade, but not both.
Each window has its own control signal for the shade. This signal is exposed by the port <code>uSha</code>, which
has the same dimension as the number of windows. The values for <code>uSha</code> must be between 
<code>0</code> and <code>1</code>. Set <code>uSha=0</code> to open the shade, and <code>uSha=1</code>
to close the shade.
</td>
</tr>
<tr>
<td>
datConPar
</td>
<td>
modConPar
</td>
<td>
<a href=\"modelica://Buildings.Rooms.Constructions.Construction\">Buildings.Rooms.Constructions.Construction</a>
</td>
<td>
Interior constructions such as partitions within a room. Both surfaces of this construction are inside the room model
and participate in the infrared and solar radiation balance. 
Since the view factor between these surfaces is zero, there is no infrared radiation from one surface to the other
of the same construction.
</td>
</tr>
<tr>
<td>
datConBou
</td>
<td>
modConBou
</td>
<td>
<a href=\"modelica://Buildings.Rooms.Constructions.Construction\">Buildings.Rooms.Constructions.Construction</a>
</td>
<td>
Constructions that expose the other boundary conditions of the other surface to the outside of this room model.
The heat conduction through these constructions is modeled in this room model. 
The surface at the port <code>opa_b</code> is connected to the models for convection, infrared and solar radiation exchange 
with this room model and with the other surfaces of this room model.
The surface at the port <code>opa_a</code> is connected to the port <code>surf_conBou</code> of this room model. This could be used, for example,
to model a floor inside this room and connect to other side of this floor model to a model that computes heat transfer in the soil.
</td>
</tr>
<tr>
<td>
N/A
</td>
<td>
surBou
</td>
<td>
<a href=\"modelica://Buildings.HeatTransfer.Data.OpaqueSurfaces.Generic\">Buildings.HeatTransfer.Data.OpaqueSurfaces.Generic</a>
</td>
<td>
Opaque surfaces of this room model whose heat transfer through the construction is modeled outside of this room model.
This object is modeled using a data record that contains the area, solar and infrared emissivities and surface tilt.
The surface then participates in the convection and radiation heat balance of the room model. The heat flow rate and temperature
of this surface are exposed at the heat port <code>surf_surBou</code>.
An application of this object may be to connect the port <code>surf_surBou</code> of this room model with the port
<code>surf_conBou</code> of another room model in order to couple two room models.
Another application would be to model a radiant ceiling outside of this room model, and connect its surface to the port
<code>surf_conBou</code> in order for the radiant ceiling model to participate in the heat balance of this room.
</td>
</tr>
</table>
</p>
<p>
With these constructions, we may define a room as follows: </p>
<pre>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-family:'Courier New,courier';\">  </span><span style=\" font-family:'Courier New,courier'; color:#ff0000;\">Buildings.Rooms.MixedAir</span><span style=\" font-family:'Courier New,courier';\"> roo(</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">    </span><span style=\" font-family:'Courier New,courier'; color:#0000ff;\">redeclare package</span><span style=\" font-family:'Courier New,courier';\"> Medium = </span><span style=\" font-family:'Courier New,courier'; color:#ff0000;\">MediumA</span><span style=\" font-family:'Courier New,courier';\">,</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">    AFlo=6*4,</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">    hRoo=2.7,</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">    nConExt=2,</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">    datConExt(layers={matLayRoo, matLayExt},</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">           A={6*4, 6*3},</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">           til={Buildings.HeatTransfer.Types.Tilt.Ceiling, Buildings.HeatTransfer.Types.Tilt.Wall},</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">           azi={Buildings.HeatTransfer.Types.Azimuth.S, Buildings.HeatTransfer.Types.Azimuth.W}),</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">    nConExtWin=nConExtWin,</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">    datConExtWin(layers={matLayExt}, A={4*3},</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">              glaSys={glaSys},</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">              AWin={2*2},</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">              fFra={0.1},</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">              til={Buildings.HeatTransfer.Types.Tilt.Wall},</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">              azi={Buildings.HeatTransfer.Types.Azimuth.S}),</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">    nConPar=1,</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">    datConPar(layers={matLayPar}, </span><span style=\" font-family:'Courier New,courier'; color:#0000ff;\">each </span><span style=\" font-family:'Courier New,courier';\">A=10,</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">           </span><span style=\" font-family:'Courier New,courier'; color:#0000ff;\">each </span><span style=\" font-family:'Courier New,courier';\">til=Buildings.HeatTransfer.Types.Tilt.Wall),</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">    nConBou=1,</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">    datConBou(layers={matLayFlo}, </span><span style=\" font-family:'Courier New,courier'; color:#0000ff;\">each </span><span style=\" font-family:'Courier New,courier';\">A=6*4,</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">           </span><span style=\" font-family:'Courier New,courier'; color:#0000ff;\">each </span><span style=\" font-family:'Courier New,courier';\">til=Buildings.HeatTransfer.Types.Tilt.Floor),</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">    nSurBou=1,</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">    surBou(</span><span style=\" font-family:'Courier New,courier'; color:#0000ff;\">each </span><span style=\" font-family:'Courier New,courier';\">A=6*3, </span><span style=\" font-family:'Courier New,courier'; color:#0000ff;\">each </span><span style=\" font-family:'Courier New,courier';\">absIR=0.9, </span><span style=\" font-family:'Courier New,courier'; color:#0000ff;\">each </span><span style=\" font-family:'Courier New,courier';\">absSol=0.9, </span><span style=\" font-family:'Courier New,courier'; color:#0000ff;\">each </span><span style=\" font-family:'Courier New,courier';\">til=Buildings.HeatTransfer.Types.Tilt.Wall),</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">    linearizeRadiation = true ,</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">    energyDynamics=Modelica.Fluid.Types.Dynamics.FixedInitial,</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">    lat=0.73268921998722) </span><span style=\" font-family:'Courier New,courier'; color:#006400;\">\"Room model\"</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">    </span><span style=\" font-family:'Courier New,courier'; color:#0000ff;\">annotation </span><span style=\" font-family:'Courier New,courier';\">(Placement(transformation(extent={{46,20},{86,60}})));</span></p>

</pre>
<p>
The following paragraphs explain the different declarations.
</p>
<p>
The statement
<pre>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">    </span><span style=\" font-family:'Courier New,courier'; color:#0000ff;\">redeclare package</span><span style=\" font-family:'Courier New,courier';\"> Medium = </span><span style=\" font-family:'Courier New,courier'; color:#ff0000;\">MediumA</span><span style=\" font-family:'Courier New,courier';\">,</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">    AFlo=20,</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">    V=20*2.5,</span></p>

</pre>
declares that the medium of the room air is set to <code>MediumA</code>, 
that the floor area is <i>20 m<sup>2</sup></i> and that 
the room air volume is <i>20*2.5 m<sup>3</sup></i>. 
The floor area is used to scale the internal heat
gains, which are declared with units of <i>W/m<sup>2</sup></i> 
using the input signal <code>qGai_flow</code>.
</p>
<p>
The next entries specify constructions and surfaces
that participate in the heat exchange.
</p>
<p>
The entry
<pre>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">    nConExt=2,</span></p>

</pre>
declares that there are two exterior constructions.
</p>
<p>
The lines 
<pre>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">    datConExt(layers={matLayRoo, matLayExt},</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">           A={6*4, 6*3},</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">           til={Buildings.HeatTransfer.Types.Tilt.Ceiling, Buildings.HeatTransfer.Types.Tilt.Wall},</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">           azi={Buildings.HeatTransfer.Types.Azimuth.S, Buildings.HeatTransfer.Types.Azimuth.W}),</span></p>

</pre>
declare that the material layers in these constructions are
set the the records <code>matLayRoo</code> and <code>matLayExt</code>.
What follows are the declarations for the surface area,
the tilt of the surface and the azimuth of the surfaces. Thus, the 
surface with construction <code>matLayExt</code> is <i>6*3 m<sup>2</sup></i> large
and it is a west-facing wall.
</p>
<p>
Next, the declaration
<pre>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">    nConExtWin=nConExtWin,</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">    datConExtWin(layers={matLayExt}, A={4*3},</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">              glaSys={glaSys},</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">              AWin={2*2},</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0p"     + "x; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">              fFra={0.1},</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">              til={Buildings.HeatTransfer.Types.Tilt.Wall},</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">              azi={Buildings.HeatTransfer.Types.Azimuth.S}),</span></p>

</pre>
declares the construction that contains a window. This construction is built
using the materials defined in the record <code>matLayExt</code>. Its total area,
including the window, is <i>4*3 m<sup>2</sup></i>.
The glazing system is built using the construction defined in the record
<code>glaSys</code>. The glass area is <i>2*2 m<sup>2</sup></i> and the ratio of frame
to total glazing system area is <i>10%</i>. The construction is a wall that is 
south exposed.
</p>
<p>
What follows is the declaration of the partition constructions, as declared by
<pre>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">    nConPar=1,</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">    datConPar(layers={matLayPar}, </span><span style=\" font-family:'Courier New,courier'; color:#0000ff;\">each </span><span style=\" font-family:'Courier New,courier';\">A=10,</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">           </span><span style=\" font-family:'Courier New,courier'; color:#0000ff;\">each </span><span style=\" font-family:'Courier New,courier';\">til=Buildings.HeatTransfer.Types.Tilt.Wall),</span></p>

</pre>
Thus, there is one partition construction. Its area is <i>10 m<sup>2</sup></i> for <emph>each</emph>
surface, to form a total surface area inside this thermal zone of <i>20 m<sup>2</sup></i>.
</p>
<p>
Next, the declaration
<pre>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">    nConBou=1,</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">    datConBou(layers={matLayFlo}, </span><span style=\" font-family:'Courier New,courier'; color:#0000ff;\">each </span><span style=\" font-family:'Courier New,courier';\">A=6*4,</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">           </span><span style=\" font-family:'Courier New,courier'; color:#0000ff;\">each </span><span style=\" font-family:'Courier New,courier';\">til=Buildings.HeatTransfer.Types.Tilt.Floor),</span></p>

</pre>
declares one construction whose other surface boundary condition is exposed by this
room model (through the connector <code>surf_conBou</code>).
</p>
<p>
The declaration
<pre>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">    nSurBou=1,</span></p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">    surBou(</span><span style=\" font-family:'Courier New,courier'; color:#0000ff;\">each </span><span style=\" font-family:'Courier New,courier';\">A=6*3, </span><span style=\" font-family:'Courier New,courier'; color:#0000ff;\">each </span><span style=\" font-family:'Courier New,courier';\">absIR=0.9, </span><span style=\" font-family:'Courier New,courier'; color:#0000ff;\">each </span><span style=\" font-family:'Courier New,courier';\">absSol=0.9, </span><span style=\" font-family:'Courier New,courier'; color:#0000ff;\">each </span><span style=\" font-family:'Courier New,courier';\">til=Buildings.HeatTransfer.Types.Tilt.Wall),</span></p>

</pre>
is used to instantiate a model for a surface that is in this room. 
The surface has an area of <i>6*3 m<sup>2</sup></i>, absorptivity in the infrared and the solar
spectrum of <i>0.9</i> and it is a wall.
The room model will compute infrared radiative heat exchange, solar radiative heat gains
and infrared radiative heat gains of this surface. The surface temperature and 
heat flow rate are exposed by this room model at the heat port 
<code>surf_surBou</code>. 
A model builder may use this construct
to couple this room model to another room model that may model the construction.
</p>
<p>
The declaration
<pre>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">    linearizeRadiation = true ,</span></p>

</pre>
causes the equations for radiative heat transfer to be linearized. This can
reduce computing time at the expense of accuracy.
</p>
<p>
The declaration 
<pre>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">    energyDynamics=Modelica.Fluid.Types.Dynamics.FixedInitial,</span></p>

</pre>
is used to initialize the air volume inside the thermal zone.
</p>
<p>
Finally, the declaration
<pre>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\"><span style=\" font-family:'Courier New,courier';\">    lat=0.73268921998722) </span><span style=\" font-family:'Courier New,courier'; color:#006400;\">\"Room model\"</span></p>

</pre>
sets the latitude of the building which needs to correspond with the latitude of the weather data file.
</p>
<h4>References</h4>
<p>
<A NAME=\"WetterEtAl2011\"></A> 
Michael Wetter, Wangda Zuo and Thierry Stephane Nouidui.<br>
<a href=\"modelica://Buildings/Resources/Images/Rooms/2011-ibpsa-BuildingsLib.pdf\">
Modeling of Heat Transfer in Rooms in the Modelica \"Buildings\" Library.</a><br/>
Proc. of the 12th IBPSA Conference, p. 1096-1103. Sydney, Australia, November 2011. 
</p>
</html>",     revisions="<html>
<ul>
<li>
December 6, 2011, by Michael Wetter:<br>
Fixed bug that caused convective heat gains to be 
removed from the room instead of added to the room.
This error was caused by a wrong sign in
<a href=\"modelica://Buildings.Rooms.BaseClasses.HeatGain\">
Buildings.Rooms.BaseClasses.HeatGain</a>.
This closes ticket <a href=\"https://corbu.lbl.gov/trac/bie/ticket/46\">ticket 46</a>.
</li>
<li>
August 9, 2011, by Michael Wetter:<br>
Fixed bug that caused too high a surface temperature of the window frame.
The previous version did not compute the infrared radiation exchange between the
window frame and the sky. This has been corrected by adding the instance
<code>skyRadExcWin</code> and the parameter <code>absIRFra</code> to the 
model 
<a href=\"modelica://Buildings.Rooms.BaseClasses.ExteriorBoundaryConditionsWithWindow\">
Buildings.Rooms.BaseClasses.ExteriorBoundaryConditionsWithWindow</a>.
This closes ticket <a href=\"https://corbu.lbl.gov/trac/bie/ticket/36\">ticket 36</a>.
</li>
<li>
August 9, 2011 by Michael Wetter:<br>
Changed assignment of tilt in instances <code>bouConExt</code> and <code>bouConExtWin</code>.
This fixes the bug in <a href=\"https://corbu.lbl.gov/trac/bie/ticket/35\">ticket 35</a>
that led to the wrong solar radiation gain for roofs and floors.
</li>
<li>
March 23, 2011, by Michael Wetter:<br>
Propagated convection model to exterior boundary condition models.
</li>
<li>
December 14, 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
    end MixedAir;

    package Constructions
    "Package with models for constructions that are used in the room model"
      extends Modelica.Icons.VariantsPackage;

      model ConstructionWithWindow
      "Model for an opaque construction that has one window embedded in the construction"
        extends Buildings.Rooms.Constructions.BaseClasses.PartialConstruction(
          final AOpa=A-AWin);

        parameter Modelica.SIunits.Area AWin "Heat transfer area of window"
            annotation (Dialog(group="Glazing system"));
        parameter Real fFra(
          min=0,
          max=1) = 0.1 "Fraction of window frame divided by total window area"
          annotation (Dialog(group="Glazing system"));
        final parameter Modelica.SIunits.Area AFra = fFra*AWin "Frame area"
          annotation (Dialog(group="Glazing system"));
        final parameter Modelica.SIunits.Area AGla=AWin - AFra "Glass area"
          annotation (Dialog(group="Glazing system"));
        parameter Boolean linearizeRadiation = true
        "Set to true to linearize emissive power"
          annotation (Dialog(group="Glazing system"));

       replaceable parameter HeatTransfer.Data.GlazingSystems.Generic glaSys
        "Material properties of glazing system"
          annotation (Dialog(group="Glazing system"), Evaluate=true, choicesAllMatching=true, Placement(transformation(extent={{140,80},
                  {160,100}})));

        HeatTransfer.Conduction.MultiLayer opa(
          final A=AOpa,
          final layers=layers,
          final steadyStateInitial=steadyStateInitial,
          final T_a_start=T_a_start,
          final T_b_start=T_b_start)
        "Model for heat transfer through opaque construction"
          annotation (Placement(transformation(extent={{-52,148},{52,252}})));

        HeatTransfer.Windows.Window win(
          final glaSys=glaSys,
          final A=AWin,
          final fFra=fFra,
          final linearize = linearizeRadiation,
          final til=til) "Window model"
          annotation (Placement(transformation(extent={{-114,-184},{112,42}})));

        HeatTransfer.Interfaces.RadiosityOutflow JOutUns_a
        "Outgoing radiosity that connects to unshaded part of glass at exterior side"
          annotation (Placement(transformation(extent={{-300,-30},{-320,-10}}),
              iconTransformation(extent={{-300,-30},{-320,-10}})));
        HeatTransfer.Interfaces.RadiosityInflow JInUns_a
        "Incoming radiosity that connects to unshaded part of glass at exterior side"
          annotation (Placement(transformation(extent={{-320,10},{-300,30}}),
              iconTransformation(extent={{-320,10},{-300,30}})));
        HeatTransfer.Interfaces.RadiosityOutflow JOutSha_a if haveShade
        "Outgoing radiosity that connects to shaded part of glass at exterior side"
          annotation (Placement(transformation(extent={{-300,-210},{-320,-190}}),
              iconTransformation(extent={{-300,-210},{-320,-190}})));
        HeatTransfer.Interfaces.RadiosityInflow JInSha_a if haveShade
        "Incoming radiosity that connects to shaded part of glass at exterior side"
          annotation (Placement(transformation(extent={{-320,-170},{-300,-150}}),
              iconTransformation(extent={{-320,-170},{-300,-150}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a glaUns_a
        "Heat port at unshaded glass of exterior-facing surface"
                                                          annotation (Placement(transformation(extent={{-310,
                  -90},{-290,-70}},
                             rotation=0), iconTransformation(extent={{-310,-90},{-290,
                  -70}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a glaSha_a if haveShade
        "Heat port at shaded glass of exterior-facing surface"
          annotation (Placement(transformation(extent={{-310,-130},{-290,-110}}, rotation=0),
              iconTransformation(extent={{-310,-130},{-290,-110}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a fra_a
        "Heat port at frame of exterior-facing surface"                                     annotation (Placement(transformation(extent={{-310,
                  -270},{-290,-250}},
                             rotation=0), iconTransformation(extent={{-310,-270},{-290,
                  -250}})));
        Modelica.Blocks.Interfaces.RealInput uSha(min=0, max=1) if
             haveShade
        "Control signal for the shading device, 0: unshaded; 1: fully shaded (removed if no shade is present)"
          annotation (Placement(transformation(extent={{-340,40},{-300,80}}),
              iconTransformation(extent={{-340,40},{-300,80}})));
        HeatTransfer.Interfaces.RadiosityOutflow JOutUns_b
        "Outgoing radiosity that connects to unshaded part of glass at room-side"
          annotation (Placement(transformation(extent={{300,10},{320,30}}),
              iconTransformation(extent={{300,10},{320,30}})));
        HeatTransfer.Interfaces.RadiosityInflow JInUns_b
        "Incoming radiosity that connects to unshaded part of glass at room-side"
          annotation (Placement(transformation(extent={{320,-30},{300,-10}}),
              iconTransformation(extent={{320,-30},{300,-10}})));
        HeatTransfer.Interfaces.RadiosityOutflow JOutSha_b if haveShade
        "Outgoing radiosity that connects to shaded part of glass at room-side"
          annotation (Placement(transformation(extent={{300,-170},{320,-150}}),
              iconTransformation(extent={{300,-170},{320,-150}})));
        HeatTransfer.Interfaces.RadiosityInflow JInSha_b if haveShade
        "Incoming radiosity that connects to shaded part of glass at room-side"
          annotation (Placement(transformation(extent={{320,-210},{300,-190}}),
              iconTransformation(extent={{320,-210},{300,-190}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b glaUns_b
        "Heat port at unshaded glass of room-facing surface"
                                                      annotation (Placement(transformation(extent={{290,-90},
                  {310,-70}},
                            rotation=0), iconTransformation(extent={{290,-90},{310,-70}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b glaSha_b if haveShade
        "Heat port at shaded glass of room-facing surface"
        annotation (Placement(transformation(extent={{290,-130},{310,-110}},rotation=0),
              iconTransformation(extent={{290,-130},{310,-110}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b fra_b
        "Heat port at frame of room-facing surface"
          annotation (Placement(transformation(extent={{292,-270},{312,-250}},
                            rotation=0), iconTransformation(extent={{292,-270},{312,-250}})));

    protected
        final parameter Boolean haveShade = glaSys.haveExteriorShade or glaSys.haveInteriorShade
        "Parameter, equal to true if the window has a shade"
          annotation(Evaluate=true);

    public
        Modelica.Blocks.Interfaces.RealInput QAbsUns_flow[glaSys.nLay](each unit="W",
            each quantity="Power")
        "Solar radiation absorbed by unshaded part of glass" annotation (Placement(
              transformation(
              extent={{-20,-20},{20,20}},
              rotation=90,
              origin={-40,-320}), iconTransformation(
              extent={{-20,-20},{20,20}},
              rotation=90,
              origin={-80,-320})));
        Modelica.Blocks.Interfaces.RealInput QAbsSha_flow[glaSys.nLay](each unit="W",
            each quantity="Power") if haveShade
        "Solar radiation absorbed by shaded part of glass"
                                              annotation (Placement(transformation(
              extent={{-20,-20},{20,20}},
              rotation=90,
              origin={100,-320}),iconTransformation(
              extent={{-20,-20},{20,20}},
              rotation=90,
              origin={80,-320})));

      equation
        connect(win.uSha, uSha) annotation (Line(
            points={{-125.3,19.4},{-178.75,19.4},{-178.75,60},{-320,60}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(JInUns_a, win.JInUns_a) annotation (Line(
            points={{-310,20},{-200,20},{-200,-3.2},{-119.65,-3.2}},
            color={0,0,0},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(JOutUns_a, win.JOutUns_a) annotation (Line(
            points={{-310,-20},{-220,-20},{-220,-25.8},{-119.65,-25.8}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(win.glaUns_a, glaUns_a) annotation (Line(
            points={{-114,-59.7},{-200,-59.7},{-200,-80},{-300,-80}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(win.glaSha_a, glaSha_a) annotation (Line(
            points={{-114,-82.3},{-180,-82.3},{-180,-120},{-300,-120}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(win.JInSha_a, JInSha_a) annotation (Line(
            points={{-119.65,-104.9},{-162,-104.9},{-162,-160},{-310,-160}},
            color={0,0,0},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(win.JOutSha_a, JOutSha_a) annotation (Line(
            points={{-119.65,-127.5},{-139.375,-127.5},{-139.375,-200},{-310,-200}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(win.fra_a, fra_a) annotation (Line(
            points={{-114,-161.4},{-128,-161.4},{-128,-260},{-300,-260}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(win.JOutUns_b, JOutUns_b) annotation (Line(
            points={{117.65,-3.2},{225.375,-3.2},{225.375,20},{310,20}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(win.JInUns_b, JInUns_b) annotation (Line(
            points={{117.65,-25.8},{233.375,-25.8},{233.375,-20},{310,-20}},
            color={0,0,0},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(win.glaUns_b, glaUns_b) annotation (Line(
            points={{112,-59.7},{239,-59.7},{239,-80},{300,-80}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(win.glaSha_b, glaSha_b) annotation (Line(
            points={{112,-82.3},{220,-82.3},{220,-120},{300,-120}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(win.JOutSha_b, JOutSha_b) annotation (Line(
            points={{117.65,-104.9},{201.375,-104.9},{201.375,-160},{310,-160}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(win.JInSha_b, JInSha_b) annotation (Line(
            points={{117.65,-127.5},{178.375,-127.5},{178.375,-200},{310,-200}},
            color={0,0,0},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(win.fra_b, fra_b) annotation (Line(
            points={{113.13,-161.4},{159.675,-161.4},{159.675,-260},{302,-260}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(opa.port_a, opa_a)                 annotation (Line(
            points={{-52,200},{-300,200}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(opa.port_b, opa_b)                 annotation (Line(
            points={{52,200},{302,200}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(win.QAbsUns_flow, QAbsUns_flow) annotation (Line(
            points={{-46.2,-195.3},{-46.2,-280},{-40,-280},{-40,-320}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(win.QAbsSha_flow, QAbsSha_flow) annotation (Line(
            points={{44.2,-195.3},{44.2,-280},{100,-280},{100,-320}},
            color={0,0,127},
            smooth=Smooth.None));
        annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-300,
                  -300},{300,300}},
              initialScale=0.1), graphics),
                                Icon(coordinateSystem(preserveAspectRatio=true,
                extent={{-300,-300},{300,300}},
              initialScale=0.1), graphics={
              Rectangle(
                extent={{-290,202},{298,198}},
                lineColor={0,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                visible=  glaSys.haveInteriorShade,
                points={{48,60},{48,-40},{116,-104},{116,-4},{48,60}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillPattern=FillPattern.CrossDiag,
                fillColor={215,215,215}),
              Line(
                points={{-74,-188},{28,-188}},
                color={0,0,0},
                smooth=Smooth.None),
              Polygon(
                points={{28,60},{28,-188},{90,-252},{90,-4},{28,60}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{38,38},{38,-184},{78,-224},{78,-4},{38,38}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={170,213,255},
                fillPattern=FillPattern.Solid),
              Line(
                points={{-102,60},{48,60}},
                color={0,0,0},
                smooth=Smooth.None),
              Polygon(
                points={{-20,60},{-20,-188},{42,-252},{42,-4},{-20,60}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-10,38},{-10,-184},{30,-224},{30,-4},{-10,38}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={170,213,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-74,60},{-74,-188},{-12,-252},{-12,-4},{-74,60}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-64,36},{-64,-186},{-24,-226},{-24,-6},{-64,36}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={170,213,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                visible=  glaSys.haveExteriorShade,
                points={{-102,60},{-102,-40},{-34,-104},{-34,-4},{-102,60}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillPattern=FillPattern.CrossDiag,
                fillColor={215,215,215}),
              Line(
                points={{-34,-4},{116,-4}},
                color={0,0,0},
                smooth=Smooth.None),
              Line(
                visible=  glaSys.haveExteriorShade,
                points={{56,-80},{290,-80}},
                color={160,0,0},
                smooth=Smooth.None),
              Line(
                visible=  glaSys.haveExteriorShade,
                points={{-290,-80},{-56,-80}},
                color={160,0,0},
                smooth=Smooth.None),
              Line(
                visible=  glaSys.haveExteriorShade,
                points={{-294,-120},{-44,-120}},
                color={160,0,0},
                smooth=Smooth.None),
              Line(
                visible=  glaSys.haveExteriorShade,
                points={{60,-120},{296,-120}},
                color={160,0,0},
                smooth=Smooth.None),
              Line(
                visible=  glaSys.haveExteriorShade,
                points={{-60,-200},{-60,-260}},
                color={160,0,0},
                smooth=Smooth.None),
              Line(
                visible=  glaSys.haveExteriorShade,
                points={{84,-218},{84,-260}},
                color={160,0,0},
                smooth=Smooth.None),
              Line(
                visible=  glaSys.haveExteriorShade,
                points={{84,-260},{302,-260}},
                color={160,0,0},
                smooth=Smooth.None),
              Line(
                visible=  glaSys.haveExteriorShade,
                points={{-292,-260},{-60,-260}},
                color={160,0,0},
                smooth=Smooth.None),
              Rectangle(
                extent={{-62,270},{-44,156}},
                lineColor={0,0,0},
                fillColor={192,192,192},
                fillPattern=FillPattern.Backward),
              Rectangle(
                extent={{42,270},{60,156}},
                lineColor={0,0,0},
                fillColor={192,192,192},
                fillPattern=FillPattern.Backward),
              Rectangle(
                extent={{8,276},{68,76}},
                lineColor={0,0,0},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-48,276},{8,76}},
                lineColor={0,0,0},
                fillColor={183,183,121},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-72,276},{-48,76}},
                lineColor={0,0,0},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-48,276},{-62,290},{-10,290},{8,276},{-48,276}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={183,183,121},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-72,276},{-80,290},{-62,290},{-48,276},{-72,276}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{8,276},{-10,290},{48,290},{68,276},{8,276}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-80,290},{-80,98},{-72,76},{-72,276},{-80,290}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
                                     Ellipse(
                extent={{-222,68},{-160,4}},
                lineColor={255,255,0},
                fillColor={255,213,170},
                fillPattern=FillPattern.Sphere)}),
      defaultComponentName="conWin",
      Documentation(revisions="<html>
<ul>
<li>
December 6 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>",       info="<html>
This model is used to compute heat transfer through constructions with windows inside the 
room model.
</p>
<p>
The model consists of the following two main submodels:
<ul>
<li>
The instance <code>opa</code>, which uses the model 
<a href=\"modelica://Buildings.HeatTransfer.Conduction.MultiLayer\">
Buildings.HeatTransfer.Conduction.MultiLayer</a> to compute
the heat transfer through the opaque part of the construction.
This model uses the record <code>layers</code> to access the material properties
of the opaque construction.
</li>
<li>
The instance <code>win</code>, which uses the model
<a href=\"modelica://Buildings.HeatTransfer.Windows.Window\">
Buildings.HeatTransfer.Windows.Window</a> to compute
the heat transfer through the glazing system.
This model uses the record <code>glaSys</code> to access the material properties
of the glazing system.
</li>
</ul>
</p>
<p>
The parameter <code>A</code> is the area of the opaque construction plus the window.
The parameter <code>AWin</code> is the area of the glazing system, including the frame.
The area of the opaque construction is assigned internally as <code>AOpa=A-AWin</code>.
</p>
</html>"));
      end ConstructionWithWindow;

      model Construction "Model for an opaque construction that has no window"
        extends Buildings.Rooms.Constructions.BaseClasses.PartialConstruction(
          final AOpa=A);

        annotation (
      defaultComponentName="conOpa",
      Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-300,-300},
                  {300,300}},
              initialScale=0.1), graphics),
                                Icon(coordinateSystem(preserveAspectRatio=true,
                extent={{-300,-300},{300,300}},
              initialScale=0.1), graphics={
              Rectangle(
                extent={{-290,202},{298,198}},
                lineColor={0,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{0,260},{60,60}},
                lineColor={0,0,0},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-56,260},{0,60}},
                lineColor={0,0,0},
                fillColor={183,183,121},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-80,260},{-56,60}},
                lineColor={0,0,0},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-56,260},{-70,274},{-18,274},{0,260},{-56,260}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={183,183,121},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-80,260},{-88,274},{-70,274},{-56,260},{-80,260}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{0,260},{-18,274},{40,274},{60,260},{0,260}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-88,274},{-88,82},{-80,60},{-80,260},{-88,274}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid)}),
          Documentation(
          info="<html>
This model is used to compute heat transfer through opaque constructions inside the 
room model.
The model uses the record <code>layers</code> to access the material properties
of the opaque construction. The heat transfer is computed in the instance
<code>opa</code>, which uses the model 
<a href=\"modelica://Buildings.HeatTransfer.Conduction.MultiLayer\">
Buildings.HeatTransfer.Conduction.MultiLayer</a>.
</html>",
      revisions="<html>
<ul>
<li>
December 6 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
      end Construction;

      package BaseClasses
      "Package with base classes for Buildings.Rooms.Constructions"
        extends Modelica.Icons.BasesPackage;

        partial model PartialConstruction
        "Partial model for exterior construction that has no window"

          parameter Modelica.SIunits.Area A "Heat transfer area";
          parameter Modelica.SIunits.Area AOpa
          "Heat transfer area of opaque construction"
            annotation (Dialog(group="Opaque construction"));

          replaceable parameter
          Buildings.HeatTransfer.Data.OpaqueConstructions.Generic
            layers "Material properties of opaque construction"
            annotation(Dialog(group="Opaque construction"),
                       Evaluate=true, choicesAllMatching=true, Placement(transformation(extent={{146,258},
                    {166,278}})));

          parameter Modelica.SIunits.Angle til "Surface tilt";

          final parameter Boolean isFloor=til > 2.74889125 and til < 3.53428875
          "Flag, true if construction is a floor"   annotation (Evaluate=true);
          final parameter Boolean isCeiling=til > -0.392699 and til < 0.392699
          "Flag, true if construction is a floor"   annotation (Evaluate=true);
      public
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a opa_a
          "Heat port at surface a of opaque construction"
            annotation (Placement(transformation(extent={{-310,190},{-290,210}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b opa_b
          "Heat port at surface b of opaque construction"
            annotation (Placement(transformation(extent={{292,190},{312,210}})));

          final parameter Integer nLay(min=1, fixed=true) = layers.nLay
          "Number of layers";
          final parameter Integer nSta[nLay](min=1)={layers.material[i].nSta for i in 1:nLay}
          "Number of states"    annotation(Evaluate=true);
          parameter Boolean steadyStateInitial=false
          "=true initializes dT(0)/dt=0, false initializes T(0) at fixed temperature using T_a_start and T_b_start"
                annotation (Dialog(group="Initialization"), Evaluate=true);
          parameter Modelica.SIunits.Temperature T_a_start=293.15
          "Initial temperature at port_a, used if steadyStateInitial = false"
            annotation (Dialog(group="Initialization", enable=not steadyStateInitial));
          parameter Modelica.SIunits.Temperature T_b_start=293.15
          "Initial temperature at port_b, used if steadyStateInitial = false"
            annotation (Dialog(group="Initialization", enable=not steadyStateInitial));

      public
          HeatTransfer.Conduction.MultiLayer opa(
            final A=AOpa,
            final layers=layers,
            final steadyStateInitial=steadyStateInitial,
            final T_a_start=T_a_start,
            final T_b_start=T_b_start)
          "Model for heat transfer through opaque construction"
            annotation (Placement(transformation(extent={{-52,148},{52,252}})));

        equation
          connect(opa.port_a, opa_a) annotation (Line(
              points={{-52,200},{-300,200}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(opa.port_b, opa_b) annotation (Line(
              points={{52,200},{302,200}},
              color={191,0,0},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-300,-300},
                    {300,300}},
                initialScale=0.1), graphics),
                                  Icon(coordinateSystem(preserveAspectRatio=true,
                  extent={{-300,-300},{300,300}},
                initialScale=0.1), graphics={
                Rectangle(
                  extent={{-290,202},{298,198}},
                  lineColor={0,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-70,254},{-52,140}},
                  lineColor={0,0,0},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Backward),
                Polygon(
                  points={{2,208},{4,208},{6,204},{8,198},{8,194},{6,188},{0,184},{-4,180},
                      {-12,178},{-16,182},{-22,188},{-24,198},{-22,204},{-20,208},{-18,210},
                      {-16,212},{-12,214},{-8,214},{-2,212},{2,208}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{34,254},{52,140}},
                  lineColor={0,0,0},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Backward),
                Text(
                  extent={{-314,336},{286,302}},
                  lineColor={0,0,255},
                  textString="%name")}),
            Documentation(info="<html>
<p>
This is the base class that is used to model opaque constructions in the room model.
</p>
<p>
The surface azimuth is defined in 
<a href=\"modelica://Buildings.HeatTransfer.Types.Azimuth\">
Buildings.HeatTransfer.Types.Azimuth</a>
and the surface tilt is defined in <a href=\"modelica://Buildings.HeatTransfer.Types.Tilt\">
Buildings.HeatTransfer.Types.Tilt</a>
</p>
</html>",         revisions="<html>
<ul>
<li>
December 14, 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end PartialConstruction;
      annotation (preferedView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Rooms.Constructions\">Buildings.Rooms.Constructions</a>.
</p>
</html>"));
      end BaseClasses;
      annotation (
      preferedView="info", Documentation(info="<html>
This package contains models for constructions that are
used in the room model.
</html>"));
    end Constructions;

    package BaseClasses "Package with base classes for Buildings.Rooms"
      extends Modelica.Icons.BasesPackage;

      model ExteriorBoundaryConditions
      "Model for convection and radiation bounary condition of exterior constructions"
        parameter Integer nCon(min=1) "Number of exterior constructions"
        annotation (Dialog(group="Exterior constructions"));
        parameter Modelica.SIunits.Angle lat "Latitude";
        parameter Modelica.SIunits.Angle til[nCon]
        "Surface tilt (0 if the surface is a roof)";
        parameter Modelica.SIunits.Angle azi[nCon] "Surface azimuth";

        parameter Modelica.SIunits.Area AOpa[nCon]
        "Areas of exterior constructions (excluding the window area)";
        parameter Boolean linearizeRadiation
        "Set to true to linearize emissive power";
        parameter Modelica.SIunits.Emissivity absIR[nCon]
        "Infrared absorptivity of building surface";
        parameter Modelica.SIunits.Emissivity absSol[nCon]
        "Solar absorptivity of building surface";

        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a opa_a[nCon]
        "Heat port at surface a of opaque construction"
          annotation (Placement(transformation(extent={{-310,190},{-290,210}})));
        parameter Buildings.HeatTransfer.Types.ExteriorConvection conMod=
        Buildings.HeatTransfer.Types.ExteriorConvection.TemperatureWind
        "Convective heat transfer model for opaque part of the constructions"
          annotation (Dialog(group="Convective heat transfer"));
        parameter Modelica.SIunits.CoefficientOfHeatTransfer hFixed=10.0
        "Constant convection coefficient for opaque part of the constructions"
          annotation (Dialog(group="Convective heat transfer",
                             enable=(conMod == Buildings.HeatTransfer.Types.ExteriorConvection.Fixed)));

        // The convection coefficients are not final to allow a user to individually
        // assign them.
        // We reassign the tilt since a roof has been declared in the room model as the
        // ceiling (of the room)
        HeatTransfer.Convection.Exterior conOpa[nCon](
          final A=AOpa,
          final til=Modelica.Constants.pi*ones(nCon) - til,
          final azi=azi,
          each conMod=conMod,
          each hFixed=hFixed) "Convection model for opaque part of the wall"
          annotation (Placement(transformation(extent={{-180,160},{-140,200}})));

        SkyRadiationExchange skyRadExc(
          final n=nCon,
          each final A=AOpa,
          each final absIR=absIR,
          vieFacSky={(Modelica.Constants.pi - til[i])./Modelica.Constants.pi for i in 1:nCon})
        "Infrared radiative heat exchange with sky"
          annotation (Placement(transformation(extent={{-140,240},{-180,280}})));
        BoundaryConditions.WeatherData.Bus weaBus
          annotation (Placement(transformation(extent={{234,32},{254,52}}),
              iconTransformation(extent={{192,-10},{254,52}})));

        BoundaryConditions.SolarIrradiation.DirectTiltedSurface HDirTil[
                  nCon](
          each final lat=lat,
          final til=til,
          final azi=azi) "Direct solar irradiation on the surface"
          annotation (Placement(transformation(extent={{100,120},{80,140}})));
        BoundaryConditions.SolarIrradiation.DiffusePerez HDifTil[nCon](
          each final lat=lat,
          final til=til,
          final azi=azi) "Diffuse solar irradiation"
          annotation (Placement(transformation(extent={{100,80},{80,100}})));
        Modelica.Blocks.Math.Add HTotConExt[nCon](
          final k1=absSol .* AOpa,
          final k2=absSol .* AOpa) "Total solar irradiation"
          annotation (Placement(transformation(extent={{40,100},{20,120}})));
        Buildings.HeatTransfer.Sources.PrescribedHeatFlow solHeaGaiConExt[nCon]
        "Total solar heat gain of the surface"
          annotation (Placement(transformation(extent={{0,100},{-20,120}})));

    protected
        Buildings.HeatTransfer.Sources.PrescribedTemperature TAirConExt[
          nCon] "Outside air temperature for exterior constructions"
          annotation (Placement(transformation(extent={{8,160},{-32,200}})));
        Modelica.Blocks.Routing.Replicator repConExt(nout=nCon)
        "Signal replicator"
          annotation (Placement(transformation(extent={{100,170},{80,190}})));

        Modelica.Blocks.Routing.Replicator repConExt1(
                                                     nout=nCon)
        "Signal replicator"
          annotation (Placement(transformation(extent={{130,200},{110,220}})));
        Modelica.Blocks.Routing.Replicator repConExt2(
                                                     nout=nCon)
        "Signal replicator"
          annotation (Placement(transformation(extent={{180,220},{160,240}})));
      equation
        connect(conOpa.solid, opa_a) annotation (Line(
            points={{-180,180},{-240,180},{-240,200},{-300,200}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(skyRadExc.port, opa_a) annotation (Line(
            points={{-180,261.6},{-212,261.6},{-212,260},{-240,260},{-240,200},{-300,200}},
            color={191,0,0},
            smooth=Smooth.None));

        connect(TAirConExt.port, conOpa.fluid) annotation (Line(
            points={{-32,180},{-140,180}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(repConExt.y, TAirConExt.T) annotation (Line(
            points={{79,180},{12,180}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(repConExt.u, weaBus.TDryBul) annotation (Line(
            points={{102,180},{244,180},{244,42}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(skyRadExc.TOut, weaBus.TDryBul) annotation (Line(
            points={{-136,252},{244,252},{244,42}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(skyRadExc.TBlaSky, weaBus.TBlaSky) annotation (Line(
            points={{-136,268},{244,268},{244,42}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        for i in 1:nCon loop
        connect(weaBus, HDirTil[i].weaBus) annotation (Line(
            points={{244,42},{244,130},{100,130}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(HDifTil[i].weaBus, weaBus) annotation (Line(
            points={{100,90},{244,90},{244,42}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
         end for;
        connect(HTotConExt.y, solHeaGaiConExt.Q_flow) annotation (Line(
            points={{19,110},{5.55112e-16,110}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(solHeaGaiConExt.port, opa_a) annotation (Line(
            points={{-20,110},{-240,110},{-240,200},{-300,200}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(HDirTil.H, HTotConExt.u1) annotation (Line(
            points={{79,130},{60,130},{60,116},{42,116}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(HDifTil.H, HTotConExt.u2) annotation (Line(
            points={{79,90},{60,90},{60,104},{42,104}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(repConExt2.u, weaBus.winDir) annotation (Line(
            points={{182,230},{244,230},{244,42}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(repConExt1.u, weaBus.winSpe) annotation (Line(
            points={{132,210},{244,210},{244,42}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(repConExt1.y, conOpa.v) annotation (Line(
            points={{109,210},{-194,210},{-194,200},{-184,200}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(repConExt2.y, conOpa.dir) annotation (Line(
            points={{159,230},{-200,230},{-200,190},{-184,190}},
            color={0,0,127},
            smooth=Smooth.None));
        annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-300,-300},
                  {300,300}},
              initialScale=0.1), graphics),
                                Icon(coordinateSystem(preserveAspectRatio=true,
                extent={{-300,-300},{300,300}},
              initialScale=0.1), graphics={
              Rectangle(
                extent={{-160,280},{280,-250}},
                fillColor={230,243,255},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
                                     Ellipse(
                extent={{164,262},{270,162}},
                lineColor={255,255,0},
                fillColor={255,213,170},
                fillPattern=FillPattern.Sphere),
              Rectangle(
                extent={{-220,280},{-160,-280}},
                lineColor={0,0,0},
                fillColor={175,175,175},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-160,-250},{280,-280}},
                lineColor={0,0,0},
                fillColor={0,127,0},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-168,346},{212,280}},
                lineColor={0,0,255},
                textString="%name")}),
              Documentation(info="<html>
This model computes the boundary conditions for the outside-facing surface of
opaque constructions.
</p>
<p>
The model computes the infrared, solar, and convective heat exchange
between these surfaces and the exterior temperature and the sky temperature.
Input into this model are weather data that may be obtained from
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData\">
Buildings.BoundaryConditions.WeatherData</a>.
</p>
<p>
In this model, the solar radiation data are converted from horizontal irradiation to
irradiation on tilted surfaces using models from the package
<a href=\"modelica://Buildings.BoundaryConditions.SolarIrradiation\">
Buildings.BoundaryConditions.SolarIrradiation</a>.
The convective heat transfer between the exterior surface of the opaque constructions
is computed using
<a href=\"modelica://Buildings.HeatTransfer.Convection\">
Buildings.HeatTransfer.Convection</a>.
</p>
<p>
The heat transfer of windows are not computed in this model. They are implemented in
<a href=\"modelica:Buildings.Rooms.BaseClasses.ExteriorBoundaryConditionsWithWindow\">
Buildings.Rooms.BaseClasses.ExteriorBoundaryConditionsWithWindow</a>.
</p>
</html>",     revisions="<html>
<ul>
<li>
August 9, 2011 by Michael Wetter:<br>
Changed assignment of tilt in instance <code>conOpa</code>.
This fixes the bug in <a href=\"https://corbu.lbl.gov/trac/bie/ticket/35\">ticket 35</a>
that led to the wrong solar radiation gain for roofs and floors. 
(Since the tilt has been changed in the model 
<a href=\"modelica://Buildings.Rooms.MixedAir\">
Buildings.Rooms.MixedAir</a> at the place where it makes an instance of this model, 
the change in the tilt parameter of the convective heat transfer model was required.)
</li>
<li>
March 28, 2011, by Michael Wetter:<br>
Propaged parameter <code>hFixed</code> to top-level of the model.
</li>
<li>
March 23, 2011, by Michael Wetter:<br>
Removed default value for convection model.
</li>
<li>
November 23, 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
      end ExteriorBoundaryConditions;

      model ExteriorBoundaryConditionsWithWindow
      "Model for exterior boundary conditions for constructions with a window"
        extends Buildings.Rooms.BaseClasses.ExteriorBoundaryConditions;
        parameter Modelica.SIunits.Area AWin[nCon]
        "Areas of window glass and frame";
        parameter Real fFra[nCon](each min=0, each max=1)
        "Fraction of window frame divided by total window area"
          annotation (Dialog(group="Frame"));

        parameter Modelica.SIunits.Emissivity absSolFra[nCon]
        "Solar absorptivity of window frame"
          annotation (Dialog(group="Frame"));
        parameter Modelica.SIunits.Emissivity absIRFra[nCon]
        "Infrared absorptivity of window frame"
          annotation (Dialog(group="Frame"));
        parameter Modelica.SIunits.Emissivity absIRSha_air[nCon]
        "Infrared absorptivity of shade surface that faces air"
              annotation (Dialog(group="Shading"));
        parameter Modelica.SIunits.Emissivity absIRSha_glass[nCon]
        "Infrared absorptivity of shade surface that faces glass"
          annotation (Dialog(group="Shading"));

        parameter Modelica.SIunits.TransmissionCoefficient tauIRSha_air[nCon]
        "Infrared transmissivity of shade for radiation coming from the exterior or the room"
          annotation (Dialog(group="Shading"));
        parameter Modelica.SIunits.TransmissionCoefficient tauIRSha_glass[nCon]
        "Infrared transmissivity of shade for radiation coming from the glass"
          annotation (Dialog(group="Shading"));

        parameter Boolean haveExteriorShade[nCon]
        "Set to true if window has exterior shade (at surface a)"
          annotation (Dialog(group="Shading"));
        parameter Boolean haveInteriorShade[nCon]
        "Set to true if window has interior shade (at surface b)"
          annotation (Dialog(group="Shading"));

        final parameter Boolean windowHasShade=
          haveExteriorShade[1] or haveInteriorShade[1]
        "Set to true if window system has a shade"
          annotation (Dialog(group="Shading"), Evaluate=true);

        Modelica.Blocks.Interfaces.RealInput uSha[nCon](min=0, max=1) if
             windowHasShade
        "Control signal for the shading device, 0: unshaded; 1: fully shaded"
          annotation (Placement(transformation(extent={{-340,80},{-300,120}}),
              iconTransformation(extent={{-340,80},{-300,120}})));

        Modelica.Blocks.Interfaces.RealInput QAbsSolSha_flow[nCon](
          final unit="W", quantity="Power") "Solar radiation absorbed by shade"
          annotation (Placement(transformation(extent={{-340,40},{-300,80}})));

        HeatTransfer.Windows.ExteriorHeatTransfer conExtWin[nCon](
          final A=AWin,
          final fFra=fFra,
          each final linearizeRadiation = linearizeRadiation,
          final F_sky={(Modelica.Constants.pi - til[i]) ./ Modelica.Constants.pi for i in 1:nCon},
          final absIRSha_air=absIRSha_air,
          final absIRSha_glass=absIRSha_glass,
          final tauIRSha_air=tauIRSha_air,
          final tauIRSha_glass=tauIRSha_glass,
          final haveExteriorShade=haveExteriorShade,
          final haveInteriorShade=haveInteriorShade)
        "Exterior convection of the window"
          annotation (Placement(transformation(extent={{20,-120},{-40,-60}})));

        SkyRadiationExchange skyRadExcWin(
          final n=nCon,
          each final absIR=absIRFra,
          vieFacSky={(Modelica.Constants.pi - til[i]) ./ Modelica.Constants.pi for i in
                  1:nCon},
          each final A=AWin .* fFra)
        "Infrared radiative heat exchange between window frame and sky"
          annotation (Placement(transformation(extent={{-140,-282},{-180,-242}})));
        HeatTransfer.Interfaces.RadiosityOutflow JOutUns[nCon]
        "Outgoing radiosity that connects to unshaded part of glass at exterior side"
          annotation (Placement(transformation(extent={{-300,-30},{-320,-10}}),
              iconTransformation(extent={{-300,-30},{-320,-10}})));
        HeatTransfer.Interfaces.RadiosityInflow JInUns[nCon]
        "Incoming radiosity that connects to unshaded part of glass at exterior side"
          annotation (Placement(transformation(extent={{-320,10},{-300,30}}),
              iconTransformation(extent={{-320,10},{-300,30}})));
        HeatTransfer.Interfaces.RadiosityOutflow JOutSha[nCon] if
             windowHasShade
        "Outgoing radiosity that connects to shaded part of glass at exterior side"
          annotation (Placement(transformation(extent={{-300,-210},{-320,-190}}),
              iconTransformation(extent={{-300,-210},{-320,-190}})));
        HeatTransfer.Interfaces.RadiosityInflow JInSha[nCon] if
             windowHasShade
        "Incoming radiosity that connects to shaded part of glass at exterior side"
          annotation (Placement(transformation(extent={{-320,-170},{-300,-150}}),
              iconTransformation(extent={{-320,-170},{-300,-150}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a glaUns[nCon]
        "Heat port at unshaded glass of exterior-facing surface"
                                                          annotation (Placement(transformation(extent={{-310,
                  -90},{-290,-70}},
                             rotation=0), iconTransformation(extent={{-310,-90},{-290,
                  -70}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a glaSha[nCon] if
             windowHasShade
        "Heat port at shaded glass of exterior-facing surface"
          annotation (Placement(transformation(extent={{-310,-130},{-290,-110}}, rotation=0),
              iconTransformation(extent={{-310,-130},{-290,-110}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a fra[nCon](T(each nominal=
                300, each start=283.15))
        "Heat port at frame of exterior-facing surface"                                     annotation (Placement(transformation(extent={{-310,
                  -270},{-290,-250}},
                             rotation=0), iconTransformation(extent={{-310,-270},{-290,
                  -250}})));
        Modelica.Blocks.Math.Add HTotConExtWinFra[nCon](
           final k1=fFra .* absSolFra .* AWin,
           final k2=fFra .* absSolFra .* AWin)
        "Total solar irradiation on window frame"
          annotation (Placement(transformation(extent={{40,60},{20,80}})));
        Buildings.HeatTransfer.Sources.PrescribedHeatFlow solHeaGaiConWin[nCon]
        "Total solar heat gain of the window frame"
          annotation (Placement(transformation(extent={{0,60},{-20,80}})));
        Modelica.Blocks.Interfaces.RealOutput HDir[nCon](
           each final quantity="RadiantEnergyFluenceRate",
           each final unit="W/m2") "Direct solar irradition on tilted surface"
          annotation (Placement(transformation(extent={{300,110},{320,130}})));
        Modelica.Blocks.Interfaces.RealOutput HDif[nCon](
           each final quantity="RadiantEnergyFluenceRate",
           each final unit="W/m2")
        "Diffuse solar irradiation on tilted surface"
          annotation (Placement(transformation(extent={{300,50},{320,70}})));
        Modelica.Blocks.Interfaces.RealOutput inc[nCon](
          each final quantity="Angle",
          each final unit="rad",
          each displayUnit="deg") "Incidence angle"
          annotation (Placement(transformation(extent={{300,170},{320,190}})));

    protected
        Buildings.HeatTransfer.Sources.PrescribedTemperature TAirConExtWin[
          nCon] "Outside air temperature for window constructions"
          annotation (Placement(transformation(extent={{160,-90},{120,-50}})));
        Modelica.Blocks.Routing.Replicator repConExtWin(final nout=nCon)
        "Signal replicator"
          annotation (Placement(transformation(extent={{200,-80},{180,-60}})));
        Modelica.Blocks.Routing.Replicator repConExtWinF_clr(final nout=nCon)
        "Signal replicator"
          annotation (Placement(transformation(extent={{140,-140},{120,-120}})));
        Modelica.Blocks.Routing.Replicator repConExtWinVWin(final nout=nCon)
        "Signal replicator"
          annotation (Placement(transformation(extent={{140,-22},{120,-2}})));
      equation
        connect(uSha, conExtWin.uSha)
                                annotation (Line(
            points={{-320,100},{-140,100},{-140,-40},{40,-40},{40,-66},{22.4,-66}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(JInUns,conExtWin. JInUns) annotation (Line(
            points={{-310,20},{-200,20},{-200,-72},{-43,-72}},
            color={0,0,0},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(conExtWin.JOutUns,JOutUns)  annotation (Line(
            points={{-43,-66},{-196.45,-66},{-196.45,-20},{-310,-20}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(conExtWin.glaUns,glaUns)  annotation (Line(
            points={{-40,-84},{-192,-84},{-192,-80},{-300,-80}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(conExtWin.glaSha,glaSha)  annotation (Line(
            points={{-40,-96},{-190,-96},{-190,-120},{-300,-120}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(conExtWin.JOutSha,JOutSha)  annotation (Line(
            points={{-43,-108},{-176,-108},{-176,-200},{-310,-200}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(conExtWin.JInSha,JInSha)  annotation (Line(
            points={{-43,-114},{-184.45,-114},{-184.45,-160},{-310,-160}},
            color={0,0,0},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(conExtWin.frame,fra)  annotation (Line(
            points={{-31,-120},{-31,-220},{-260,-220},{-260,-260},{-300,-260}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(TAirConExtWin.port,conExtWin. air) annotation (Line(
            points={{120,-70},{90,-70},{90,-90},{20,-90}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(TAirConExtWin.T,repConExtWin. y) annotation (Line(
            points={{164,-70},{179,-70}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(repConExtWin.u, weaBus.TDryBul) annotation (Line(
            points={{202,-70},{244,-70},{244,42}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(repConExtWinF_clr.y,conExtWin. f_clr) annotation (Line(
            points={{119,-130},{94.5,-130},{94.5,-114},{22.4,-114}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(repConExtWinVWin.y,conExtWin. vWin) annotation (Line(
            points={{119,-12},{108,-12},{108,-78},{22.4,-78}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(repConExtWinVWin.u, weaBus.winSpe) annotation (Line(
            points={{142,-12},{192,-12},{192,-14},{244,-14},{244,42}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(repConExtWinF_clr.u, weaBus.nTot) annotation (Line(
            points={{142,-130},{244,-130},{244,42}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(HTotConExtWinFra.y, solHeaGaiConWin.Q_flow) annotation (Line(
            points={{19,70},{5.55112e-16,70}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(solHeaGaiConWin.port, fra) annotation (Line(
            points={{-20,70},{-60,70},{-60,-220},{-260,-220},{-260,-260},{-300,-260}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(HDirTil.H, HDir) annotation (Line(
            points={{79,130},{72,130},{72,180},{280,180},{280,120},{310,120}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(HDifTil.H, HDif) annotation (Line(
            points={{79,90},{72,90},{72,60},{310,60}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(HDirTil.inc, inc) annotation (Line(
            points={{79,126},{72,126},{72,180},{310,180}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(HTotConExtWinFra.u2, HDifTil.H) annotation (Line(
            points={{42,64},{72,64},{72,90},{79,90}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(HTotConExtWinFra.u1, HDirTil.H) annotation (Line(
            points={{42,76},{66,76},{66,130},{79,130}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(conExtWin.QAbs_flow, QAbsSolSha_flow) annotation (Line(
            points={{-10,-123},{-10,-140},{-160,-140},{-160,60},{-320,60}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(skyRadExcWin.TOut, weaBus.TDryBul)
                                                annotation (Line(
            points={{-136,-270},{244,-270},{244,42}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(skyRadExcWin.TBlaSky, weaBus.TBlaSky)
                                                   annotation (Line(
            points={{-136,-254},{244,-254},{244,42}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(skyRadExcWin.port, fra) annotation (Line(
            points={{-180,-260.4},{-242,-260.4},{-242,-260},{-300,-260}},
            color={191,0,0},
            smooth=Smooth.None));
        annotation (Icon(graphics={
              Rectangle(
                extent={{-220,180},{-160,-102}},
                lineColor={0,0,0},
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-212,180},{-202,-102}},
                lineColor={0,0,0},
                fillColor={170,213,255},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.Dash),
              Rectangle(
                extent={{-180,180},{-170,-102}},
                lineColor={0,0,0},
                fillColor={170,213,255},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.Dash)}),
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-300,-300},{300,
                  300}}), graphics),
          Documentation(info="<html>
This model computes the boundary conditions for the outside-facing surface of
opaque constructions and of windows.
</p>
<p>
The model computes the infrared, solar, and convective heat exchange
between these surfaces and the exterior temperature and the sky temperature.
Input into this model are weather data that may be obtained from
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData\">
Buildings.BoundaryConditions.WeatherData</a>.
</p>
<p>
This model extends
<a href=\"modelica://Buildings.Rooms.BaseClasses.ExteriorBoundaryConditions\">
Buildings.Rooms.BaseClasses.ExteriorBoundaryConditions</a>,
which models the boundary conditions for the opaque constructions,
and then implements the boundary condition for windows by using
the model
<a href=\"modelica://Buildings.HeatTransfer.Windows.ExteriorHeatTransfer\">
Buildings.HeatTransfer.Windows.ExteriorHeatTransfer</a>.
</html>",       revisions="<html>
<ul>
<li>
August 9, 2011, by Michael Wetter:<br>
Fixed bug that caused too high a surface temperature of the window frame.
The previous version did not compute the infrared radiation exchange between the
window frame and the sky. This has been corrected by adding the instance
<code>skyRadExcWin</code> and adding the parameter <code>absIRFra</code>.
This closes ticket <a href=\"https://corbu.lbl.gov/trac/bie/ticket/36\">ticket 36</a>.
</li>
<li>
November 23, 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
      end ExteriorBoundaryConditionsWithWindow;

      model HeatGain "Model to convert internal heat gain signals"
        extends Buildings.BaseClasses.BaseIcon;

        replaceable package Medium =
           Modelica.Media.Interfaces.PartialMedium "Medium in the component"
            annotation (choicesAllMatching = true);

        parameter Modelica.SIunits.Area AFlo "Floor area";
        parameter Modelica.SIunits.Temperature TWat=273.15+34
        "Temperature at which water vapor is released";

        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a QCon_flow
        "Convective heat gain"      annotation (Placement(transformation(extent={{90,-10},
                  {110,10}},         rotation=0), iconTransformation(extent={{90,-10},
                  {110,10}})));

    public
        Modelica.Blocks.Interfaces.RealInput qGai_flow[3]
        "Radiant, convective and latent heat input into room (positive if heat gain)"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
        Modelica.Blocks.Interfaces.RealOutput QRad_flow "Radiative heat gain"
          annotation (Placement(transformation(extent={{100,50},{120,70}})));
        Modelica.Fluid.Interfaces.FluidPort_b QLat_flow(redeclare final package
          Medium =
              Medium) "Latent heat gain"
          annotation (Placement(transformation(extent={{90,-70},{110,-50}})));
    protected
        Modelica.SIunits.MassFlowRate mWat_flow
        "Water vapor flow rate released by latent gain";

        parameter Modelica.SIunits.SpecificEnergy h_fg = Medium.enthalpyOfCondensingGas(TWat)
        "Latent heat of water vapor";
       // constant Medium.MassFraction Xi[Medium.nXi] = {1}
       //   "Species concentration (water vapor only)";

    protected
        parameter Real s[Medium.nX](fixed=false)
        "Vector with zero everywhere except where water vapor is";
      initial algorithm
        for i in 1:Medium.nX loop
          if ( Modelica.Utilities.Strings.isEqual(string1=Medium.substanceNames[i],
                                                  string2="water",
                                                  caseSensitive=false)) then
            s[i] :=1;
          else
            s[i] :=0;
          end if;
         end for;
         assert(Medium.nX == 1 or abs(1-sum(s)) < 1E-4, "Substance 'water' is not present in medium '"
                        + Medium.mediumName + "'.\n"
                        + "Change medium model to one that has 'water' as a substance.");
      equation
        QRad_flow = qGai_flow[1]*AFlo;
        QCon_flow.Q_flow = -qGai_flow[2]*AFlo;

        // Interface to fluid port
        // If a medium does not contain water vapor, then h_fg is equal to zero.
        if Medium.nXi == 0 or (h_fg == 0) then
          mWat_flow = 0;
        else
          mWat_flow = qGai_flow[3]*AFlo/h_fg;
        end if;

        QLat_flow.C_outflow  = fill(0, Medium.nC);
        QLat_flow.h_outflow  = h_fg;
        QLat_flow.Xi_outflow = s[1:Medium.nXi];
        QLat_flow.m_flow     = if (h_fg > 0) then
                                 -qGai_flow[3]*AFlo/h_fg else
                                  0;

       annotation(Documentation(info="<html>
This model computes the radiant, convective and latent heat flow.
Input into this model are these three components in units of [W/m2].
The inputs need to be positive quantities if heat or moisture is added
to the room.
The outputs are 
<ul>
<li>
the radiant heat flow in Watts,
</li>
<li>
the convective heat flow in Watts, and
</li>
<li>
the water vapor released into the air.
</li>
</ul>
If the medium model does not contain water vapor, then
the water vapor released into the air is zero, i.e., 
the mass flow rate at the fluid port is equal to zero.
</html>",     revisions="<html>
<ul>
<li>
December 6, 2011, by Michael Wetter:<br>
Fixed sign error in convective heat gain that is assigned to 
<code>QCon_flow.Q_flow</code>.
This closes ticket <a href=\"https://corbu.lbl.gov/trac/bie/ticket/46\">ticket 46</a>.
</li>
<li>
April 27, 2011, by Michael Wetter:<br>
Changed assert statement to allow use of model for media without water vapor.
</li>
<li>
June 9, 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),       Icon(graphics={
                  Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
              Line(
                points={{-48,-66},{-24,-18},{0,-68}},
                color={0,0,255},
                smooth=Smooth.None),
              Line(
                points={{-24,-18},{-24,46}},
                color={0,0,255},
                smooth=Smooth.None),
              Line(
                points={{-52,24},{-24,38}},
                color={0,0,255},
                smooth=Smooth.None),
              Line(
                points={{-24,38},{8,22}},
                color={0,0,255},
                smooth=Smooth.None),
              Ellipse(extent={{-40,76},{-8,46}},  lineColor={0,0,255}),
              Text(
                extent={{-98,30},{-38,-26}},
                lineColor={0,0,127},
                textString="q_flow"),
              Text(
                extent={{12,72},{86,50}},
                lineColor={0,0,127},
                textString="QRad_flow"),
              Text(
                extent={{10,12},{84,-10}},
                lineColor={0,0,127},
                textString="QCon_flow"),
              Text(
                extent={{12,-46},{86,-68}},
                lineColor={0,0,127},
                textString="mLat_flow")}),
              Documentation(info = "<html>
This is a dummy model that is required to implement the room
model with a variable number of surface models.
The model is required since arrays of models, such as used for the surfaces
that model the construction outside of the room, 
must have at least one element, unless the whole array
is conditionally removed if its size is zero.
However, conditionally removing the surface models does not work in this
situation since some models, such as for computing the radiative heat exchange
between the surfaces, require access to the area and absorptivity of the surface models.

</html>",     revisions="<html>
<ul>
<li>
February 22, by Michael Wetter:<br>
Improved the code that searches for the index of 'water' in the medium model.
</li>
<li>
June 8 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),Diagram(graphics));
      end HeatGain;

      model InfraredRadiationExchange
      "Infrared radiation heat exchange between the room facing surfaces"
        extends Buildings.Rooms.BaseClasses.PartialSurfaceInterface;

        parameter Boolean linearizeRadiation
        "Set to true to linearize emissive power";
        parameter Boolean homotopyInitialization = true
        "= true, use homotopy method"
          annotation(Evaluate=true, Dialog(tab="Advanced"));

        HeatTransfer.Interfaces.RadiosityInflow JInConExtWin[NConExtWin]
        "Incoming radiosity that connects to non-frame part of the window"
          annotation (Placement(transformation(extent={{260,70},{240,90}})));
        HeatTransfer.Interfaces.RadiosityOutflow JOutConExtWin[NConExtWin]
        "Outgoing radiosity that connects to non-frame part of the window"
          annotation (Placement(transformation(extent={{240,110},{260,130}})));

    protected
        final parameter Integer NOpa = NConExt+2*NConExtWin+2*NConPar+NConBou+NSurBou
        "Number of opaque surfaces, including the window frame";
        final parameter Integer nOpa = nConExt+2*nConExtWin+2*nConPar+nConBou+nSurBou
        "Number of opaque surfaces, including the window frame";
        final parameter Integer NWin = NConExtWin "Number of window surfaces";
        final parameter Integer nWin = nConExtWin "Number of window surfaces";
        final parameter Integer NTot = NOpa + NWin "Total number of surfaces";
        final parameter Integer nTot = nOpa + nWin "Total number of surfaces";
        final parameter Real epsOpa[nOpa](min=0, max=1, fixed=false)
        "Absorptivity of opaque surfaces";
        final parameter Real rhoOpa[nOpa](min=0, max=1, fixed=false)
        "Reflectivity of opaque surfaces";
        final parameter Modelica.SIunits.Area AOpa[nOpa](fixed=false)
        "Surface area of opaque surfaces";
        final parameter Modelica.SIunits.Area A[nTot](fixed=false)
        "Surface areas";
        final parameter Real kOpa[nOpa](unit="W/K4", fixed=false)
        "Product sigma*epsilon*A for opaque surfaces";
        final parameter Real F[nTot,nTot](min=0, max=1, fixed=false)
        "View factor from surface i to j";

        Modelica.SIunits.HeatFlowRate J[nTot](max=0, start=A.*0.8*Modelica.Constants.sigma*293.15^4,
           each nominal=10*0.8*Modelica.Constants.sigma*293.15^4)
        "Radiosity leaving the surface";
        Modelica.SIunits.HeatFlowRate G[nTot](min=0, start=A.*0.8*Modelica.Constants.sigma*293.15^4,
           each nominal=10*0.8*Modelica.Constants.sigma*293.15^4)
        "Radiosity entering the surface";
        constant Real T40(unit="K4") = 293.15^4 "Nominal temperature";
        Modelica.SIunits.Temperature TOpa[nOpa](each start=293.15, each nominal=293.15)
        "Temperature of opaque surfaces";
        Real T4Opa[nOpa](each unit="K4", each start=T40, each nominal=293.15^4)
        "Forth power of temperature of opaque surfaces";
        Modelica.SIunits.HeatFlowRate Q_flow[nTot] "Heat flow rate at surfaces";

        parameter Modelica.SIunits.Temperature T0=293.15
        "Temperature used to linearize radiative heat transfer";
        final parameter Real T03(min=0, unit="K3")=T0^3
        "3rd power of temperature T0"
       annotation(Evaluate=true);
        Modelica.SIunits.HeatFlowRate sumEBal
        "Sum of energy balance, should be zero";

      initial equation
        // The next loops build the array epsOpa, AOpa and kOpa that simplify
        // the model equations.
        // These arrays store the values of the constructios in the following order
        // [x[1:NConExt] x[1:NConPar] x[1: NConPar] x[1: NConBou] x[1: NSurBou] x[1: NConExtWin] x[1: NConExtWin]]
        // where x is epsOpa, AOpa or kOpa.
        // The last two entries are for the opaque wall that contains a window, and for the window frame.
        for i in 1:nConExt loop
          epsOpa[i] = epsConExt[i];
          AOpa[i]   = AConExt[i];
          kOpa[i]   = Modelica.Constants.sigma * epsConExt[i] *AOpa[i];
        end for;
        for i in 1:nConPar loop
          epsOpa[i+nConExt]         = epsConPar_a[i];
          AOpa[i+nConExt]           = AConPar[i];
          kOpa[i+nConExt]           = Modelica.Constants.sigma * epsConPar_a[i] *AOpa[i+nConExt];
          epsOpa[i+nConExt+nConPar] = epsConPar_b[i];
          AOpa[i+nConExt+nConPar]   = AConPar[i];
          kOpa[i+nConExt+nConPar]   = Modelica.Constants.sigma * epsConPar_b[i] *AOpa[i+nConExt+nConPar];
        end for;
        for i in 1:nConBou loop
          epsOpa[i+nConExt+2*nConPar] = epsConBou[i];
          AOpa[i+nConExt+2*nConPar]   = AConBou[i];
          kOpa[i+nConExt+2*nConPar]   = Modelica.Constants.sigma * epsConBou[i] *AOpa[i+nConExt+2*nConPar];
        end for;
        for i in 1:nSurBou loop
          epsOpa[i+nConExt+2*nConPar+nConBou] = epsSurBou[i];
          AOpa[i+nConExt+2*nConPar+nConBou]   = ASurBou[i];
          kOpa[i+nConExt+2*nConPar+nConBou]   = Modelica.Constants.sigma * epsSurBou[i] *AOpa[i+nConExt+2*nConPar+nConBou];
        end for;

        for i in 1:nConExtWin loop
          // Opaque part of construction that has a window embedded
          epsOpa[i+nConExt+2*nConPar+nConBou+nSurBou] = epsConExtWinOpa[i];
          AOpa[i+nConExt+2*nConPar+nConBou+nSurBou]   = AConExtWinOpa[i];
          kOpa[i+nConExt+2*nConPar+nConBou+nSurBou]   = Modelica.Constants.sigma * epsConExtWinOpa[i] *AOpa[i+nConExt+2*nConPar+nConBou+nSurBou];
          // Window frame
          epsOpa[i+nConExt+2*nConPar+nConBou+nSurBou+nConExtWin] = epsConExtWinFra[i];
          AOpa[i+nConExt+2*nConPar+nConBou+nSurBou+nConExtWin]   = AConExtWinFra[i];
          kOpa[i+nConExt+2*nConPar+nConBou+nSurBou+nConExtWin]   = Modelica.Constants.sigma * epsConExtWinFra[i] *AOpa[i+nConExt+2*nConPar+nConBou+nSurBou+nConExtWin];
        end for;
        // Vector with all surface areas.
        // The next loops build the array A that simplifies
        // the model equations.
        // These array stores the values of the constructios in the following order
        // [AOpa[1:nConExt] AOpa[1:nConPar] AOpa[1: nConPar] AOpa[1: nConBou] AOpa[1: nSurBou]
        //  AOpa[1: nConExtWin] AOpa[1: nConExtWin] AGla[1: nConExtWin]]
        // since nWin=nConExtWin.
        for i in 1:nOpa loop
          A[i] = AOpa[i];
        end for;
        for i in 1:nWin loop
          A[i+nOpa] = AConExtWinGla[i];
        end for;
        // Reflectivity for opaque surfaces
        rhoOpa = 1 .- epsOpa;

       // View factors from surface i to surface j
        for i in 1:nTot loop
           for j in 1:nTot loop
             F[i,j] = A[j] /sum((A[k]) for k in 1:nTot);
           end for;
        end for;

        // Test whether the view factors add up to one, or the sum is zero in case there
        // is only one construction
        for i in 1:nTot loop
          assert((abs(1-sum(F[i,j] for j in 1:nTot))) < 1E-10,
                 "Program error: Sum 1 of view factors is " + String(sum(F[i,j] for j in 1:nTot)));
        end for;

      ////////////////////////////////////////////////////////////////////
      equation
        // If the room has no window, then the incoming radiosity from the window
        // is not connected. In this situation, we set it to zero.
        // This approach is easier than using a conditional connector, since
        // this port carries a flow variable, and hence the sign of the radiosity
        // would change in a connect statement.
        if (cardinality(JInConExtWin) == 0) then
          JInConExtWin = zeros(NConExtWin);
        end if;

        // Assign temperature of opaque surfaces
        for i in 1:nConExt loop
          TOpa[i] = conExt[i].T;
        end for;
        for i in 1:nConPar loop
          TOpa[i+nConExt]         = conPar_a[i].T;
          TOpa[i+nConExt+nConPar] = conPar_b[i].T;
        end for;
        for i in 1:nConBou loop
          TOpa[i+nConExt+2*nConPar] = conBou[i].T;
        end for;
        for i in 1:nSurBou loop
          TOpa[i+nConExt+2*nConPar+nConBou] = conSurBou[i].T;
        end for;
        for i in 1:nConExtWin loop
          TOpa[i+nConExt+2*nConPar+nConBou+nSurBou]            = conExtWin[i].T;
          TOpa[i+nConExt+2*nConPar+nConBou+nConExtWin+nSurBou] = conExtWinFra[i].T;
        end for;
        // Incoming radiosity at each surface
        // is equal to the negative of the outgoing radiosity of
        // all other surfaces times the view factor
         G = -transpose(F)*J;

        // Outgoing radiosity
        // Opaque surfaces.
        // If kOpa[j]=absIR[j]*A[j] < 1E-28, then A < 1E-20 and the surface is
        // from a dummy construction. In this situation, we set T40=293.15^4 to
        // avoid a singularity.
        for j in 1:nOpa loop
         //   T4Opa[j] = if (kOpa[j] > 1E-28) then (Q_flow[j]-epsOpa[j] * G[j])/kOpa[j] else T40;
          T4Opa[j] = (-J[j]-rhoOpa[j] * G[j])/kOpa[j];
        end for;

        // 4th power of temperature
        if linearizeRadiation then
          TOpa = T4Opa./T03;
        else
          if homotopyInitialization then
            TOpa = homotopy(actual=Buildings.Utilities.Math.Functions.powerLinearized(x=T4Opa, x0=243.15^4, n=0.25),
              simplified=T4Opa./T03);
          else
            TOpa = Buildings.Utilities.Math.Functions.powerLinearized(x=T4Opa, x0=243.15^4, n=0.25);
          end if;

        end if;
        // Assign radiosity that comes from window
        // and that leaves window.
        // J < 0 because it leaves the surface
        // G > 0 because it strikes the surface
        // JIn > 0 because it enters the model
        // JOut < 0 because it leaves the model
        for j in 1:nWin loop
          J[j+nOpa] = -JInConExtWin[j];
          G[j+nOpa] = -JOutConExtWin[j];
        end for;
        // Net heat exchange
        Q_flow = -J-G;

        // Assign heat exchange to connectors
        for i in 1:nConExt loop
          Q_flow[i] = conExt[i].Q_flow;
        end for;
        if nConExt == 0 then
          conExt[1].T = T0;
        end if;
        for i in 1:nConPar loop
          Q_flow[i+nConExt]         = conPar_a[i].Q_flow;
          Q_flow[i+nConExt+nConPar] = conPar_b[i].Q_flow;
        end for;
        if nConPar == 0 then
          conPar_a[1].T = T0;
          conPar_b[1].T = T0;
        end if;
        for i in 1:nConBou loop
          Q_flow[i+nConExt+2*nConPar] = conBou[i].Q_flow;
        end for;
        if nConBou == 0 then
          conBou[1].T = T0;
        end if;
        for i in 1:nSurBou loop
          Q_flow[i+nConExt+2*nConPar+nConBou] = conSurBou[i].Q_flow;
        end for;
        if nSurBou == 0 then
          conSurBou[1].T = T0;
        end if;
        for i in 1:nConExtWin loop
          Q_flow[i+nConExt+2*nConPar+nConBou+nSurBou]            = conExtWin[i].Q_flow;
          Q_flow[i+nConExt+2*nConPar+nConBou+nSurBou+nConExtWin] = conExtWinFra[i].Q_flow;
        end for;
        if nConExtWin == 0 then
          conExtWin[1].T = T0;
          conExtWinFra[1].T = T0;
          JOutConExtWin[1] = 0;
        end if;

        // Sum of energy balance
        // Remove sumEBal and assert statement for final release
        sumEBal = sum(conExt.Q_flow)+sum(conPar_a.Q_flow)+sum(conPar_b.Q_flow)
          +sum(conBou.Q_flow)+sum(conSurBou.Q_flow)+sum(conExtWin.Q_flow)+sum(conExtWinFra.Q_flow)
          +(sum(JInConExtWin)+sum(JOutConExtWin));
        assert(abs(sumEBal) < 1E-1, "Program error: Energy is not conserved in InfraredRadiationExchange."
         + "\n  Sum of all energy is " + String(sumEBal));
        annotation (
      preferedView="info",
      Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-240,
                  -240},{240,240}}),
                            graphics), Icon(coordinateSystem(preserveAspectRatio=true,
                extent={{-240,-240},{240,240}}),
                                            graphics={
              Line(
                points={{-144,-8},{146,-8}},
                color={255,0,0},
                smooth=Smooth.None,
                thickness=0.5),
              Line(
                points={{-144,-8},{2,184}},
                color={255,0,0},
                smooth=Smooth.None,
                thickness=0.5),
              Line(
                points={{-144,-8},{2,-200}},
                color={255,0,0},
                smooth=Smooth.None,
                thickness=0.5),
              Line(
                points={{2,-200},{2,184}},
                color={255,0,0},
                smooth=Smooth.None,
                thickness=0.5),
              Line(
                points={{2,184},{148,-8}},
                color={255,0,0},
                smooth=Smooth.None,
                thickness=0.5),
              Line(
                points={{2,-200},{148,-8}},
                color={255,0,0},
                smooth=Smooth.None,
                thickness=0.5)}),
      Documentation(
      info="<html>
<p>
This model computes the infrared radiative heat transfer between the interior
surfaces of a room. Each opaque surface emits radiation according to
<p/>
<p align=\"center\" style=\"font-style:italic;\">
  E<sup>i</sup> = &sigma; &nbsp; A<sup>i</sup> &nbsp; &epsilon;<sup>i</sup> &nbsp; 
(T<sup>i</sup>)<sup>4</sup>,
<p/>
<p>
where
<i>&sigma;</i>
is the Stefan-Boltzmann constant,
<i>A<sup>i</sup> </i>
is the surface area,
<i>&epsilon;<sup>i</sup> </i>
is the absorptivity in the infrared spectrum, and
<i>T<sup>i</sup></i>
is the surface temperature.
If the parameter <code>linearizeRadidation</code> is set to <code>true</code>,
then the term <i>(T<sup>i</sup>)<sup>4</sup></i> is replaced with
<i>T<sub>0</sub><sup>3</sup> T<sup>i</sup></i>,
where <i>T<sub>0</sub> = 20&deg;C</i> is a parameter.
</p>
<p>
The incoming radiation at surface <i>i</i> is
<p/>
<p align=\"center\" style=\"font-style:italic;\">
  G<sup>i</sup> = -&sum;<sub>j</sub> &nbsp; F<sup>j,i</sup> &nbsp; J<sup>j</sup>
<p/>
<p>
where 
<i>F<sup>j,i</sup></i> 
is the view factor from surface
<i>j</i> to surface <i>i</i>, 
<i>J<sup>j</sup></i> 
is the radiosity leaving surface <i>j</i>
and the sum is over all surfaces.
For opaque surfaces, it follows from the first law
that the radiosity
<i>J<sup>i</sup></i> 
is
<p/>
<p align=\"center\" style=\"font-style:italic;\">
 J<sup>i</sup> = -E<sup>i</sup>  - (1-&epsilon;<sup>i</sup>) &nbsp; G<sup>i</sup>.
<p/>
<p>
For windows, the outgoing radiosity is an input into this model
because the window model computes this quantity directly.
</p>
<p>
For each surface <i>i</i>, the heat balance is
<p/>
<p align=\"center\" style=\"font-style:italic;\">
  0 = Q<sup>i</sup> + J<sup>i</sup> + G<sup>i</sup>.
<p/>
<p>
For opaque surfaces, the heat flow rate 
<i>Q<sup>i</sup></i> 
is set to be equal to the heat flow rate at the heat port.
For the glass of the windows, the radiosity outflow at the connector is
set to the radiosity
<i>G<sup>i</sup></i>
that is leaving the surface.
<p/>
<p>
The view factor from surface <i>i</i> to <i>j</i> is approximated as
<p align=\"center\" style=\"font-style:italic;\">
  F<sup>i,j</sup> = A<sup>j</sup> &frasl; &sum;<sub>k </sub> A<sup>k</sup>.
</p>
</html>",
      revisions="<html>
<ul>
<li>
April 21, 2011 by Michael Wetter:<br>
Fixed a bug in the view factor calculation, and rewrote the model to reduce simulation time. The bug caused too much radiosity to flow from large to small surfaces because the law of reciprocity for view factors was not satisfied. This led to low surface temperatures if a surface had a large area compared to other surfaces.
</li>
<li>
April 2, 2011 by Michael Wetter:<br>
Added <code>homotopy</code> operator.
</li>
<li>
Feb. 3, 2011, by Michael Wetter:<br>
Corrected bug in start value of radiosity, reformulated equations to get
smaller system of coupled equations.
<li>
Dec. 1, 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
      end InfraredRadiationExchange;

      model InfraredRadiationGainDistribution
      "Infrared radiative heat gain distribution between the room facing surfaces"
        extends Buildings.Rooms.BaseClasses.PartialSurfaceInterface;
        parameter Boolean haveShade "Set to true if a shade is present";

        Modelica.Blocks.Interfaces.RealInput uSha[NConExtWin](each min=0, each max=1) if
             haveShade
        "Control signal for the shading device (removed if no shade is present)"
          annotation (Placement(transformation(extent={{-280,160},{-240,200}}),
              iconTransformation(extent={{-280,160},{-240,200}})));

        Modelica.Blocks.Interfaces.RealInput Q_flow
        "Radiative heat input into room (positive if heat gain)"
              annotation (Placement(transformation(
              origin={-260,0},
              extent={{20,-20},{-20,20}},
              rotation=180)));
        HeatTransfer.Interfaces.RadiosityOutflow[NConExtWin] JOutConExtWin
        "Outgoing radiosity that connects to shaded and unshaded part of glass"
          annotation (Placement(transformation(extent={{240,110},{260,130}})));
    protected
        Real fraConExt[NConExt] = AEpsConExt/sumAEps
        "Fraction of infrared radiant heat gain absorbed by exterior constructions";
        Real fraConExtWinOpa[NConExtWin] = AEpsConExtWinOpa/sumAEps
        "Fraction of infrared radiant heat gain absorbed by opaque part of exterior constructions that have a window";
        Real fraConExtWinGla[NConExtWin] = (AEpsConExtWinSha + AEpsConExtWinUns)/sumAEps
        "Fraction of infrared radiant heat gain absorbed by opaque part of glass constructions that have a window";
        Real fraConExtWinFra[NConExtWin] = AEpsConExtWinFra/sumAEps
        "Fraction of infrared radiant heat gain absorbed by window frame of exterior constructions that have a window";

        Real fraConPar_a[NConPar] = AEpsConPar_a/sumAEps
        "Fraction of infrared radiant heat gain absorbed by partition constructions surface a";
        Real fraConPar_b[NConPar] = AEpsConPar_b/sumAEps
        "Fraction of infrared radiant heat gain absorbed by partition constructions surface b";
        Real fraConBou[NConBou] = AEpsConBou/sumAEps
        "Fraction of infrared radiant heat gain absorbed by constructions with exterior boundary conditions exposed to outside of room model";
        Real fraSurBou[NSurBou] = AEpsSurBou/sumAEps
        "Fraction of infrared radiant heat gain absorbed by surface models of constructions that are modeled outside of this room";

       parameter Real AEpsConExt[NConExt] = {AConExt[i]*epsConExt[i] for i in 1:NConExt}
        "Absorptivity times area of exterior constructions";
       parameter Real AEpsConExtWinOpa[NConExtWin] = {AConExtWinOpa[i]*epsConExtWinOpa[i] for i in 1:NConExtWin}
        "Absorptivity times area of opaque part of exterior constructions that contain a window";
       Real AEpsConExtWinUns[NConExtWin] = {shaSig[i].yCom * AConExtWinGla[i]*epsConExtWinUns[i]
           for i in 1:NConExtWin}
        "Absorptivity times area of unshaded window constructions";
       Real AEpsConExtWinSha[NConExtWin] = {shaSig[i].y    * AConExtWinGla[i]*epsConExtWinSha[i]
          for i in 1:NConExtWin}
        "Absorptivity times area of shaded window constructions";
       parameter Real AEpsConExtWinFra[NConExtWin] = {AConExtWinFra[i]*epsConExtWinFra[i] for i in 1:NConExtWin}
        "Absorptivity times area of window frame";
       parameter Real AEpsConPar_a[NConPar] = {AConPar[i]*epsConPar_a[i] for i in 1:NConPar}
        "Absorptivity times area of partition constructions surface a";
       parameter Real AEpsConPar_b[NConPar] = {AConPar[i]*epsConPar_b[i] for i in 1:NConPar}
        "Absorptivity times area of partition constructions surface b";
       parameter Real AEpsConBou[NConBou] = {AConBou[i]*epsConBou[i] for i in 1:NConBou}
        "Absorptivity times area of constructions with exterior boundary conditions exposed to outside of room model";
       parameter Real AEpsSurBou[NSurBou] = {ASurBou[i]*epsSurBou[i] for i in 1:NSurBou}
        "Absorptivity times area of surface models of constructions that are modeled outside of this room";

       parameter Real sumAEpsNoWin(fixed=false)
        "Sum of absorptivity times area of all constructions except for windows";
       Real sumAEps
        "Sum of absorptivity times area of all constructions including windows";

       Buildings.HeatTransfer.Windows.BaseClasses.ShadingSignal shaSig[NConExtWin](
            each final haveShade=haveShade)
        "Block to constrain the shading control signal to be strictly within (0, 1) if a shade is present";
      initial equation
        sumAEpsNoWin = sum(AEpsConExt)+sum(AEpsConExtWinOpa)+sum(AEpsConExtWinFra)
                      +sum(AEpsConPar_a)+sum(AEpsConPar_b)+sum(AEpsConBou)+sum(AEpsSurBou);
      equation
        connect(uSha, shaSig.u);

        sumAEps      = sumAEpsNoWin + sum(AEpsConExtWinUns) + sum(AEpsConExtWinSha);

        // Infrared radiative heat flow
        conExt.Q_flow    = -fraConExt*Q_flow;
        conExtWin.Q_flow = -fraConExtWinOpa*Q_flow;
        conPar_a.Q_flow  = -fraConPar_a*Q_flow;
        conPar_b.Q_flow  = -fraConPar_b*Q_flow;
        conBou.Q_flow    = -fraConBou*Q_flow;
        conSurBou.Q_flow    = -fraSurBou*Q_flow;
        // This model makes the simplification that the shade, the glass and the frame have
        // the same absorptivity in the infrared region
        JOutConExtWin        = -fraConExtWinGla*Q_flow;
        conExtWinFra.Q_flow  = -fraConExtWinFra*Q_flow;
        // Check for conservation of energy
        assert(abs(1 - sum(fraConExt) - sum(fraConExtWinOpa)- sum(fraConExtWinGla) - sum(fraConExtWinFra)
                 - sum(fraConPar_a) - sum(fraConPar_b)
                 - sum(fraConBou) - sum(fraSurBou))  < 1E-5,
                 "Programming error: Radiation balance is wrong. Check equations.");
        annotation (
      preferedView="info",
      Documentation(info = "<html>
This model computes the distribution of the infrared radiant heat gain
to the room surfaces. 
The infrared radiant heat gain <i>Q</i> is an input to this model.
It is distributed to the individual surfaces according to
</p>
<p align=\"center\" style=\"font-style:italic;\">
  Q<sup>i</sup> = Q &nbsp; A<sup>i</sup> &nbsp; &epsilon;<sup>i</sup> &frasl; 
 &sum;<sub>k</sub> A<sup>k</sup> &nbsp; &epsilon;<sup>k</sup>.
</p>
<p>
For opaque surfaces, the heat flow rate 
<i>Q<sup>i</sup></i> 
is set to be equal to the heat flow rate at the heat port.
For the glass of the windows, the heat flow rate 
<i>Q<sup>i</sup></i> is set to the radiosity
<i>J<sup>i</sup></i>
that will strike the glass or the window shade.
<p/>
</html>",     revisions="<html>
<ul>
<li>
December 1, 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),       Icon(graphics={
              Text(
                extent={{-234,40},{-178,10}},
                lineColor={0,0,127},
                textString="Q_flow"),
              Rectangle(
                extent={{-242,4},{-2,-4}},
                lineColor={255,0,0},
                fillColor={255,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-4,4},{2,-8}},
                lineColor={255,0,0},
                fillColor={255,0,0},
                fillPattern=FillPattern.Solid),
              Line(
                points={{-144,-8},{146,-8}},
                color={255,0,0},
                smooth=Smooth.None,
                thickness=0.5),
              Line(
                points={{2,-200},{2,184}},
                color={255,0,0},
                smooth=Smooth.None,
                thickness=0.5),
              Text(
                extent={{-230,210},{-174,148}},
                lineColor={0,0,127},
                textString="uSha")}),
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-240,-240},{240,
                  240}}),
                  graphics));
      end InfraredRadiationGainDistribution;

      model MixedAir "Model for room air that is completely mixed"
        extends Buildings.Fluid.Interfaces.LumpedVolumeDeclarations;
        extends Buildings.Rooms.BaseClasses.PartialSurfaceInterface;

        parameter Modelica.SIunits.Volume V "Volume";

        // Port definitions
        parameter Integer nPorts=0 "Number of fluid ports of this model"
          annotation(Evaluate=true, Dialog(connectorSizing=true, tab="General",group="Ports"));
        parameter Modelica.SIunits.Area AFlo "Floor area";
        parameter Modelica.SIunits.Length hRoo "Average room height";

        parameter Buildings.HeatTransfer.Types.InteriorConvection conMod=
        Buildings.HeatTransfer.Types.InteriorConvection.Temperature
        "Convective heat transfer model for opaque constructions"
          annotation (Dialog(group="Convective heat transfer"));
        parameter Modelica.SIunits.CoefficientOfHeatTransfer hFixed=3.0
        "Constant convection coefficient for opaque constructions"
          annotation (Dialog(group="Convective heat transfer",
                             enable=(conMod == Buildings.HeatTransfer.Types.InteriorConvection.Fixed)));

        final parameter Boolean isFloorConExt[NConExt]=
          datConExt.isFloor
        "Flag to indicate if floor for exterior constructions";
        final parameter Boolean isFloorConExtWin[NConExtWin]=
          datConExtWin.isFloor "Flag to indicate if floor for constructions";
        final parameter Boolean isFloorConPar_a[NConPar]=
          datConPar.isFloor "Flag to indicate if floor for constructions";
        final parameter Boolean isFloorConPar_b[NConPar]=
          datConPar.isCeiling "Flag to indicate if floor for constructions";
        final parameter Boolean isFloorConBou[NConBou]=
          datConBou.isFloor
        "Flag to indicate if floor for constructions with exterior boundary conditions exposed to outside of room model";
        parameter Boolean isFloorSurBou[NSurBou]=
          surBou.isFloor
        "Flag to indicate if floor for constructions that are modeled outside of this room";

        parameter Modelica.SIunits.Emissivity tauGlaSol[NConExtWin]
        "Transmissivity of window";

        Buildings.Fluid.MixingVolumes.MixingVolume vol(V=AFlo*hRoo,
          redeclare package Medium = Medium,
          final energyDynamics=energyDynamics,
          final massDynamics=massDynamics,
          final p_start=p_start,
          final T_start=T_start,
          final X_start=X_start,
          final C_start=C_start,
          final C_nominal=C_nominal,
          final m_flow_nominal = m_flow_nominal,
          final prescribedHeatFlowRate = true,
          final nPorts=nPorts+1) "Room air volume"
          annotation (Placement(transformation(extent={{10,-210},{-10,-190}})));
        // Heat ports that are needed to connect to the window glass
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a glaUns[NConExtWin] if
           haveConExtWin
        "Heat port that connects to room-side surface of unshaded glass"
                                    annotation (Placement(transformation(extent={{232,110},
                  {252,130}},          rotation=0)));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a glaSha[NConExtWin] if
             haveShade
        "Heat port that connects to room-side surface of shaded glass"
                                    annotation (Placement(transformation(extent={{232,70},
                  {252,90}},           rotation=0)));
        Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b ports[nPorts](
            redeclare each final package Medium = Medium)
        "Fluid inlets and outlets"
          annotation (Placement(transformation(extent={{-40,-10},{40,10}},
            origin={0,-238})));

        Buildings.HeatTransfer.Convection.Interior convConExt[
                                           NConExt](
          final A=AConExt,
          final til =  datConExt.til,
          each conMod=conMod,
          each hFixed=hFixed) if
             haveConExt "Convective heat transfer"
          annotation (Placement(transformation(extent={{120,210},{100,230}})));
        Buildings.HeatTransfer.Convection.Interior convConExtWin[
                                              NConExtWin](
          final A=AConExtWinOpa,
          final til =  datConExtWin.til,
          each conMod=conMod,
          each hFixed=hFixed) if
             haveConExtWin "Convective heat transfer"
          annotation (Placement(transformation(extent={{120,170},{100,190}})));
        HeatTransfer.Windows.InteriorHeatTransfer convConWin[NConExtWin](
          final fFra=fFra,
          each final linearizeRadiation = linearizeRadiation,
          final haveExteriorShade=haveExteriorShade,
          final haveInteriorShade=haveInteriorShade,
          final A=AConExtWinGla + AConExtWinFra,
          final absIRSha_air=epsConExtWinSha,
          final absIRSha_glass=epsConExtWinUns,
          final tauIRSha_air=tauIRSha_air,
          final tauIRSha_glass=tauIRSha_glass) if
             haveConExtWin "Model for convective heat transfer at window"
          annotation (Placement(transformation(extent={{98,108},{118,128}})));
        // For conPar_a, we use for the tilt pi-tilt since it is the
        // surface that is on the other side of the construction
        Buildings.HeatTransfer.Convection.Interior convConPar_a[
                                             nConPar](
          final A=AConPar,
          final til=Modelica.Constants.pi .- datConPar.til,
          each conMod=conMod,
          each hFixed=hFixed) if
             haveConPar "Convective heat transfer"
          annotation (Placement(transformation(extent={{120,-70},{100,-50}})));
        Buildings.HeatTransfer.Convection.Interior convConPar_b[
                                             nConPar](
          final A=AConPar,
          final til =  datConPar.til,
          each conMod=conMod,
          each hFixed=hFixed) if
             haveConPar "Convective heat transfer"
          annotation (Placement(transformation(extent={{120,-110},{100,-90}})));
        Buildings.HeatTransfer.Convection.Interior convConBou[
                                           nConBou](
          final A=AConBou,
          final til =  datConBou.til,
          each conMod=conMod,
          each hFixed=hFixed) if
             haveConBou "Convective heat transfer"
          annotation (Placement(transformation(extent={{120,-170},{100,-150}})));
        Buildings.HeatTransfer.Convection.Interior convSurBou[
                                           nSurBou](
          final A=ASurBou,
          final til =  surBou.til,
          each conMod=conMod,
          each hFixed=hFixed) if
             haveSurBou "Convective heat transfer"
          annotation (Placement(transformation(extent={{122,-230},{102,-210}})));
    protected
        Modelica.Thermal.HeatTransfer.Components.ThermalCollector theConConExt(final m=
              nConExt) if
             haveConExt
        "Thermal collector to convert from vector to scalar connector"
          annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=270,
              origin={48,220})));
        Modelica.Thermal.HeatTransfer.Components.ThermalCollector theConConExtWin(
            final m=nConExtWin) if
             haveConExtWin
        "Thermal collector to convert from vector to scalar connector"
          annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=270,
              origin={48,180})));
        Modelica.Thermal.HeatTransfer.Components.ThermalCollector theConConWin(final m=
              nConExtWin) if
             haveConExtWin
        "Thermal collector to convert from vector to scalar connector"
          annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=270,
              origin={50,120})));
        Modelica.Thermal.HeatTransfer.Components.ThermalCollector theConConPar_a(final m=
              nConPar) if
             haveConPar
        "Thermal collector to convert from vector to scalar connector"
          annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=270,
              origin={52,-60})));
        Modelica.Thermal.HeatTransfer.Components.ThermalCollector theConConPar_b(final m=
              nConPar) if
             haveConPar
        "Thermal collector to convert from vector to scalar connector"
          annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=270,
              origin={50,-100})));
        Modelica.Thermal.HeatTransfer.Components.ThermalCollector theConConBou(final m=
              nConBou) if
             haveConBou
        "Thermal collector to convert from vector to scalar connector"
          annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=270,
              origin={50,-160})));
        Modelica.Thermal.HeatTransfer.Components.ThermalCollector theConSurBou(final m=
              nSurBou) if
             haveSurBou
        "Thermal collector to convert from vector to scalar connector"
          annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=270,
              origin={52,-220})));
    public
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heaPorAir
        "Heat port to air volume"
          annotation (Placement(transformation(extent={{-250,-10},{-230,10}})));

        final parameter Modelica.SIunits.TransmissionCoefficient tauIRSha_air[NConExtWin]=
          datConExtWin.glaSys.shade.tauIR_a
        "Infrared transmissivity of shade for radiation coming from the exterior or the room"
          annotation (Dialog(group="Shading"));
              final parameter Modelica.SIunits.TransmissionCoefficient tauIRSha_glass[
                                                                                NConExtWin]=
          datConExtWin.glaSys.shade.tauIR_b
        "Infrared transmissivity of shade for radiation coming from the glass"
          annotation (Dialog(group="Shading"));

        final parameter Boolean haveExteriorShade[NConExtWin]=
          {datConExtWin[i].glaSys.haveExteriorShade for i in 1:NConExtWin}
        "Set to true if window has exterior shade (at surface a)"
          annotation (Dialog(group="Shading"));
        final parameter Boolean haveInteriorShade[NConExtWin]=
          {datConExtWin[i].glaSys.haveInteriorShade for i in 1:NConExtWin}
        "Set to true if window has interior shade (at surface b)"
          annotation (Dialog(group="Shading"));
        final parameter Boolean haveShade = haveExteriorShade[1] or haveInteriorShade[1]
        "Set to true if the windows have a shade";
        final parameter Real fFra[NConExtWin](each min=0, each max=1) = datConExtWin.fFra
        "Fraction of window frame divided by total window area";
        parameter Boolean linearizeRadiation
        "Set to true to linearize emissive power";
        parameter Modelica.SIunits.MassFlowRate m_flow_nominal(min=0)
        "Nominal mass flow rate"
          annotation(Dialog(group = "Nominal condition"));
        HeatTransfer.Interfaces.RadiosityInflow JInSha[NConExtWin] if
                                             haveShade
        "Incoming radiosity that connects to shaded part of glass"
          annotation (Placement(transformation(extent={{260,30},{240,50}})));

        HeatTransfer.Interfaces.RadiosityOutflow JOutSha[NConExtWin] if
                                               haveShade
        "Outgoing radiosity that connects to shaded part of glass"
          annotation (Placement(transformation(extent={{240,50},{260,70}})));
        HeatTransfer.Interfaces.RadiosityInflow JInUns[NConExtWin] if
           haveConExtWin
        "Incoming radiosity that connects to unshaded part of glass"
          annotation (Placement(transformation(extent={{258,134},{238,154}})));
        HeatTransfer.Interfaces.RadiosityOutflow JOutUns[NConExtWin] if
           haveConExtWin
        "Outgoing radiosity that connects to unshaded part of glass"
          annotation (Placement(transformation(extent={{240,150},{260,170}})));

        SolarRadiationExchange solRadExc(
          final nConExt=nConExt,
          final nConExtWin=nConExtWin,
          final nConPar=nConPar,
          final nConBou=nConBou,
          final nSurBou=nSurBou,
          final datConExt = datConExt,
          final datConExtWin = datConExtWin,
          final datConPar = datConPar,
          final datConBou = datConBou,
          final surBou = surBou,
          final isFloorConExt=isFloorConExt,
          final isFloorConExtWin=isFloorConExtWin,
          final isFloorConPar_a=isFloorConPar_a,
          final isFloorConPar_b=isFloorConPar_b,
          final isFloorConBou=isFloorConBou,
          final isFloorSurBou=isFloorSurBou,
          final tauGla=tauGlaSol) if
             haveConExtWin "Solar radiative heat exchange"
          annotation (Placement(transformation(extent={{-100,40},{-80,60}})));

        InfraredRadiationGainDistribution irRadGai(
          final nConExt=nConExt,
          final nConExtWin=nConExtWin,
          final nConPar=nConPar,
          final nConBou=nConBou,
          final nSurBou=nSurBou,
          final datConExt = datConExt,
          final datConExtWin = datConExtWin,
          final datConPar = datConPar,
          final datConBou = datConBou,
          final surBou = surBou,
          final haveShade=haveShade)
        "Distribution for infrared radiative heat gains (e.g., due to equipment and people)"
          annotation (Placement(transformation(extent={{-100,-40},{-80,-20}})));
        InfraredRadiationExchange irRadExc(
          final nConExt=nConExt,
          final nConExtWin=nConExtWin,
          final nConPar=nConPar,
          final nConBou=nConBou,
          final nSurBou=nSurBou,
          final datConExt = datConExt,
          final datConExtWin = datConExtWin,
          final datConPar = datConPar,
          final datConBou = datConBou,
          final surBou = surBou,
          final linearizeRadiation = linearizeRadiation)
        "Infrared radiative heat exchange"
          annotation (Placement(transformation(extent={{-100,0},{-80,20}})));

        Modelica.Blocks.Interfaces.RealInput qGai_flow[3]
        "Radiant, convective and latent heat input into room (positive if heat gain)"
          annotation (Placement(transformation(extent={{-280,80},{-240,120}})));

        Modelica.Blocks.Interfaces.RealInput uSha[NConExtWin](each min=0, each max=1) if
             haveShade
        "Control signal for the shading device (removed if no shade is present)"
          annotation (Placement(transformation(extent={{-280,160},{-240,200}}),
              iconTransformation(extent={{-280,162},{-240,202}})));

        Modelica.Blocks.Interfaces.RealInput QAbsSolSha_flow[NConExtWin](
          final unit="W", quantity="Power") if
             haveConExtWin "Solar radiation absorbed by shade"
          annotation (Placement(transformation(extent={{-280,-220},{-240,-180}})));
        Modelica.Blocks.Interfaces.RealInput JInConExtWin[NConExtWin](final unit="W",
            quantity="Power") if haveConExtWin
        "Solar radiation transmitted from the outside through the glazing system"
          annotation (Placement(transformation(extent={{-280,-120},{-240,-80}}),
              iconTransformation(extent={{-280,-120},{-240,-80}})));

        Modelica.Blocks.Interfaces.RealOutput HOutConExtWin[NConExtWin](unit="W/m2") if
             haveConExtWin "Outgoing solar radiation that strikes window"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=270,
              origin={-200,-250})));

        HeatGain heaGai(redeclare package Medium = Medium, final AFlo=AFlo)
        "Model to convert internal heat gains"
          annotation (Placement(transformation(extent={{-220,90},{-200,110}})));
    protected
        RadiationAdapter radiationAdapter
          annotation (Placement(transformation(extent={{-220,120},{-200,140}})));
        Modelica.Blocks.Math.Add add
          annotation (Placement(transformation(extent={{-180,110},{-160,130}})));
    public
        RadiationTemperature radTem(
          final nConExt=nConExt,
          final nConExtWin=nConExtWin,
          final nConPar=nConPar,
          final nConBou=nConBou,
          final nSurBou=nSurBou,
          final datConExt=datConExt,
          final datConExtWin=datConExtWin,
          final datConPar=datConPar,
          final datConBou=datConBou,
          final surBou=surBou,
          final haveShade=haveShade) "Radiative temperature of the room"
          annotation (Placement(transformation(extent={{-100,-80},{-80,-60}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heaPorRad
        "Heat port for radiative heat gain and radiative temperature"
          annotation (Placement(transformation(extent={{-250,-50},{-230,-30}})));
      equation
        connect(convConExt.solid, conExt)
                                         annotation (Line(
            points={{120,220},{240,220}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(convConPar_a.solid, conPar_a)
                                             annotation (Line(
            points={{120,-60},{242,-60}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(convConPar_b.solid, conPar_b)
                                             annotation (Line(
            points={{120,-100},{242,-100}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(convConBou.solid, conBou)
                                         annotation (Line(
            points={{120,-160},{242,-160}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(convSurBou.solid, conSurBou) annotation (Line(
            points={{122,-220},{241,-220}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(convConExt.fluid, theConConExt.port_a)
                                                      annotation (Line(
            points={{100,220},{58,220}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(convConPar_a.fluid, theConConPar_a.port_a)
                                                          annotation (Line(
            points={{100,-60},{62,-60}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(convConPar_b.fluid, theConConPar_b.port_a)
                                                          annotation (Line(
            points={{100,-100},{60,-100}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(convConBou.fluid, theConConBou.port_a)
                                                      annotation (Line(
            points={{100,-160},{60,-160}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(convSurBou.fluid, theConSurBou.port_a) annotation (Line(
            points={{102,-220},{62,-220}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(theConConExt.port_b,vol. heatPort) annotation (Line(
            points={{38,220},{20,220},{20,-200},{10,-200}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(theConConExtWin.port_b,vol. heatPort) annotation (Line(
            points={{38,180},{20,180},{20,-200},{10,-200}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(theConConPar_a.port_b,vol. heatPort) annotation (Line(
            points={{42,-60},{20,-60},{20,-200},{10,-200}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(theConConPar_b.port_b,vol. heatPort) annotation (Line(
            points={{40,-100},{20,-100},{20,-200},{10,-200}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(theConConBou.port_b,vol. heatPort) annotation (Line(
            points={{40,-160},{20,-160},{20,-200},{10,-200}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(theConSurBou.port_b,vol. heatPort) annotation (Line(
            points={{42,-220},{20,-220},{20,-200},{10,-200}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(vol.heatPort, heaPorAir)
                                        annotation (Line(
            points={{10,-200},{20,-200},{20,-90},{-150,-90},{-150,0},{-200,0},{-200,
                5.55112e-16},{-240,5.55112e-16}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(convConWin.JOutUns, JOutUns)
                                            annotation (Line(
            points={{119,126},{196,126},{196,160},{250,160}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(JInUns, convConWin.JInUns)
                                          annotation (Line(
            points={{248,144},{200,144},{200,124},{119,124}},
            color={0,0,0},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(convConWin.JOutSha, JOutSha)
                                            annotation (Line(
            points={{119,112},{200,112},{200,60},{250,60}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(convConWin.JInSha, JInSha)
                                          annotation (Line(
            points={{119,110},{196,110},{196,40},{250,40}},
            color={0,0,0},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(uSha, convConWin.uSha)
                                annotation (Line(
            points={{-260,180},{-220,180},{-220,148},{90,148},{90,126},{97.2,126}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(conExt, irRadExc.conExt) annotation (Line(
            points={{240,220},{160,220},{160,19.1667},{-80,19.1667}},
            color={190,0,0},
            smooth=Smooth.None));
        connect(conExtWinFra, irRadExc.conExtWinFra) annotation (Line(
            points={{242,5.55112e-16},{192,5.55112e-16},{192,10},{-79.9167,10}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(conPar_a, irRadExc.conPar_a) annotation (Line(
            points={{242,-60},{188,-60},{188,7.5},{-79.9167,7.5}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(conPar_b, irRadExc.conPar_b) annotation (Line(
            points={{242,-100},{184,-100},{184,6},{180,6},{180,5.83333},{-79.9167,
                5.83333}},
            color={191,0,0},
            smooth=Smooth.None));

        connect(conBou, irRadExc.conBou) annotation (Line(
            points={{242,-160},{180,-160},{180,4},{-79.9167,4},{-79.9167,3.33333}},
            color={191,0,0},
            smooth=Smooth.None));

        connect(conSurBou, irRadExc.conSurBou) annotation (Line(
            points={{241,-220},{176,-220},{176,0},{-79.9583,0},{-79.9583,0.833333}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(irRadExc.JOutConExtWin, convConWin.JInRoo)    annotation (Line(
            points={{-79.5833,15},{86,15},{86,110},{98,110}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(convConWin.JOutRoo, irRadExc.JInConExtWin)    annotation (Line(
            points={{97.6,114},{84,114},{84,13.3333},{-79.5833,13.3333}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(irRadGai.JOutConExtWin, convConWin.JInRoo)    annotation (Line(
            points={{-79.5833,-25},{86,-25},{86,110},{98,110}},
            color={0,127,0},
            smooth=Smooth.None));
        connect(irRadGai.conExt, irRadExc.conExt) annotation (Line(
            points={{-80,-20.8333},{-80,-20},{-58,-20},{-58,19.1667},{-80,19.1667}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(irRadGai.conExtWinFra, irRadExc.conExtWinFra) annotation (Line(
            points={{-79.9167,-30},{-54,-30},{-54,10},{-79.9167,10}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(irRadGai.conPar_a, irRadExc.conPar_a) annotation (Line(
            points={{-79.9167,-32.5},{-52,-32.5},{-52,7.5},{-79.9167,7.5}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(irRadGai.conPar_b, irRadExc.conPar_b) annotation (Line(
            points={{-79.9167,-34.1667},{-50,-34.1667},{-50,5.83333},{-79.9167,
                5.83333}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(irRadGai.conBou, irRadExc.conBou) annotation (Line(
            points={{-79.9167,-36.6667},{-54,-36.6667},{-54,-36},{-48,-36},{-48,
                3.33333},{-79.9167,3.33333}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(irRadGai.conSurBou, irRadExc.conSurBou) annotation (Line(
            points={{-79.9583,-39.1667},{-46,-39.1667},{-46,0.833333},{-79.9583,
                0.833333}},
            color={191,0,0},
            smooth=Smooth.None));

        connect(irRadGai.uSha, uSha)
                                   annotation (Line(
            points={{-100.833,-22.5},{-120,-22.5},{-120,148},{-220,148},{-220,180},{
                -260,180}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(heaGai.QCon_flow,vol. heatPort) annotation (Line(
            points={{-200,100},{-150,100},{-150,-90},{20,-90},{20,-200},{10,-200}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(heaGai.qGai_flow, qGai_flow) annotation (Line(
            points={{-222,100},{-260,100}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(convConExtWin.fluid, theConConExtWin.port_a)
                                                      annotation (Line(
            points={{100,180},{58,180}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(convConExtWin.solid, conExtWin)
                                               annotation (Line(
            points={{120,180},{240,180}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(conExtWin, irRadExc.conExtWin) annotation (Line(
            points={{240,180},{166,180},{166,17.5},{-80,17.5}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(irRadExc.conExtWin, irRadGai.conExtWin) annotation (Line(
            points={{-80,17.5},{-56,17.5},{-56,-22.5},{-80,-22.5}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(heaGai.QLat_flow,vol. ports[nPorts+1]) annotation (Line(
            points={{-200,94},{-180,94},{-180,-220},{-2,-220},{-2,-210},{-7.77156e-16,
                -210}},
            color={0,127,255},
            smooth=Smooth.None));
        for i in 1:nPorts loop
        connect(ports[i],vol. ports[i]) annotation (Line(
            points={{2.22045e-15,-238},{0,-238},{0,-220},{0,-210},{-7.77156e-16,-210}},
            color={0,127,255},
            smooth=Smooth.None));
        end for;
        connect(convConWin.air, theConConWin.port_a)
                                                    annotation (Line(
            points={{98,118},{80,118},{80,120},{60,120}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(theConConWin.port_b,vol. heatPort) annotation (Line(
            points={{40,120},{20,120},{20,-200},{10,-200}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(glaUns, convConWin.glaUns)
                                          annotation (Line(
            points={{242,120},{118,120}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(convConWin.glaSha, glaSha)
                                          annotation (Line(
            points={{118,116},{216,116},{216,80},{242,80}},
            color={191,0,0},
            smooth=Smooth.None));

        connect(conExt, solRadExc.conExt) annotation (Line(
            points={{240,220},{160,220},{160,59.1667},{-80,59.1667}},
            color={190,0,0},
            smooth=Smooth.None));
        connect(conExtWinFra, solRadExc.conExtWinFra) annotation (Line(
            points={{242,5.55112e-16},{192,5.55112e-16},{192,50},{-79.9167,50}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(conPar_a, solRadExc.conPar_a) annotation (Line(
            points={{242,-60},{188,-60},{188,48},{-79.9167,48},{-79.9167,47.5}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(conPar_b, solRadExc.conPar_b) annotation (Line(
            points={{242,-100},{184,-100},{184,44},{-79.9167,44},{-79.9167,45.8333}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(conBou, solRadExc.conBou) annotation (Line(
            points={{242,-160},{180,-160},{180,42},{-79.9167,42},{-79.9167,43.3333}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(conSurBou, solRadExc.conSurBou) annotation (Line(
            points={{241,-220},{176,-220},{176,40.8333},{-79.9583,40.8333}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(conExtWin, solRadExc.conExtWin) annotation (Line(
            points={{240,180},{166,180},{166,57.5},{-80,57.5}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(QAbsSolSha_flow, convConWin.QAbs_flow)
                                                     annotation (Line(
            points={{-260,-200},{-210,-200},{-210,80},{108,80},{108,107}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(solRadExc.JInConExtWin, JInConExtWin) annotation (Line(
            points={{-79.5833,53.3333},{-74,53.3333},{-74,70},{-220,70},{-220,-100},{
                -260,-100}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(solRadExc.HOutConExtWin,HOutConExtWin)  annotation (Line(
            points={{-79.5833,55},{-70,55},{-70,76},{-200,76},{-200,-250}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(uSha, radTem.uSha) annotation (Line(
            points={{-260,180},{-220,180},{-220,148},{-120,148},{-120,-62.5},{
                -100.833,-62.5}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(irRadExc.conExt, radTem.conExt) annotation (Line(
            points={{-80,19.1667},{-58,19.1667},{-58,-60.8333},{-80,-60.8333}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(irRadExc.conExtWin, radTem.conExtWin) annotation (Line(
            points={{-80,17.5},{-56,17.5},{-56,-62.5},{-80,-62.5}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(irRadExc.conExtWinFra, radTem.conExtWinFra) annotation (Line(
            points={{-79.9167,10},{-54,10},{-54,-70},{-79.9167,-70}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(irRadExc.conPar_a, radTem.conPar_a) annotation (Line(
            points={{-79.9167,7.5},{-52,7.5},{-52,-72.5},{-79.9167,-72.5}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(irRadExc.conPar_b, radTem.conPar_b) annotation (Line(
            points={{-79.9167,5.83333},{-50,5.83333},{-50,-74.1667},{-79.9167,
                -74.1667}},
            color={191,0,0},
            smooth=Smooth.None));

        connect(irRadExc.conBou, radTem.conBou) annotation (Line(
            points={{-79.9167,3.33333},{-48,3.33333},{-48,-76.6667},{-79.9167,
                -76.6667}},
            color={191,0,0},
            smooth=Smooth.None));

        connect(irRadExc.conSurBou, radTem.conSurBou) annotation (Line(
            points={{-79.9583,0.833333},{-46,0.833333},{-46,-79.1667},{-79.9583,
                -79.1667}},
            color={191,0,0},
            smooth=Smooth.None));

        connect(radTem.glaUns, glaUns) annotation (Line(
            points={{-80,-65},{-8,-65},{-8,-32},{212,-32},{212,120},{242,120}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(radTem.glaSha, glaSha) annotation (Line(
            points={{-80,-66.6667},{-4,-66.6667},{-4,-36},{216,-36},{216,80},{242,80}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(convConWin.sha, radTem.sha) annotation (Line(
            points={{104.8,108},{104,108},{104,-40},{0,-40},{0,-68},{-80,-68},{-80,
                -68.4167}},
            color={191,0,0},
            smooth=Smooth.None));

        connect(radTem.TRad, radiationAdapter.TRad) annotation (Line(
            points={{-100.417,-77.6667},{-232,-77.6667},{-232,130},{-222,130}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(radiationAdapter.rad, heaPorRad)
                                           annotation (Line(
            points={{-210.2,120},{-210,120},{-210,114},{-226,114},{-226,-40},{-240,-40}},
            color={191,0,0},
            smooth=Smooth.None));

        connect(radiationAdapter.QRad_flow, add.u1) annotation (Line(
            points={{-199,130},{-190,130},{-190,126},{-182,126}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(heaGai.QRad_flow, add.u2) annotation (Line(
            points={{-199,106},{-190,106},{-190,114},{-182,114}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(add.y, irRadGai.Q_flow) annotation (Line(
            points={{-159,120},{-130,120},{-130,-30},{-100.833,-30}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(conExtWinFra, convConWin.frame) annotation (Line(
            points={{242,5.55112e-16},{218,5.55112e-16},{218,0},{192,0},{192,100},{
                115,100},{115,108}},
            color={191,0,0},
            smooth=Smooth.None));
        annotation (Diagram(coordinateSystem(preserveAspectRatio=true,
                 extent={{-240,-240},{240,240}}),
              graphics), Icon(coordinateSystem(
                preserveAspectRatio=true, extent={{-300,-300},{300,300}}), graphics={
                Rectangle(
                extent={{-144,184},{148,-200}},
                pattern=LinePattern.None,
                lineColor={0,0,0},
                fillColor={170,213,255},
                fillPattern=FillPattern.Sphere),
              Text(
                extent={{-232,130},{-176,68}},
                lineColor={0,0,127},
                textString="qGai_flow"),
              Text(
                extent={{-230,210},{-174,148}},
                lineColor={0,0,127},
                textString="uSha"),
              Text(
                extent={{-230,-90},{-174,-152}},
                lineColor={0,0,127},
                textString="QTraSW"),
              Text(
                extent={{-230,-168},{-174,-230}},
                lineColor={0,0,127},
                textString="QAbsSW"),
              Text(
                extent={{-104,-230},{-48,-292}},
                lineColor={0,0,127},
                textString="TRad")}),
          Documentation(info="<html>
Model for the heat exchange inside a room.
This model integrates various components that model
heat exchange between the room-facing surfaces of constructions
and the room air, the internal heat gains, and the fluid port that
can be used to connect models of HVAC systems to the room model.
</p>
<p>
The main components that are used in this model are as follows:
<ol>
<li>
The model 
<a href=\"modelica://Buildings.HeatTransfer.Convection\">
Buildings.HeatTransfer.Convection</a>
is used to compute heat convection between the room air
and the surface of opaque constructions.
</li>
<li>
The model 
<a href=\"modelica://Buildings.HeatTransfer.Windows.InteriorHeatTransfer\">
Buildings.HeatTransfer.Windows.InteriorHeatTransfer</a>
is used to compute heat convection between the room air
and the surfaces of the window glass, frame and shade.
</li>
<li>
The thermodynamics of the room air is modeled using
<a href=\"modelica://Buildings.Fluid.MixingVolumes.MixingVolume\">
Buildings.Fluid.MixingVolumes.MixingVolume</a>
which assumes the room air to be completely mixed.
Depending on the medium model, moisture and species concentrations,
such as CO<sub>2</sub>, can be modeled transiently.
</li>
<li>
The latent heat gain of the room, which is a user-input,
is converted to a moisture source using
the model
<a href=\"modelica://Buildings.Rooms.BaseClasses.HeatGain\">
Buildings.Rooms.BaseClasses.HeatGain</a>.
</li>
<li>
The radiant heat gains in the infrared spectrum are also a user
input. They are distributed to the room enclosing surfaces using
the model
<a href=\"modelica://Buildings.Rooms.BaseClasses.InfraredRadiationGainDistribution\">
Buildings.Rooms.BaseClasses.InfraredRadiationGainDistribution</a>.
</li>
<li>
The infrared radiative heat exchange between the room enclosing
surfaces is modeled in
<a href=\"modelica://Buildings.Rooms.BaseClasses.InfraredRadiationExchange\">
Buildings.Rooms.BaseClasses.InfraredRadiationExchange</a>.
This model takes into account the absorptivity of the surfaces and
the surface area. However, the view factors are assumed to be 
proportional to the area of the receiving surface, without taking
into account the location of the surfaces.
</li>
<li>
The solar radiation exchange is modeled in
<a href=\"modelica://Buildings.Rooms.BaseClasses.SolarRadiationExchange\">
Buildings.Rooms.BaseClasses.SolarRadiationExchange</a>.
The assumptions in this model is that all solar radiation
first hits the floor, and is then partially absorbed and partially reflected by the floor.
The reflectance are diffuse, and the reflected radiation is distributed
in proportion to the product of the receiving areas times their
solar absorptivity.
</li>
</ol>
</p>


</html>",       revisions="<html>
<ul>
<li>
November 29, 2011, by Michael Wetter:<br>
Added missing connect statement between window frame
surface and window frame convection model. Prior to this bug fix,
no convective heat transfer was computed between window frame and
room air.
Bug fix is due to feedback from Tobias Klingbeil (Fraunhofer ISE).
</li>
<li>
November 16 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
      end MixedAir;

      model RadiationAdapter
      "Model to connect between signals and heat port for radiative gains of the room"
        extends Buildings.BaseClasses.BaseIcon;

        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a rad
        "Port for radiative heat gain and radiation temperature"      annotation (Placement(transformation(extent={{-10,
                  -110},{10,-90}},   rotation=0), iconTransformation(extent={{-12,
                  -110},{8,-90}})));
    public
        Modelica.Blocks.Interfaces.RealInput TRad
        "Radiation temperature of room"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
        Modelica.Blocks.Interfaces.RealOutput QRad_flow "Radiative heat gain"
          annotation (Placement(transformation(extent={{100,-10},{120,10}}),
              iconTransformation(extent={{100,-10},{120,10}})));
      equation
        QRad_flow = rad.Q_flow;
        rad.T = TRad;
       annotation (Placement(transformation(extent={{-140,-20},{-100,20}})),
                  Documentation(info="<html>
This model can be used as a thermal adapter in situations where the temperature
and the heat flow rate are computed in separate models. 
For example, this thermal adapter is used in the room model, which computes
the distribution of radiative heat gains (such as due to a radiator) in
<a href=\"modelica://Buildings.Rooms.BaseClasses.InfraredRadiationGainDistribution\">
Buildings.Rooms.BaseClasses.InfraredRadiationGainDistribution</a>
and computes the the radiative temperature in
<a href=\"modelica://Buildings.Rooms.BaseClasses.RadiationTemperature\">
Buildings.Rooms.BaseClasses.RadiationTemperature</a>.
This adapter combines the heat flow rate and the temperatures that are computed in these
separate models, and exposes these two quantities at its heat port.

</html>",     revisions="<html>
<ul>
<li>
Feb. 2, 2011, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),       Icon(graphics={
                  Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
              Text(
                extent={{-90,24},{-40,-26}},
                lineColor={0,0,127},
                textString="TRad"),
              Text(
                extent={{50,14},{92,-12}},
                lineColor={0,0,127},
                textString="Q")}),
              Documentation(info = "<html>
This is a dummy model that is required to implement the room
model with a variable number of surface models.
The model is required since arrays of models, such as used for the surfaces
that model the construction outside of the room, 
must have at least one element, unless the whole array
is conditionally removed if its size is zero.
However, conditionally removing the surface models does not work in this
situation since some models, such as for computing the radiative heat exchange
between the surfaces, require access to the area and absorptivity of the surface models.

</html>",     revisions="<html>
<ul>
<li>
June 8 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),Diagram(graphics));
      end RadiationAdapter;

      model RadiationTemperature "Radiative temperature of the room"
        extends Buildings.Rooms.BaseClasses.PartialSurfaceInterface;

        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a glaUns[NConExtWin] if
           haveConExtWin
        "Heat port that connects to room-side surface of unshaded glass"
                                    annotation (Placement(transformation(extent={{230,110},
                  {250,130}},          rotation=0)));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a glaSha[NConExtWin] if
          haveShade
        "Heat port that connects to room-side surface of shaded glass"
                                    annotation (Placement(transformation(extent={{230,70},
                  {250,90}},           rotation=0)));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a sha[NConExtWin] if
          haveShade "Heat port that connects to shade"
                                             annotation (Placement(transformation(extent={{230,28},
                  {250,48}},           rotation=0)));
        parameter Boolean haveShade "Set to true if the windows have a shade"
        annotation(HideResult="true");

        Modelica.Blocks.Interfaces.RealInput uSha[NConExtWin](each min=0, each max=1) if
             haveShade
        "Control signal for the shading device (removed if no shade is present)"
          annotation (Placement(transformation(extent={{-280,160},{-240,200}}),
              iconTransformation(extent={{-280,160},{-240,200}})));

        Modelica.Blocks.Interfaces.RealOutput TRad(min=0, unit="K", displayUnit="degC")
        "Radiative temperature"
          annotation (Placement(transformation(extent={{-240,-190},{-260,-170}}),
              iconTransformation(extent={{-240,-194},{-260,-174}})));

    protected
        final parameter Integer NOpa = NConExt+2*NConExtWin+2*NConPar+NConBou+NSurBou
        "Number of opaque surfaces, including the window frame";
        final parameter Integer NWin = NConExtWin "Number of window surfaces";
        final parameter Integer NTot = NOpa + NWin "Total number of surfaces";

        final parameter Modelica.SIunits.Area AGla[NWin] = datConExtWin.AGla
        "Surface area of opaque surfaces";
        final parameter Real epsGla[NWin](min=0, max=1)=
          {datConExtWin[i].glaSys.glass[datConExtWin[i].glaSys.nLay].absIR_b for i in 1:NWin}
        "Absorptivity of glass";
        final parameter Real epsSha[NWin](min=0, max=1)=
          {datConExtWin[i].glaSys.shade.absIR_a for i in 1:NWin}
        "Absorptivity of shade";
        final parameter Real tauSha[NWin](min=0, max=1)=
          {(if datConExtWin[i].glaSys.haveInteriorShade then
            datConExtWin[i].glaSys.shade.tauIR_a else 1) for i in 1:NWin}
        "Transmissivity of shade";
        final parameter Modelica.SIunits.Area epsAOpa[NOpa](fixed=false)
        "Product of area times absorptivity of opaque surfaces";
        final parameter Modelica.SIunits.Area epsAGla[NWin](fixed=false)
        "Product of area times absorptivity of window surfaces";
        final parameter Modelica.SIunits.Area epsASha[NWin](fixed=false)
        "Product of area times absorptivity of window shade";
        final parameter Modelica.SIunits.Area epsTauASha[NWin](fixed=false)
        "Product of area times glass absorptivity times shade transmittance";
        Modelica.SIunits.Temperature TOpa[NOpa](each start=293.15, each nominal=293.15)
        "Temperature of opaque surfaces";
        Modelica.SIunits.Temperature TGlaUns[NWin](each start=293.15, each nominal=293.15)
        "Temperature of unshaded part of glass";
        Modelica.SIunits.Temperature TGlaSha[NWin](each start=293.15, each nominal=293.15)
        "Temperature of shaded part of glass";
        Modelica.SIunits.Temperature TSha[NWin](each start=293.15, each nominal=293.15)
        "Temperature of shade";
        // Internal connectors, used because of the conditionally removed connectors
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a glaUns_internal[NConExtWin]
        "Heat port that connects to room-side surface of unshaded glass";
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a glaSha_internal[NConExtWin]
        "Heat port that connects to room-side surface of shaded glass";
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a sha_internal[NConExtWin]
        "Heat port that connects to shade";
        Modelica.Blocks.Interfaces.RealInput uSha_internal[NConExtWin](each min=0, each max=1)
        "Control signal for the shading device";

      initial equation
        // The next loops build the array epsAOpa that simplifies
        // the model equations.
        // The arrays stores the values of the constructios in the following order
        // [x[1:NConExt] x[1:NConPar] x[1: NConPar] x[1: NConBou] x[1: NSurBou] x[1: NConExtWin] x[1: NConExtWin]]
        // where x is epsOpa, AOpa or kOpa.
        // The last two entries are for the opaque wall that contains a window, and for the window frame.
        for i in 1:NConExt loop
          epsAOpa[i] = epsConExt[i] * AConExt[i];
        end for;
        for i in 1:NConPar loop
          epsAOpa[i+NConExt]         = epsConPar_a[i] * AConPar[i];
          epsAOpa[i+NConExt+NConPar] = epsConPar_b[i] * AConPar[i];
        end for;
        for i in 1:NConBou loop
          epsAOpa[i+NConExt+2*NConPar] = epsConBou[i] * AConBou[i];
        end for;
        for i in 1:NSurBou loop
          epsAOpa[i+NConExt+2*NConPar+NConBou] = epsSurBou[i] * ASurBou[i];
        end for;
        for i in 1:NConExtWin loop
          // Opaque part of construction that has a window embedded
          epsAOpa[i+NConExt+2*NConPar+NConBou+NSurBou] = epsConExtWinOpa[i] * AConExtWinOpa[i];
          // Window frame
          epsAOpa[i+NConExt+2*NConPar+NConBou+NSurBou+NConExtWin] = epsConExtWinFra[i] * AConExtWinFra[i];
        end for;
        // Window glass
        for i in 1:NConExtWin loop
          // Window glass
          epsAGla[i] = AGla[i] * epsGla[i];
          // Window shade
          epsASha[i]    = AGla[i] * epsSha[i];
          // Emitted from glas and transmitted through window shade
          epsTauASha[i] = AGla[i] * epsGla[i] * tauSha[i];
        end for;
      ////////////////////////////////////////////////////////////////////
      equation
        // Conditional connnector
        connect(glaUns, glaUns_internal);
        connect(glaSha, glaSha_internal);
        connect(sha, sha_internal);
        connect(uSha, uSha_internal);
        if not haveConExtWin then
          glaUns_internal.T = fill(293.15, NConExtWin);
        end if;
        if not haveShade then
          glaSha_internal.T = fill(293.15, NConExtWin);
          sha_internal.T = fill(293.15, NConExtWin);
          uSha_internal = fill(0, NConExtWin);
        end if;

        // Assign temperature of opaque surfaces
        for i in 1:NConExt loop
          TOpa[i] = conExt[i].T;
        end for;
        for i in 1:NConPar loop
          TOpa[i+NConExt]         = conPar_a[i].T;
          TOpa[i+NConExt+NConPar] = conPar_b[i].T;
        end for;
        for i in 1:NConBou loop
          TOpa[i+NConExt+2*NConPar] = conBou[i].T;
        end for;
        for i in 1:NSurBou loop
          TOpa[i+NConExt+2*NConPar+NConBou] = conSurBou[i].T;
        end for;
        for i in 1:NConExtWin loop
          TOpa[i+NConExt+2*NConPar+NConBou+NSurBou]            = conExtWin[i].T;
          TOpa[i+NConExt+2*NConPar+NConBou+NConExtWin+NSurBou] = conExtWinFra[i].T;
        end for;
        // Assign temperature of glass and shade
        for i in 1:NConExtWin loop
          TGlaUns[i] = glaUns_internal[i].T;
          TGlaSha[i] = glaSha_internal[i].T;
          TSha[i]    = sha_internal[i].T;
        end for;
        // Compute radiative temperature
        if haveShade then
          TRad = (sum(epsAOpa[i] * TOpa[i] for i in 1:NOpa)
              + sum(
            ( uSha_internal[i] * (epsASha[i] * TSha[i] + epsTauASha[i] * TGlaSha[i]) +
            (1-uSha_internal[i]) * epsAGla[i] * TGlaUns[i])
              for i in 1:NConExtWin))  /
              (sum(epsAOpa) + sum(
            ( uSha_internal[i] * (epsASha[i] + epsTauASha[i]) + (1-uSha_internal[i]) * epsAGla[i])
              for i in 1:NConExtWin));
            else
          TRad = (sum(epsAOpa[i] * TOpa[i] for i in 1:NOpa) + sum(epsAGla .* TGlaUns)) / (sum(epsAOpa) + sum(epsAGla));
        end if;

        // Assign heat exchange to connectors
        for i in 1:NConExt loop
          0 = conExt[i].Q_flow;
        end for;
        for i in 1:NConPar loop
          0 = conPar_a[i].Q_flow;
          0 = conPar_b[i].Q_flow;
        end for;
        for i in 1:NConBou loop
          0 = conBou[i].Q_flow;
        end for;
        for i in 1:NSurBou loop
          0 = conSurBou[i].Q_flow;
        end for;
        for i in 1:NConExtWin loop
          0 = conExtWin[i].Q_flow;
          0 = conExtWinFra[i].Q_flow;
        end for;

       /*
  for i in 1:NConExtWin loop
    0 = glaUns_internal[i].Q_flow;
    0 = glaSha_internal[i].Q_flow;
    0 = sha_internal[i].Q_flow;
  end for;
*/

        annotation (
      preferedView="info",
      Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-240,-240},{240,240}}),
                            graphics), Icon(coordinateSystem(preserveAspectRatio=true,
                extent={{-240,-240},{240,240}}),
                                            graphics={
              Line(
                points={{-144,-8},{146,-8}},
                color={255,0,0},
                smooth=Smooth.None,
                thickness=0.5),
              Line(
                points={{2,-200},{2,184}},
                color={255,0,0},
                smooth=Smooth.None,
                thickness=0.5)}),
      Documentation(
      info="<html>
<p>
This model computes the radiative temperature in the room.
For a room with windows but no shade, the radiative temperature is
computed as
</p>
<p align=\"center\" style=\"font-style:italic;\">
  T<sub>rad</sub> = &sum;<sub>i</sub> &nbsp; (A<sup>i</sup> &nbsp; &epsilon;<sup>i</sup> &nbsp; T<sup>i</sup>)
  &frasl;
  &sum;<sub>i</sub> &nbsp; (A<sup>i</sup> &nbsp; &epsilon;<sup>i</sup>)
</p>
where 
<i>T<sub>rad</sub></i> is the radiative temperature of the room,
<i>A<sup>i</sup></i> are the surface areas of the room,
<i>&epsilon;<sup>i</sup></i> are the infrared emissivities of the surfaces, and
<i>T<sup>i</sup></i> are the surface temperatures.
<p>
If a the windows have a shade, then the equation is modified to take the actual shaded and non-shaded
surface area into account. In this situation, the shaded part of a window has a infrared radiative power
of 
<p align=\"center\" style=\"font-style:italic;\">
 E = A &nbsp; ( u &nbsp; &epsilon;<sub>s</sub> &nbsp; T<sub>s</sub> + 
   (1-u) &nbsp; &epsilon;<sub>g</sub> &tau;<sub>s</sub> &nbsp; T<sub>gs</sub>)
</p>
where
<i>A</i> is the surface area of the glass,
<i>u</i> is the control signal of the shade,
<i>&epsilon;<sub>s</sub></i> is the infrared absorptivity of the shade,
<i>T<sub>s</sub></i> is the temperature of the shade,
<i>&epsilon;<sub>g</sub></i> is the infrared absorptivity of the glass,
<i>&tau;<sub>s</sub></i> is the infrared transmittance of the shade, and
<i>T<sub>gs</sub></i> is the glass temperature behind the shade.
<br>
For the unshaded part of the window, the radiative power is
<p align=\"center\" style=\"font-style:italic;\">
 E = A &nbsp; (1-u) &nbsp; &epsilon;<sub>g</sub> &nbsp; T<sub>gn</sub>
</p>
where
<i>T<sub>gn</sub></i> is the glass temperature of the non-shaded part of the window.
</p>
</html>",
      revisions="<html>
<ul>
<li>
March 29 2011, by Michael Wetter:<br>
Rewrote sum for the radiation temperature.
</li>
<li>
Jan. 18 2011, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
      end RadiationTemperature;

      model SolarRadiationExchange
      "Solar radiation heat exchange between the room facing surfaces"
        extends Buildings.Rooms.BaseClasses.PartialSurfaceInterface(
        final epsConExt = datConExt.layers.absSol_b,
        final epsConExtWinOpa = datConExtWin.layers.absSol_b,
        final epsConExtWinUns={(1-datConExtWin[i].glaSys.glass[datConExtWin[i].glaSys.nLay].tauSol
                           -datConExtWin[i].glaSys.glass[datConExtWin[i].glaSys.nLay].rhoSol_b) for i in 1:NConExtWin},
        final epsConExtWinSha = {(1-datConExtWin[i].glaSys.glass[datConExtWin[i].glaSys.nLay].tauSol
                             -datConExtWin[i].glaSys.glass[datConExtWin[i].glaSys.nLay].rhoSol_b) for i in 1:NConExtWin},
        final epsConExtWinFra = datConExtWin.glaSys.absSolFra,
        final epsConPar_a = datConPar.layers.absSol_a,
        final epsConPar_b = datConPar.layers.absSol_b,
        final epsConBou = datConBou.layers.absSol_b,
        final epsSurBou = surBou.absSol);
        // In the above declaration, we simplified the assignment of epsConExtWinSha.
        // An exact formulation would need to take into account the transmission and reflection
        // of the shade for the solar radiation that strikes the window from the room-side.
        // The simplification leads to too low a value of epsConExtWinSha. Since epsConExtWinSha
        // is used as a weight for how much solar radiation hits the window from the room-side,
        // underestimating epsConExtWinSha does not seem to cause concerns. The reason is that
        // the model assumes diffuse reflection, whereas in reality, reflection of the solar
        // radiation at the floor is likely specular, and therefore less radiation would hit
        // the window from the room-side.
        parameter Boolean isFloorConExt[NConExt]
        "Flag to indicate if floor for exterior constructions";
        parameter Boolean isFloorConExtWin[NConExtWin]
        "Flag to indicate if floor for constructions";
        parameter Boolean isFloorConPar_a[NConPar]
        "Flag to indicate if floor for constructions";
        parameter Boolean isFloorConPar_b[NConPar]
        "Flag to indicate if floor for constructions";
        parameter Boolean isFloorConBou[NConBou]
        "Flag to indicate if floor for constructions with exterior boundary conditions exposed to outside of room model";
        parameter Boolean isFloorSurBou[NSurBou]
        "Flag to indicate if floor for constructions that are modeled outside of this room";

        parameter Modelica.SIunits.Emissivity tauGla[NConExtWin]
        "Transmissivity of window";

        Modelica.Blocks.Interfaces.RealOutput HOutConExtWin[NConExtWin](unit="W/m2")
        "Outgoing solar radiation that strikes window per unit area"
          annotation (Placement(transformation(extent={{240,110},{260,130}})));
        Modelica.Blocks.Interfaces.RealInput JInConExtWin[NConExtWin](unit="W")
        "Solar radiation transmitted by window per unit area"
          annotation (Placement(transformation(extent={{260,70},{240,90}})));
        Modelica.SIunits.HeatFlowRate JOutConExtWin[NConExtWin]
        "Outgoing solar radiation that strikes the window";

        Modelica.SIunits.HeatFlowRate HTot
        "Total solar radiation that enters the room";

    protected
        final parameter Real k1(unit="1", fixed=false)
        "Intermediate variable for gain for solar radiation distribution";
        final parameter Real k2(fixed=false)
        "Intermediate variable for gain for solar radiation distribution";
        Modelica.SIunits.HeatFlowRate Q_flow[NTot]
        "Total solar radiation that is absorbed by the surfaces (or transmitted back through the glass)";
        final parameter Integer NOpa = NConExt+2*NConExtWin+2*NConPar+NConBou+NSurBou
        "Number of opaque surfaces, including the window frame";
        final parameter Integer NWin = NConExtWin "Number of window surfaces";
        final parameter Integer NTot = NOpa + NWin "Total number of surfaces";
        final parameter Boolean isFlo[NTot](fixed=false)
        "Flag, true if a surface is a floor";
        final parameter Real eps[NTot](min=0, max=1, fixed=false)
        "Solar absorptivity";
        final parameter Real tau[NTot](min=0, max=1, fixed=false)
        "Solar transmissivity";
        final parameter Modelica.SIunits.Area AFlo(fixed=false)
        "Total floor area";
        final parameter Modelica.SIunits.Area A[NTot](fixed=false)
        "Surface areas";
        final parameter Real k[NTot](unit="1", fixed=false)
        "Gain for solar radiation distribution";

      initial equation
        // The next loops builds arrays that simplify
        // the model equations.
        // These arrays store the values of the constructios in the following order
        // [x[1:NConExt] x[1:NConPar] x[1: NConPar] x[1: NConBou] x[1: NSurBou] x[1: NConExtWin] x[1: NConExtWin]]
        // where x is epsOpa, AOpa or kOpa.
        // The last two entries are for the opaque wall that contains a window, and for the window frame.
        for i in 1:NConExt loop
          eps[i] = epsConExt[i];
          A[i]      = AConExt[i];
          isFlo[i]  = isFloorConExt[i];
        end for;
        for i in 1:NConPar loop
          eps[i+NConExt]           = epsConPar_a[i];
          A[i+NConExt]             = AConPar[i];
          isFlo[i+NConExt]         = isFloorConPar_a[i];
          eps[i+NConExt+NConPar]   = epsConPar_b[i];
          A[i+NConExt+NConPar]     = AConPar[i];
          isFlo[i+NConExt+NConPar] = isFloorConPar_b[i];
        end for;
        for i in 1:NConBou loop
          eps[i+NConExt+2*NConPar]   = epsConBou[i];
          A[i+NConExt+2*NConPar]     = AConBou[i];
          isFlo[i+NConExt+2*NConPar] = isFloorConBou[i];
        end for;
        for i in 1:NSurBou loop
          eps[i+NConExt+2*NConPar+NConBou]   = epsSurBou[i];
          A[i+NConExt+2*NConPar+NConBou]     = ASurBou[i];
          isFlo[i+NConExt+2*NConPar+NConBou] = isFloorSurBou[i];
        end for;

        for i in 1:NConExtWin loop
          // Opaque part of construction that has a window embedded
          eps[i+NConExt+2*NConPar+NConBou+NSurBou]   = epsConExtWinOpa[i];
          A[i+NConExt+2*NConPar+NConBou+NSurBou]     = AConExtWinOpa[i];
          isFlo[i+NConExt+2*NConPar+NConBou+NSurBou] = isFloorConExtWin[i];
          // Window frame
          eps[i+NConExt+2*NConPar+NConBou+NSurBou+NConExtWin]   = epsConExtWinFra[i];
          A[i+NConExt+2*NConPar+NConBou+NSurBou+NConExtWin]     = AConExtWinFra[i];
          isFlo[i+NConExt+2*NConPar+NConBou+NSurBou+NConExtWin] = isFloorConExtWin[i];
        end for;
        // Window glass
        for i in 1:NConExtWin loop
          // We simplify and assume that the shaded and unshaded part of the window
          // have the same solar absorbtance.
          // This simplification allows lumping the solar distribution into
          // a parameter.
          eps[i+NConExt+2*NConPar+NConBou+NSurBou+2*NConExtWin] = epsConExtWinUns[i];
          isFlo[i+NConExt+2*NConPar+NConBou+NSurBou+2*NConExtWin] = isFloorConExtWin[i];
          A[i+NConExt+2*NConPar+NConBou+NSurBou+2*NConExtWin] = AConExtWinGla[i];
        end for;
        // Vector with all surface areas.
        // The next loops build the array A that simplifies
        // the model equations.
        // These array stores the values of the constructios in the following order
        // [AOpa[1:NConExt] AOpa[1:NConPar] AOpa[1: NConPar] AOpa[1: NConBou] AOpa[1: NSurBou]
        //  AOpa[1: NConExtWin] AOpa[1: NConExtWin] AGla[1: NConExtWin]]
        // since NWin=NConExtWin.

        // Solar transmissivity
        for i in 1:NOpa loop
          tau[i] = 0;
        end for;
        for i in 1:NWin loop
          tau[NOpa+i] = tauGla[i];
        end for;

        // Sum of surface areas
        AFlo = sum( (if isFlo[i] then A[i] else 0) for i in 1:NTot);

        // Coefficient that is used for non-floor areas.
        // The expression  max(1E-20, AFlo) is used to prevent a division by zero in case AFlo=0.
        // The situation for AFlo=0 is caught by the assert statement.
        k1 = sum( ( if isFlo[i] then (A[i] * (1-eps[i]-tau[i])) else 0)  for i in 1:NTot) / max(1E-20, AFlo);

        k2 = sum( ( if isFlo[i] then 0 else (A[i] * (eps[i]+tau[i])))  for i in 1:NTot);

        if ( k2 > 1E-10) then
          for i in 1:NTot loop
            if isFlo[i] then
               k[i] = (eps[i]+tau[i]) * A[i] / AFlo;
            else
               k[i] = k1/k2*(eps[i]+tau[i]) * A[i];
            end if;
           end for;
        else
              // This branch only happens if k2=0, i.e., there is no surface other than floors
          for i in 1:NTot loop
            if isFlo[i] then
              k[i] = A[i] / AFlo;
            else
              k[i] = 0;
            end if;
          end for;
        end if;

        // Test whether there is a floor inside this room
        assert( AFlo > 1E-10,
           "Error in parameters of the room model: The geometry is incorrect:\n" +
           "    The room model must have a construction that is a floor,\n" +
           "    and this construction must not have a window.\n" +
           "    The parameters for the room model are such that there is no such construction.\n" +
           "    Revise the model parameters.");
        // Test whether the distribution factors add up to one
        assert(abs(1-sum(k)) < 1E-5,
           "Program error: Sum of solar distribution factors in room is not equal to one. k=" + String(sum(k)));

      ////////////////////////////////////////////////////////////////////
      equation
        // Incoming radiation
        HTot = sum(JInConExtWin);
        // Radiation that is absorbed by the surfaces
        Q_flow = -k .* HTot;
        // Assign heat exchange to connectors
        for i in 1:NConExt loop
          Q_flow[i] = conExt[i].Q_flow;
        end for;
        for i in 1:NConPar loop
          Q_flow[i+NConExt]         = conPar_a[i].Q_flow;
          Q_flow[i+NConExt+NConPar] = conPar_b[i].Q_flow;
        end for;
        for i in 1:NConBou loop
          Q_flow[i+NConExt+2*NConPar] = conBou[i].Q_flow;
        end for;
        for i in 1:NSurBou loop
          Q_flow[i+NConExt+2*NConPar+NConBou] = conSurBou[i].Q_flow;
        end for;
        for i in 1:NConExtWin loop
          Q_flow[i+NConExt+2*NConPar+NConBou+NSurBou]            = conExtWin[i].Q_flow;
          Q_flow[i+NConExt+2*NConPar+NConBou+NSurBou+NConExtWin] = conExtWinFra[i].Q_flow;
        end for;
        // Windows
        for j in 1:NWin loop
          Q_flow[j+NOpa] = JOutConExtWin[j];
          HOutConExtWin[j] = if (AConExtWinGla[j] > 1E-10) then JOutConExtWin[j] / AConExtWinGla[j] else 0;
        end for;

        annotation (
      preferedView="info",
      Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-240,-240},
                  {240,240}}),
                            graphics), Icon(coordinateSystem(preserveAspectRatio=true,
                extent={{-240,-240},{240,240}}),
                                            graphics={
              Line(
                points={{-144,-8},{2,-200}},
                color={255,128,0},
                smooth=Smooth.None),
              Line(
                points={{2,-200},{2,184}},
                color={255,128,0},
                smooth=Smooth.None),
              Line(
                points={{2,-200},{148,-8}},
                color={255,128,0},
                smooth=Smooth.None,
                thickness=1),
              Rectangle(
                extent={{148,74},{174,-78}},
                lineColor={95,95,95},
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{154,74},{158,-78}},
                lineColor={95,95,95},
                fillColor={85,170,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{166,74},{170,-78}},
                lineColor={95,95,95},
                fillColor={85,170,255},
                fillPattern=FillPattern.Solid)}),
              Documentation(info="<html>
<p>
This model computes the distribution of the solar radiation gain
to the room surfaces.
Let 
<i>N<sup>w</sup></i> 
denote the number of windows,
<i>N<sup>f</sup></i> 
the number of floor elements and
<i>N<sup>n</sup></i> 
the number of non-floor elements such as ceiling, wall and window elements.
Input to the model are the solar radiosities 
<i>J<sup>i</sup>, i &isin; {1, &hellip; , N<sup>w</sup>}</i>,
that were transmitted through the window.
The total incoming solar radiation is therefore
</p>
<p align=\"center\" style=\"font-style:italic;\">
H = &sum;<sub>i=1</sub><sup>N<sup>w</sup></sup> J<sub>in</sub><sup>i</sup>
</p>
<p>
It is assumed that <i>H</i> first hits the floor where some of it is absorbed,
and some of it is diffusely reflected to all other surfaces. Only the first 
reflection is taken into account and the location of the floor patch
relative to the window is neglected.
</p>
<p>Hence, the radiation that is 
absorbed by each floor patch <i>i &isin; {1, &hellip;, N<sup>f</sup>}</i>,
and may be partially transmitted in
the unusual case that the floor contains a window, is
</p>
<p align=\"center\" style=\"font-style:italic;\">
 Q<sup>i</sup> = H &nbsp; (&epsilon;<sup>i</sup>+&tau;<sup>i</sup>) &nbsp; A<sup>i</sup> 
&frasl; &sum;<sub>j=1</sub><sup>N<sup>f</sup></sup> &nbsp; A<sup>j</sup>.
</p>
The sum of the radiation that is reflected by the floor is therefore
</p>
<p align=\"center\" style=\"font-style:italic;\">
 J<sup>f</sup> = H &nbsp; 
&sum;<sub>i=1</sub><sup>N<sup>f</sup></sup>
(1-&epsilon;<sup>i</sup>-&tau;<sup>i</sup>) &nbsp; A<sup>i</sup> 
&frasl; &sum;<sub>j=1</sub><sup>N<sup>f</sup></sup> &nbsp; A<sup>j</sup>.
</p>
<p>
This reflected radiosity is then distributed to all non-floor areas
<i>i &isin; {1, &hellip;, N<sup>n</sup>}</i>
using</p>
</p>
<p align=\"center\" style=\"font-style:italic;\">
  Q<sup>i</sup> = J<sup>f</sup> &nbsp;
A<sup>i</sup> &nbsp; (&epsilon;<sup>i</sup>+&tau;<sup>i</sup>)
&frasl;
&sum;<sub>k=1</sub><sup>N<sup>n</sup></sup>
A<sup>k</sup> &nbsp; (&epsilon;<sup>k</sup>+&tau;<sup>k</sup>)
</p>
<p>
For opaque surfaces, the heat flow rate 
<i>Q<sup>i</sup></i> 
is set to be equal to the heat flow rate at the heat port.
For the glass of the windows, the heat flow rate 
<i>Q<sup>i</sup></i> is set to the radiosity
<i>J<sub>out</sub><sup>i</sup></i>
that will strike the glass or the window shade as diffuse solar
radiation.
</html>",     revisions="<html>
<ul>
<li>
November 6, 2011, by Michael Wetter:<br>
Fixed bug as in the old version, the absorbtance and reflectance
of the infrared spectrum has been used instead of the solar spectrum.
</li>
<li>
Dec. 1 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
      end SolarRadiationExchange;

      partial model PartialSurfaceInterface
      "Partial model that is used for infrared radiation balance"
        import Buildings;
        extends Buildings.Rooms.BaseClasses.ConstructionRecords;

        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a conExt[NConExt]
        "Heat port that connects to room-side surface of exterior constructions"
                                    annotation (Placement(transformation(extent={{230,210},
                  {250,230}},          rotation=0)));

        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a conExtWin[NConExtWin]
        "Heat port that connects to room-side surface of exterior constructions that contain a window"
                                    annotation (Placement(transformation(extent={{230,170},
                  {250,190}},          rotation=0)));

        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a conExtWinFra[NConExtWin]
        "Heat port that connects to room-side surface of window frame"
                                    annotation (Placement(transformation(extent={{232,-10},
                  {252,10}},           rotation=0)));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a conPar_a[NConPar]
        "Heat port that connects to room-side surface a of partition constructions"
                                    annotation (Placement(transformation(extent={{232,-70},
                  {252,-50}},          rotation=0)));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a conPar_b[NConPar]
        "Heat port that connects to room-side surface b of partition constructions"
                                    annotation (Placement(transformation(extent={{232,
                  -110},{252,-90}},    rotation=0)));

        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a conBou[NConBou]
        "Heat port that connects to room-side surface of constructions that expose their other surface to the outside"
                                    annotation (Placement(transformation(extent={{232,
                  -170},{252,-150}},   rotation=0)));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a conSurBou[NSurBou]
        "Heat port to surfaces of models that compute the heat conduction outside of this room"
                                    annotation (Placement(transformation(extent={{231,
                  -230},{251,-210}},   rotation=0)));
    protected
        final parameter Modelica.SIunits.Area AConExt[NConExt] = datConExt.A
        "Areas of exterior constructions";
        final parameter Modelica.SIunits.Area AConExtWinOpa[NConExtWin] = datConExtWin.AOpa
        "Opaque areas of exterior construction that have a window";
        final parameter Modelica.SIunits.Area AConExtWinGla[NConExtWin] = (1 .- datConExtWin.fFra) .* datConExtWin.AWin
        "Glass areas of exterior construction that have a window";
        final parameter Modelica.SIunits.Area AConExtWinFra[NConExtWin] = datConExtWin.fFra .* datConExtWin.AWin
        "Frame areas of exterior construction that have a window";
        final parameter Modelica.SIunits.Area AConPar[NConPar] = datConPar.A
        "Areas of partition constructions";
        final parameter Modelica.SIunits.Area AConBou[NConBou] = datConBou.A
        "Areas of constructions with exterior boundary conditions exposed to outside of room model";
        final parameter Modelica.SIunits.Area ASurBou[NSurBou] = surBou.A
        "Area of surface models of constructions that are modeled outside of this room";

        parameter Modelica.SIunits.Emissivity epsConExt[NConExt] = datConExt.layers.absIR_b
        "Absorptivity of exterior constructions";
        parameter Modelica.SIunits.Emissivity epsConExtWinOpa[NConExtWin] = datConExtWin.layers.absIR_b
        "Absorptivity of opaque part of exterior constructions that contain a window";
        parameter Modelica.SIunits.Emissivity epsConExtWinUns[NConExtWin]=
          {(datConExtWin[i].glaSys.glass[datConExtWin[i].glaSys.nLay].absIR_b) for i in 1:NConExtWin}
        "Absorptivity of unshaded part of window constructions";
        parameter Modelica.SIunits.Emissivity epsConExtWinSha[NConExtWin] = datConExtWin.glaSys.shade.absIR_a
        "Absorptivity of shaded part of window constructions";
        parameter Modelica.SIunits.Emissivity epsConExtWinFra[NConExtWin] = datConExtWin.glaSys.absIRFra
        "Absorptivity of window frame";
        parameter Modelica.SIunits.Emissivity epsConPar_a[NConPar] = datConPar.layers.absIR_a
        "Absorptivity of partition constructions surface a";
        parameter Modelica.SIunits.Emissivity epsConPar_b[NConPar] = datConPar.layers.absIR_b
        "Absorptivity of partition constructions surface b";
        parameter Modelica.SIunits.Emissivity epsConBou[NConBou] = datConBou.layers.absIR_b
        "Absorptivity of constructions with exterior boundary conditions exposed to outside of room model";
        parameter Modelica.SIunits.Emissivity epsSurBou[NSurBou] = surBou.absIR
        "Absorptivity of surface models of constructions that are modeled outside of this room";
        annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-240,
                  -240},{240,240}}),
                            graphics), Icon(coordinateSystem(preserveAspectRatio=true,
                extent={{-240,-240},{240,240}}),
                                            graphics={
              Rectangle(
                extent={{-240,240},{240,-240}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{148,206},{174,-206}},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Rectangle(
                extent={{-170,-200},{172,-224}},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Rectangle(
                extent={{-170,206},{-144,-224}},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Rectangle(
                extent={{-170,208},{174,184}},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Text(
                extent={{-234,328},{242,244}},
                lineColor={0,0,127},
                textString="%name"),
              Rectangle(
                extent={{-144,184},{148,-198}},
                pattern=LinePattern.None,
                lineColor={0,0,0},
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid)}),
              Documentation(info="<html>
This partial model is used as a base class for models that need to exchange
heat with room-facing surfaces. It defines parameters for the surface area,
the absorptivity, and the products of area times absorptivity.
</p>
<p>
There are also parameters that contain the number of constructions,
such as the number of exterior constructions <code>nConExt</code>. 
This parameter may take on the value <code>0</code>. 
If this parameter were to be used to declare the size of vectors of
component models, then there may be vectors with zero components.
This can cause problems in Dymola 7.4. 
We therefore also introduced the parameter
<pre>
  NConExt = max(1, nConExt)

</pre>
which can be used to set the size of the vector of component models.
</p>
<p>
There are also parameters that can be used to conditionally remove components,
such as <code>haveConExt</code>, which is set to 
<pre>
  haveConExt = nConExt > 0;

</pre>
</p>
</html>",
      revisions="<html>
<ul>
<li>
November 6, 2011, by Michael Wetter:<br>
Changed parameters that contain radiative properties from final to non-final, as
they need to be overwritten by 
<a href=\"modelica://Buildings.Rooms.BaseClasses.SolarRadiationExchange\">
Buildings.Rooms.BaseClasses.SolarRadiationExchange</a>.
</li>
<li>
November 16 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
      end PartialSurfaceInterface;

      model SkyRadiationExchange
      "Radiative heat exchange with the sky and the ambient"
        import Buildings;
        extends Buildings.BaseClasses.BaseIcon;
        parameter Integer n(min=1) "Number of constructions";
         parameter Modelica.SIunits.Area A[n] "Area of exterior constructions";
        parameter Real vieFacSky[n](min=0, max=1)
        "View factor to sky (=1 for roofs)";
        parameter Modelica.SIunits.Emissivity absIR[n]
        "Infrared absorptivity of building surface";
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port[n] "Heat port"
          annotation (Placement(transformation(extent={{90,-2},{110,18}})));
        Modelica.Blocks.Interfaces.RealInput TOut(final quantity="ThermodynamicTemperature",
                                                  final unit = "K", min=0)
        "Outside air temperature"
          annotation (Placement(transformation(extent={{-140,-60},{-100,-20}}),
              iconTransformation(extent={{-140,-60},{-100,-20}})));
        Modelica.Blocks.Interfaces.RealInput TBlaSky(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          min=0) "Black body sky temperature"
          annotation (Placement(transformation(extent={{-140,20},{-100,60}}),
              iconTransformation(extent={{-140,20},{-100,60}})));
    protected
        parameter Real k[n](unit="W/K4") = {4*A[i]*Modelica.Constants.sigma*absIR[i] for i in 1:n}
        "Constant for radiative heat exchange";
        Modelica.SIunits.Temperature TEnv[n] "Environment temperature";
        Real TBlaSky4(unit="K4")
        "Auxiliary variable for radiative heat exchange";
        Real TOut4(unit="K4") "Auxiliary variable for radiative heat exchange";
        Modelica.SIunits.CoefficientOfHeatTransfer h[n]
        "Radiative heat transfer coefficient";

      equation
        TBlaSky4 = TBlaSky^4;
        TOut4 = TOut^4;
        for i in 1:n loop
          TEnv[i] = (vieFacSky[i] * TBlaSky4 + (1-vieFacSky[i]) * TOut4)^(0.25);
          // h[i] uses TEnv[i] instead of (port[i].T+TEnv[i])/2 to avoid
          // a nonlinear equation system
          h[i]  = k[i] * TEnv[i]^3;
          port[i].Q_flow = h[i] * (port[i].T-TEnv[i]);
        end for;
        annotation (Diagram(graphics), Icon(graphics={
              Rectangle(
                extent={{-100,100},{100,-100}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-60,80},{-40,-60}},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Rectangle(
                extent={{88,-60},{-74,-74}},
                fillColor={5,135,13},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None,
                lineColor={0,0,0}),
              Ellipse(
                extent={{2,82},{86,36}},
                pattern=LinePattern.None,
                fillColor={170,213,255},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,0}),
              Line(
                points={{-40,16},{-30,28},{-14,28},{-6,44},{10,42},{12,46}},
                smooth=Smooth.None,
                color={255,0,0},
                thickness=0.5),
              Line(
                points={{-40,16},{-22,-4},{2,-6},{12,-30},{42,-40},{48,-58}},
                smooth=Smooth.None,
                color={255,0,0},
                thickness=0.5),
              Text(
                extent={{-128,12},{-78,-34}},
                lineColor={0,0,127},
                textString="TOut"),
              Text(
                extent={{-130,96},{-80,50}},
                lineColor={0,0,127},
                textString="TSky"),
              Text(
                extent={{86,52},{136,6}},
                lineColor={0,0,127},
                textString="QIR_flow")}),
              Documentation(info = "<html>
This model computes the infrared radiative heat flow 
between exterior building surfaces and the ambient. The ambient consists
of the sky black-body radiation and the outdoor temperature 
(which is used as an approximation to the surface temperature of
the ground and neighboring buildings).
</html>",     revisions="<html>
<ul>
<li>
June 4 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
      end SkyRadiationExchange;

      record ConstructionNumbers "Data records for construction data"

        ////////////////////////////////////////////////////////////////////////
        // Number of constructions and surface areas
        parameter Integer nConExt(min=0) "Number of exterior constructions"
          annotation (Dialog(group="Exterior constructions"));
        parameter Integer nConExtWin(min=0) "Number of window constructions"
          annotation (Dialog(group="Exterior constructions"));

        parameter Integer nConPar(min=0) "Number of partition constructions"
        annotation (Dialog(group="Partition constructions"));

        parameter Integer nConBou(min=0)
        "Number of constructions that have their outside surface exposed to the boundary of this room"
        annotation (Dialog(group="Boundary constructions"));

        parameter Integer nSurBou(min=0)
        "Number of surface heat transfer models that connect to constructions that are modeled outside of this room"
        annotation (Dialog(group="Boundary constructions"));

        // Dimensions of components and connectors
    protected
        parameter Integer NConExt(min=1)=max(1, nConExt)
        "Number of elements for exterior constructions";

        parameter Integer NConExtWin(min=1)=max(1, nConExtWin)
        "Number of elements for exterior constructions with windows";

        parameter Integer NConPar(min=1)=max(1, nConPar)
        "Number of elements for partition constructions";

        parameter Integer NConBou(min=1)=max(1, nConBou)
        "Number of elements for constructions that have their outside surface exposed to the boundary of this room";

        parameter Integer NSurBou(min=1)=max(1, nSurBou)
        "Number of elements for surface heat transfer models that connect to constructions that are modeled outside of this room";

        // Flags to conditionally remove components
        final parameter Boolean haveConExt = nConExt > 0
        "Flag to conditionally remove components";
        final parameter Boolean haveConExtWin = nConExtWin > 0
        "Flag to conditionally remove components";
        final parameter Boolean haveConPar = nConPar > 0
        "Flag to conditionally remove components";
        final parameter Boolean haveConBou = nConBou > 0
        "Flag to conditionally remove components";
        final parameter Boolean haveSurBou = nSurBou > 0
        "Flag to conditionally remove components";
      annotation (
      Documentation(
      info="<html>
<p>
Record that defines the number of constructions that are 
used in the room model.
</p>
</html>",
      revisions="<html>
<ul>
<li>
January 14, 2011, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));

      end ConstructionNumbers;

      record ConstructionRecords "Data records for construction data"
        extends Buildings.Rooms.BaseClasses.ConstructionNumbers;

        parameter ParameterConstruction datConExt[NConExt](
          each A=0,
          redeclare Buildings.HeatTransfer.Data.OpaqueConstructions.Brick120 layers,
          each til=0,
          each azi=0) "Data for exterior construction"
          annotation (Placement(transformation(extent={{-140,-120},{-120,-100}})), HideResult=true);
        parameter Buildings.Rooms.BaseClasses.ParameterConstructionWithWindow
          datConExtWin[NConExtWin](
          each A=0,
          redeclare Buildings.HeatTransfer.Data.OpaqueConstructions.Brick120 layers,
          each til=0,
          each azi=0,
          each AWin=0,
          redeclare Buildings.HeatTransfer.Data.GlazingSystems.SingleClear3 glaSys)
        "Data for exterior construction with window"
          annotation (Placement(transformation(extent={{-140,-160},{-120,-140}})), HideResult=true);
        parameter Buildings.Rooms.BaseClasses.ParameterConstruction datConPar[
                    NConPar](
          each A=0,
          redeclare Buildings.HeatTransfer.Data.OpaqueConstructions.Brick120 layers,
          each til=0,
          each azi=0) "Data for partition construction"
          annotation (Placement(transformation(extent={{-140,-200},{-120,-180}})), HideResult=true);
        parameter Buildings.Rooms.BaseClasses.ParameterConstruction datConBou[NConBou](
          each A=0,
          redeclare Buildings.HeatTransfer.Data.OpaqueConstructions.Brick120 layers,
          each til=0,
          each azi=0) "Data for construction boundary"
          annotation (Placement(transformation(extent={{-100,-120},{-80,-100}})), HideResult=true);
        parameter Buildings.HeatTransfer.Data.OpaqueSurfaces.Generic surBou[
                                          NSurBou](each A=0, each til=0)
        "Record for data of surfaces whose heat conduction is modeled outside of this room"
          annotation (Placement(transformation(extent={{-80,-160},{-100,-140}})), HideResult=true);

        annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-200,-200},
                  {100,100}})),       Icon(coordinateSystem(preserveAspectRatio=true,
                extent={{-200,-200},{100,100}})),
      Documentation(
      info="<html>
<p>
Record that defines the number of constructions that are
used in the room model.
</p>
</html>",
      revisions="<html>
<ul>
<li>
January 14, 2011, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));

      end ConstructionRecords;

      record ParameterConstructionWithWindow
      "Record for exterior constructions that have a window"
        extends Buildings.Rooms.BaseClasses.PartialParameterConstruction;

        parameter Modelica.SIunits.Area A
        "Heat transfer area of opaque construction and window combined";
        parameter Modelica.SIunits.Area AWin "Heat transfer area of window"
            annotation (Dialog(group="Glazing system"));

        final parameter Modelica.SIunits.Area AOpa = A-AWin
        "Heat transfer area of opaque construction"
          annotation (Dialog(group="Opaque construction"));

        parameter Real fFra(
          min=0,
          max=1) = 0.1 "Fraction of window frame divided by total window area"
          annotation (Dialog(group="Glazing system"));
        final parameter Modelica.SIunits.Area AFra = fFra*AWin "Frame area"
          annotation (Dialog(group="Glazing system"));
        final parameter Modelica.SIunits.Area AGla=AWin - AFra "Glass area"
          annotation (Dialog(group="Glazing system"));
        parameter Boolean linearizeRadiation = true
        "Set to true to linearize emissive power"
          annotation (Dialog(group="Glazing system"));

       replaceable parameter HeatTransfer.Data.GlazingSystems.Generic glaSys
        "Material properties of glazing system"
          annotation (Dialog(group="Glazing system"), Evaluate=true, choicesAllMatching=true, Placement(transformation(extent={{140,80},
                  {160,100}})));
        annotation (
      Documentation(info="<html>
<p>
This data record is used to set the parameters of constructions that do have a window.
</p>
<p>
The surface azimuth is defined in 
<a href=\"modelica://Buildings.HeatTransfer.Types.Azimuth\">
Buildings.HeatTransfer.Types.Azimuth</a>
and the surface tilt is defined in <a href=\"modelica://Buildings.HeatTransfer.Types.Tilt\">
Buildings.HeatTransfer.Types.Tilt</a>
</p>
</html>",       revisions="<html>
<ul>
<li>
December 14, 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));

      end ParameterConstructionWithWindow;

      record ParameterConstruction
      "Record for exterior constructions that have no window"
        extends Buildings.Rooms.BaseClasses.PartialParameterConstruction;
        parameter Modelica.SIunits.Area A "Heat transfer area";

        annotation (
      Documentation(info="<html>
<p>
This data record is used to set the parameters of constructions that do not have a window.
</p>
<p>
The surface azimuth is defined in 
<a href=\"modelica://Buildings.HeatTransfer.Types.Azimuth\">
Buildings.HeatTransfer.Types.Azimuth</a>
and the surface tilt is defined in <a href=\"modelica://Buildings.HeatTransfer.Types.Tilt\">
Buildings.HeatTransfer.Types.Tilt</a>
</p>
</html>",       revisions="<html>
<ul>
<li>
December 14, 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));

      end ParameterConstruction;

      record PartialParameterConstruction "Partial record for constructions"
        extends Modelica.Icons.Record;
        replaceable parameter
        Buildings.HeatTransfer.Data.OpaqueConstructions.Generic
          layers "Material properties of opaque construction"
          annotation(Dialog(group="Opaque construction"),
                     Evaluate=true, choicesAllMatching=true, Placement(transformation(extent={{146,258},
                  {166,278}})));
        parameter Modelica.SIunits.Angle til "Surface tilt";
        parameter Modelica.SIunits.Angle azi "Surface azimuth";
        final parameter Boolean isFloor=til > 2.74889125 and til < 3.53428875
        "Flag, true if construction is a floor"   annotation (Evaluate=true);
        final parameter Boolean isCeiling=til > -0.392699 and til < 0.392699
        "Flag, true if construction is a floor"   annotation (Evaluate=true);
        final parameter Integer nLay(min=1, fixed=true) = layers.nLay
        "Number of layers";
        final parameter Integer nSta[nLay](min=1)={layers.material[i].nSta for i in 1:nLay}
        "Number of states"    annotation(Evaluate=true);
        parameter Boolean steadyStateInitial=false
        "=true initializes dT(0)/dt=0, false initializes T(0) at fixed temperature using T_a_start and T_b_start"
              annotation (Dialog(group="Initialization"), Evaluate=true);
        parameter Modelica.SIunits.Temperature T_a_start=293.15
        "Initial temperature at port_a, used if steadyStateInitial = false"
          annotation (Dialog(group="Initialization", enable=not steadyStateInitial));
        parameter Modelica.SIunits.Temperature T_b_start=293.15
        "Initial temperature at port_b, used if steadyStateInitial = false"
          annotation (Dialog(group="Initialization", enable=not steadyStateInitial));

        annotation (
      Documentation(info="<html>
<p>
This data record is used to set the parameters of constructions that do not have a window.
</p>
<p>
The surface azimuth is defined in 
<a href=\"modelica://Buildings.HeatTransfer.Types.Azimuth\">
Buildings.HeatTransfer.Types.Azimuth</a>
and the surface tilt is defined in <a href=\"modelica://Buildings.HeatTransfer.Types.Tilt\">
Buildings.HeatTransfer.Types.Tilt</a>
</p>
</html>",       revisions="<html>
<ul>
<li>
December 14, 2010, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));

      end PartialParameterConstruction;
    annotation (preferedView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Rooms\">Buildings.Rooms</a>.
</p>
</html>"));
    end BaseClasses;
  annotation (
  preferedView="info", Documentation(info="<html>
<p>
This package contains models for the heat transfer in rooms
and through the building envelope. 
Multiple instances of these models can be connected to create
a multi-zone building model.
To compute the air exchange between rooms and between a room
and the exterior, the room models can be connected to 
multi-zone air exchange models from the package
<a href=\"modelica://Buildings.Airflow\">
Buildings.Airflow</a>.
The room models can also be linked to models of HVAC systems
that are composed of the components in the package
<a href=\"modelica://Buildings.Fluid\">
Buildings.Fluid</a>.
</html>"));
  end Rooms;

  package Utilities "Package with utility functions such as for I/O"
    extends Modelica.Icons.Package;

    package Math "Library with functions such as for smoothing"
      extends Modelica.Icons.VariantsPackage;

      package Functions "Package with mathematical functions"
        extends Modelica.Icons.BasesPackage;

        function cubicHermiteLinearExtrapolation
        "Interpolate using a cubic Hermite spline with linear extrapolation"
          input Real x "Abscissa value";
          input Real x1 "Lower abscissa value";
          input Real x2 "Upper abscissa value";
          input Real y1 "Lower ordinate value";
          input Real y2 "Upper ordinate value";
          input Real y1d "Lower gradient";
          input Real y2d "Upper gradient";
          output Real y "Interpolated ordinate value";
        algorithm
          if (x > x1 and x < x2) then
            y:=Modelica.Fluid.Utilities.cubicHermite(
              x=x,
              x1=x1,
              x2=x2,
              y1=y1,
              y2=y2,
              y1d=y1d,
              y2d=y2d);
          elseif x <= x1 then
            // linear extrapolation
            y:=y1 + (x - x1)*y1d;
          else
            y:=y2 + (x - x2)*y2d;
          end if;
          annotation(smoothOrder=1,
              Documentation(info="<html>
<p>
For <i>x<sub>1</sub> &lt; x &lt; x<sub>2</sub></i>, this function interpolates
using cubic hermite spline. For <i>x</i> outside this interval, the function 
linearly extrapolates.
</p>
<p>
For how to use this function, see
<a href=\"modelica://Buildings.Utilities.Math.Functions.Examples.CubicHermite\">
Buildings.Utilities.Math.Functions.Examples.CubicHermite</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
September 27, 2011 by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end cubicHermiteLinearExtrapolation;

        function powerLinearized
        "Power function that is linearized below a user-defined threshold"

         input Real x "Abscissa value";
         input Real n "Exponent";
         input Real x0 "Abscissa value below which linearization occurs";
         output Real y "Function value";
        algorithm
          if x > x0 then
           y := x^n;
          else
           y := x0^n * (1-n) + n * x0^(n-1) * x;
          end if;
          annotation (
            Documentation(info="<html>
<p>
Function that approximates <i>y=x<sup>n</sup></i> 
where <i>0 &lt; n</i> so that
<ul>
<li>the function is defined and monotone increasing for all <i>x</i>.
<li><i>dy/dx</i> is bounded and continuous everywhere (for <i>n &lt; 1</i>).
</ul>
</p>
<p>
For <i>x &lt; x<sub>0</sub></i>, this function replaces 
<i>y=x<sup>n</sup></i> by 
a linear function that is continuously differentiable everywhere.
</p>
<p>
A typical use of this function is to replace 
<i>T = T4<sup>(1/4)</sup></i> in a radiation balance to ensure that the 
function is defined everywhere. This can help solving the initialization problem
when a solver may be far from a solution and hence <i>T4 &lt; 0</i>.
</p>
<p>
See the package <code>Examples</code> for the graph.
</p>
</html>",         revisions="<html>
<ul>
<li>
February 3, 2011, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),          smoothOrder=1, Inline=true);
        end powerLinearized;

        function regNonZeroPower
        "Power function, regularized near zero, but nonzero value for x=0"

         input Real x "Abscissa value";
         input Real n "Exponent";
         input Real delta = 0.01 "Abscissa value where transition occurs";
         output Real y "Function value";
      protected
          Real a1;
          Real a3;
          Real a5;
          Real delta2;
          Real x2;
          Real y_d "=y(delta)";
          Real yP_d "=dy(delta)/dx";
          Real yPP_d "=d^2y(delta)/dx^2";
        algorithm
          if abs(x) > delta then
           y := abs(x)^n;
          else
           delta2 :=delta*delta;
           x2 :=x*x;
           y_d :=delta^n;
           yP_d :=n*delta^(n - 1);
           yPP_d :=n*(n - 1)*delta^(n - 2);
           a1 := -(yP_d/delta - yPP_d)/delta2/8;
           a3 := (yPP_d - 12 * a1 * delta2)/2;
           a5 := (y_d - delta2 * (a3 + delta2 * a1));
           y := a5 + x2 * (a3 + x2 * a1);
           assert(a5>0, "Delta is too small for this exponent.");
          end if;
          annotation (
            Documentation(info="<html>
<p>
Function that approximates <i>y=|x|<sup>n</sup></i> where <i>n &gt; 0</i> 
so that
<ul>
<li><i>y(0)</i> is not equal to zero.
<li><i>dy/dx</i> is bounded and continuous everywhere.
</ul>
</p>
<p>
This function replaces <i>y=|x|<sup>n</sup></i> in the interval
<i>-&delta;...+&delta;</i> by a 4-th order polynomial that has the same
function value and the first and second derivative at <i>x=&pm; &delta;</i>.
</p>
<p>
A typical use of this function is to replace the 
function for the convective heat transfer
coefficient for forced or free convection that is of the form 
<i>h=c |dT|<sup>n</sup></i> for some constant <i>c</i> and exponent 
<i>0 &le; n &le; 1</i>. 
By using this function, the original function
that has an infinite derivative near zero and that takes on zero
at the origin is replaced by a function with a bounded derivative and 
a non-zero value at the origin. Physically, 
the region <i>-&delta;...+&delta;</i> may be interpreted as the region
where heat conduction dominates convection in the boundary layer.
</p>
<p>
See the package <code>Examples</code> for the graph.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 30, 2011, by Michael Wetter:<br>
Added <code>zeroDerivative</code> keyword.
</li>
<li>
April 14, 2008, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),         Inline=true,
                   smoothOrder=2,
                   derivative(zeroDerivative=n, zeroDerivative=delta)=BaseClasses.der_regNonZeroPower);
        end regNonZeroPower;

        function smoothHeaviside
        "Once continuously differentiable approximation to the Heaviside function"
          input Real x "Argument";
          input Real delta "Parameter used for scaling";
          output Real y "Result";
        algorithm
         y := Buildings.Utilities.Math.Functions.spliceFunction(1, 0, x, delta);
         annotation (Documentation(info="<html>
<p>
Once Lipschitz continuously differentiable approximation to the 
<code>Heaviside(.,.)</code> function.
</p>
</html>",         revisions="<html>
<ul>
<li>
July 14, 2010, by Wangda Zuo, Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end smoothHeaviside;

        function smoothMax
        "Once continuously differentiable approximation to the maximum function"
          input Real x1 "First argument";
          input Real x2 "Second argument";
          input Real deltaX "Width of transition interval";
          output Real y "Result";
        algorithm
          y := Buildings.Utilities.Math.Functions.spliceFunction(
                 pos=x1, neg=x2, x=x1-x2, deltax=deltaX);
          annotation (
        Documentation(info="<html>
<p>
Once continuously differentiable approximation to the <code>max(.,.)</code> function.
</p>
</html>",
        revisions="<html>
<ul>
<li>
August 15, 2008, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end smoothMax;

        function smoothMin
        "Once continuously differentiable approximation to the minimum function"
          input Real x1 "First argument";
          input Real x2 "Second argument";
          input Real deltaX "Width of transition interval";
          output Real y "Result";
        algorithm
          y := Buildings.Utilities.Math.Functions.spliceFunction(
               pos=x1, neg=x2, x=x2-x1, deltax=deltaX);
          annotation (
        Documentation(info="<html>
<p>
Once continuously differentiable approximation to the <code>max(.,.)</code> function.
</p>
</html>",
        revisions="<html>
<ul>
<li>
August 15, 2008, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end smoothMin;

        function smoothLimit
        "Once continuously differentiable approximation to the limit function"
          input Real x "Variable";
          input Real l "Low limit";
          input Real u "Upper limit";
          input Real deltaX "Width of transition interval";
          output Real y "Result";

      protected
          Real cor;
        algorithm
          cor :=deltaX/10;
          y := Buildings.Utilities.Math.Functions.smoothMax(x,l+deltaX,cor);
          y := Buildings.Utilities.Math.Functions.smoothMin(y,u-deltaX,cor);
          annotation (Documentation(info="<html>
<p>
Once continuously differentiable approximation to the <code>limit(.,.)</code> function.
The output is bounded to be in <i>[0, 1]</i>.
</p>
</html>",         revisions="<html>
<ul>
<li>
Sept 1, 2010, by Michael Wetter:<br>
Changed scaling to make sure that bounds are never violated.
</li>
<li>
July 14, 2010, by Wangda Zuo, Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end smoothLimit;

        function spliceFunction
            input Real pos "Argument of x > 0";
            input Real neg "Argument of x < 0";
            input Real x "Independent value";
            input Real deltax "Half width of transition interval";
            output Real out "Smoothed value";
      protected
            Real scaledX;
            Real scaledX1;
            Real y;
        algorithm
            scaledX1 := x/deltax;
            scaledX := scaledX1*Modelica.Math.asin(1);
            if scaledX1 <= -0.999999999 then
              y := 0;
            elseif scaledX1 >= 0.999999999 then
              y := 1;
            else
              y := (Modelica.Math.tanh(Modelica.Math.tan(scaledX)) + 1)/2;
            end if;
            out := pos*y + (1 - y)*neg;
            annotation (
        smoothOrder=1,
        derivative=BaseClasses.der_spliceFunction,
        Documentation(info="<html>
<p>
Function to provide a once continuously differentialbe transition between 
to arguments.
</p><p>
The function is adapted from 
<a href=\"Modelica:Modelica.Media.Air.MoistAir.Utilities.spliceFunction\">
Modelica.Media.Air.MoistAir.Utilities.spliceFunction</a> and provided here
for easier accessability to model developers.
</html>",         revisions="<html>
<ul>
<li>
May 11, 2010, by Michael Wetter:<br>
Removed default value for transition interval as this is problem dependent.
</li>
<li>
May 20, 2008, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end spliceFunction;

        function splineDerivatives
        "Function to compute the derivatives for cubic hermite spline interpolation"
          input Real x[size(x, 1)] "Support point, strict monotone increasing";
          input Real y[size(x, 1)] "Function values at x";
          input Boolean ensureMonotonicity=isMonotonic(y, strict=false)
          "Set to true to ensure monotonicity of the cubic hermite";
          output Real d[size(x, 1)] "Derivative at the support points";
      protected
          Integer n=size(x, 1) "Number of data points";
          Real delta[n - 1] "Slope of secant line between data points";
          Real alpha "Coefficient to ensure monotonicity";
          Real beta "Coefficient to ensure monotonicity";
          Real tau "Coefficient to ensure monotonicity";

        algorithm
          if (n>1) then
            assert(x[1] < x[n], "x must be strictly increasing.
  Received x[1] = "         + String(x[1]) + "
           x["         + String(n) + "] = " + String(x[n]));
          // Check data
            assert(isMonotonic(x, strict=true),
              "x-values must be strictly monontone increasing or decreasing.");
            if ensureMonotonicity then
              assert(isMonotonic(y, strict=false),
                "If ensureMonotonicity=true, y-values must be monontone increasing or decreasing.");
            end if;
          end if;

          // Compute derivatives at the support points
          if n == 1 then
            // only one data point
            d[1] :=0;
          elseif n == 2 then
            // linear function
            d[1] := (y[2] - y[1])/(x[2] - x[1]);
            d[2] := d[1];
          else
            // Slopes of the secant lines between i and i+1
            for i in 1:n - 1 loop
              delta[i] := (y[i + 1] - y[i])/(x[i + 1] - x[i]);
            end for;
            // Initial values for tangents at the support points.
            // End points use one-sided derivatives
            d[1] := delta[1];
            d[n] := delta[n - 1];

            for i in 2:n - 1 loop
              d[i] := (delta[i - 1] + delta[i])/2;
            end for;

          end if;
          // Ensure monotonicity
          if n > 2 and ensureMonotonicity then
            for i in 1:n - 1 loop
              if (abs(delta[i]) < Modelica.Constants.small) then
                d[i] := 0;
                d[i + 1] := 0;
              else
                alpha := d[i]/delta[i];
                beta := d[i + 1]/delta[i];
                // Constrain derivative to ensure monotonicity in this interval
                if (alpha^2 + beta^2) > 9 then
                  tau := 3/(alpha^2 + beta^2)^(1/2);
                  d[i] := delta[i]*alpha*tau;
                  d[i + 1] := delta[i]*beta*tau;
                end if;
              end if;
            end for;
          end if;
          annotation (Documentation(info="<html>
<p>
This function computes the derivatives at the support points <i>x<sub>i</sub></i>
that can be used as input for evaluating a cubic hermite spline.
If <code>ensureMonotonicity=true</code>, then the support points <i>y<sub>i</sub></i>
need to be monotone increasing (or increasing), and the computed derivatives
<i>d<sub>i</sub></i> are such that the cubic hermite is monotone increasing (or decreasing).
The algorithm to ensure monotonicity is based on the method described in Fritsch and Carlson (1980) for
<i>&rho; = &rho;<sub>2</sub></i>.
</p>
<p>
This function is typically used with
<a href=\"modelica://Buildings.Utilities.Math.Functions.cubicHermiteLinearExtrapolation\">
Buildings.Utilities.Math.Functions.cubicHermiteLinearExtrapolation</a>
which is used to evaluate the cubic spline.
Because in many applications, the shape of the spline depends on parameters,
this function has been implemented in such a way that all derivatives can be 
computed at once and then stored for use during the time stepping,
in which the above function may be called.
</p>
<h4>References</h4>
<p>
F.N. Fritsch and R.E. Carlson, <a href=\"http://dx.doi.org/10.1137/0717021\">Monotone piecewise cubic interpolation</a>. 
<i>SIAM J. Numer. Anal.</i>, 17 (1980), pp. 238?246.
</p>
</html>",         revisions="<html>
<ul>
<li>
September 29, 2011 by Michael Wetter:<br>
Added special case for one data point and two data points.
</li>
<li>
September 27, 2011 by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end splineDerivatives;

        function trapezoidalIntegration
        "Integration using the trapezoidal rule"
          input Integer N "Number of integrand points";
          input Real[:] f "Integrands";
          input Real deltaX "Width of interval for Trapezoidal integration";
          output Real result "Result";
        algorithm
          assert(N >= 2, "N must be no less than 2.");
          result := 0;
          for i in 1:N loop
            result := result + f[i];
          end for;

          result := 2*result;
          result := result - f[1] - f[N];
          result := result*deltaX/2;
          annotation (Documentation(info="<html>
<p>
This function computes a definite integral using the trapezoidal rule.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 23, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"));
        end trapezoidalIntegration;

        function inverseXRegularized
        "Function that approximates 1/x by a twice continuously differentiable function"

         input Real x "Abscissa value";
         input Real delta(min=0)
          "Abscissa value below which approximation occurs";
         output Real y "Function value";
      protected
         Real delta2 "Delta^2";
         Real x2_d2 "=x^2/delta^2";
        algorithm
          delta2 :=delta*delta;
          x2_d2  := x*x/delta2;
          y :=smooth(2, if (abs(x) > delta) then 1/x else
            x/delta2 + x*abs(x/delta2/delta*(2 - x2_d2*(3 - x2_d2))));
          annotation (
            Documentation(info="<html>
<p>
Function that approximates <i>y=1 &frasl; x</i> 
inside the interval <i>-&delta; &le; x &le; &delta;</i>.
The approximation is twice continuously differentiable with a bounded derivative on the whole 
real line.
<p>
See the package <code>Examples</code> for the graph.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 18, 2011, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),          smoothOrder=2, Inline=true);
        end inverseXRegularized;

        function isMonotonic
        "Returns true if the argument is a monotonic sequence"
          input Real x[:] "Sequence to be tested";
          input Boolean strict=false
          "Set to true to test for strict monotonicity";
          output Boolean monotonic
          "True if x is monotonic increasing or decreasing";
      protected
          Integer n=size(x, 1) "Number of data points";

        algorithm
          if n == 1 then
            monotonic := true;
          else
            monotonic := true;
            if strict then
              if (x[1] >= x[n]) then
                for i in 1:n - 1 loop
                  if (not x[i] > x[i + 1]) then
                    monotonic := false;
                  end if;
                end for;
              else
                for i in 1:n - 1 loop
                  if (not x[i] < x[i + 1]) then
                    monotonic := false;
                  end if;
                end for;
              end if;
            else
              // not strict
              if (x[1] >= x[n]) then
                for i in 1:n - 1 loop
                  if (not x[i] >= x[i + 1]) then
                    monotonic := false;
                  end if;
                end for;
              else
                for i in 1:n - 1 loop
                  if (not x[i] <= x[i + 1]) then
                    monotonic := false;
                  end if;
                end for;
              end if;
            end if;
            // strict
          end if;

          annotation (Documentation(info="<html>
<p>
This function returns <code>true</code> if its argument is 
monotonic increasing or decreasing, and <code>false</code> otherwise.
If <code>strict=true</code>, then strict monotonicity is tested,
otherwise weak monotonicity is tested.
</p>
</html>",         revisions="<html>
<ul>
<li>
September 28, 2011 by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
        end isMonotonic;

        package BaseClasses
        "Package with base classes for Buildings.Utilities.Math.Functions"
          extends Modelica.Icons.BasesPackage;

          encapsulated function der_regNonZeroPower
          "Power function, regularized near zero, but nonzero value for x=0"
           input Real x "Abscissa value";
           input Real n "Exponent";
           input Real delta = 0.01 "Abscissa value where transition occurs";
           input Real der_x;
           output Real der_y "Function value";
        protected
            Real a1;
            Real a3;
            Real delta2;
            Real x2;
            Real y_d "=y(delta)";
            Real yP_d "=dy(delta)/dx";
            Real yPP_d "=d^2y(delta)/dx^2";
          algorithm
            if abs(x) > delta then
             der_y := sign(x)*n*abs(x)^(n-1);
            else
             delta2 :=delta*delta;
             x2 :=x*x;
             y_d :=delta^n;
             yP_d :=n*delta^(n - 1);
             yPP_d :=n*(n - 1)*delta^(n - 2);
             a1 := -(yP_d/delta - yPP_d)/delta2/8;
             a3 := (yPP_d - 12 * a1 * delta2)/2;
             der_y := x * ( 4 * a1 * x * x + 2 * a3);
            end if;
           annotation(derivative(zeroDerivative=n, zeroDerivative=delta)=BaseClasses.der_2_regNonZeroPower,
          Documentation(
          info="<html>
<p>
Implementation of the first derivative of the function
<a href=\"modelica://Buildings.Utilities.Math.Functions.regNonZeroPower\">
Buildings.Utilities.Math.Functions.regNonZeroPower</a>.
</p>
</html>", revisions="<html>
<ul>
<li>
March 30, 2011, by Michael Wetter:<br>
Added <code>zeroDerivative</code> keyword.
</li>
<li>
April 9, 2009, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
          end der_regNonZeroPower;

          function der_spliceFunction "Derivative of splice function"
              input Real pos;
              input Real neg;
              input Real x;
              input Real deltax=1;
              input Real dpos;
              input Real dneg;
              input Real dx;
              input Real ddeltax=0;
              output Real out;
        protected
              Real scaledX;
              Real scaledX1;
              Real dscaledX1;
              Real y;
          algorithm
              scaledX1 := x/deltax;
              scaledX := scaledX1*Modelica.Math.asin(1);
              dscaledX1 := (dx - scaledX1*ddeltax)/deltax;
              if scaledX1 <= -0.99999999999 then
                y := 0;
              elseif scaledX1 >= 0.9999999999 then
                y := 1;
              else
                y := (Modelica.Math.tanh(Modelica.Math.tan(scaledX)) + 1)/2;
              end if;
              out := dpos*y + (1 - y)*dneg;
              if (abs(scaledX1) < 1) then
                out := out + (pos - neg)*dscaledX1*Modelica.Math.asin(1)/2/(
                  Modelica.Math.cosh(Modelica.Math.tan(scaledX))*Modelica.Math.cos(
                  scaledX))^2;
              end if;
          annotation (
          Documentation(
          info="<html>
<p>
Implementation of the first derivative of the function
<a href=\"modelica://Buildings.Utilities.Math.Functions.spliceFunction\">
Buildings.Utilities.Math.Functions.spliceFunction</a>.
</p>
</html>", revisions="<html>
<ul>
<li>
April 7, 2009, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
          end der_spliceFunction;
        annotation (preferedView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Utilities.Math.Functions\">Buildings.Utilities.Math.Functions</a>.
</p>
</html>"));
        end BaseClasses;
      annotation (preferedView="info", Documentation(info="<html>
<p>
This package contains functions for commonly used
mathematical operations. The functions are used in 
the blocks
<a href=\"modelica://Buildings.Utilities.Math\">
Buildings.Utilities.Math</a>.
</p>
</html>"));
      end Functions;

      block Average "Average of a vector"
        extends Modelica.Blocks.Interfaces.MISO;
      equation
       y = sum(u)/nin;
      annotation (defaultComponentName="ave",
      Documentation(info="<html>
<p>
This function outputs the average of the vector.
</p>
</html>",
      revisions="<html>
<ul>
<li>
April 3, 2009, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),       Icon(graphics={Text(
                extent={{-74,46},{66,-58}},
                lineColor={0,0,255},
                textString="ave")}));
      end Average;

      block Max "Maximum element of a vector"
        extends Modelica.Blocks.Interfaces.MISO;
      equation
       y = max(u);
      annotation (defaultComponentName="max",
      Documentation(info="<html>
<p>
Outputs the minimum of the vector.
</p>
</html>",
      revisions="<html>
<ul>
<li>
April 3, 2009, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),       Icon(graphics={Text(
                extent={{-74,90},{70,-70}},
                lineColor={0,0,255},
                textString="max")}));
      end Max;

      block Min "Minimum element of a vector"
        extends Modelica.Blocks.Interfaces.MISO;
      equation
       y = min(u);
      annotation (
      defaultComponentName="min",
      Documentation(info="<html>
<p>
Outputs the minimum of the vector.
</p>
</html>",
      revisions="<html>
<ul>
<li>
April 3, 2009, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),       Icon(graphics={Text(
                extent={{-72,88},{72,-72}},
                lineColor={0,0,255},
                textString="min")}));
      end Min;

      block SmoothMax
      "Once continuously differentiable approximation to the maximum function"
        extends Modelica.Blocks.Interfaces.SI2SO;
       parameter Real deltaX "Width of transition interval";
      equation
        y =  Buildings.Utilities.Math.Functions.smoothMax(x1=u1, x2=u2, deltaX=deltaX);
        annotation (Icon(graphics={Text(
                extent={{-88,40},{92,-32}},
                lineColor={160,160,164},
                textString="smoothMax()"), Text(
                extent={{-74,-44},{68,-114}},
                lineColor={0,0,255},
                textString="dX=%deltaX%")}),        Diagram(graphics),
      Documentation(info="<html>
<p>
Once continuously differentiable approximation to the <i>max(.,.)</i> function.
</p>
</html>",
      revisions="<html>
<ul>
<li>
August 15, 2008, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
      end SmoothMax;

      block SmoothMin
      "Once continuously differentiable approximation to the minimum function"
        extends Modelica.Blocks.Interfaces.SI2SO;
        parameter Real deltaX "Width of transition interval";
      equation
        y = Buildings.Utilities.Math.Functions.smoothMin(x1=u1, x2=u2, deltaX=deltaX);
        annotation (Icon(graphics={Text(
                extent={{-88,40},{92,-32}},
                lineColor={160,160,164},
                textString="smoothMin()"), Text(
                extent={{-66,-50},{76,-120}},
                lineColor={0,0,255},
                textString="dX=%deltaX%")}),        Diagram(graphics),
      Documentation(info="<html>
<p>
Once continuously differentiable approximation to the <i>max(.,.)</i> function.
</p>
</html>",
      revisions="<html>
<ul>
<li>
August 15, 2008, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
      end SmoothMin;
    annotation (preferedView="info", Documentation(info="<html>
<p>
This package contains blocks and functions for commonly used
mathematical operations. 
The classes in this package augment the classes
<a href=\"modelica://Modelica.Blocks\">
Modelica.Blocks</a>.
</p>
</html>"));
    end Math;

    package Psychrometrics "Library with psychrometric functions"
      extends Modelica.Icons.VariantsPackage;

      block X_pW "Humidity ratio for given water vapor pressure"
        extends
        Buildings.Utilities.Psychrometrics.BaseClasses.HumidityRatioVaporPressure;
        Modelica.Blocks.Interfaces.RealOutput X_w(min=0, max=1, nominal=0.01)
        "Species concentration at dry bulb temperature"
          annotation (Placement(transformation(extent={{100,-10},{120,10}},
                rotation=0)));
        Modelica.Blocks.Interfaces.RealInput p_w(final quantity="Pressure",
                                                 final unit="Pa",
                                                 displayUnit="Pa",
                                                 min = 0)
        "Water vapor pressure"
          annotation (Placement(transformation(extent={{-120,-10},{-100,10}},
                rotation=0)));
        output Modelica.SIunits.MassFraction x_w(min=0, max=1, nominal=0.01, start=0.001)
        "Water mass fraction per mass of dry air";
      equation
        X_w = Buildings.Utilities.Psychrometrics.Functions.X_pW(p_w=p_w, p=p_in_internal);
        x_w = X_w/(1-X_w);
        annotation (
      defaultComponentName="humRat",
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}),
                  graphics),
          Documentation(info="<html>
<p>
Block to compute the humidity ratio for a given water vapor partial pressure.
</p>
<p>If <code>use_p_in</code> is false (default option), the <code>p</code> parameter
is used as atmospheric pressure, 
and the <code>p_in</code> input connector is disabled; 
if <code>use_p_in</code> is true, then the <code>p</code> parameter is ignored, 
and the value provided by the input connector is used instead.
</p>
</html>",       revisions="<html>
<ul>
<li>
February 17, 2010 by Michael Wetter:<br>
Renamed block from <code>HumidityRatio_pWat</code> to <code>X_pW</code>.
</li>
<li>
April 14, 2009 by Michael Wetter:<br>
Converted model to block because <code>RealInput</code> are obsolete in Modelica 3.0.
</li>
<li>
August 7, 2008 by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),Icon(graphics={Text(
                extent={{-92,52},{-36,-40}},
                lineColor={0,0,0},
                textString="pW"), Text(
                extent={{46,44},{94,-24}},
                lineColor={0,0,0},
                textString="X")}));
      end X_pW;

      block X_pTphi
      "Return steam mass fraction as a function of relative humidity phi and temperature T"
        extends
        Buildings.Utilities.Psychrometrics.BaseClasses.HumidityRatioVaporPressure;
       replaceable package Medium =
            Modelica.Media.Interfaces.PartialCondensingGases "Medium model" annotation (choicesAllMatching = true);

    public
        Modelica.Blocks.Interfaces.RealInput T(final unit="K",
                                                 displayUnit="degC",
                                                 min = 0) "Temperature"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
        Modelica.Blocks.Interfaces.RealInput phi(min = 0, max=1)
        "Relative humidity (0...1)"
          annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));
        Modelica.Blocks.Interfaces.RealOutput X[Medium.nX](min = 0, max=1)
        "Steam mass fraction"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));
    protected
        constant Real k = 0.621964713077499 "Ratio of molar masses";
        Modelica.SIunits.AbsolutePressure psat "Saturation pressure";
       parameter Integer i_w(min=1, fixed=false) "Index for water substance";
       parameter Integer i_nw(min=1, fixed=false)
        "Index for non-water substance";
       parameter Boolean found(fixed=false) "Flag, used for error checking";
      initial algorithm
        found:=false;
        i_w :=1;
          for i in 1:Medium.nXi loop
            if Modelica.Utilities.Strings.isEqual(string1=Medium.substanceNames[i],
                                                  string2="water",
                                                  caseSensitive=false) then
              i_w :=i;
              found:=true;
            end if;
          end for;
        i_nw := if i_w == 1 then 2 else 1;
        assert(found, "Did not find medium species 'water' in the medium model. Change medium model.");
      algorithm
        psat := Medium.saturationPressure(T);
        X[i_w] := phi*k/(k*phi+p_in_internal/psat-phi);
        //sum(X[:]) = 1; // The formulation with a sum in an equation section leads to a nonlinear equation system
        X[i_nw] := 1 - X[i_w];
        annotation (Documentation(info="<html>
<p>
Block to compute the water vapor concentration based on
pressure, temperature and relative humidity.
</p>
<p>If <code>use_p_in</code> is false (default option), the <code>p</code> parameter
is used as atmospheric pressure, 
and the <code>p_in</code> input connector is disabled; 
if <code>use_p_in</code> is true, then the <code>p</code> parameter is ignored, 
and the value provided by the input connector is used instead.
</p>
</html>",       revisions="<html>
<ul>
<li>
February 22, by Michael Wetter:<br>
Improved the code that searches for the index of 'water' in the medium model.
</li>
<li>
February 17, 2010 by Michael Wetter:<br>
Renamed block from <code>MassFraction_pTphi</code> to <code>X_pTphi</code>
</li>
<li>
February 4, 2009 by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),       Icon(graphics={
              Text(
                extent={{-96,16},{-54,-22}},
                lineColor={0,0,0},
                textString="T"),
              Text(
                extent={{-86,-18},{-36,-100}},
                lineColor={0,0,0},
                textString="phi"),
              Text(
                extent={{26,56},{90,-54}},
                lineColor={0,0,0},
                textString="X_steam")}));
      end X_pTphi;

      block pW_TDewPoi
      "Model to compute the water vapor pressure for a given dew point temperature of moist air"
        extends Modelica.Blocks.Interfaces.BlockIcon;
        Modelica.Blocks.Interfaces.RealOutput p_w
        "Water vapor partial pressure"
          annotation (Placement(transformation(extent={{100,-10},{120,10}}, rotation=
                  0)));
        Modelica.Blocks.Interfaces.RealInput T(final quantity="Temperature",
                                               final unit="K",
                                               min = 0,
                                               displayUnit="degC")
        "Dew point temperature"
          annotation (Placement(transformation(extent={{-120,-10},{-100,10}},
                rotation=0)));

      equation
       p_w = Buildings.Utilities.Psychrometrics.Functions.pW_TDewPoi_amb(T=T);
          annotation (
          defaultComponentName="pWat",
          Documentation(info="<html>
<p>
Block to compute the water vapor pressure for a given dew point temperature.
</p>
<p>
The correlation used in this model is valid for dew point temperatures between 
<code>0 degC</code> and <code>200 degC</code>. It is the correlation from 2005
ASHRAE Handbook, p. 6.2. In an earlier version of this model, the equation from
Peppers has been used, but this equation yielded about 15 Kelvin lower dew point 
temperatures.
</p>
</html>",       revisions="<html>
<ul>
<li>
December 7, 2011 by Michael Wetter:<br>
Changed function call from 
<code>p_w = Buildings.Utilities.Psychrometrics.Functions.pW_TDewPoi(T=T);</code>
to 
<code>p_w = Buildings.Utilities.Psychrometrics.Functions.pW_TDewPoi_amb(T=T);</code>
as the first version sometimes triggered warnings when the solver attempts negative 
temperatures. The accuracy of the two implementation does not change much in the
region of interest for building HVAC applications.
</li>
<li>February 17, 2010 by Michael Wetter:<br>
Renamed block from <code>DewPointTemperature_pWat</code>
to <code>pW_TDewPoi</code>.
</li>
<li>
September 4, 2008 by Michael Wetter:<br>
Changed from causal to acausal ports, needed, for example, for
<a href=\"modelica://Buildings.Fluid.Examples.MixingVolumeMoistAir\">
Buildings.Fluid.Examples.MixingVolumeMoistAir</a>.
</li>
<li>
August 7, 2008 by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                  100}}), graphics={
              Rectangle(
                extent={{-100,100},{100,-100}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{104,44},{142,-2}},
                lineColor={0,0,255},
                textString="p_w"),
              Text(
                extent={{-136,50},{-98,4}},
                lineColor={0,0,255},
                textString="TDP"),
              Line(points={{-68,86},{-68,-72}}, color={0,0,0}),
              Line(points={{82,-72},{-66,-72}}, color={0,0,0}),
              Line(points={{-68,-46},{-54,-42},{-24,-30},{8,-2},{20,22},{28,54},{32,
                    74}}, color={0,0,0}),
              Line(
                points={{42,-32},{-28,-32}},
                color={255,0,0},
                thickness=0.5),
              Polygon(
                points={{-28,-32},{-14,-30},{-14,-34},{-28,-32}},
                lineColor={255,0,0},
                fillColor={255,0,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{84,-72},{74,-70},{74,-74},{84,-72}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-68,88},{-66,74},{-70,74},{-68,88}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-64,84},{-42,66}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                textString="X"),
              Text(
                extent={{82,-80},{92,-96}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                textString="T"),
              Line(points={{68,-44},{-62,-44}}, color={175,175,175}),
              Line(points={{68,-18},{-10,-18}}, color={175,175,175}),
              Line(points={{70,6},{12,6}}, color={175,175,175}),
              Line(points={{68,32},{22,32}}, color={175,175,175})}),
          Diagram(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{
                  100,100}}), graphics));
      end pW_TDewPoi;

      package Functions "Package with psychrometric functions"
        extends Modelica.Icons.Package;

        function pW_TDewPoi_amb
        "Function to compute the water vapor partial pressure for a given dew point temperature of moist air"
          extends
          Buildings.Utilities.Psychrometrics.Functions.BaseClasses.pW_TDewPoi_amb;

          input Modelica.SIunits.Temperature T "Dew point temperature";
          output Modelica.SIunits.Pressure p_w "Water vapor partial pressure";

        algorithm
          p_w := Modelica.Math.exp(a1 + a2*T);
          annotation (
            inverse(T=TDewPoi_pW_amb(p_w)),
            smoothOrder=1,
            Inline=true,
            derivative=BaseClasses.der_pW_TDewPoi_amb,
            Documentation(info="<html>
<p>
Dew point temperature calculation for moist air between <i>0 degC</i> and <i>30 degC</i>.
</p>
<p>
The correlation used in this model is valid for dew point temperatures between 
<code>0 degC</code> and <code>30 degC</code>. It is an approximation to the correlation from 2005
ASHRAE Handbook, p. 6.2, which is valid in a wider range of temperatures and implemented
in
<a href=\"modelica:Buildings.Utilities.Psychrometrics.Functions.pW_TDewPoi\">
Buildings.Utilities.Psychrometrics.Functions.pW_TDewPoi</a>.
The approximation error of this simplified function is below 5% for a 
temperature of <code>0 degC</code> to <code>30 degC</code>.
The benefit of this simpler function is that it can be inverted analytically,
whereas the other function requires a numerical solution.
</p>
</html>",         revisions="<html>
<ul>
<li>
May 21, 2010 by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                    100}}), graphics),
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics));
        end pW_TDewPoi_amb;

        function TDewPoi_pW_amb
        "Function to compute the dew point temperature of moist air for a given water vapor partial pressure"
          extends
          Buildings.Utilities.Psychrometrics.Functions.BaseClasses.pW_TDewPoi_amb;

          input Modelica.SIunits.Pressure p_w "Water vapor partial pressure";
          output Modelica.SIunits.Temperature T "Dew point temperature";

        algorithm
          T := (Modelica.Math.log(p_w) - a1)/a2;
          annotation (
            inverse(p_w=pW_TDewPoi_amb(T)),
            Inline=true,
            derivative=BaseClasses.der_TDewPoi_pW_amb,
            Documentation(info="<html>
<p>
Dew point temperature calculation for moist air between <i>0 degC</i> and <i>30 degC</i>
with partial pressure of water vapor as an input.
</p>
<p>
The correlation used in this model is valid for dew point temperatures between 
<code>0 degC</code> and <code>30 degC</code>. It is an approximation to the correlation from 2005
ASHRAE Handbook, p. 6.2, which is valid in a wider range of temperatures and implemented
in
<a href=\"modelica:Buildings.Utilities.Psychrometrics.Functions.pW_TDewPoi\">
Buildings.Utilities.Psychrometrics.Functions.pW_TDewPoi</a>.
The approximation error of this simplified function is below 5% for a 
temperature of <code>0 degC</code> to <code>30 degC</code>.
The benefit of this simpler function is that it can be inverted analytically,
whereas the other function requires a numerical solution.
</p>
</html>",         revisions="<html>
<ul>
<li>
May 21, 2010 by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                    100}}), graphics),
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics));
        end TDewPoi_pW_amb;

        function X_pW "Humidity ratio for given water vapor pressure"

          input Modelica.SIunits.Pressure p_w "Water vapor pressure";
          input Modelica.SIunits.Pressure p=101325 "Total pressure";
          output Modelica.SIunits.MassFraction X_w(
            min=0,
            max=1,
            nominal=0.01) "Species concentration at dry bulb temperature";

      protected
          Modelica.SIunits.MassFraction x_w(nominal=0.01)
          "Water mass fraction per mass of dry air";
        algorithm
          x_w := 0.62198*p_w/(p - p_w);
          X_w := x_w/(1 + x_w);
          annotation (
            smoothOrder=5,
            Inline=true,
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics),
            Documentation(info="<html>
<p>
Function to compute the humidity ratio for a given water vapor partial pressure.
</p>
</html>",         revisions="<html>
<ul>
<li>
February 17, 2010 by Michael Wetter:<br>
Renamed block from <code>HumidityRatio_pWat</code> to <code>X_pW</code>.
</li>
<li>
April 14, 2009 by Michael Wetter:<br>
Converted model to block because <code>RealInput</code> are obsolete in Modelica 3.0.
</li>
<li>
August 7, 2008 by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                    100}}), graphics));
        end X_pW;

        package BaseClasses
        "Package with base classes for Buildings.Utilities.Psychrometrics.Functions"
          extends Modelica.Icons.BasesPackage;

          function der_pW_TDewPoi_amb "Derivative of function pW_TDewPoi_amb"
            extends
            Buildings.Utilities.Psychrometrics.Functions.BaseClasses.pW_TDewPoi_amb;
            input Modelica.SIunits.Temperature T "Dew point temperature";
            input Real dT;
            output Real dp_w "Differential of water vapor partial pressure";
          algorithm
            dp_w:=a2*Modelica.Math.exp(a1 + a2*T)*dT;

            annotation (
              Documentation(info="<html>
<p>
Derivative of dew point temperature calculation for moist air.
</p>
</html>",           revisions="<html>
<ul>
<li>
May 21, 2010 by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),    Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                      100}}), graphics),
              Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                      100}}), graphics));
          end der_pW_TDewPoi_amb;

          function der_TDewPoi_pW_amb "Derivative of function TDewPoi_pW_amb"
            extends
            Buildings.Utilities.Psychrometrics.Functions.BaseClasses.pW_TDewPoi_amb;

            input Modelica.SIunits.Pressure p_w "Water vapor partial pressure";
            input Real dp_w "Differential of water vapor partial pressure";
            output Real dT "Differential of dew point temperature";
          algorithm
            dT := dp_w / a2 / p_w;

            annotation (
              Documentation(info="<html>
<p>
Derivative of dew point temperature calculation for moist air.
</p>
</html>",           revisions="<html>
<ul>
<li>
May 21, 2010 by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),    Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                      100}}), graphics),
              Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                      100}}), graphics));
          end der_TDewPoi_pW_amb;

          partial function pW_TDewPoi_amb
          "Partial function to compute the water vapor partial pressure for a given dew point temperature of moist air and its inverse"

        protected
            constant Modelica.SIunits.Temperature T1=283.15
            "First support point";
            constant Modelica.SIunits.Temperature T2=293.15
            "Second support point";
            constant Modelica.SIunits.Pressure p1=1227.97 "First support point";
            constant Modelica.SIunits.Pressure p2=2338.76
            "Second support point";

            constant Real a1=(Modelica.Math.log(p2) - Modelica.Math.log(p1)*T2/T1)/(1 -
                T2/T1);
            constant Real a2(unit="1/K")=(Modelica.Math.log(p1) - a1)/T1;

            annotation (
              Documentation(info="<html>
<p>
Partial function to compute the dew point temperature for moist air between <i>0 degC</i> and <i>30 degC</i>,
and for its inverse function.
</p>
</p>
</html>",           revisions="<html>
<ul>
<li>
May 21, 2010 by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),    Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                      100}}), graphics),
              Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                      100}}), graphics));
          end pW_TDewPoi_amb;
        annotation (preferedView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Utilities.Psychrometrics.Functions\">Buildings.Utilities.Psychrometrics.Functions</a>.
</p>
</html>"));
        end BaseClasses;
        annotation (preferedView="info", Documentation(info="<html>
This package contains functions for psychrometric calculations.
</p>
<p>
The nomenclature used in this package is described at
<a href=\"modelica://Buildings.UsersGuide.Conventions\">
Buildings.UsersGuide.Conventions</a>.
</html>"));
      end Functions;

      package BaseClasses
      "Package with base classes for Buildings.Utilities.Psychrometrics"
        extends Modelica.Icons.BasesPackage;

        partial block HumidityRatioVaporPressure
        "Humidity ratio for given water vapor pressure"
          extends Modelica.Blocks.Interfaces.BlockIcon;
          parameter Boolean use_p_in = true
          "Get the pressure from the input connector"
            annotation(Evaluate=true, HideResult=true);

          parameter Modelica.SIunits.Pressure p = 101325
          "Fixed value of pressure"
            annotation (Evaluate = true,
                        Dialog(enable = not use_p_in));
          Modelica.Blocks.Interfaces.RealInput p_in(final quantity="Pressure",
                                                 final unit="Pa",
                                                 min = 0) if  use_p_in
          "Atmospheric Pressure"
            annotation (Placement(transformation(extent={{-140,40},{-100,80}},
                        rotation=0)));

      protected
          Modelica.Blocks.Interfaces.RealInput p_in_internal
          "Needed to connect to conditional connector";
        equation
          connect(p_in, p_in_internal);
          if not use_p_in then
            p_in_internal = p;
          end if;
          annotation (
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}),
                    graphics),
            Documentation(info="<html>
<p>
Partial Block to compute the relation between humidity ratio and water vapor partial pressure.
</p>
<p>If <code>use_p_in</code> is false (default option), the <code>p</code> parameter
is used as atmospheric pressure, 
and the <code>p_in</code> input connector is disabled; 
if <code>use_p_in</code> is true, then the <code>p</code> parameter is ignored, 
and the value provided by the input connector is used instead.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 14, 2009 by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                    100}}), graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-96,96},{96,-96}},
                  fillPattern=FillPattern.Sphere,
                  pattern=LinePattern.None,
                  lineColor={255,255,255},
                  fillColor={170,213,255}),
                Text(
                  visible=use_p_in,
                  extent={{-90,108},{-34,16}},
                  lineColor={0,0,0},
                  textString="p_in")}));
        end HumidityRatioVaporPressure;
      annotation (preferedView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Utilities.Psychrometrics\">Buildings.Utilities.Psychrometrics</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferedView="info", Documentation(info="<html>
This package contains blocks and functions for psychrometric calculations.
</p>
<p>
The nomenclature used in this package is described at
<a href=\"modelica://Buildings.UsersGuide.Conventions\">
Buildings.UsersGuide.Conventions</a>.
</html>"));
    end Psychrometrics;

    block SimulationTime "Simulation time"
      extends Modelica.Blocks.Interfaces.SO;
    equation
      y = time;
      annotation (
        defaultComponentName="simTim",
        Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}},
            grid={1,1}), graphics={
            Ellipse(extent={{-80,80},{80,-80}}, lineColor={160,160,164},
              fillColor={215,215,215},
              fillPattern=FillPattern.Solid),
            Line(points={{0,80},{0,60}}, color={160,160,164}),
            Line(points={{80,0},{60,0}}, color={160,160,164}),
            Line(points={{0,-80},{0,-60}}, color={160,160,164}),
            Line(points={{-80,0},{-60,0}}, color={160,160,164}),
            Line(points={{37,70},{26,50}}, color={160,160,164}),
            Line(points={{70,38},{49,26}}, color={160,160,164}),
            Line(points={{71,-37},{52,-27}}, color={160,160,164}),
            Line(points={{39,-70},{29,-51}}, color={160,160,164}),
            Line(points={{-39,-70},{-29,-52}}, color={160,160,164}),
            Line(points={{-71,-37},{-50,-26}}, color={160,160,164}),
            Line(points={{-71,37},{-54,28}}, color={160,160,164}),
            Line(points={{-38,70},{-28,51}}, color={160,160,164}),
            Line(
              points={{0,0},{-50,50}},
              color={0,0,0},
              thickness=0.5),
            Line(
              points={{0,0},{40,0}},
              color={0,0,0},
              thickness=0.5)}),
        Diagram(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}},
            grid={1,1}), graphics),
        Documentation(info="<html>
<p>
This component generates a time signal by using the simulation time.
The model is used to allow the simulation to start from any
time without having to set the parameters for the clock, as
would be necessairy for the model
<a href=\"modelica:Modelica.Blocks.Sources.Clock\">
Modelica.Blocks.Sources.Clock</a>.
</p>
</html>",     revisions="<html>
<ul>
<li>
May 18, 2010, by Wangda Zuo:<br>
First implementation.
</li>
</ul>
</html>"));
    end SimulationTime;
  annotation (preferedView="info", Documentation(info="<html>
<p>
This package contains utility models such as for thermal comfort calculation, input/output, co-simulation, psychrometric calculations and various functions that are used throughout the library.
</p>
</html>"));
  end Utilities;

  package Examples
  "Collection of models that illustrate model use and test models"
    extends Modelica.Icons.ExamplesPackage;

    package VAVReheat
    "Variable air volume flow system with terminal reheat and five thermal zones"
      extends Modelica.Icons.ExamplesPackage;

      package Controls "Package with controller models"
          extends Modelica.Icons.VariantsPackage;

        type OperationModes = enumeration(
          occupied "Occupied",
          unoccupiedOff "Unoccupied off",
          unoccupiedNightSetBack "Unoccupied, night set back",
          unoccupiedWarmUp "Unoccupied, warm-up",
          unoccupiedPreCool "Unoccupied, pre-cool",
          safety "Safety (smoke, fire, etc.)")
        "Enumeration for modes of operation";
      end Controls;
    end VAVReheat;
  annotation (preferedView="info", Documentation(info="<html>
<p>
This package contains examples of system models that are
composed of models from a variety of packages of the 
<code>Buildings</code> library. The examples illustrate
the scope of the library. Smaller examples that typically only
use models from a few packages can be found in the individual packages.
For example, see 
<a href=\"modelica://Buildings.Airflow.Multizone.Examples\">
Buildings.Airflow.Multizone.Examples</a> for examples of 
multizone airflow and contaminant transport models, or 
<a href=\"modelica://Buildings.Fluid.HeatExchangers.Examples\">
Buildings.Fluid.HeatExchangers.Examples</a> for 
examples of heat exchanger models.
</p>
</html>"));
  end Examples;

  package BaseClasses "Package with base classes for the Buildings library"
    extends Modelica.Icons.BasesPackage;

    block BaseIcon "Base icon"

      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={Text(
              extent={{-46,140},{52,92}},
              lineColor={0,0,255},
              textString="%name")}),
    Documentation(
    info="<html>
<p>
Basic class that provides a label with the component name above the icon.
</p>
</html>",
    revisions="<html>
<ul>
<li>
April 28, 2008, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
    end BaseIcon;

    block BaseIconLow "Base icon with model name below the icon"

      annotation (Icon(graphics={Text(
              extent={{-50,-84},{48,-132}},
              lineColor={0,0,255},
              textString=
                   "%name")}),
    Documentation(
    info="<html>
<p>
Basic class that provides a label with the component name below the icon.
</p>
</html>",
    revisions="<html>
<ul>
<li>
April 28, 2008, by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));

    end BaseIconLow;
  annotation (preferedView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings\">Buildings</a>.
</p>
</html>"));
  end BaseClasses;
annotation (
version="1.0",
versionBuild=2,
versionDate="2011-11-04",
dateModified = "$Date: 2011-12-08 16:25:22 -0800 (Thu, 08 Dec 2011) $",
uses(Modelica(version="3.2")),
conversion(
 from(version="0.12",
      script="modelica://Buildings/Resources/Scripts/Dymola/ConvertBuildings_from_0.12_to_1.0.mos")),
revisionId="$Id: package.mo 3157 2011-12-09 01:12:19Z mwetter $",
preferredView="info",
Documentation(info="<html>
<p>
The <code>Buildings</code> library is a free library
for modeling building energy and control systems. 
Many models are based on models from the package
<code>Modelica.Fluid</code> and use
the same ports to ensure compatibility with the Modelica Standard
Library.
</p>
<p>
The figure below shows a section of the schematic view of the model 
<a href=\"modelica://Buildings.Examples.HydronicHeating\">
Buildings.Examples.HydronicHeating</a>.
In the lower part of the figure, there is a dynamic model of a boiler, a pump and a stratified energy storage tank. Based on the temperatures of the storage tank, a finite state machine switches the boiler and its pump on and off. 
The heat distribution is done using a hydronic heating system with a three way valve and a pump with variable revolutions. The upper right hand corner shows a room model that is connected to a radiator whose flow is controlled by a thermostatic valve.
</p>
<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/UsersGuide/HydronicHeating.png\" border=\"1\">
</p>
<p>
The web page for this library is
<a href=\"http://simulationresearch.lbl.gov/modelica\">http://simulationresearch.lbl.gov/modelica</a>. 
Contributions from different users to further advance this library are
welcomed.
Contributions may not only be in the form of model development, but also
through model use, model testing,
requirements definition or providing feedback regarding the model applicability
to solve specific problems.
</p>
</html>"));
end Buildings;

package Modelica "Modelica Standard Library (Version 3.2)"
extends Modelica.Icons.Package;

  package Blocks
  "Library of basic input/output control blocks (continuous, discrete, logical, table blocks)"
  import SI = Modelica.SIunits;
  extends Modelica.Icons.Package;

    package Continuous
    "Library of continuous control blocks with internal states"
      import Modelica.Blocks.Interfaces;
      import Modelica.SIunits;
      extends Modelica.Icons.Package;

      block Integrator "Output the integral of the input signal"
        import Modelica.Blocks.Types.Init;
        parameter Real k(unit="1")=1 "Integrator gain";

        /* InitialState is the default, because it was the default in Modelica 2.2
     and therefore this setting is backward compatible
  */
        parameter Modelica.Blocks.Types.Init initType=Modelica.Blocks.Types.Init.InitialState
        "Type of initialization (1: no init, 2: steady state, 3,4: initial output)"
                                                                                          annotation(Evaluate=true,
            Dialog(group="Initialization"));
        parameter Real y_start=0 "Initial or guess value of output (= state)"
          annotation (Dialog(group="Initialization"));
        extends Interfaces.SISO(y(start=y_start));

      initial equation
        if initType == Init.SteadyState then
           der(y) = 0;
        elseif initType == Init.InitialState or
               initType == Init.InitialOutput then
          y = y_start;
        end if;
      equation
        der(y) = k*u;
        annotation (
          Documentation(info="<html>
<p>
This blocks computes output <b>y</b> (element-wise) as
<i>integral</i> of the input <b>u</b> multiplied with
the gain <i>k</i>:
</p>
<pre>
         k
     y = - u
         s
</pre>

<p>
It might be difficult to initialize the integrator in steady state.
This is discussed in the description of package
<a href=\"modelica://Modelica.Blocks.Continuous#info\">Continuous</a>.
</p>

</html>
"),       Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={2,2}), graphics={
              Line(points={{-80,78},{-80,-90}}, color={192,192,192}),
              Polygon(
                points={{-80,90},{-88,68},{-72,68},{-80,90}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-90,-80},{82,-80}}, color={192,192,192}),
              Polygon(
                points={{90,-80},{68,-72},{68,-88},{90,-80}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{0,-10},{60,-70}},
                lineColor={192,192,192},
                textString="I"),
              Text(
                extent={{-150,-150},{150,-110}},
                lineColor={0,0,0},
                textString="k=%k"),
              Line(points={{-80,-80},{80,80}}, color={0,0,127})}),
          Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={2,2}), graphics={
              Rectangle(extent={{-60,60},{60,-60}}, lineColor={0,0,255}),
              Line(points={{-100,0},{-60,0}}, color={0,0,255}),
              Line(points={{60,0},{100,0}}, color={0,0,255}),
              Text(
                extent={{-36,60},{32,2}},
                lineColor={0,0,0},
                textString="k"),
              Text(
                extent={{-32,0},{36,-58}},
                lineColor={0,0,0},
                textString="s"),
              Line(points={{-46,0},{46,0}}, color={0,0,0})}));
      end Integrator;

      block Derivative "Approximated derivative block"
        import Modelica.Blocks.Types.Init;
        parameter Real k(unit="1")=1 "Gains";
        parameter SIunits.Time T(min=Modelica.Constants.small) = 0.01
        "Time constants (T>0 required; T=0 is ideal derivative block)";
        parameter Modelica.Blocks.Types.Init initType=Modelica.Blocks.Types.Init.NoInit
        "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)"
                                                                                          annotation(Evaluate=true,
            Dialog(group="Initialization"));
        parameter Real x_start=0 "Initial or guess value of state"
          annotation (Dialog(group="Initialization"));
        parameter Real y_start=0 "Initial value of output (= state)"
          annotation(Dialog(enable=initType == Init.InitialOutput, group=
                "Initialization"));
        extends Interfaces.SISO;

        output Real x(start=x_start) "State of block";

    protected
        parameter Boolean zeroGain = abs(k) < Modelica.Constants.eps;
      initial equation
        if initType == Init.SteadyState then
          der(x) = 0;
        elseif initType == Init.InitialState then
          x = x_start;
        elseif initType == Init.InitialOutput then
          if zeroGain then
             x = u;
          else
             y = y_start;
          end if;
        end if;
      equation
        der(x) = if zeroGain then 0 else (u - x)/T;
        y = if zeroGain then 0 else (k/T)*(u - x);
        annotation (
          Documentation(info="
<HTML>
<p>
This blocks defines the transfer function between the
input u and the output y
(element-wise) as <i>approximated derivative</i>:
</p>
<pre>
             k * s
     y = ------------ * u
            T * s + 1
</pre>
<p>
If you would like to be able to change easily between different
transfer functions (FirstOrder, SecondOrder, ... ) by changing
parameters, use the general block <b>TransferFunction</b> instead
and model a derivative block with parameters<br>
b = {k,0}, a = {T, 1}.
</p>

<p>
If k=0, the block reduces to y=0.
</p>
</HTML>
"),       Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={2,2}), graphics={
              Line(points={{-80,78},{-80,-90}}, color={192,192,192}),
              Polygon(
                points={{-80,90},{-88,68},{-72,68},{-80,90}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-90,-80},{82,-80}}, color={192,192,192}),
              Polygon(
                points={{90,-80},{68,-72},{68,-88},{90,-80}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-80,-80},{-80,60},{-70,17.95},{-60,-11.46},{-50,-32.05},
                    {-40,-46.45},{-30,-56.53},{-20,-63.58},{-10,-68.51},{0,-71.96},
                    {10,-74.37},{20,-76.06},{30,-77.25},{40,-78.07},{50,-78.65},{60,
                    -79.06}}, color={0,0,127}),
              Text(
                extent={{-30,14},{86,60}},
                lineColor={192,192,192},
                textString="DT1"),
              Text(
                extent={{-150,-150},{150,-110}},
                lineColor={0,0,0},
                textString="k=%k")}),
          Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={2,2}), graphics={
              Text(
                extent={{-54,52},{50,10}},
                lineColor={0,0,0},
                textString="k s"),
              Text(
                extent={{-54,-6},{52,-52}},
                lineColor={0,0,0},
                textString="T s + 1"),
              Line(points={{-50,0},{50,0}}, color={0,0,0}),
              Rectangle(extent={{-60,60},{60,-60}}, lineColor={0,0,255}),
              Line(points={{-100,0},{-60,0}}, color={0,0,255}),
              Line(points={{60,0},{100,0}}, color={0,0,255})}));
      end Derivative;

      block FirstOrder "First order transfer function block (= 1 pole)"
        import Modelica.Blocks.Types.Init;
        parameter Real k(unit="1")=1 "Gain";
        parameter SIunits.Time T(start=1) "Time Constant";
        parameter Modelica.Blocks.Types.Init initType=Modelica.Blocks.Types.Init.NoInit
        "Type of initialization (1: no init, 2: steady state, 3/4: initial output)"
                                                                                          annotation(Evaluate=true,
            Dialog(group="Initialization"));
        parameter Real y_start=0 "Initial or guess value of output (= state)"
          annotation (Dialog(group="Initialization"));

        extends Interfaces.SISO(y(start=y_start));

      initial equation
        if initType == Init.SteadyState then
          der(y) = 0;
        elseif initType == Init.InitialState or initType == Init.InitialOutput then
          y = y_start;
        end if;
      equation
        der(y) = (k*u - y)/T;
        annotation (
          Documentation(info="<HTML>
<p>
This blocks defines the transfer function between the input u
and the output y (element-wise) as <i>first order</i> system:
</p>
<pre>
               k
     y = ------------ * u
            T * s + 1
</pre>
<p>
If you would like to be able to change easily between different
transfer functions (FirstOrder, SecondOrder, ... ) by changing
parameters, use the general block <b>TransferFunction</b> instead
and model a first order SISO system with parameters<br>
b = {k}, a = {T, 1}.
</p>
<pre>
Example:
   parameter: k = 0.3, T = 0.4
   results in:
             0.3
      y = ----------- * u
          0.4 s + 1.0
</pre>

</HTML>
"),       Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={2,2}), graphics={
              Line(points={{-80,78},{-80,-90}}, color={192,192,192}),
              Polygon(
                points={{-80,90},{-88,68},{-72,68},{-80,88},{-80,90}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-90,-80},{82,-80}}, color={192,192,192}),
              Polygon(
                points={{90,-80},{68,-72},{68,-88},{90,-80}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-80,-80},{-70,-45.11},{-60,-19.58},{-50,-0.9087},{-40,
                    12.75},{-30,22.75},{-20,30.06},{-10,35.41},{0,39.33},{10,42.19},
                    {20,44.29},{30,45.82},{40,46.94},{50,47.76},{60,48.36},{70,48.8},
                    {80,49.12}}, color={0,0,127}),
              Text(
                extent={{0,0},{60,-60}},
                lineColor={192,192,192},
                textString="PT1"),
              Text(
                extent={{-150,-150},{150,-110}},
                lineColor={0,0,0},
                textString="T=%T")}),
          Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={2,2}), graphics={
              Text(
                extent={{-48,52},{50,8}},
                lineColor={0,0,0},
                textString="k"),
              Text(
                extent={{-54,-6},{56,-56}},
                lineColor={0,0,0},
                textString="T s + 1"),
              Line(points={{-50,0},{50,0}}, color={0,0,0}),
              Rectangle(extent={{-60,60},{60,-60}}, lineColor={0,0,255}),
              Line(points={{-100,0},{-60,0}}, color={0,0,255}),
              Line(points={{60,0},{100,0}}, color={0,0,255})}));
      end FirstOrder;

      block LimPID
      "P, PI, PD, and PID controller with limited output, anti-windup compensation and setpoint weighting"
        import Modelica.Blocks.Types.InitPID;
        import Modelica.Blocks.Types.SimpleController;
        extends Interfaces.SVcontrol;
        output Real controlError = u_s - u_m
        "Control error (set point - measurement)";

        parameter Modelica.Blocks.Types.SimpleController controllerType=
               Modelica.Blocks.Types.SimpleController.PID "Type of controller";
        parameter Real k(min=0, unit="1") = 1 "Gain of controller";
        parameter SIunits.Time Ti(min=Modelica.Constants.small, start=0.5)
        "Time constant of Integrator block"
           annotation(Dialog(enable=controllerType==SimpleController.PI or
                                    controllerType==SimpleController.PID));
        parameter SIunits.Time Td(min=0, start= 0.1)
        "Time constant of Derivative block"
             annotation(Dialog(enable=controllerType==SimpleController.PD or
                                      controllerType==SimpleController.PID));
        parameter Real yMax(start=1) "Upper limit of output";
        parameter Real yMin=-yMax "Lower limit of output";
        parameter Real wp(min=0) = 1
        "Set-point weight for Proportional block (0..1)";
        parameter Real wd(min=0) = 0
        "Set-point weight for Derivative block (0..1)"
             annotation(Dialog(enable=controllerType==SimpleController.PD or
                                      controllerType==SimpleController.PID));
        parameter Real Ni(min=100*Modelica.Constants.eps) = 0.9
        "Ni*Ti is time constant of anti-windup compensation"
           annotation(Dialog(enable=controllerType==SimpleController.PI or
                                    controllerType==SimpleController.PID));
        parameter Real Nd(min=100*Modelica.Constants.eps) = 10
        "The higher Nd, the more ideal the derivative block"
             annotation(Dialog(enable=controllerType==SimpleController.PD or
                                      controllerType==SimpleController.PID));
        parameter Modelica.Blocks.Types.InitPID initType= Modelica.Blocks.Types.InitPID.DoNotUse_InitialIntegratorState
        "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)"
                                           annotation(Evaluate=true,
            Dialog(group="Initialization"));
        parameter Boolean limitsAtInit = true
        "= false, if limits are ignored during initializiation"
          annotation(Evaluate=true, Dialog(group="Initialization",
                             enable=controllerType==SimpleController.PI or
                                    controllerType==SimpleController.PID));
        parameter Real xi_start=0
        "Initial or guess value value for integrator output (= integrator state)"
          annotation (Dialog(group="Initialization",
                      enable=controllerType==SimpleController.PI or
                             controllerType==SimpleController.PID));
        parameter Real xd_start=0
        "Initial or guess value for state of derivative block"
          annotation (Dialog(group="Initialization",
                               enable=controllerType==SimpleController.PD or
                                      controllerType==SimpleController.PID));
        parameter Real y_start=0 "Initial value of output"
          annotation(Dialog(enable=initType == InitPID.InitialOutput, group=
                "Initialization"));

        Blocks.Math.Add addP(k1=wp, k2=-1)
          annotation (Placement(transformation(extent={{-80,40},{-60,60}}, rotation=
                 0)));
        Blocks.Math.Add addD(k1=wd, k2=-1) if with_D
          annotation (Placement(transformation(extent={{-80,-10},{-60,10}},
                rotation=0)));
        Blocks.Math.Gain P(k=1)
                           annotation (Placement(transformation(extent={{-40,40},{
                  -20,60}}, rotation=0)));
        Blocks.Continuous.Integrator I(k=1/Ti, y_start=xi_start,
          initType=if initType==InitPID.SteadyState then
                      InitPID.SteadyState else
                   if initType==InitPID.InitialState or
                      initType==InitPID.DoNotUse_InitialIntegratorState then
                      InitPID.InitialState else InitPID.NoInit) if with_I
          annotation (Placement(transformation(extent={{-40,-60},{-20,-40}},
                rotation=0)));
        Blocks.Continuous.Derivative D(k=Td, T=max([Td/Nd, 1.e-14]), x_start=xd_start,
          initType=if initType==InitPID.SteadyState or
                      initType==InitPID.InitialOutput then InitPID.SteadyState else
                   if initType==InitPID.InitialState then InitPID.InitialState else
                      InitPID.NoInit) if with_D
          annotation (Placement(transformation(extent={{-40,-10},{-20,10}},
                rotation=0)));
        Blocks.Math.Gain gainPID(k=k) annotation (Placement(transformation(extent={
                  {30,-10},{50,10}}, rotation=0)));
        Blocks.Math.Add3 addPID annotation (Placement(transformation(
                extent={{0,-10},{20,10}}, rotation=0)));
        Blocks.Math.Add3 addI(k2=-1) if with_I annotation (Placement(
              transformation(extent={{-80,-60},{-60,-40}}, rotation=0)));
        Blocks.Math.Add addSat(k1=+1, k2=-1) if
                                         with_I
          annotation (Placement(transformation(
              origin={80,-50},
              extent={{-10,-10},{10,10}},
              rotation=270)));
        Blocks.Math.Gain gainTrack(k=1/(k*Ni)) if with_I
          annotation (Placement(transformation(extent={{40,-80},{20,-60}}, rotation=
                 0)));
        Blocks.Nonlinear.Limiter limiter(uMax=yMax, uMin=yMin, limitsAtInit=limitsAtInit)
          annotation (Placement(transformation(extent={{70,-10},{90,10}}, rotation=
                  0)));
    protected
        parameter Boolean with_I = controllerType==SimpleController.PI or
                                   controllerType==SimpleController.PID annotation(Evaluate=true, HideResult=true);
        parameter Boolean with_D = controllerType==SimpleController.PD or
                                   controllerType==SimpleController.PID annotation(Evaluate=true, HideResult=true);
    public
        Sources.Constant Dzero(k=0) if not with_D
          annotation (Placement(transformation(extent={{-30,20},{-20,30}}, rotation=
                 0)));
        Sources.Constant Izero(k=0) if not with_I
          annotation (Placement(transformation(extent={{10,-55},{0,-45}}, rotation=
                  0)));
      initial equation
        if initType==InitPID.InitialOutput then
           y = y_start;
        end if;
      equation
        assert(yMax >= yMin, "LimPID: Limits must be consistent. However, yMax (=" + String(yMax) +
                             ") < yMin (=" + String(yMin) + ")");
        if initType == InitPID.InitialOutput and (y_start < yMin or y_start > yMax) then
            Modelica.Utilities.Streams.error("LimPID: Start value y_start (=" + String(y_start) +
               ") is outside of the limits of yMin (=" + String(yMin) +") and yMax (=" + String(yMax) + ")");
        end if;
        assert(limitsAtInit or not limitsAtInit and y >= yMin and y <= yMax,
               "LimPID: During initialization the limits have been switched off.\n" +
               "After initialization, the output y (=" + String(y) +
               ") is outside of the limits of yMin (=" + String(yMin) +") and yMax (=" + String(yMax) + ")");

        connect(u_s, addP.u1) annotation (Line(points={{-120,0},{-96,0},{-96,56},{
                -82,56}}, color={0,0,127}));
        connect(u_s, addD.u1) annotation (Line(points={{-120,0},{-96,0},{-96,6},{
                -82,6}}, color={0,0,127}));
        connect(u_s, addI.u1) annotation (Line(points={{-120,0},{-96,0},{-96,-42},{
                -82,-42}}, color={0,0,127}));
        connect(addP.y, P.u) annotation (Line(points={{-59,50},{-42,50}}, color={0,
                0,127}));
        connect(addD.y, D.u)
          annotation (Line(points={{-59,0},{-42,0}}, color={0,0,127}));
        connect(addI.y, I.u) annotation (Line(points={{-59,-50},{-42,-50}}, color={
                0,0,127}));
        connect(P.y, addPID.u1) annotation (Line(points={{-19,50},{-10,50},{-10,8},
                {-2,8}}, color={0,0,127}));
        connect(D.y, addPID.u2)
          annotation (Line(points={{-19,0},{-2,0}}, color={0,0,127}));
        connect(I.y, addPID.u3) annotation (Line(points={{-19,-50},{-10,-50},{-10,
                -8},{-2,-8}}, color={0,0,127}));
        connect(addPID.y, gainPID.u)
          annotation (Line(points={{21,0},{28,0}}, color={0,0,127}));
        connect(gainPID.y, addSat.u2) annotation (Line(points={{51,0},{60,0},{60,
                -20},{74,-20},{74,-38}}, color={0,0,127}));
        connect(gainPID.y, limiter.u)
          annotation (Line(points={{51,0},{68,0}}, color={0,0,127}));
        connect(limiter.y, addSat.u1) annotation (Line(points={{91,0},{94,0},{94,
                -20},{86,-20},{86,-38}}, color={0,0,127}));
        connect(limiter.y, y)
          annotation (Line(points={{91,0},{110,0}}, color={0,0,127}));
        connect(addSat.y, gainTrack.u) annotation (Line(points={{80,-61},{80,-70},{
                42,-70}}, color={0,0,127}));
        connect(gainTrack.y, addI.u3) annotation (Line(points={{19,-70},{-88,-70},{
                -88,-58},{-82,-58}}, color={0,0,127}));
        connect(u_m, addP.u2) annotation (Line(
            points={{0,-120},{0,-92},{-92,-92},{-92,44},{-82,44}},
            color={0,0,127},
            thickness=0.5));
        connect(u_m, addD.u2) annotation (Line(
            points={{0,-120},{0,-92},{-92,-92},{-92,-6},{-82,-6}},
            color={0,0,127},
            thickness=0.5));
        connect(u_m, addI.u2) annotation (Line(
            points={{0,-120},{0,-92},{-92,-92},{-92,-50},{-82,-50}},
            color={0,0,127},
            thickness=0.5));
        connect(Dzero.y, addPID.u2) annotation (Line(points={{-19.5,25},{-14,25},{
                -14,0},{-2,0}}, color={0,0,127}));
        connect(Izero.y, addPID.u3) annotation (Line(points={{-0.5,-50},{-10,-50},{
                -10,-8},{-2,-8}}, color={0,0,127}));
        annotation (defaultComponentName="PID",
          Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics={
              Line(points={{-80,78},{-80,-90}}, color={192,192,192}),
              Polygon(
                points={{-80,90},{-88,68},{-72,68},{-80,90}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-90,-80},{82,-80}}, color={192,192,192}),
              Polygon(
                points={{90,-80},{68,-72},{68,-88},{90,-80}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-80,-80},{-80,50},{-80,-20},{30,60},{80,60}}, color={0,
                    0,127}),
              Text(
                extent={{-20,-20},{80,-60}},
                lineColor={192,192,192},
                textString="PID")}),
          Documentation(info="<HTML>
<p>
Via parameter <b>controllerType</b> either <b>P</b>, <b>PI</b>, <b>PD</b>,
or <b>PID</b> can be selected. If, e.g., PI is selected, all components belonging to the
D-part are removed from the block (via conditional declarations).
The example model
<a href=\"modelica://Modelica.Blocks.Examples.PID_Controller\">Modelica.Blocks.Examples.PID_Controller</a>
demonstrates the usage of this controller.
Several practical aspects of PID controller design are incorporated
according to chapter 3 of the book:
</p>

<dl>
<dt>&Aring;str&ouml;m K.J., and H&auml;gglund T.:</dt>
<dd> <b>PID Controllers: Theory, Design, and Tuning</b>.
     Instrument Society of America, 2nd edition, 1995.
</dd>
</dl>

<p>
Besides the additive <b>proportional, integral</b> and <b>derivative</b>
part of this controller, the following features are present:
</p>
<ul>
<li> The output of this controller is limited. If the controller is
     in its limits, anti-windup compensation is activated to drive
     the integrator state to zero. </li>
<li> The high-frequency gain of the derivative part is limited
     to avoid excessive amplification of measurement noise.</li>
<li> Setpoint weighting is present, which allows to weight
     the setpoint in the proportional and the derivative part
     independantly from the measurement. The controller will respond
     to load disturbances and measurement noise independantly of this setting
     (parameters wp, wd). However, setpoint changes will depend on this
     setting. For example, it is useful to set the setpoint weight wd
     for the derivative part to zero, if steps may occur in the
     setpoint signal.</li>
</ul>

<p>
The parameters of the controller can be manually adjusted by performing
simulations of the closed loop system (= controller + plant connected
together) and using the following strategy:
</p>

<ol>
<li> Set very large limits, e.g., yMax = Modelica.Constants.inf</li>
<li> Select a <b>P</b>-controller and manually enlarge parameter <b>k</b>
     (the total gain of the controller) until the closed-loop response
     cannot be improved any more.</li>
<li> Select a <b>PI</b>-controller and manually adjust parameters
     <b>k</b> and <b>Ti</b> (the time constant of the integrator).
     The first value of Ti can be selected, such that it is in the
     order of the time constant of the oscillations occuring with
     the P-controller. If, e.g., vibrations in the order of T=10 ms
     occur in the previous step, start with Ti=0.01 s.</li>
<li> If you want to make the reaction of the control loop faster
     (but probably less robust against disturbances and measurement noise)
     select a <b>PID</b>-Controller and manually adjust parameters
     <b>k</b>, <b>Ti</b>, <b>Td</b> (time constant of derivative block).</li>
<li> Set the limits yMax and yMin according to your specification.</li>
<li> Perform simulations such that the output of the PID controller
     goes in its limits. Tune <b>Ni</b> (Ni*Ti is the time constant of
     the anti-windup compensation) such that the input to the limiter
     block (= limiter.u) goes quickly enough back to its limits.
     If Ni is decreased, this happens faster. If Ni=infinity, the
     anti-windup compensation is switched off and the controller works bad.</li>
</ol>

<p>
<b>Initialization</b>
</p>

<p>
This block can be initialized in different
ways controlled by parameter <b>initType</b>. The possible
values of initType are defined in
<a href=\"modelica://Modelica.Blocks.Types.InitPID\">Modelica.Blocks.Types.InitPID</a>.
This type is identical to
<a href=\"modelica://Modelica.Blocks.Types.Init\">Types.Init</a>,
with the only exception that the additional option
<b>DoNotUse_InitialIntegratorState</b> is added for
backward compatibility reasons (= integrator is initialized with
InitialState whereas differential part is initialized with
NoInit which was the initialization in version 2.2 of the Modelica
standard library).
</p>

<p>
Based on the setting of initType, the integrator (I) and derivative (D)
blocks inside the PID controller are initialized according to the following table:
</p>

<table border=1 cellspacing=0 cellpadding=2>
  <tr><td valign=\"top\"><b>initType</b></td>
      <td valign=\"top\"><b>I.initType</b></td>
      <td valign=\"top\"><b>D.initType</b></td></tr>

  <tr><td valign=\"top\"><b>NoInit</b></td>
      <td valign=\"top\">NoInit</td>
      <td valign=\"top\">NoInit</td></tr>

  <tr><td valign=\"top\"><b>SteadyState</b></td>
      <td valign=\"top\">SteadyState</td>
      <td valign=\"top\">SteadyState</td></tr>

  <tr><td valign=\"top\"><b>InitialState</b></td>
      <td valign=\"top\">InitialState</td>
      <td valign=\"top\">InitialState</td></tr>

  <tr><td valign=\"top\"><b>InitialOutput</b><br>
          and initial equation: y = y_start</td>
      <td valign=\"top\">NoInit</td>
      <td valign=\"top\">SteadyState</td></tr>

  <tr><td valign=\"top\"><b>DoNotUse_InitialIntegratorState</b></td>
      <td valign=\"top\">InitialState</td>
      <td valign=\"top\">NoInit</td></tr>
</table>

<p>
In many cases, the most useful initial condition is
<b>SteadyState</b> because initial transients are then no longer
present. If initType = InitPID.SteadyState, then in some
cases difficulties might occur. The reason is the
equation of the integrator:
</p>

<pre>
   <b>der</b>(y) = k*u;
</pre>

<p>
The steady state equation \"der(x)=0\" leads to the condition that the input u to the
integrator is zero. If the input u is already (directly or indirectly) defined
by another initial condition, then the initialization problem is <b>singular</b>
(has none or infinitely many solutions). This situation occurs often
for mechanical systems, where, e.g., u = desiredSpeed - measuredSpeed and
since speed is both a state and a derivative, it is natural to
initialize it with zero. As sketched this is, however, not possible.
The solution is to not initialize u_m or the variable that is used
to compute u_m by an algebraic equation.
</p>

<p>
If parameter <b>limitAtInit</b> = <b>false</b>, the limits at the
output of this controller block are removed from the initialization problem which
leads to a much simpler equation system. After initialization has been
performed, it is checked via an assert whether the output is in the
defined limits. For backward compatibility reasons
<b>limitAtInit</b> = <b>true</b>. In most cases it is best
to use <b>limitAtInit</b> = <b>false</b>.
</p>
</HTML>
"),       Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics));
      end LimPID;
      annotation (
        Documentation(info="<html>
<p>
This package contains basic <b>continuous</b> input/output blocks
described by differential equations.
</p>

<p>
All blocks of this package can be initialized in different
ways controlled by parameter <b>initType</b>. The possible
values of initType are defined in
<a href=\"modelica://Modelica.Blocks.Types.Init\">Modelica.Blocks.Types.Init</a>:
</p>

<table border=1 cellspacing=0 cellpadding=2>
  <tr><td valign=\"top\"><b>Name</b></td>
      <td valign=\"top\"><b>Description</b></td></tr>

  <tr><td valign=\"top\"><b>Init.NoInit</b></td>
      <td valign=\"top\">no initialization (start values are used as guess values with fixed=false)</td></tr>

  <tr><td valign=\"top\"><b>Init.SteadyState</b></td>
      <td valign=\"top\">steady state initialization (derivatives of states are zero)</td></tr>

  <tr><td valign=\"top\"><b>Init.InitialState</b></td>
      <td valign=\"top\">Initialization with initial states</td></tr>

  <tr><td valign=\"top\"><b>Init.InitialOutput</b></td>
      <td valign=\"top\">Initialization with initial outputs (and steady state of the states if possibles)</td></tr>
</table>

<p>
For backward compatibility reasons the default of all blocks is
<b>Init.NoInit</b>, with the exception of Integrator and LimIntegrator
where the default is <b>Init.InitialState</b> (this was the initialization
defined in version 2.2 of the Modelica standard library).
</p>

<p>
In many cases, the most useful initial condition is
<b>Init.SteadyState</b> because initial transients are then no longer
present. The drawback is that in combination with a non-linear
plant, non-linear algebraic equations occur that might be
difficult to solve if appropriate guess values for the
iteration variables are not provided (i.e., start values with fixed=false).
However, it is often already useful to just initialize
the linear blocks from the Continuous blocks library in SteadyState.
This is uncritical, because only linear algebraic equations occur.
If Init.NoInit is set, then the start values for the states are
interpreted as <b>guess</b> values and are propagated to the
states with fixed=<b>false</b>.
</p>

<p>
Note, initialization with Init.SteadyState is usually difficult
for a block that contains an integrator
(Integrator, LimIntegrator, PI, PID, LimPID).
This is due to the basic equation of an integrator:
</p>

<pre>
  <b>initial equation</b>
     <b>der</b>(y) = 0;   // Init.SteadyState
  <b>equation</b>
     <b>der</b>(y) = k*u;
</pre>

<p>
The steady state equation leads to the condition that the input to the
integrator is zero. If the input u is already (directly or indirectly) defined
by another initial condition, then the initialization problem is <b>singular</b>
(has none or infinitely many solutions). This situation occurs often
for mechanical systems, where, e.g., u = desiredSpeed - measuredSpeed and
since speed is both a state and a derivative, it is always defined by
Init.InitialState or Init.SteadyState initializtion.
</p>

<p>
In such a case, <b>Init.NoInit</b> has to be selected for the integrator
and an additional initial equation has to be added to the system
to which the integrator is connected. E.g., useful initial conditions
for a 1-dim. rotational inertia controlled by a PI controller are that
<b>angle</b>, <b>speed</b>, and <b>acceleration</b> of the inertia are zero.
</p>

</html>
"));
    end Continuous;

    package Interfaces
    "Library of connectors and partial models for input/output blocks"
      import Modelica.SIunits;
        extends Modelica.Icons.InterfacesPackage;

    connector RealInput = input Real "'input Real' as connector"
      annotation (defaultComponentName="u",
      Icon(graphics={Polygon(
              points={{-100,100},{100,0},{-100,-100},{-100,100}},
              lineColor={0,0,127},
              fillColor={0,0,127},
              fillPattern=FillPattern.Solid)},
           coordinateSystem(extent={{-100,-100},{100,100}}, preserveAspectRatio=true, initialScale=0.2)),
      Diagram(coordinateSystem(
            preserveAspectRatio=true, initialScale=0.2,
            extent={{-100,-100},{100,100}},
            grid={1,1}), graphics={Polygon(
              points={{0,50},{100,0},{0,-50},{0,50}},
              lineColor={0,0,127},
              fillColor={0,0,127},
              fillPattern=FillPattern.Solid), Text(
              extent={{-10,85},{-10,60}},
              lineColor={0,0,127},
              textString="%name")}),
        Documentation(info="<html>
<p>
Connector with one input signal of type Real.
</p>
</html>"));

    connector RealOutput = output Real "'output Real' as connector"
      annotation (defaultComponentName="y",
      Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}},
            grid={1,1}), graphics={Polygon(
              points={{-100,100},{100,0},{-100,-100},{-100,100}},
              lineColor={0,0,127},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid)}),
      Diagram(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}},
            grid={1,1}), graphics={Polygon(
              points={{-100,50},{0,0},{-100,-50},{-100,50}},
              lineColor={0,0,127},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid), Text(
              extent={{30,110},{30,60}},
              lineColor={0,0,127},
              textString="%name")}),
        Documentation(info="<html>
<p>
Connector with one output signal of type Real.
</p>
</html>"));

    connector BooleanInput = input Boolean "'input Boolean' as connector"
      annotation (defaultComponentName="u",
           Icon(graphics={Polygon(
              points={{-100,100},{100,0},{-100,-100},{-100,100}},
              lineColor={255,0,255},
              fillColor={255,0,255},
              fillPattern=FillPattern.Solid)},
                coordinateSystem(extent={{-100,-100},{100,100}},
            preserveAspectRatio=true, initialScale=0.2)),    Diagram(coordinateSystem(
            preserveAspectRatio=true, initialScale=0.2,
            extent={{-100,-100},{100,100}},
            grid={1,1}), graphics={Polygon(
              points={{0,50},{100,0},{0,-50},{0,50}},
              lineColor={255,0,255},
              fillColor={255,0,255},
              fillPattern=FillPattern.Solid), Text(
              extent={{-10,85},{-10,60}},
              lineColor={255,0,255},
              textString="%name")}),
        Documentation(info="<html>
<p>
Connector with one input signal of type Boolean.
</p>
</html>"));

    connector BooleanOutput = output Boolean "'output Boolean' as connector"
                                      annotation (defaultComponentName="y",
      Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}},
            grid={1,1}), graphics={Polygon(
              points={{-100,100},{100,0},{-100,-100},{-100,100}},
              lineColor={255,0,255},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid)}),
      Diagram(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}},
            grid={1,1}), graphics={Polygon(
              points={{-100,50},{0,0},{-100,-50},{-100,50}},
              lineColor={255,0,255},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid), Text(
              extent={{30,110},{30,60}},
              lineColor={255,0,255},
              textString="%name")}),
        Documentation(info="<html>
<p>
Connector with one output signal of type Boolean.
</p>
</html>"));

    connector IntegerInput = input Integer "'input Integer' as connector"
      annotation (defaultComponentName="u",
      Icon(graphics={Polygon(
              points={{-100,100},{100,0},{-100,-100},{-100,100}},
              lineColor={255,127,0},
              fillColor={255,127,0},
              fillPattern=FillPattern.Solid)},
           coordinateSystem(extent={{-100,-100},{100,100}}, preserveAspectRatio=true,
                     initialScale=0.2)),
      Diagram(coordinateSystem(
            preserveAspectRatio=true, initialScale=0.2,
            extent={{-100,-100},{100,100}},
            grid={1,1}), graphics={Polygon(
              points={{0,50},{100,0},{0,-50},{0,50}},
              lineColor={255,127,0},
              fillColor={255,127,0},
              fillPattern=FillPattern.Solid), Text(
              extent={{-10,85},{-10,60}},
              lineColor={255,127,0},
              textString="%name")}),
        Documentation(info="<html>
<p>
Connector with one input signal of type Integer.
</p>
</html>"));

    connector IntegerOutput = output Integer "'output Integer' as connector"
                                      annotation (defaultComponentName="y",
      Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}},
            grid={1,1}), graphics={Polygon(
              points={{-100,100},{100,0},{-100,-100},{-100,100}},
              lineColor={255,127,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid)}),
      Diagram(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}},
            grid={1,1}), graphics={Polygon(
              points={{-100,50},{0,0},{-100,-50},{-100,50}},
              lineColor={255,127,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid), Text(
              extent={{30,110},{30,60}},
              lineColor={255,127,0},
              textString="%name")}),
        Documentation(info="<html>
<p>
Connector with one output signal of type Integer.
</p>
</html>"));

    connector IntegerVectorInput =
                             input Integer "Vector of Integer inputs"
      annotation (defaultComponentName="u",
           Icon(graphics={Ellipse(
              extent={{-100,100},{100,-100}},
              lineColor={255,128,0},
              fillColor={255,128,0},
              fillPattern=FillPattern.Solid)},
                coordinateSystem(extent={{-100,-100},{100,100}},
            preserveAspectRatio=true,  initialScale=0.2)),    Diagram(coordinateSystem(
            preserveAspectRatio=false, initialScale=0.2,
            extent={{-100,-100},{100,100}},
            grid={1,1}), graphics={Text(
              extent={{-10,85},{-10,60}},
              lineColor={255,128,0},
              textString="%name"), Ellipse(
              extent={{-50,50},{50,-50}},
              lineColor={255,128,0},
              fillColor={255,128,0},
              fillPattern=FillPattern.Solid)}),
        Documentation(info="<html>
<p>
Connector with one input signal of type Boolean.
</p>
</html>"));

    connector BooleanVectorInput =
                             input Boolean "Vector of Boolean inputs"
      annotation (defaultComponentName="u",
           Icon(graphics={Ellipse(
              extent={{-100,-100},{100,100}},
              lineColor={255,0,255},
              fillColor={255,0,255},
              fillPattern=FillPattern.Solid)},
                coordinateSystem(extent={{-100,-100},{100,100}},
            preserveAspectRatio=false,  initialScale=0.2)),    Diagram(coordinateSystem(
            preserveAspectRatio=false, initialScale=0.2,
            extent={{-100,-100},{100,100}},
            grid={1,1}), graphics={Text(
              extent={{-10,85},{-10,60}},
              lineColor={255,0,255},
              textString="%name"), Ellipse(
              extent={{-50,50},{50,-50}},
              lineColor={255,0,255},
              fillColor={255,0,255},
              fillPattern=FillPattern.Solid)}),
        Documentation(info="<html>
<p>
Connector with one input signal of type Boolean.
</p>
</html>"));

        partial block BlockIcon "Basic graphical layout of input/output block"

          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid), Text(
                extent={{-150,150},{150,110}},
                textString="%name",
                lineColor={0,0,255})}),
          Documentation(info="<html>
<p>
Block that has only the basic icon for an input/output
block (no declarations, no equations). Most blocks
of package Modelica.Blocks inherit directly or indirectly
from this block.
</p>
</html>"));

        end BlockIcon;

        partial block SO "Single Output continuous control block"
          extends BlockIcon;

          RealOutput y "Connector of Real output signal"
            annotation (Placement(transformation(extent={{100,-10},{120,10}},
                rotation=0)));
          annotation (
            Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={2,2}), graphics),
          Documentation(info="<html>
<p>
Block has one continuous Real output signal.
</p>
</html>"));

        end SO;

        partial block MO "Multiple Output continuous control block"
          extends BlockIcon;

          parameter Integer nout(min=1) = 1 "Number of outputs";
          RealOutput y[nout] "Connector of Real output signals"
            annotation (Placement(transformation(extent={{100,-10},{120,10}},
                rotation=0)));
          annotation (
            Documentation(info="<html>
<p>
Block has one continuous Real output signal vector.
</p>
</html>"));

        end MO;

        partial block SISO
      "Single Input Single Output continuous control block"
          extends BlockIcon;

          RealInput u "Connector of Real input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}},
                rotation=0)));
          RealOutput y "Connector of Real output signal"
            annotation (Placement(transformation(extent={{100,-10},{120,10}},
                rotation=0)));
          annotation (
          Documentation(info="<html>
<p>
Block has one continuous Real input and one continuous Real output signal.
</p>
</html>"));
        end SISO;

        partial block SI2SO
      "2 Single Input / 1 Single Output continuous control block"
          extends BlockIcon;

          RealInput u1 "Connector of Real input signal 1"
            annotation (Placement(transformation(extent={{-140,40},{-100,80}},
                rotation=0)));
          RealInput u2 "Connector of Real input signal 2"
            annotation (Placement(transformation(extent={{-140,-80},{-100,-40}},
                rotation=0)));
          RealOutput y "Connector of Real output signal"
            annotation (Placement(transformation(extent={{100,-10},{120,10}},
                rotation=0)));

          annotation (
            Documentation(info="<html>
<p>
Block has two continuous Real input signals u1 and u2 and one
continuous Real output signal y.
</p>
</html>"),  Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={2,2}), graphics));

        end SI2SO;

    partial block SIMO "Single Input Multiple Output continuous control block"
      extends BlockIcon;
      parameter Integer nout=1 "Number of outputs";
          RealInput u "Connector of Real input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}},
                rotation=0)));
          RealOutput y[nout] "Connector of Real output signals"
            annotation (Placement(transformation(extent={{100,-10},{120,10}},
                rotation=0)));

      annotation (Documentation(info="<HTML>
<p> Block has one continuous Real input signal and a
    vector of continuous Real output signals.</p>

</HTML>
"));
    end SIMO;

        partial block MISO
      "Multiple Input Single Output continuous control block"

          extends BlockIcon;
          parameter Integer nin=1 "Number of inputs";
          RealInput u[nin] "Connector of Real input signals"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}},
                rotation=0)));
          RealOutput y "Connector of Real output signal"
            annotation (Placement(transformation(extent={{100,-10},{120,10}},
                rotation=0)));
          annotation (Documentation(info="<HTML>
<p>
Block has a vector of continuous Real input signals and
one continuous Real output signal.
</p>
</HTML>
"));
        end MISO;

        partial block MIMO
      "Multiple Input Multiple Output continuous control block"

          extends BlockIcon;
          parameter Integer nin=1 "Number of inputs";
          parameter Integer nout=1 "Number of outputs";
          RealInput u[nin] "Connector of Real input signals"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}},
                rotation=0)));
          RealOutput y[nout] "Connector of Real output signals"
            annotation (Placement(transformation(extent={{100,-10},{120,10}},
                rotation=0)));
          annotation (Documentation(info="<HTML>
<p>
Block has a continuous Real input and a continuous Real output signal vector.
The signal sizes of the input and output vector may be different.
</p>
</HTML>
"));
        end MIMO;

        partial block SVcontrol "Single-Variable continuous controller"
          extends BlockIcon;

          RealInput u_s "Connector of setpoint input signal"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}},
                rotation=0)));
          RealInput u_m "Connector of measurement input signal"
            annotation (Placement(transformation(
              origin={0,-120},
              extent={{20,-20},{-20,20}},
              rotation=270)));
          RealOutput y "Connector of actuator output signal"
            annotation (Placement(transformation(extent={{100,-10},{120,10}},
                rotation=0)));
          annotation (
            Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={2,2}), graphics={
              Text(
                extent={{-102,34},{-142,24}},
                textString="(setpoint)",
                lineColor={0,0,255}),
              Text(
                extent={{100,24},{140,14}},
                textString="(actuator)",
                lineColor={0,0,255}),
              Text(
                extent={{-83,-112},{-33,-102}},
                textString=" (measurement)",
                lineColor={0,0,255})}),
          Documentation(info="<html>
<p>
Block has two continuous Real input signals and one
continuous Real output signal. The block is designed
to be used as base class for a corresponding controller.
</p>
</html>"));
        end SVcontrol;

        partial block BooleanBlockIcon
      "Basic graphical layout of Boolean block"

          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={255,0,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid), Text(
                extent={{-150,150},{150,110}},
                textString="%name",
                lineColor={0,0,255})}),
          Documentation(info="<html>
<p>
Block that has only the basic icon for an input/output,
Boolean block (no declarations, no equations).
</p>
</html>"));

        end BooleanBlockIcon;

        partial block BooleanSignalSource
      "Base class for Boolean signal sources"

          extends BooleanBlockIcon;
          BooleanOutput y "Connector of Boolean output signal"
            annotation (Placement(transformation(extent={{100,-10},{120,10}},
                rotation=0)));
          annotation (
            Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={2,2}), graphics={
              Line(points={{-80,68},{-80,-80}}, color={192,192,192}),
              Polygon(
                points={{-80,90},{-88,68},{-72,68},{-80,90}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-90,-70},{68,-70}}, color={192,192,192}),
              Polygon(
                points={{90,-70},{68,-62},{68,-78},{90,-70}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid)}),
            Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={2,2}), graphics),
          Documentation(info="<html>
<p>
Basic block for Boolean sources of package Blocks.Sources.
This component has one continuous Boolean output signal y.
</p>
</html>"));

        end BooleanSignalSource;

    partial block IntegerBlockIcon "Basic graphical layout of Integer block"

      annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={255,127,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid), Text(
                extent={{-150,150},{150,110}},
                textString="%name",
                lineColor={0,0,255})}),
            Documentation(info="<html>
<p>
Block that has only the basic icon for an input/output,
Integer block (no declarations, no equations).
</p>
</html>"));
    end IntegerBlockIcon;

      partial block PartialIntegerMISO
      "Partial block with an IntegerVectorInput and an IntegerOutput signal"

        parameter Integer nu(min=0)=0 "Number of input connections"
                                                                  annotation(Dialog(connectorSizing=true), HideResult=true);
        Modelica.Blocks.Interfaces.IntegerVectorInput u[nu]
        "Vector of Integer input signals"
          annotation (Placement(transformation(extent={{-120,70},{-80,-70}})));
        Modelica.Blocks.Interfaces.IntegerOutput y "Integer output signal"
          annotation (Placement(transformation(extent={{100,-15},{130,15}})));
        annotation (Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={1,1},
              initialScale=0.06), graphics),
                                   Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={1,1},
              initialScale=0.06), graphics={
              Text(
                extent={{110,-50},{250,-70}},
                lineColor={0,0,0},
                textString=DynamicSelect(" ", realString(
                        y,
                        1,
                        0))),
              Text(
                extent={{-250,170},{250,110}},
                textString="%name",
                lineColor={0,0,255}),
              Rectangle(
                extent={{-100,100},{100,-100}},
                lineColor={255,137,0},
                fillColor={255,213,170},
                borderPattern=BorderPattern.Raised,
                fillPattern=FillPattern.Solid)}));
      end PartialIntegerMISO;

      partial block partialBooleanBlockIcon
      "Basic graphical layout of logical block"

        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Rectangle(
                extent={{-100,100},{100,-100}},
                lineColor={0,0,0},
                fillColor={210,210,210},
                fillPattern=FillPattern.Solid,
                borderPattern=BorderPattern.Raised), Text(
                extent={{-150,150},{150,110}},
                textString="%name",
                lineColor={0,0,255})}),                        Documentation(info="<html>
<p>
Block that has only the basic icon for an input/output,
Boolean block (no declarations, no equations) used especially
in the Blocks.Logical library.
</p>
</html>"));
      end partialBooleanBlockIcon;

      partial block partialBooleanSISO
      "Partial block with 1 input and 1 output Boolean signal"
        extends partialBooleanBlockIcon;
               Blocks.Interfaces.BooleanInput u
        "Connector of Boolean input signal"     annotation (Placement(
              transformation(extent={{-140,-20},{-100,20}}, rotation=0)));
               Blocks.Interfaces.BooleanOutput y
        "Connector of Boolean output signal"     annotation (Placement(
              transformation(extent={{100,-10},{120,10}}, rotation=0)));

        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Ellipse(
                extent={{-71,7},{-85,-7}},
                lineColor=DynamicSelect({235,235,235}, if u > 0.5 then {0,255,0} else
                          {235,235,235}),
                fillColor=DynamicSelect({235,235,235}, if u > 0.5 then {0,255,0} else
                          {235,235,235}),
                fillPattern=FillPattern.Solid), Ellipse(
                extent={{71,7},{85,-7}},
                lineColor=DynamicSelect({235,235,235}, if y > 0.5 then {0,255,0} else
                          {235,235,235}),
                fillColor=DynamicSelect({235,235,235}, if y > 0.5 then {0,255,0} else
                          {235,235,235}),
                fillPattern=FillPattern.Solid)}),
                                  Documentation(info="<html>
<p>
Block has one continuous Boolean input and one continuous Boolean output signal
with a 3D icon (e.g., used in Blocks.Logical library).
</p>
</html>"));

      end partialBooleanSISO;

      partial block partialBooleanSI2SO
      "Partial block with 2 input and 1 output Boolean signal"
        extends partialBooleanBlockIcon;
               Blocks.Interfaces.BooleanInput u1
        "Connector of first Boolean input signal"
                                                 annotation (Placement(
              transformation(extent={{-140,-20},{-100,20}}, rotation=0)));
               Blocks.Interfaces.BooleanInput u2
        "Connector of second Boolean input signal"
                                                 annotation (Placement(
              transformation(extent={{-140,-100},{-100,-60}}, rotation=0)));
               Blocks.Interfaces.BooleanOutput y
        "Connector of Boolean output signal"     annotation (Placement(
              transformation(extent={{100,-10},{120,10}}, rotation=0)));

        annotation (Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics={
              Ellipse(
                extent={{-71,7},{-85,-7}},
                lineColor=DynamicSelect({235,235,235}, if u1 > 0.5 then {0,255,0} else
                          {235,235,235}),
                fillColor=DynamicSelect({235,235,235}, if u1 > 0.5 then {0,255,0} else
                          {235,235,235}),
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-71,-74},{-85,-88}},
                lineColor=DynamicSelect({235,235,235}, if u2 > 0.5 then {0,255,0} else
                          {235,235,235}),
                fillColor=DynamicSelect({235,235,235}, if u2 > 0.5 then {0,255,0} else
                          {235,235,235}),
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{71,7},{85,-7}},
                lineColor=DynamicSelect({235,235,235}, if y > 0.5 then {0,255,0} else
                          {235,235,235}),
                fillColor=DynamicSelect({235,235,235}, if y > 0.5 then {0,255,0} else
                          {235,235,235}),
                fillPattern=FillPattern.Solid)}),
          Documentation(info="<html>
<p>
Block has two continuous Boolean input and one continuous Boolean output signal
with a 3D icon (e.g., used in Blocks.Logical library).
</p>
</html>"));

      end partialBooleanSI2SO;

      partial block partialBooleanThresholdComparison
      "Partial block to compare the Real input u with a threshold and provide the result as 1 Boolean output signal"

        parameter Real threshold=0 "Comparison with respect to threshold";

        Blocks.Interfaces.RealInput u "Connector of Boolean input signal"
                                      annotation (Placement(transformation(extent={
                  {-140,-20},{-100,20}}, rotation=0)));
        Blocks.Interfaces.BooleanOutput y "Connector of Boolean output signal"
                                          annotation (Placement(transformation(
                extent={{100,-10},{120,10}}, rotation=0)));

        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={
              Rectangle(
                extent={{-100,100},{100,-100}},
                lineColor={0,0,0},
                fillColor={210,210,210},
                fillPattern=FillPattern.Solid,
                borderPattern=BorderPattern.Raised),
              Text(
                extent={{-150,-140},{150,-110}},
                lineColor={0,0,0},
                textString="%threshold"),
              Ellipse(
                extent={{71,7},{85,-7}},
                lineColor=DynamicSelect({235,235,235}, if y > 0.5 then {0,255,0} else
                          {235,235,235}),
                fillColor=DynamicSelect({235,235,235}, if y > 0.5 then {0,255,0} else
                          {235,235,235}),
                fillPattern=FillPattern.Solid)}),
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                  {100,100}}),
                    graphics),
          Documentation(info="<html>
<p>
Block has one continuous Real input and one continuous Boolean output signal
as well as a 3D icon (e.g., used in Blocks.Logical library).
</p>
</html>"));

      end partialBooleanThresholdComparison;

      partial block partialBooleanComparison
      "Partial block with 2 Real input and 1 Boolean output signal (the result of a comparison of the two Real inputs"

        Blocks.Interfaces.RealInput u1
        "Connector of first Boolean input signal"
                                       annotation (Placement(transformation(extent=
                  {{-140,-20},{-100,20}}, rotation=0)));
        Blocks.Interfaces.RealInput u2
        "Connector of second Boolean input signal"
                                       annotation (Placement(transformation(extent=
                  {{-140,-100},{-100,-60}}, rotation=0)));
        Blocks.Interfaces.BooleanOutput y "Connector of Boolean output signal"
          annotation (Placement(transformation(extent={{100,-10},{120,10}},
                rotation=0)));

        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={
              Rectangle(
                extent={{-100,100},{100,-100}},
                lineColor={0,0,0},
                fillColor={210,210,210},
                fillPattern=FillPattern.Solid,
                borderPattern=BorderPattern.Raised),
              Ellipse(
                extent={{73,7},{87,-7}},
                lineColor=DynamicSelect({235,235,235}, if y > 0.5 then {0,255,0} else
                          {235,235,235}),
                fillColor=DynamicSelect({235,235,235}, if y > 0.5 then {0,255,0} else
                          {235,235,235}),
                fillPattern=FillPattern.Solid),
              Ellipse(extent={{32,10},{52,-10}}, lineColor={0,0,255}),
              Line(points={{-100,-80},{42,-80},{42,0}}, color={0,0,255})}),
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                  {100,100}}),
                    graphics),
          Documentation(info="<html>
<p>
Block has two continuous Real input and one continuous Boolean output signal
as a result of the comparision of the two input signals. The block
has a 3D icon (e.g., used in Blocks.Logical library).
</p>
</html>"));

      end partialBooleanComparison;

      partial block PartialBooleanMISO
      "Partial block with a BooleanVectorInput and a BooleanOutput signal"

        parameter Integer nu(min=0)=0 "Number of input connections"
                                                                  annotation(Dialog(connectorSizing=true), HideResult=true);
        Modelica.Blocks.Interfaces.BooleanVectorInput u[nu]
        "Vector of Boolean input signals"
          annotation (Placement(transformation(extent={{-120,70},{-80,-70}})));
        Modelica.Blocks.Interfaces.BooleanOutput y "Boolean output signal"
          annotation (Placement(transformation(extent={{100,-15},{130,15}})));
      initial equation
        pre(u) = fill(false,nu);
        annotation (Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={1,1},
              initialScale=0.06), graphics),
                                   Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={1,1},
              initialScale=0.06), graphics={
              Text(
                extent={{-250,170},{250,110}},
                textString="%name",
                lineColor={0,0,255}),
              Rectangle(
                extent={{-100,100},{100,-100}},
                lineColor={0,0,0},
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid,
                borderPattern=BorderPattern.Raised),
              Ellipse(
                extent={{60,10},{80,-10}},
                lineColor=DynamicSelect({235,235,235}, if y > 0.5 then {0,255,0}
                     else {235,235,235}),
                fillColor=DynamicSelect({235,235,235}, if y > 0.5 then {0,255,0}
                     else {235,235,235}),
                fillPattern=FillPattern.Solid)}));
      end PartialBooleanMISO;

      partial block PartialConversionBlock
      "Partial block defining the interface for conversion blocks"

        RealInput u "Connector of Real input signal to be converted"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}},
                rotation=0)));
        RealOutput y
        "Connector of Real output signal containing input signal u in another unit"
          annotation (Placement(transformation(extent={{100,-10},{120,10}},
                rotation=0)));
        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={
              Rectangle(
                extent={{-100,100},{100,-100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(points={{-90,0},{30,0}}, color={191,0,0}),
              Polygon(
                points={{90,0},{30,20},{30,-20},{90,0}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-115,155},{115,105}},
                textString="%name",
                lineColor={0,0,255})}),                                      Documentation(info="<html>
<p>
This block defines the interface of a conversion block that
converts from one unit into another one.
</p>

</html>"));

      end PartialConversionBlock;
        annotation (
          Documentation(info="<HTML>
<p>
This package contains interface definitions for
<b>continuous</b> input/output blocks with Real,
Integer and Boolean signals. Furthermore, it contains
partial models for continuous and discrete blocks.
</p>

</HTML>
",     revisions="<html>
<ul>
<li><i>Oct. 21, 2002</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
       and <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
       Added several new interfaces. <a href=\"modelica://Modelica/Documentation/ChangeNotes1.5.html\">Detailed description</a> available.
<li><i>Oct. 24, 1999</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       RealInputSignal renamed to RealInput. RealOutputSignal renamed to
       output RealOutput. GraphBlock renamed to BlockIcon. SISOreal renamed to
       SISO. SOreal renamed to SO. I2SOreal renamed to M2SO.
       SignalGenerator renamed to SignalSource. Introduced the following
       new models: MIMO, MIMOs, SVcontrol, MVcontrol, DiscreteBlockIcon,
       DiscreteBlock, DiscreteSISO, DiscreteMIMO, DiscreteMIMOs,
       BooleanBlockIcon, BooleanSISO, BooleanSignalSource, MI2BooleanMOs.</li>
<li><i>June 30, 1999</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Realized a first version, based on an existing Dymola library
       of Dieter Moormann and Hilding Elmqvist.</li>
</ul>
</html>
"));
    end Interfaces;

    package Logical
    "Library of components with Boolean input and output signals"
        extends Modelica.Icons.Package;

      model And "Logical 'and': y = u1 and u2"
        extends Blocks.Interfaces.partialBooleanSI2SO;
      equation
        y = u1 and u2;
        annotation (defaultComponentName="and1",
               Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                  {100,100}}), graphics={Text(
                extent={{-90,40},{90,-40}},
                lineColor={0,0,0},
                textString="and")}),
                                  Diagram(coordinateSystem(preserveAspectRatio=
                  false, extent={{-100,-100},{100,100}}),
                                          graphics),
          Documentation(info="<html>
<p>
The output is <b>true</b> if all inputs are <b>true</b>, otherwise
the output is <b>false</b>.
</p>
</html>"));
      end And;

      model Not "Logical 'not': y = not u"
        extends Blocks.Interfaces.partialBooleanSISO;

      equation
        y =not  u;
        annotation (defaultComponentName="not1",
             Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={Text(
                extent={{-90,40},{90,-40}},
                lineColor={0,0,0},
                textString="not")}),
                                Diagram(coordinateSystem(preserveAspectRatio=true,
                extent={{-100,-100},{100,100}}),
                                        graphics),
          Documentation(info="<html>
<p>
The output is <b>true</b> if the input is <b>false</b>, otherwise
the output is <b>false</b>.
</p>
</html>"));
      end Not;

      block GreaterThreshold
      "Output y is true, if input u is greater than threshold"
        extends Blocks.Interfaces.partialBooleanThresholdComparison;
      equation
        y = u > threshold;
        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Text(
                extent={{-90,-40},{60,40}},
                lineColor={0,0,0},
                textString=">")}),
                            Diagram(coordinateSystem(preserveAspectRatio=true,
                extent={{-100,-100},{100,100}}),
                                    graphics),
          Documentation(info="<html>
<p>
The output is <b>true</b> if the Real input is greater than
parameter <b>threshold</b>, otherwise
the output is <b>false</b>.
</p>
</html>"));
      end GreaterThreshold;

      block LessThreshold "Output y is true, if input u is less than threshold"

        extends Blocks.Interfaces.partialBooleanThresholdComparison;
      equation
        y = u < threshold;
        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Text(
                extent={{-90,-40},{60,40}},
                lineColor={0,0,0},
                textString="<")}),
                                Diagram(coordinateSystem(preserveAspectRatio=true,
                extent={{-100,-100},{100,100}}),
                                        graphics),
          Documentation(info="<html>
<p>
The output is <b>true</b> if the Real input is less than
parameter <b>threshold</b>, otherwise
the output is <b>false</b>.
</p>
</html>"));
      end LessThreshold;

      block LessEqualThreshold
      "Output y is true, if input u is less or equal than threshold"
        extends Blocks.Interfaces.partialBooleanThresholdComparison;
      equation
        y = u <= threshold;
        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Text(
                extent={{-90,-40},{60,40}},
                lineColor={0,0,0},
                textString="<=")}),
                                Diagram(coordinateSystem(preserveAspectRatio=true,
                extent={{-100,-100},{100,100}}),
                                        graphics),
          Documentation(info="<html>
<p>
The output is <b>true</b> if the Real input is less than or equal to
parameter <b>threshold</b>, otherwise
the output is <b>false</b>.
</p>
</html>"));
      end LessEqualThreshold;

      block Greater "Output y is true, if input u1 is greater as input u2"
        extends Blocks.Interfaces.partialBooleanComparison;

      equation
        y = u1 > u2;
        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={
              Ellipse(extent={{32,10},{52,-10}}, lineColor={0,0,255}),
              Line(points={{-100,-80},{42,-80},{42,0}}, color={0,0,255}),
              Text(
                extent={{-80,-60},{20,60}},
                lineColor={0,0,0},
                textString=">")}),
            Documentation(info="<html>
<p>
The output is <b>true</b> if Real input u1 is greater than
Real input u2, otherwise the output is <b>false</b>.
</p>
</html>"));
      end Greater;

      block Switch "Switch between two Real signals"
        extends Blocks.Interfaces.partialBooleanBlockIcon;
        Blocks.Interfaces.RealInput u1 "Connector of first Real input signal"
                                       annotation (Placement(transformation(extent=
                  {{-140,60},{-100,100}}, rotation=0)));
        Blocks.Interfaces.BooleanInput u2 "Connector of Boolean input signal"
                                          annotation (Placement(transformation(
                extent={{-140,-20},{-100,20}}, rotation=0)));
        Blocks.Interfaces.RealInput u3 "Connector of second Real input signal"
                                       annotation (Placement(transformation(extent=
                  {{-140,-100},{-100,-60}}, rotation=0)));
        Blocks.Interfaces.RealOutput y "Connector of Real output signal"
                                       annotation (Placement(transformation(extent=
                  {{100,-10},{120,10}}, rotation=0)));

      equation
        y = if u2 then u1 else u3;
        annotation (defaultComponentName="switch1",
          Documentation(info="<html>
<p>The Logical.Switch switches, depending on the
logical connector u2 (the middle connector)
between the two possible input signals
u1 (upper connector) and u3 (lower connector).</p>
<p>If u2 is <b>true</b>, the output signal y is set equal to
u1, else it is set equal to u3.</p>
</html>
"),       Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={2,2}), graphics={
              Line(
                points={{12,0},{100,0}},
                pattern=LinePattern.Solid,
                thickness=0.25,
                arrow={Arrow.None,Arrow.None},
                color={0,0,255}),
              Line(
                points={{-100,0},{-40,0}},
                color={255,0,127},
                pattern=LinePattern.Solid,
                thickness=0.25,
                arrow={Arrow.None,Arrow.None}),
              Line(
                points={{-100,-80},{-40,-80},{-40,-80}},
                pattern=LinePattern.Solid,
                thickness=0.25,
                arrow={Arrow.None,Arrow.None},
                color={0,0,255}),
              Line(points={{-40,12},{-40,-12}}, color={255,0,127}),
              Line(points={{-100,80},{-38,80}}, color={0,0,255}),
              Line(
                points={{-38,80},{6,2}},
                thickness=1,
                color={0,0,255}),
              Ellipse(
                extent={{2,8},{18,-6}},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,255})}),
          Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={2,2}), graphics));
      end Switch;

      block Hysteresis "Transform Real to Boolean signal with Hysteresis"

        extends Blocks.Interfaces.partialBooleanBlockIcon;
        parameter Real uLow(start=0) "if y=true and u<=uLow, switch to y=false";
        parameter Real uHigh(start=1)
        "if y=false and u>=uHigh, switch to y=true";
        parameter Boolean pre_y_start = false "Value of pre(y) at initial time";

        Blocks.Interfaces.RealInput u annotation (Placement(transformation(extent={
                  {-140,-20},{-100,20}}, rotation=0)));
        Blocks.Interfaces.BooleanOutput y
          annotation (Placement(transformation(extent={{100,-10},{120,10}},
                rotation=0)));

      initial equation
        pre(y) = pre_y_start;
      equation
         y = u > uHigh or pre(y) and u >= uLow;
        annotation (
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={
              Polygon(
                points={{-65,89},{-73,67},{-57,67},{-65,89}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-65,67},{-65,-81}}, color={192,192,192}),
              Line(points={{-90,-70},{82,-70}}, color={192,192,192}),
              Polygon(
                points={{90,-70},{68,-62},{68,-78},{90,-70}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{70,-80},{94,-100}},
                lineColor={160,160,164},
                textString="u"),
              Text(
                extent={{-65,93},{-12,75}},
                lineColor={160,160,164},
                textString="y"),
              Line(
                points={{-80,-70},{30,-70}},
                color={0,0,0},
                thickness=0.5),
              Line(
                points={{-50,10},{80,10}},
                color={0,0,0},
                thickness=0.5),
              Line(
                points={{-50,10},{-50,-70}},
                color={0,0,0},
                thickness=0.5),
              Line(
                points={{30,10},{30,-70}},
                color={0,0,0},
                thickness=0.5),
              Line(
                points={{-10,-65},{0,-70},{-10,-75}},
                color={0,0,0},
                thickness=0.5),
              Line(
                points={{-10,15},{-20,10},{-10,5}},
                color={0,0,0},
                thickness=0.5),
              Line(
                points={{-55,-20},{-50,-30},{-44,-20}},
                color={0,0,0},
                thickness=0.5),
              Line(
                points={{25,-30},{30,-19},{35,-30}},
                color={0,0,0},
                thickness=0.5),
              Text(
                extent={{-99,2},{-70,18}},
                lineColor={160,160,164},
                textString="true"),
              Text(
                extent={{-98,-87},{-66,-73}},
                lineColor={160,160,164},
                textString="false"),
              Text(
                extent={{19,-87},{44,-70}},
                lineColor={0,0,0},
                textString="uHigh"),
              Text(
                extent={{-63,-88},{-38,-71}},
                lineColor={0,0,0},
                textString="uLow"),
              Line(points={{-69,10},{-60,10}}, color={160,160,164})}),
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={
              Polygon(
                points={{-80,90},{-88,68},{-72,68},{-80,90}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-80,68},{-80,-29}}, color={192,192,192}),
              Polygon(
                points={{92,-29},{70,-21},{70,-37},{92,-29}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-79,-29},{84,-29}}, color={192,192,192}),
              Line(points={{-79,-29},{41,-29}}, color={0,0,0}),
              Line(points={{-15,-21},{1,-29},{-15,-36}}, color={0,0,0}),
              Line(points={{41,51},{41,-29}}, color={0,0,0}),
              Line(points={{33,3},{41,22},{50,3}}, color={0,0,0}),
              Line(points={{-49,51},{81,51}}, color={0,0,0}),
              Line(points={{-4,59},{-19,51},{-4,43}}, color={0,0,0}),
              Line(points={{-59,29},{-49,11},{-39,29}}, color={0,0,0}),
              Line(points={{-49,51},{-49,-29}}, color={0,0,0}),
              Text(
                extent={{-92,-49},{-9,-92}},
                lineColor={192,192,192},
                textString="%uLow"),
              Text(
                extent={{2,-49},{91,-92}},
                lineColor={192,192,192},
                textString="%uHigh"),
              Rectangle(extent={{-91,-49},{-8,-92}}, lineColor={192,192,192}),
              Line(points={{-49,-29},{-49,-49}}, color={192,192,192}),
              Rectangle(extent={{2,-49},{91,-92}}, lineColor={192,192,192}),
              Line(points={{41,-29},{41,-49}}, color={192,192,192})}),
          Documentation(info="<HTML>
<p>
This block transforms a <b>Real</b> input signal into a <b>Boolean</b>
output signal:
</p>
<ul>
<li> When the output was <b>false</b> and the input becomes
     <b>greater</b> than parameter <b>uHigh</b>, the output
     switches to <b>true</b>.</li>
<li> When the output was <b>true</b> and the input becomes
     <b>less</b> than parameter <b>uLow</b>, the output
     switches to <b>false</b>.</li>
</ul>
<p>
The start value of the output is defined via parameter
<b>pre_y_start</b> (= value of pre(y) at initial time).
The default value of this parameter is <b>false</b>.
</p>
</HTML>
"));
      end Hysteresis;
      annotation(Documentation(info="<html>
<p>
This package provides blocks with Boolean input and output signals
to describe logical networks. A typical example for a logical
network built with package Logical is shown in the next figure:
</p>

<img src=\"modelica://Modelica/Resources/Images/Blocks/LogicalNetwork1.png\">

<p>
The actual value of Boolean input and/or output signals is displayed
in the respective block icon as \"circle\", where \"white\" color means
value <b>false</b> and \"green\" color means value <b>true</b>. These
values are visualized in a diagram animation.
</p>
</html>"));
    end Logical;

    package Math
    "Library of Real mathematical functions as input/output blocks"
      import Modelica.SIunits;
      import Modelica.Blocks.Interfaces;
      extends Modelica.Icons.Package;

      encapsulated package UnitConversions
      "Conversion blocks to convert between SI and non-SI unit signals"
        import Modelica;
        import SI = Modelica.SIunits;
        import NonSI = Modelica.SIunits.Conversions.NonSIunits;
        extends Modelica.Icons.Package;

        block From_degC "Convert from degCelsius to Kelvin"
          extends Modelica.Blocks.Interfaces.PartialConversionBlock(u(unit="degC"),
              y(unit="K"));
        equation
          y = SI.Conversions.from_degC(u);
          annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                    -100},{100,100}}), graphics={Text(
                  extent={{-20,100},{-100,20}},
                  lineColor={0,0,0},
                  textString="degC"), Text(
                  extent={{100,-20},{20,-100}},
                  lineColor={0,0,0},
                  textString="K")}),
                              Documentation(info="<html>
<p>
This block converts the input signal from degCelsius to Kelvin and returns
the result as output signal.
</p>
</html>"));
        end From_degC;

        block From_deg "Convert from degree to radian"
          extends Modelica.Blocks.Interfaces.PartialConversionBlock(u(unit="deg"),
              y(unit="rad"));
        equation
          y = SI.Conversions.from_deg(u);
          annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                    -100},{100,100}}), graphics={Text(
                  extent={{-20,100},{-100,20}},
                  lineColor={0,0,0},
                  textString="deg"), Text(
                  extent={{100,-20},{20,-100}},
                  lineColor={0,0,0},
                  textString="rad")}),
                                Documentation(info="<html>
<p>
This block converts the input signal from degree to radian and returns
the result as output signal.
</p>
</html>"));
        end From_deg;
        annotation (Documentation(info="<html>
<p>
This package consists of blocks that convert an input signal
with a specific unit to an output signal in another unit
(e.g., conversion of an angle signal from \"deg\" to \"rad\").
Block \"ConvertAllUnits\" converts between a set of units that
can be selected in a pull-down menu of the parameter menu.
All other blocks convert exactly between two different units.
</p>

</html>"));
      end UnitConversions;

          block Gain "Output the product of a gain value with the input signal"

            parameter Real k(start=1, unit="1")
        "Gain value multiplied with input signal";
    public
            Interfaces.RealInput u "Input signal connector"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}},
                rotation=0)));
            Interfaces.RealOutput y "Output signal connector"
              annotation (Placement(transformation(extent={{100,-10},{120,10}},
                rotation=0)));

          equation
            y = k*u;
            annotation (
              Documentation(info="
<HTML>
<p>
This block computes output <i>y</i> as
<i>product</i> of gain <i>k</i> with the
input <i>u</i>:
</p>
<pre>
    y = k * u;
</pre>

</HTML>
"),           Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={2,2}), graphics={
              Polygon(
                points={{-100,-100},{-100,100},{100,0},{-100,-100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-150,-140},{150,-100}},
                lineColor={0,0,0},
                textString="k=%k"),
              Text(
                extent={{-150,140},{150,100}},
                textString="%name",
                lineColor={0,0,255})}),
              Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={2,2}), graphics={Polygon(
                points={{-100,-100},{-100,100},{100,0},{-100,-100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid), Text(
                extent={{-76,38},{0,-34}},
                textString="k",
                lineColor={0,0,255})}));
          end Gain;

          block MatrixGain
      "Output the product of a gain matrix with the input signal vector"

            parameter Real K[:, :]=[1, 0; 0, 1]
        "Gain matrix which is multiplied with the input";
            extends Interfaces.MIMO(final nin=size(K, 2), final nout=size(K, 1));
          equation
            y = K*u;
            annotation (
              Documentation(info="
<HTML>
<p>
This blocks computes output vector <b>y</b> as <i>product</i> of the
gain matrix <b>K</b> with the input signal vector <b>u</b>:
</p>
<pre>
    <b>y</b> = <b>K</b> * <b>u</b>;
</pre>
<p>
Example:
</p>
<pre>
   parameter: <b>K</b> = [0.12 2; 3 1.5]

   results in the following equations:

     | y[1] |     | 0.12  2.00 |   | u[1] |
     |      |  =  |            | * |      |
     | y[2] |     | 3.00  1.50 |   | u[2] |
</pre>

</HTML>
"),           Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={2,2}), graphics={Text(
                extent={{-90,-60},{90,60}},
                lineColor={160,160,164},
                textString="*K"), Text(
                extent={{-150,150},{150,110}},
                textString="%name",
                lineColor={0,0,255})}),
              Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={2,2}), graphics={Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid), Text(
                extent={{-90,-60},{90,60}},
                lineColor={160,160,164},
                textString="*K")}));
          end MatrixGain;

          block Feedback
      "Output difference between commanded and feedback input"

            input Interfaces.RealInput u1 annotation (Placement(transformation(
                extent={{-100,-20},{-60,20}}, rotation=0)));
            input Interfaces.RealInput u2
              annotation (Placement(transformation(
              origin={0,-80},
              extent={{-20,-20},{20,20}},
              rotation=90)));
            output Interfaces.RealOutput y annotation (Placement(transformation(
                extent={{80,-10},{100,10}}, rotation=0)));

          equation
            y = u1 - u2;
            annotation (
              Documentation(info="
<HTML>
<p>
This blocks computes output <b>y</b> as <i>difference</i> of the
commanded input <b>u1</b> and the feedback
input <b>u2</b>:
</p>
<pre>
    <b>y</b> = <b>u1</b> - <b>u2</b>;
</pre>
<p>
Example:
</p>
<pre>
     parameter:   n = 2

  results in the following equations:

     y = u1 - u2
</pre>

</HTML>
"),           Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={2,2}), graphics={
              Ellipse(
                extent={{-20,20},{20,-20}},
                lineColor={0,0,127},
                fillColor={235,235,235},
                fillPattern=FillPattern.Solid),
              Line(points={{-60,0},{-20,0}}, color={0,0,127}),
              Line(points={{20,0},{80,0}}, color={0,0,127}),
              Line(points={{0,-20},{0,-60}}, color={0,0,127}),
              Text(
                extent={{-14,0},{82,-94}},
                lineColor={0,0,0},
                textString="-"),
              Text(
                extent={{-150,94},{150,44}},
                textString="%name",
                lineColor={0,0,255})}),
              Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={2,2}), graphics={
              Ellipse(
                extent={{-20,20},{20,-20}},
                pattern=LinePattern.Solid,
                lineThickness=0.25,
                fillColor={235,235,235},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,255}),
              Line(points={{-60,0},{-20,0}}, color={0,0,255}),
              Line(points={{20,0},{80,0}}, color={0,0,255}),
              Line(points={{0,-20},{0,-60}}, color={0,0,255}),
              Text(
                extent={{-12,10},{84,-84}},
                lineColor={0,0,0},
                textString="-")}));
          end Feedback;

          block Add
      "Output the sum of the two inputs (this is an obsolet block. Use instead MultiSum)"
            extends Interfaces.SI2SO;
            parameter Real k1=+1 "Gain of upper input";
            parameter Real k2=+1 "Gain of lower input";

          equation
            y = k1*u1 + k2*u2;
            annotation (
              Documentation(info="
<HTML>
<p>
This blocks computes output <b>y</b> as <i>sum</i> of the
two input signals <b>u1</b> and <b>u2</b>:
</p>
<pre>
    <b>y</b> = k1*<b>u1</b> + k2*<b>u2</b>;
</pre>
<p>
Example:
</p>
<pre>
     parameter:   k1= +2, k2= -3

  results in the following equations:

     y = 2 * u1 - 3 * u2
</pre>

</HTML>
"),           Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={2,2}), graphics={
              Text(
                extent={{-98,-52},{7,-92}},
                lineColor={0,0,0},
                textString="%k2"),
              Text(
                extent={{-100,90},{5,50}},
                lineColor={0,0,0},
                textString="%k1"),
              Text(
                extent={{-150,150},{150,110}},
                textString="%name",
                lineColor={0,0,255}),
              Line(points={{-100,60},{-40,60},{-30,40}}, color={0,0,255}),
              Ellipse(extent={{-50,50},{50,-50}}, lineColor={0,0,255}),
              Line(points={{-100,-60},{-40,-60},{-30,-40}}, color={0,0,255}),
              Line(points={{-15,-25.99},{15,25.99}}, color={0,0,0}),
              Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(points={{50,0},{100,0}}, color={0,0,255}),
              Line(points={{-100,60},{-74,24},{-44,24}}, color={0,0,127}),
              Line(points={{-100,-60},{-74,-28},{-42,-28}}, color={0,0,127}),
              Ellipse(extent={{-50,50},{50,-50}}, lineColor={0,0,127}),
              Line(points={{50,0},{100,0}}, color={0,0,127}),
              Text(
                extent={{-38,34},{38,-34}},
                lineColor={0,0,0},
                textString="+"),
              Text(
                extent={{-100,52},{5,92}},
                lineColor={0,0,0},
                textString="%k1"),
              Text(
                extent={{-100,-52},{5,-92}},
                lineColor={0,0,0},
                textString="%k2")}),
              Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={2,2}), graphics={
              Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-98,-52},{7,-92}},
                lineColor={0,0,0},
                textString="%k2"),
              Text(
                extent={{-100,90},{5,50}},
                lineColor={0,0,0},
                textString="%k1"),
              Line(points={{-100,60},{-40,60},{-30,40}}, color={0,0,255}),
              Ellipse(extent={{-50,50},{50,-50}}, lineColor={0,0,255}),
              Line(points={{-100,-60},{-40,-60},{-30,-40}}, color={0,0,255}),
              Line(points={{-15,-25.99},{15,25.99}}, color={0,0,0}),
              Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(points={{50,0},{100,0}}, color={0,0,255}),
              Line(points={{-100,60},{-74,24},{-44,24}}, color={0,0,127}),
              Line(points={{-100,-60},{-74,-28},{-42,-28}}, color={0,0,127}),
              Ellipse(extent={{-50,50},{50,-50}}, lineColor={0,0,127}),
              Line(points={{50,0},{100,0}}, color={0,0,127}),
              Text(
                extent={{-38,34},{38,-34}},
                lineColor={0,0,0},
                textString="+"),
              Text(
                extent={{-100,52},{5,92}},
                lineColor={0,0,0},
                textString="k1"),
              Text(
                extent={{-100,-52},{5,-92}},
                lineColor={0,0,0},
                textString="k2")}));
          end Add;

          block Add3
      "Output the sum of the three inputs (this is an obsolet block. Use instead MultiSum)"
            extends Interfaces.BlockIcon;

            parameter Real k1=+1 "Gain of upper input";
            parameter Real k2=+1 "Gain of middle input";
            parameter Real k3=+1 "Gain of lower input";
            input Interfaces.RealInput u1 "Connector 1 of Real input signals"
              annotation (Placement(transformation(extent={{-140,60},{-100,100}},
                rotation=0)));
            input Interfaces.RealInput u2 "Connector 2 of Real input signals"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}},
                rotation=0)));
            input Interfaces.RealInput u3 "Connector 3 of Real input signals"
              annotation (Placement(transformation(extent={{-140,-100},{-100,-60}},
                rotation=0)));
            output Interfaces.RealOutput y "Connector of Real output signals"
              annotation (Placement(transformation(extent={{100,-10},{120,10}},
                rotation=0)));

          equation
            y = k1*u1 + k2*u2 + k3*u3;
            annotation (
              Documentation(info="
<HTML>
<p>
This blocks computes output <b>y</b> as <i>sum</i> of the
three input signals <b>u1</b>, <b>u2</b> and <b>u3</b>:
</p>
<pre>
    <b>y</b> = k1*<b>u1</b> + k2*<b>u2</b> + k3*<b>u3</b>;
</pre>
<p>
Example:
</p>
<pre>
     parameter:   k1= +2, k2= -3, k3=1;

  results in the following equations:

     y = 2 * u1 - 3 * u2 + u3;
</pre>

</HTML>
"),           Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={2,2}), graphics={
              Text(
                extent={{-100,50},{5,90}},
                lineColor={0,0,0},
                textString="%k1"),
              Text(
                extent={{-100,-20},{5,20}},
                lineColor={0,0,0},
                textString="%k2"),
              Text(
                extent={{-100,-50},{5,-90}},
                lineColor={0,0,0},
                textString="%k3"),
              Text(
                extent={{2,36},{100,-44}},
                lineColor={0,0,0},
                textString="+")}),
              Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={2,2}), graphics={
              Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-100,50},{5,90}},
                lineColor={0,0,0},
                textString="%k1"),
              Text(
                extent={{-100,-20},{5,20}},
                lineColor={0,0,0},
                textString="%k2"),
              Text(
                extent={{-100,-50},{5,-90}},
                lineColor={0,0,0},
                textString="%k3"),
              Text(
                extent={{2,36},{100,-44}},
                lineColor={0,0,0},
                textString="+"),
              Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-100,50},{5,90}},
                lineColor={0,0,0},
                textString="k1"),
              Text(
                extent={{-100,-20},{5,20}},
                lineColor={0,0,0},
                textString="k2"),
              Text(
                extent={{-100,-50},{5,-90}},
                lineColor={0,0,0},
                textString="k3"),
              Text(
                extent={{2,36},{100,-44}},
                lineColor={0,0,0},
                textString="+")}));
          end Add3;

          block Product
      "Output product of the two inputs (this is an obsolet block. Use instead MultiProduct)"
            extends Interfaces.SI2SO;

          equation
            y = u1*u2;
            annotation (
              Documentation(info="
<HTML>
<p>
This blocks computes the output <b>y</b> (element-wise)
as <i>product</i> of the corresponding elements of
the two inputs <b>u1</b> and <b>u2</b>:
</p>
<pre>
    y = u1 * u2;
</pre>

</HTML>
"),           Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={2,2}), graphics={
              Line(points={{-100,60},{-40,60},{-30,40}}, color={0,0,127}),
              Line(points={{-100,-60},{-40,-60},{-30,-40}}, color={0,0,127}),
              Line(points={{50,0},{100,0}}, color={0,0,127}),
              Line(points={{-30,0},{30,0}}, color={0,0,0}),
              Line(points={{-15,25.99},{15,-25.99}}, color={0,0,0}),
              Line(points={{-15,-25.99},{15,25.99}}, color={0,0,0}),
              Ellipse(extent={{-50,50},{50,-50}}, lineColor={0,0,127})}),
              Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={2,2}), graphics={
              Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(points={{-100,60},{-40,60},{-30,40}}, color={0,0,255}),
              Line(points={{-100,-60},{-40,-60},{-30,-40}}, color={0,0,255}),
              Line(points={{50,0},{100,0}}, color={0,0,255}),
              Line(points={{-30,0},{30,0}}, color={0,0,0}),
              Line(points={{-15,25.99},{15,-25.99}}, color={0,0,0}),
              Line(points={{-15,-25.99},{15,25.99}}, color={0,0,0}),
              Ellipse(extent={{-50,50},{50,-50}}, lineColor={0,0,255})}));
          end Product;

      block Max "Pass through the largest signal"
        extends Interfaces.SI2SO;
      equation
        y = max(u1, u2);
        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Text(
                extent={{-90,36},{90,-36}},
                lineColor={160,160,164},
                textString="max()")}),
                                Documentation(info="<html>
<p>
This block computes the output <b>y</b> as <i>maximum</i>
of the two Real inputs <b>u1</b> and <b>u2</b>:
</p>
<pre>    y = <b>max</b> ( u1 , u2 );
</pre>
</html>
"));
      end Max;

      block Min "Pass through the smallest signal"
        extends Interfaces.SI2SO;
      equation
         y = min(u1, u2);
        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Text(
                extent={{-90,36},{90,-36}},
                lineColor={160,160,164},
                textString="min()")}),
                                Documentation(info="<html>
<p>
This block computes the output <b>y</b> as <i>minimum</i> of
the two Real inputs <b>u1</b> and <b>u2</b>:
</p>
<pre>    y = <b>min</b> ( u1 , u2 );
</pre>
</html>
"));
      end Min;
      annotation (
        Documentation(info="
<HTML>
<p>
This package contains basic <b>mathematical operations</b>,
such as summation and multiplication, and basic <b>mathematical
functions</b>, such as <b>sqrt</b> and <b>sin</b>, as
input/output blocks. All blocks of this library can be either
connected with continuous blocks or with sampled-data blocks.
</p>
</HTML>
",     revisions="<html>
<ul>
<li><i>October 21, 2002</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
       and <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
       New blocks added: RealToInteger, IntegerToReal, Max, Min, Edge, BooleanChange, IntegerChange.</li>
<li><i>August 7, 1999</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Realized (partly based on an existing Dymola library
       of Dieter Moormann and Hilding Elmqvist).
</li>
</ul>
</html>"));
    end Math;

    package MathInteger
    "Library of Integer mathematical functions as input/output blocks"
      extends Modelica.Icons.Package;

      block Sum "Sum of Integers: y = k[1]*u[1] + k[2]*u[2] + ... + k[n]*u[n]"
         extends Modelica.Blocks.Interfaces.PartialIntegerMISO;
         parameter Integer k[nu] = fill(1,nu) "Input gains";
      equation
        if size(u,1) > 0 then
           y = k*u;
        else
           y = 0;
        end if;
        annotation (Icon(graphics={Text(
                  extent={{-200,-110},{200,-140}},
                  lineColor={0,0,0},
                  fillColor={255,213,170},
                  fillPattern=FillPattern.Solid,
                  textString="%k"), Text(
                  extent={{-72,68},{92,-68}},
                  lineColor={0,0,0},
                  fillColor={255,213,170},
                  fillPattern=FillPattern.Solid,
                  textString="+")}), Documentation(info="<html>
<p>
This blocks computes the scalar Integer output \"y\" as sum of the elements of the
Integer input signal vector u:
</p>
<blockquote><pre>
y = k[1]*u[1] + k[2]*u[2] + ... k[N]*u[N];
</pre></blockquote>

<p>
The input connector is a vector of Integer input signals.
When a connection line is drawn, the dimension of the input
vector is enlarged by one and the connection is automatically
connected to this new free index (thanks to the 
connectorSizing annotation).
</p>

<p>
The usage is demonstrated, e.g., in example
<a href=\"modelica://Modelica.Blocks.Examples.IntegerNetwork1\">Modelica.Blocks.Examples.IntegerNetwork1</a>.
</p>

<p>
If no connection to the input connector \"u\" is present, 
the output is set to zero: y=0.
</p>
</html>"));
      end Sum;
      annotation (Documentation(info="<html>
<p>
This package contains basic <b>mathematical operations</b>
on <b>Integer</b> signals.
</p>
</html>"));
    end MathInteger;

    package MathBoolean
    "Library of Boolean mathematical functions as input/output blocks"
      extends Modelica.Icons.Package;

      block And "Logical 'and': y = u[1] and u[2] and ... and u[nu]"
        extends Modelica.Blocks.Interfaces.PartialBooleanMISO;

      equation
        y = Modelica.Math.BooleanVectors.allTrue(
                                  u);
        annotation (defaultComponentName="and1", Icon(graphics={Text(
                  extent={{-76,40},{60,-40}},
                  lineColor={0,0,0},
                  textString="and")}),
          Documentation(info="<html>
<p>
The output is <b>true</b> if all inputs are <b>true</b>, otherwise
the output is <b>false</b>.
</p>

<p>
The input connector is a vector of Boolean input signals.
When a connection line is drawn, the dimension of the input
vector is enlarged by one and the connection is automatically
connected to this new free index (thanks to the
connectorSizing annotation).
</p>

<p>
The usage is demonstrated, e.g., in example
<a href=\"modelica://Modelica.Blocks.Examples.BooleanNetwork1\">Modelica.Blocks.Examples.BooleanNetwork1</a>.
</p>

<p>
If no connection to the input connector \"u\" is present,
the output is set to <b>false</b>: y=false.
</p>
</html>"));
      end And;
      annotation (Documentation(info="<html>
<p>
This package contains basic <b>mathematical operations</b>
on <b>Boolean</b> signals.
</p>

<p>
Package MathBoolean is a new design that shall replace in the future the
<a href=\"modelica://Modelica.Blocks.Logical\">Logical</a> package.
The new features are:
</p>

<ul>
<li> If useful, blocks may have an arbitrary number of inputs (e.g., \"And\" block with 2,3,4,...
     Boolean inputs). This is based on the \"connectorSizing\" annotation which
     allows a tool to conveniently handle vectors of connectors. </li>

<li> The blocks are smaller in size, so that the diagram area is better
     utilized for trivial blocks such as \"And\" or \"Or\".</li>

</ul>

</html>"));
    end MathBoolean;

    package Nonlinear
    "Library of discontinuous or non-differentiable algebraic control blocks"
      import Modelica.Blocks.Interfaces;
      extends Modelica.Icons.Package;

          block Limiter "Limit the range of a signal"
            parameter Real uMax(start=1) "Upper limits of input signals";
            parameter Real uMin= -uMax "Lower limits of input signals";
            parameter Boolean limitsAtInit = true
        "= false, if limits are ignored during initializiation (i.e., y=u)";
            extends Interfaces.SISO;

          equation
            assert(uMax >= uMin, "Limiter: Limits must be consistent. However, uMax (=" + String(uMax) +
                                 ") < uMin (=" + String(uMin) + ")");
            if initial() and not limitsAtInit then
               y = u;
               assert(u >= uMin - 0.01*abs(uMin) and
                      u <= uMax + 0.01*abs(uMax),
                     "Limiter: During initialization the limits have been ignored.\n"+
                     "However, the result is that the input u is not within the required limits:\n"+
                     "  u = " + String(u) + ", uMin = " + String(uMin) + ", uMax = " + String(uMax));
            else
               y = smooth(0,if u > uMax then uMax else if u < uMin then uMin else u);
            end if;
            annotation (
              Documentation(info="
<HTML>
<p>
The Limiter block passes its input signal as output signal
as long as the input is within the specified upper and lower
limits. If this is not the case, the corresponding limits are passed
as output.
</p>
</HTML>
"),           Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={2,2}), graphics={
              Line(points={{0,-90},{0,68}}, color={192,192,192}),
              Polygon(
                points={{0,90},{-8,68},{8,68},{0,90}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-90,0},{68,0}}, color={192,192,192}),
              Polygon(
                points={{90,0},{68,-8},{68,8},{90,0}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-80,-70},{-50,-70},{50,70},{80,70}}, color={0,0,0}),
              Text(
                extent={{-150,-150},{150,-110}},
                lineColor={0,0,0},
                textString="uMax=%uMax"),
              Text(
                extent={{-150,150},{150,110}},
                textString="%name",
                lineColor={0,0,255})}),
              Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={2,2}), graphics={
              Line(points={{0,-60},{0,50}}, color={192,192,192}),
              Polygon(
                points={{0,60},{-5,50},{5,50},{0,60}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-60,0},{50,0}}, color={192,192,192}),
              Polygon(
                points={{60,0},{50,-5},{50,5},{60,0}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-50,-40},{-30,-40},{30,40},{50,40}}, color={0,0,0}),
              Text(
                extent={{46,-6},{68,-18}},
                lineColor={128,128,128},
                textString="u"),
              Text(
                extent={{-30,70},{-5,50}},
                lineColor={128,128,128},
                textString="y"),
              Text(
                extent={{-58,-54},{-28,-42}},
                lineColor={128,128,128},
                textString="uMin"),
              Text(
                extent={{26,40},{66,56}},
                lineColor={128,128,128},
                textString="uMax")}));
          end Limiter;
          annotation (
            Documentation(info="
<HTML>
<p>
This package contains <b>discontinuous</b> and
<b>non-differentiable, algebraic</b> input/output blocks.
</p>
</HTML>
",     revisions="<html>
<ul>
<li><i>October 21, 2002</i>
       by <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
       New block VariableLimiter added.
<li><i>August 22, 1999</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Realized, based on an existing Dymola library
       of Dieter Moormann and Hilding Elmqvist.
</li>
</ul>
</html>
"));
    end Nonlinear;

    package Routing "Library of blocks to combine and extract signals"
      extends Modelica.Icons.Package;

      block Replicator "Signal replicator"
        extends Modelica.Blocks.Interfaces.SIMO;
      equation
        y = fill(u, nout);
        annotation (
          Window(
            x=0.15,
            y=0.16,
            width=0.63,
            height=0.59), Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-100,-100},{100,100}},
              grid={2,2}), graphics={
              Line(points={{-100,0},{-6,0}}, color={0,0,127}),
              Line(points={{100,0},{10,0}}, color={0,0,127}),
              Line(points={{0,0},{100,10}}, color={0,0,127}),
              Line(points={{0,0},{100,-10}}, color={0,0,127}),
              Ellipse(
                extent={{-14,16},{16,-14}},
                lineColor={0,0,0},
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid)}),
          Diagram(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-100,-100},{100,100}},
              grid={2,2}), graphics),
          Documentation(info="<html>
<p>
This block replicates the input signal to an array of <code>nout</code> identical output signals.
</p>
</html>"));
      end Replicator;

    block Extractor
      "Extract scalar signal out of signal vector dependent on IntegerRealInput index"

      extends Modelica.Blocks.Interfaces.MISO;

      parameter Boolean allowOutOfRange=false "Index may be out of range";
      parameter Real outOfRangeValue=1e10
        "Output signal if index is out of range";

      Modelica.Blocks.Interfaces.IntegerInput index             annotation (Placement(
              transformation(
              origin={0,-120},
              extent={{-20,-20},{20,20}},
              rotation=90)));
    protected
      Real k[nin];
    equation

      when {initial(),change(index)} then

        for i in 1:nin loop
          k[i] = if index == i then 1 else 0;

        end for;

      end when;

      y = if not allowOutOfRange or index > 0 and index <= nin then
                  k*u else outOfRangeValue;
      annotation (Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics={
              Rectangle(
                extent={{-80,50},{-40,-50}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-84.4104,1.9079},{-84.4104,-2.09208},{-80.4104,-0.09208},{
                    -84.4104,1.9079}},
                lineColor={0,0,127},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Line(points={{-62,2},{-50.1395,12.907},{-39.1395,12.907}}, color={0,0,
                    127}),
              Line(points={{-63,4},{-49,40},{-39,40}}, color={0,0,127}),
              Line(points={{-102,0},{-65.0373,-0.01802}}, color={0,0,127}),
              Ellipse(
                extent={{-70.0437,4.5925},{-60.0437,-4.90745}},
                lineColor={0,0,127},
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid),
              Line(points={{-63,-5},{-50,-40},{-39,-40}}, color={0,0,127}),
              Line(points={{-62,-2},{-50.0698,-12.907},{-39.0698,-12.907}}, color={
                    0,0,127}),
              Polygon(
                points={{-38.8808,-11},{-38.8808,-15},{-34.8808,-13},{-38.8808,-11}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-39,42},{-39,38},{-35,40},{-39,42}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-38.8728,-38.0295},{-38.8728,-42.0295},{-34.8728,-40.0295},
                    {-38.8728,-38.0295}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-38.9983,14.8801},{-38.9983,10.8801},{-34.9983,12.8801},{-38.9983,
                    14.8801}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-30,50},{30,-50}},
                fillColor={235,235,235},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,127}),
              Line(points={{100,0},{0,0}}, color={0,0,127}),
              Line(points={{0,2},{0,-104}}, color={255,128,0}),
              Line(points={{-35,40},{-20,40}}, color={0,0,127}),
              Line(points={{-35,13},{-20,13}}, color={0,0,127}),
              Line(points={{-35,-13},{-20,-13}}, color={0,0,127}),
              Line(points={{-35,-40},{-20,-40}}, color={0,0,127}),
              Polygon(points={{0,0},{-20,13},{-20,13},{0,0},{0,0}}, lineColor={0,0,
                    127}),
              Ellipse(
                extent={{-6,6},{6,-6}},
                lineColor={255,128,0},
                fillColor={255,128,0},
                fillPattern=FillPattern.Solid)}),
                                Documentation(info="<html>
<p>This block extracts a scalar output signal out the
vector of input signals dependent on the Integer
value of the additional u index:</p>
<pre>    y = u [ index ] ;
</pre>
<p>where index is an additional Integer input signal.</p>
</html>"),Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={1,1})));
    end Extractor;

      block Multiplex2 "Multiplexer block for two input connectors"
        extends Modelica.Blocks.Interfaces.BlockIcon;
        parameter Integer n1=1 "dimension of input signal connector 1";
        parameter Integer n2=1 "dimension of input signal connector 2";
        Modelica.Blocks.Interfaces.RealInput u1[n1]
        "Connector of Real input signals 1"   annotation (Placement(transformation(
                extent={{-140,40},{-100,80}}, rotation=0)));
        Modelica.Blocks.Interfaces.RealInput u2[n2]
        "Connector of Real input signals 2"   annotation (Placement(transformation(
                extent={{-140,-80},{-100,-40}}, rotation=0)));
        Modelica.Blocks.Interfaces.RealOutput y[n1 + n2]
        "Connector of Real output signals"   annotation (Placement(transformation(
                extent={{100,-10},{120,10}}, rotation=0)));

      equation
        [y] = [u1; u2];
        annotation (
          Documentation(info="<HTML>
<p>
The output connector is the <b>concatenation</b> of the two input connectors.
Note, that the dimensions of the input connector signals have to be
explicitly defined via parameters n1 and n2.
</p>
</HTML>
"),       Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={2,2}), graphics={
              Line(points={{8,0},{102,0}}, color={0,0,127}),
              Ellipse(
                extent={{-14,16},{16,-14}},
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,127}),
              Line(points={{-98,60},{-60,60},{-4,6}}, color={0,0,127}),
              Line(points={{-98,-60},{-60,-60},{-4,-4}}, color={0,0,127})}),
          Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={2,2}), graphics={
              Line(points={{-98,60},{-60,60},{-4,6}}, color={0,0,255}),
              Line(points={{-98,-60},{-60,-60},{-4,-4}}, color={0,0,255}),
              Line(points={{8,0},{102,0}}, color={0,0,255}),
              Ellipse(
                extent={{-14,16},{16,-14}},
                fillColor={0,0,255},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,255})}));
      end Multiplex2;

      model RealPassThrough "Pass a Real signal through without modification"

        extends Modelica.Blocks.Interfaces.BlockIcon;

        Modelica.Blocks.Interfaces.RealInput u "Input signal"
          annotation (HideResult=true, Placement(transformation(extent={{-140,-20},{-100,
                  20}}, rotation=0)));
        Modelica.Blocks.Interfaces.RealOutput y "Output signal"
          annotation (HideResult=true, Placement(transformation(extent={{100,-10},{120,10}},
                rotation=0)));
      equation
        y = u;
        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Line(points={{-100,0},{100,0}},
                  color={0,0,127})}),
                          Documentation(info="<html>
<p>
Passes a Real signal through without modification.  Enables signals to be read out of one bus, have their name changed and be sent back to a bus.
</p>
</html>"));
      end RealPassThrough;

      model IntegerPassThrough
      "Pass a Integer signal through without modification"
        extends Modelica.Blocks.Interfaces.IntegerBlockIcon;

        Modelica.Blocks.Interfaces.IntegerInput u "Input signal"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}},
                rotation=0)));
        Modelica.Blocks.Interfaces.IntegerOutput y "Output signal"
          annotation (Placement(transformation(extent={{100,-10},{120,10}},
                rotation=0)));
      equation
        y = u;

        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Line(points={{-100,0},{100,0}},
                  color={255,128,0})}),
                          Documentation(info="<html>
<p>Passes a Integer signal through without modification.  Enables signals to be read out of one bus, have their name changed and be sent back to a bus.</p>
</html>"));
      end IntegerPassThrough;

      model BooleanPassThrough
      "Pass a Boolean signal through without modification"
        extends Modelica.Blocks.Interfaces.BooleanBlockIcon;

        Modelica.Blocks.Interfaces.BooleanInput u "Input signal"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}},
                rotation=0)));
        Modelica.Blocks.Interfaces.BooleanOutput y "Output signal"
          annotation (Placement(transformation(extent={{100,-10},{120,10}},
                rotation=0)));
      equation
        y = u;
        annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{
                  -100,-100},{100,100}}),
                            graphics),
                             Documentation(info="<html>
<p>Passes a Boolean signal through without modification.  Enables signals to be read out of one bus, have their name changed and be sent back to a bus.</p>
</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={Line(points={{-100,0},{100,0}}, color={255,0,
                    255})}));
      end BooleanPassThrough;
      annotation (Documentation(info="<html>
<p>
This package contains blocks to combine and extract signals.
</p>
</html>"));
    end Routing;

    package Sources
    "Library of signal source blocks generating Real and Boolean signals"
      import Modelica.Blocks.Interfaces;
      import Modelica.SIunits;
      extends Modelica.Icons.SourcesPackage;

      block RealExpression
      "Set output signal to a time varying Real expression"

        Modelica.Blocks.Interfaces.RealOutput y=0.0 "Value of Real output"
          annotation (                            Dialog(group=
                "Time varying output signal"), Placement(transformation(extent={{
                  100,-10},{120,10}}, rotation=0)));

        annotation (
          Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-100,-100},{100,100}},
              grid={2,2}), graphics={
              Rectangle(
                extent={{-100,40},{100,-40}},
                lineColor={0,0,0},
                fillColor={235,235,235},
                fillPattern=FillPattern.Solid,
                borderPattern=BorderPattern.Raised),
              Text(
                extent={{-96,15},{96,-15}},
                lineColor={0,0,0},
                textString="%y"),
              Text(
                extent={{-150,90},{140,50}},
                textString="%name",
                lineColor={0,0,255})}),
          Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={2,2}), graphics),
          Documentation(info="<html>
<p>
The (time varying) Real output signal of this block can be defined in its
parameter menu via variable <b>y</b>. The purpose is to support the
easy definition of Real expressions in a block diagram. For example,
in the y-menu the definition \"if time &lt; 1 then 0 else 1\" can be given in order
to define that the output signal is one, if time &ge; 1 and otherwise
it is zero. Note, that \"time\" is a built-in variable that is always
accessible and represents the \"model time\" and that
Variable <b>y</b> is both a variable and a connector.
</p>
</html>"));

      end RealExpression;

      block BooleanExpression
      "Set output signal to a time varying Boolean expression"

        Modelica.Blocks.Interfaces.BooleanOutput y=false
        "Value of Boolean output"
          annotation (                            Dialog(group=
                "Time varying output signal"), Placement(transformation(extent={{
                  100,-10},{120,10}}, rotation=0)));

        annotation (
          Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-100,-100},{100,100}},
              grid={2,2}), graphics={
              Rectangle(
                extent={{-100,40},{100,-40}},
                lineColor={0,0,0},
                fillColor={235,235,235},
                fillPattern=FillPattern.Solid,
                borderPattern=BorderPattern.Raised),
              Text(
                extent={{-96,15},{96,-15}},
                lineColor={0,0,0},
                textString="%y"),
              Text(
                extent={{-150,90},{140,50}},
                textString="%name",
                lineColor={0,0,255}),
              Polygon(
                points={{100,10},{120,0},{100,-10},{100,10}},
                lineColor=DynamicSelect({255,0,255}, if y > 0.5 then {0,255,0} else
                          {255,0,255}),
                fillColor=DynamicSelect({255,255,255}, if y > 0.5 then {0,255,0} else
                          {255,255,255}),
                fillPattern=FillPattern.Solid)}),
          Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={2,2}), graphics),
          Documentation(info="<html>
<p>
The (time varying) Boolean output signal of this block can be defined in its
parameter menu via variable <b>y</b>. The purpose is to support the
easy definition of Boolean expressions in a block diagram. For example,
in the y-menu the definition \"time &gt;= 1 and time &lt;= 2\" can be given in order
to define that the output signal is <b>true</b> in the time interval
1 &le; time &le; 2 and otherwise it is <b>false</b>.
Note, that \"time\" is a built-in variable that is always
accessible and represents the \"model time\" and that
Variable <b>y</b> is both a variable and a connector.
</p>
</html>"));

      end BooleanExpression;

          block Constant "Generate constant signal of type Real"
            parameter Real k(start=1) "Constant output value";
            extends Interfaces.SO;

          equation
            y = k;
            annotation (defaultComponentName="const",
              Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={2,2}), graphics={
              Line(points={{-80,68},{-80,-80}}, color={192,192,192}),
              Polygon(
                points={{-80,90},{-88,68},{-72,68},{-80,90}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-90,-70},{82,-70}}, color={192,192,192}),
              Polygon(
                points={{90,-70},{68,-62},{68,-78},{90,-70}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-80,0},{80,0}}, color={0,0,0}),
              Text(
                extent={{-150,-150},{150,-110}},
                lineColor={0,0,0},
                textString="k=%k")}),
              Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={2,2}), graphics={
              Polygon(
                points={{-80,90},{-86,68},{-74,68},{-80,90}},
                lineColor={95,95,95},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Line(points={{-80,68},{-80,-80}}, color={95,95,95}),
              Line(
                points={{-80,0},{80,0}},
                color={0,0,255},
                thickness=0.5),
              Line(points={{-90,-70},{82,-70}}, color={95,95,95}),
              Polygon(
                points={{90,-70},{68,-64},{68,-76},{90,-70}},
                lineColor={95,95,95},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-83,92},{-30,74}},
                lineColor={0,0,0},
                textString="y"),
              Text(
                extent={{70,-80},{94,-100}},
                lineColor={0,0,0},
                textString="time"),
              Text(
                extent={{-101,8},{-81,-12}},
                lineColor={0,0,0},
                textString="k")}),
          Documentation(info="<html>
<p>
The Real output y is a constant signal:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Blocks/Sources/Constant.png\">
</p>
</html>"));
          end Constant;

      model CombiTimeTable
      "Table look-up with respect to time and linear/perodic extrapolation methods (data from matrix/file)"

        parameter Boolean tableOnFile=false
        "= true, if table is defined on file or in function usertab"
          annotation(Dialog(group="table data definition"));
        parameter Real table[:, :] = fill(0.0,0,2)
        "Table matrix (time = first column; e.g., table=[0,2])"
             annotation(Dialog(group="table data definition", enable = not tableOnFile));
        parameter String tableName="NoName"
        "Table name on file or in function usertab (see docu)"
             annotation(Dialog(group="table data definition", enable = tableOnFile));
        parameter String fileName="NoName" "File where matrix is stored"
             annotation(Dialog(group="table data definition", enable = tableOnFile,
                               __Dymola_loadSelector(filter="Text files (*.txt);;Matlab files (*.mat)",
                               caption="Open file in which table is present")));
        parameter Integer columns[:]=2:size(table, 2)
        "Columns of table to be interpolated"
        annotation(Dialog(group="table data interpretation"));
        parameter Modelica.Blocks.Types.Smoothness smoothness=Modelica.Blocks.Types.Smoothness.LinearSegments
        "Smoothness of table interpolation"
        annotation(Dialog(group="table data interpretation"));
        parameter Modelica.Blocks.Types.Extrapolation extrapolation=Modelica.Blocks.Types.Extrapolation.LastTwoPoints
        "Extrapolation of data outside the definition range"
        annotation(Dialog(group="table data interpretation"));
        parameter Real offset[:]={0} "Offsets of output signals"
        annotation(Dialog(group="table data interpretation"));
        parameter Modelica.SIunits.Time startTime=0
        "Output = offset for time < startTime"
        annotation(Dialog(group="table data interpretation"));
        extends Modelica.Blocks.Interfaces.MO(final nout=max([size(columns, 1); size(offset, 1)]));
        final parameter Real t_min(fixed=false)
        "Minimum abscissa value defined in table";
        final parameter Real t_max(fixed=false)
        "Maximum abscissa value defined in table";

    protected
        final parameter Real p_offset[nout]=(if size(offset, 1) == 1 then ones(nout)
             *offset[1] else offset);

        Integer tableID;

        function tableTimeInit
        "Initialize 1-dim. table where first column is time (for details see: Modelica/Resources/C-Sources/ModelicaTables.h)"
          input String tableName;
          input String fileName;
          input Real table[ :, :];
          input Real startTime;
          input Modelica.Blocks.Types.Smoothness smoothness;
          input Modelica.Blocks.Types.Extrapolation extrapolation;
          output Integer tableID;
        external "C" tableID = ModelicaTables_CombiTimeTable_init(
                       tableName, fileName, table, size(table, 1), size(table, 2),
                       startTime, smoothness, extrapolation);
          annotation(Library="ModelicaExternalC");
        end tableTimeInit;

        function tableTimeIpo
        "Interpolate 1-dim. table where first column is time (for details see: Modelica/Resources/C-Sources/ModelicaTables.h)"
          input Integer tableID;
          input Integer icol;
          input Real timeIn;
          output Real value;
        external "C" value =
                           ModelicaTables_CombiTimeTable_interpolate(tableID, icol, timeIn);
          annotation(Library="ModelicaExternalC");
        end tableTimeIpo;

        function tableTimeTmin
        "Return minimum time value of 1-dim. table where first column is time (for details see: Modelica/Resources/C-Sources/ModelicaTables.h)"
          input Integer tableID;
          output Real Tmin "minimum time value in table";
        external "C" Tmin =
                          ModelicaTables_CombiTimeTable_minimumTime(tableID);
          annotation(Library="ModelicaExternalC");
        end tableTimeTmin;

        function tableTimeTmax
        "Return maximum time value of 1-dim. table where first column is time (for details see: Modelica/Resources/C-Sources/ModelicaTables.h)"
          input Integer tableID;
          output Real Tmax "maximum time value in table";
        external "C" Tmax =
                          ModelicaTables_CombiTimeTable_maximumTime(tableID);
          annotation(Library="ModelicaExternalC");
        end tableTimeTmax;

      equation
        if tableOnFile then
          assert(tableName<>"NoName", "tableOnFile = true and no table name given");
        end if;
        if not tableOnFile then
          assert(size(table,1) > 0 and size(table,2) > 0, "tableOnFile = false and parameter table is an empty matrix");
        end if;
        for i in 1:nout loop
          y[i] = p_offset[i] + tableTimeIpo(tableID, columns[i], time);
        end for;
        when initial() then
          tableID=tableTimeInit((if not tableOnFile then "NoName" else tableName),
                                (if not tableOnFile then "NoName" else fileName), table,
                                startTime, smoothness, extrapolation);
        end when;
      initial equation
          t_min=tableTimeTmin(tableID);
          t_max=tableTimeTmax(tableID);
        annotation (
          Documentation(info="<HTML>
<p>
This block generates an output signal y[:] by <b>linear interpolation</b> in
a table. The time points and function values are stored in a matrix
<b>table[i,j]</b>, where the first column table[:,1] contains the
time points and the other columns contain the data to be interpolated.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Blocks/Sources/CombiTimeTable.png\">
</p>

<p>
Via parameter <b>columns</b> it can be defined which columns of the
table are interpolated. If, e.g., columns={2,4}, it is assumed that
2 output signals are present and that the first output is computed
by interpolation of column 2 and the second output is computed
by interpolation of column 4 of the table matrix.
The table interpolation has the following properties:
</p>
<ul>
<li>The time points need to be <b>monotonically increasing</b>. </li>
<li><b>Discontinuities</b> are allowed, by providing the same
    time point twice in the table. </li>
<li>Values <b>outside</b> of the table range, are computed by
    extrapolation according to the setting of parameter
    <b>extrapolation</b>:
<pre>
  extrapolation = 0: hold the first or last value of the table,
                     if outside of the range.
                = 1: extrapolate through the last or first two
                     points of the table.
                = 2: periodically repeat the table data
                     (periodical function).
</pre></li>
<li>Via parameter <b>smoothness</b> it is defined how the data is interpolated:
<pre>
  smoothness = 0: linear interpolation
             = 1: smooth interpolation with Akima Splines such
                  that der(y) is continuous.
</pre></li>
<li>If the table has only <b>one row</b>, no interpolation is performed and
    the table values of this row are just returned.</li>
<li>Via parameters <b>startTime</b> and <b>offset</b> the curve defined
    by the table can be shifted both in time and in the ordinate value.
    The time instants stored in the table are therefore <b>relative</b>
    to <b>startTime</b>.
    If time &lt; startTime, no interpolation is performed and the offset
    is used as ordinate value for all outputs.
<li>The table is implemented in a numerically sound way by
    generating <b>time events</b> at interval boundaries,
    in order to not integrate over a discontinuous or not differentiable
    points.
<li>For special applications it is sometimes needed to know the minimum
    and maximum time instant defined in the table as a parameter. For this
    reason parameters <b>t_min</b> and <b>t_max</b> are provided and can be access from
    the outside of the table object.
</li>
</ul>
<p>
Example:
</p>
<pre>
   table = [0  0
            1  0
            1  1
            2  4
            3  9
            4 16]; extrapolation = 1 (default)
If, e.g., time = 1.0, the output y =  0.0 (before event), 1.0 (after event)
    e.g., time = 1.5, the output y =  2.5,
    e.g., time = 2.0, the output y =  4.0,
    e.g., time = 5.0, the output y = 23.0 (i.e., extrapolation via last 2 points).
</pre>
<p>
The table matrix can be defined in the following ways:
</p>
<ol>
<li> Explicitly supplied as <b>parameter matrix</b> \"table\",
     and the other parameters have the following values:
<pre>
   tableName is \"NoName\" or has only blanks,
   fileName  is \"NoName\" or has only blanks.
</pre></li>
<li> <b>Read</b> from a <b>file</b> \"fileName\" where the matrix is stored as
      \"tableName\". Both ASCII and binary file format is possible.
      (the ASCII format is described below).
      It is most convenient to generate the binary file from Matlab
      (Matlab 4 storage format), e.g., by command
<pre>
   save tables.mat tab1 tab2 tab3 -V4
</pre>
      when the three tables tab1, tab2, tab3 should be
      used from the model.</li>
<li>  Statically stored in function \"usertab\" in file \"usertab.c\".
      The matrix is identified by \"tableName\". Parameter
      fileName = \"NoName\" or has only blanks.</li>
</ol>
<p>
Table definition methods (1) and (3) do <b>not</b> allocate dynamic memory,
and do not access files, whereas method (2) does. Therefore (1) and (3)
are suited for hardware-in-the-loop simulation (e.g., with dSpace hardware).
When the constant \"NO_FILE\" is defined in \"usertab.c\", all parts of the
source code of method (2) are removed by the C-preprocessor, such that
no dynamic memory allocation and no access to files takes place.
</p>
<p>
If tables are read from an ASCII-file, the file need to have the
following structure (\"-----\" is not part of the file content):
</p>
<pre>
-----------------------------------------------------
#1
double tab1(6,2)   # comment line
  0   0
  1   0
  1   1
  2   4
  3   9
  4  16
double tab2(6,2)   # another comment line
  0   0
  2   0
  2   2
  4   8
  6  18
  8  32
-----------------------------------------------------
</pre>
<p>
Note, that the first two characters in the file need to be
\"#1\". Afterwards, the corresponding matrix has to be declared
with type, name and actual dimensions. Finally, in successive
rows of the file, the elements of the matrix have to be given.
Several matrices may be defined one after another.
</p>

</HTML>
",     revisions="<html>
<p><b>Release Notes:</b></p>
<ul>
<li><i>March 31, 2001</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Used CombiTableTime as a basis and added the
       arguments <b>extrapolation, columns, startTime</b>.
       This allows periodic function definitions. </li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={
              Polygon(
                points={{-80,90},{-88,68},{-72,68},{-80,90}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-80,68},{-80,-80}}, color={192,192,192}),
              Line(points={{-90,-70},{82,-70}}, color={192,192,192}),
              Polygon(
                points={{90,-70},{68,-62},{68,-78},{90,-70}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-48,70},{2,-50}},
                lineColor={255,255,255},
                fillColor={255,255,0},
                fillPattern=FillPattern.Solid),
              Line(points={{-48,-50},{-48,70},{52,70},{52,-50},{-48,-50},{-48,-20},
                    {52,-20},{52,10},{-48,10},{-48,40},{52,40},{52,70},{2,70},{2,-51}},
                  color={0,0,0})}),
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={
              Polygon(
                points={{-80,90},{-88,68},{-72,68},{-80,90}},
                lineColor={95,95,95},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Line(points={{-80,68},{-80,-80}}, color={95,95,95}),
              Line(points={{-90,-70},{82,-70}}, color={95,95,95}),
              Polygon(
                points={{90,-70},{68,-62},{68,-78},{90,-70}},
                lineColor={95,95,95},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-20,90},{20,-30}},
                lineColor={255,255,255},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-20,-30},{-20,90},{80,90},{80,-30},{-20,-30},{-20,0},{
                    80,0},{80,30},{-20,30},{-20,60},{80,60},{80,90},{20,90},{20,-30}},
                  color={0,0,0}),
              Text(
                extent={{-71,-42},{-32,-54}},
                lineColor={0,0,0},
                textString="offset"),
              Polygon(
                points={{-31,-30},{-33,-40},{-28,-40},{-31,-30}},
                lineColor={95,95,95},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-31,-70},{-34,-60},{-29,-60},{-31,-70},{-31,-70}},
                lineColor={95,95,95},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Line(points={{-31,-31},{-31,-70}}, color={95,95,95}),
              Line(points={{-20,-30},{-20,-70}}, color={95,95,95}),
              Text(
                extent={{-42,-74},{6,-84}},
                lineColor={0,0,0},
                textString="startTime"),
              Line(points={{-20,-30},{-80,-30}}, color={95,95,95}),
              Text(
                extent={{-73,93},{-44,74}},
                lineColor={0,0,0},
                textString="y"),
              Text(
                extent={{66,-81},{92,-92}},
                lineColor={0,0,0},
                textString="time"),
              Text(
                extent={{-19,83},{20,68}},
                lineColor={0,0,0},
                textString="time"),
              Text(
                extent={{21,82},{50,68}},
                lineColor={0,0,0},
                textString="y[1]"),
              Line(points={{50,90},{50,-30}}, color={0,0,0}),
              Line(points={{80,0},{100,0}}, color={0,0,255}),
              Text(
                extent={{34,-30},{71,-42}},
                textString="columns",
                lineColor={0,0,255}),
              Text(
                extent={{51,82},{80,68}},
                lineColor={0,0,0},
                textString="y[2]")}));
      end CombiTimeTable;
          annotation (
            Documentation(info="<HTML>
<p>
This package contains <b>source</b> components, i.e., blocks which
have only output signals. These blocks are used as signal generators
for Real, Integer and Boolean signals.
</p>

<p>
All Real source signals (with the exception of the Constant source)
have at least the following two parameters:
</p>

<table border=1 cellspacing=0 cellpadding=2>
  <tr><td valign=\"top\"><b>offset</b></td>
      <td valign=\"top\">Value which is added to the signal</td>
  </tr>
  <tr><td valign=\"top\"><b>startTime</b></td>
      <td valign=\"top\">Start time of signal. For time &lt; startTime,
                the output y is set to offset.</td>
  </tr>
</table>

<p>
The <b>offset</b> parameter is especially useful in order to shift
the corresponding source, such that at initial time the system
is stationary. To determine the corresponding value of offset,
usually requires a trimming calculation.
</p>
</HTML>
",     revisions="<html>
<ul>
<li><i>October 21, 2002</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
       and <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
       Integer sources added. Step, TimeTable and BooleanStep slightly changed.</li>
<li><i>Nov. 8, 1999</i>
       by <a href=\"mailto:clauss@eas.iis.fhg.de\">Christoph Clau&szlig;</a>,
       <a href=\"mailto:Andre.Schneider@eas.iis.fraunhofer.de\">Andre.Schneider@eas.iis.fraunhofer.de</a>,
       <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       New sources: Exponentials, TimeTable. Trapezoid slightly enhanced
       (nperiod=-1 is an infinite number of periods).</li>
<li><i>Oct. 31, 1999</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       <a href=\"mailto:clauss@eas.iis.fhg.de\">Christoph Clau&szlig;</a>,
       <a href=\"mailto:Andre.Schneider@eas.iis.fraunhofer.de\">Andre.Schneider@eas.iis.fraunhofer.de</a>,
       All sources vectorized. New sources: ExpSine, Trapezoid,
       BooleanConstant, BooleanStep, BooleanPulse, SampleTrigger.
       Improved documentation, especially detailed description of
       signals in diagram layer.</li>
<li><i>June 29, 1999</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Realized a first version, based on an existing Dymola library
       of Dieter Moormann and Hilding Elmqvist.</li>
</ul>
</html>"));
    end Sources;

    package Tables
    "Library of blocks to interpolate in one and two-dimensional tables"
      extends Modelica.Icons.Package;

      model CombiTable1Ds
      "Table look-up in one dimension (matrix/file) with one input and n outputs"

        import Modelica.Blocks.Types;
        parameter Boolean tableOnFile=false
        "true, if table is defined on file or in function usertab"
          annotation(Dialog(group="table data definition"));
        parameter Real table[:, :]=fill(0.0,0,2)
        "table matrix (grid = first column; e.g., table=[0,2])"
             annotation(Dialog(group="table data definition", enable = not tableOnFile));
        parameter String tableName="NoName"
        "table name on file or in function usertab (see docu)"
             annotation(Dialog(group="table data definition", enable = tableOnFile));
        parameter String fileName="NoName" "file where matrix is stored"
             annotation(Dialog(group="table data definition", enable = tableOnFile,
                               __Dymola_loadSelector(filter="Text files (*.txt);;Matlab files (*.mat)",
                               caption="Open file in which table is present")));
        parameter Integer columns[:]=2:size(table, 2)
        "columns of table to be interpolated"
        annotation(Dialog(group="table data interpretation"));
        parameter Modelica.Blocks.Types.Smoothness smoothness=Types.Smoothness.LinearSegments
        "smoothness of table interpolation"
        annotation(Dialog(group="table data interpretation"));
        extends Modelica.Blocks.Interfaces.SIMO(final nout=size(columns, 1));

    protected
        Integer tableID;

        function tableInit
        "Initialize 1-dim. table defined by matrix (for details see: Modelica/Resources/C-Sources/ModelicaTables.h)"
          input String tableName;
          input String fileName;
          input Real table[ :, :];
          input Modelica.Blocks.Types.Smoothness smoothness;
          output Integer tableID;
        external "C" tableID = ModelicaTables_CombiTable1D_init(
                       tableName, fileName, table, size(table, 1), size(table, 2),
                       smoothness);
          annotation(Library="ModelicaExternalC");
        end tableInit;

        function tableIpo
        "Interpolate 1-dim. table defined by matrix (for details see: Modelica/Resources/C-Sources/ModelicaTables.h)"
          input Integer tableID;
          input Integer icol;
          input Real u;
          output Real value;
        external "C" value =
                           ModelicaTables_CombiTable1D_interpolate(tableID, icol, u);
          annotation(Library="ModelicaExternalC");
        end tableIpo;

      equation
        if tableOnFile then
          assert(tableName<>"NoName", "tableOnFile = true and no table name given");
        end if;
        if not tableOnFile then
          assert(size(table,1) > 0 and size(table,2) > 0, "tableOnFile = false and parameter table is an empty matrix");
        end if;

        for i in 1:nout loop
          y[i] = if not tableOnFile and size(table,1)==1 then
                   table[1, columns[i]] else tableIpo(tableID, columns[i], u);
        end for;
        when initial() then
          tableID=tableInit(if tableOnFile then tableName else "NoName",
                            if tableOnFile then fileName else "NoName", table, smoothness);
        end when;
        annotation (
          Documentation(info="<html>
<p>
<b>Linear interpolation</b> in <b>one</b> dimension of a <b>table</b>.
Via parameter <b>columns</b> it can be defined how many columns of the
table are interpolated. If, e.g., icol={2,4}, it is assumed that one input
and 2 output signals are present and that the first output interpolates
via column 2 and the second output interpolates via column 4 of the
table matrix.
</p>
<p>
The grid points and function values are stored in a matrix \"table[i,j]\",
where the first column \"table[:,1]\" contains the grid points and the
other columns contain the data to be interpolated. Example:
</p>
<pre>
   table = [0,  0;
            1,  1;
            2,  4;
            4, 16]
   If, e.g., the input u = 1.0, the output y =  1.0,
       e.g., the input u = 1.5, the output y =  2.5,
       e.g., the input u = 2.0, the output y =  4.0,
       e.g., the input u =-1.0, the output y = -1.0 (i.e., extrapolation).
</pre>
<ul>
<li> The interpolation is <b>efficient</b>, because a search for a new interpolation
     starts at the interval used in the last call.</li>
<li> If the table has only <b>one row</b>, the table value is returned,
     independent of the value of the input signal.</li>
<li> If the input signal <b>u</b> is <b>outside</b> of the defined <b>interval</b>, i.e.,
     u &gt; table[size(table,1),1] or u &lt; table[1,1], the corresponding
     value is also determined by linear
     interpolation through the last or first two points of the table.</li>
<li> The grid values (first column) have to be <b>strict</b>
     monotonically increasing.</li>
</ul>
<p>
The table matrix can be defined in the following ways:
</p>
<ol>
<li> Explicitly supplied as <b>parameter matrix</b> \"table\",
     and the other parameters have the following values:
<pre>
   tableName is \"NoName\" or has only blanks,
   fileName  is \"NoName\" or has only blanks.
</pre></li>
<li> <b>Read</b> from a <b>file</b> \"fileName\" where the matrix is stored as
      \"tableName\". Both ASCII and binary file format is possible.
      (the ASCII format is described below).
      It is most convenient to generate the binary file from Matlab
      (Matlab 4 storage format), e.g., by command
<pre>
   save tables.mat tab1 tab2 tab3 -V4
</pre>
      when the three tables tab1, tab2, tab3 should be
      used from the model.</li>
<li>  Statically stored in function \"usertab\" in file \"usertab.c\".
      The matrix is identified by \"tableName\". Parameter
      fileName = \"NoName\" or has only blanks.</li>
</ol>
<p>
Table definition methods (1) and (3) do <b>not</b> allocate dynamic memory,
and do not access files, whereas method (2) does. Therefore (1) and (3)
are suited for hardware-in-the-loop simulation (e.g., with dSpace hardware).
When the constant \"NO_FILE\" is defined, all parts of the
source code of method (2) are removed by the C-preprocessor, such that
no dynamic memory allocation and no access to files takes place.
</p>
<p>
If tables are read from an ASCII-file, the file need to have the
following structure (\"-----\" is not part of the file content):
</p>
<pre>
-----------------------------------------------------
#1
double tab1(5,2)   # comment line
  0   0
  1   1
  2   4
  3   9
  4  16
double tab2(5,2)   # another comment line
  0   0
  2   2
  4   8
  6  18
  8  32
-----------------------------------------------------
</pre>
<p>
Note, that the first two characters in the file need to be
\"#1\". Afterwards, the corresponding matrix has to be declared
with type, name and actual dimensions. Finally, in successive
rows of the file, the elements of the matrix have to be given.
Several matrices may be defined one after another.
</p>
</HTML>
"),       Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={
              Line(points={{-60,40},{-60,-40},{60,-40},{60,40},{30,40},{30,-40},{-30,
                    -40},{-30,40},{-60,40},{-60,20},{60,20},{60,0},{-60,0},{-60,-20},
                    {60,-20},{60,-40},{-60,-40},{-60,40},{60,40},{60,-40}}, color={
                    0,0,0}),
              Line(points={{0,40},{0,-40}}, color={0,0,0}),
              Rectangle(
                extent={{-60,40},{-30,20}},
                lineColor={0,0,0},
                fillColor={255,255,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-60,20},{-30,0}},
                lineColor={0,0,0},
                fillColor={255,255,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-60,0},{-30,-20}},
                lineColor={0,0,0},
                fillColor={255,255,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-60,-20},{-30,-40}},
                lineColor={0,0,0},
                fillColor={255,255,0},
                fillPattern=FillPattern.Solid)}),
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={
              Rectangle(
                extent={{-60,60},{60,-60}},
                fillColor={235,235,235},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,255}),
              Line(points={{-100,0},{-58,0}}, color={0,0,255}),
              Line(points={{60,0},{100,0}}, color={0,0,255}),
              Text(
                extent={{-100,100},{100,64}},
                textString="1 dimensional linear table interpolation",
                lineColor={0,0,255}),
              Line(points={{-54,40},{-54,-40},{54,-40},{54,40},{28,40},{28,-40},{-28,
                    -40},{-28,40},{-54,40},{-54,20},{54,20},{54,0},{-54,0},{-54,-20},
                    {54,-20},{54,-40},{-54,-40},{-54,40},{54,40},{54,-40}}, color={
                    0,0,0}),
              Line(points={{0,40},{0,-40}}, color={0,0,0}),
              Rectangle(
                extent={{-54,40},{-28,20}},
                lineColor={0,0,0},
                fillColor={255,255,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-54,20},{-28,0}},
                lineColor={0,0,0},
                fillColor={255,255,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-54,0},{-28,-20}},
                lineColor={0,0,0},
                fillColor={255,255,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-54,-20},{-28,-40}},
                lineColor={0,0,0},
                fillColor={255,255,0},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-52,56},{-34,44}},
                textString="u",
                lineColor={0,0,255}),
              Text(
                extent={{-22,54},{2,42}},
                textString="y[1]",
                lineColor={0,0,255}),
              Text(
                extent={{4,54},{28,42}},
                textString="y[2]",
                lineColor={0,0,255}),
              Text(
                extent={{0,-40},{32,-54}},
                textString="columns",
                lineColor={0,0,255})}));
      end CombiTable1Ds;
      annotation (Documentation(info="<html>
<p>
This package contains blocks for one- and two-dimensional
interpolation in tables.
</p>
</html>"));
    end Tables;

    package Types
    "Library of constants and types with choices, especially to build menus"
      extends Modelica.Icons.Package;

      type Smoothness = enumeration(
        LinearSegments "Table points are linearly interpolated",
        ContinuousDerivative
          "Table points are interpolated such that the first derivative is continuous")
      "Enumeration defining the smoothness of table interpolation";

      type Extrapolation = enumeration(
        HoldLastPoint "Hold the last table point outside of the table scope",
        LastTwoPoints
          "Extrapolate linearly through the last two table points outside of the table scope",

        Periodic "Repeat the table scope periodically")
      "Enumeration defining the extrapolation of time table interpolation";

      type Init = enumeration(
        NoInit
          "No initialization (start values are used as guess values with fixed=false)",

        SteadyState
          "Steady state initialization (derivatives of states are zero)",
        InitialState "Initialization with initial states",
        InitialOutput
          "Initialization with initial outputs (and steady state of the states if possibles)")
      "Enumeration defining initialization of a block"
          annotation (Evaluate=true);

      type InitPID = enumeration(
        NoInit
          "No initialization (start values are used as guess values with fixed=false)",

        SteadyState
          "Steady state initialization (derivatives of states are zero)",
        InitialState "Initialization with initial states",
        InitialOutput
          "Initialization with initial outputs (and steady state of the states if possibles)",

        DoNotUse_InitialIntegratorState
          "Don't use, only for backward compatibility (initialize only integrator state)")
      "Enumeration defining initialization of PID and LimPID blocks"
        annotation (Documentation(info="<html>
<p>
This initialization type is identical to Types.Init and has just one
additional option <b>DoNotUse_InitialIntegratorState</b>. This option
is introduced in order that the default initialization for the
Continuous.PID and Continuous.LimPID blocks are backward
compatible. In Modelica 2.2, the integrators have been initialized
with their given states where as the D-part has not been initialized.
The option \"DoNotUse_InitialIntegratorState\" leads to this
initialization definition.
</p>

</html>"),       Evaluate=true);

      type SimpleController = enumeration(
        P "P controller",
        PI "PI controller",
        PD "PD controller",
        PID "PID controller")
      "Enumeration defining P, PI, PD, or PID simple controller type"
          annotation (Evaluate=true);
      annotation ( Documentation(info="<HTML>
<p>
In this package <b>types</b> and <b>constants</b> are defined that are used
in library Modelica.Blocks. The types have additional annotation choices
definitions that define the menus to be built up in the graphical
user interface when the type is used as parameter in a declaration.
</p>
</HTML>"));
    end Types;
  annotation (
    Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,100}}),
        graphics={
        Rectangle(extent={{-32,-6},{16,-35}}, lineColor={0,0,0}),
        Rectangle(extent={{-32,-56},{16,-85}}, lineColor={0,0,0}),
        Line(points={{16,-20},{49,-20},{49,-71},{16,-71}}, color={0,0,0}),
        Line(points={{-32,-72},{-64,-72},{-64,-21},{-32,-21}}, color={0,0,0}),
        Polygon(
          points={{16,-71},{29,-67},{29,-74},{16,-71}},
          lineColor={0,0,0},
          fillColor={0,0,0},
          fillPattern=FillPattern.Solid),
        Polygon(
          points={{-32,-21},{-46,-17},{-46,-25},{-32,-21}},
          lineColor={0,0,0},
          fillColor={0,0,0},
          fillPattern=FillPattern.Solid)}),
                            Documentation(info="<html>
<p>
This library contains input/output blocks to build up block diagrams.
</p>

<dl>
<dt><b>Main Author:</b>
<dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a><br>
    Deutsches Zentrum f&uuml;r Luft und Raumfahrt e. V. (DLR)<br>
    Oberpfaffenhofen<br>
    Postfach 1116<br>
    D-82230 Wessling<br>
    email: <A HREF=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</A><br>
</dl>
<p>
Copyright &copy; 1998-2010, Modelica Association and DLR.
</p>
<p>
<i>This Modelica package is <u>free</u> software and the use is completely at <u>your own risk</u>; it can be redistributed and/or modified under the terms of the Modelica License 2. For license conditions (including the disclaimer of warranty) see <a href=\"modelica://Modelica.UsersGuide.ModelicaLicense2\">Modelica.UsersGuide.ModelicaLicense2</a> or visit <a href=\"http://www.modelica.org/licenses/ModelicaLicense2\"> http://www.modelica.org/licenses/ModelicaLicense2</a>.</i>
</p>
</HTML>
",   revisions="<html>
<ul>
<li><i>June 23, 2004</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Introduced new block connectors and adapated all blocks to the new connectors.
       Included subpackages Continuous, Discrete, Logical, Nonlinear from
       package ModelicaAdditions.Blocks.
       Included subpackage ModelicaAdditions.Table in Modelica.Blocks.Sources
       and in the new package Modelica.Blocks.Tables.
       Added new blocks to Blocks.Sources and Blocks.Logical.
       </li>
<li><i>October 21, 2002</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
       and <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
       New subpackage Examples, additional components.
       </li>
<li><i>June 20, 2000</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a> and
       Michael Tiller:<br>
       Introduced a replaceable signal type into
       Blocks.Interfaces.RealInput/RealOutput:
<pre>
   replaceable type SignalType = Real
</pre>
       in order that the type of the signal of an input/output block
       can be changed to a physical type, for example:
<pre>
   Sine sin1(outPort(redeclare type SignalType=Modelica.SIunits.Torque))
</pre>
      </li>
<li><i>Sept. 18, 1999</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Renamed to Blocks. New subpackages Math, Nonlinear.
       Additional components in subpackages Interfaces, Continuous
       and Sources. </li>
<li><i>June 30, 1999</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Realized a first version, based on an existing Dymola library
       of Dieter Moormann and Hilding Elmqvist.</li>
</ul>
</html>"));
  end Blocks;

  package StateGraph
  "Library of hierarchical state machine components to model discrete event and reactive systems"
  extends Modelica.Icons.Package;

  package Interfaces "Connectors and partial models"
    extends Modelica.Icons.InterfacesPackage;

    connector Step_in "Input port of a step"
      output Boolean occupied "true, if step is active" annotation (HideResult=true);
      input Boolean set "true, if transition fires and step is activated"
        annotation (HideResult=true);
      annotation (
     Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics={Polygon(
                points={{-100,100},{100,0},{-100,-100},{-100,100}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid)}),
                                              Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics={Polygon(
                points={{0,50},{100,0},{0,-50},{0,50}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid), Text(
                extent={{-141,100},{100,60}},
                lineColor={0,0,0},
                textString="%name")}),
          Documentation(info="<html>

</html>"));
    end Step_in;

    connector Step_out "Output port of a step"
      output Boolean available "true, if step is active" annotation (HideResult=true);

      input Boolean reset "true, if transition fires and step is deactivated"
        annotation (HideResult=true);

      annotation (Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics={Rectangle(
                extent={{-100,100},{100,-100}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid)}),
                                Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics={Rectangle(
                extent={{-100,50},{0,-50}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid), Text(
                extent={{-100,100},{186,58}},
                lineColor={0,0,0},
                textString="%name")}),
          Documentation(info="<html>

</html>"));
    end Step_out;

    connector Transition_in "Input port of a transition"
      input Boolean available
      "true, if step connected to the transition input is active"
        annotation (HideResult=true);
      output Boolean reset
      "true, if transition fires and the step connected to the transition input is deactivated"
        annotation (HideResult=true);

      annotation (Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics={Polygon(
                points={{-100,100},{100,0},{-100,-100},{-100,100}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid)}),
                                              Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics={Polygon(
                points={{0,50},{100,0},{0,-50},{0,50}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid), Text(
                extent={{-141,100},{100,60}},
                lineColor={0,0,0},
                textString="%name")}),
          Documentation(info="<html>

</html>"));
    end Transition_in;

    connector Transition_out "Output port of a transition"
      input Boolean occupied
      "true, if step connected to the transition output is active"
        annotation (HideResult=true);
      output Boolean set
      "true, if transition fires and step connected to the transition output becomes active"
        annotation (HideResult=true);

      annotation (Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics={Rectangle(
                extent={{-100,100},{100,-100}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid)}),
                                Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics={Text(
                extent={{-100,100},{146,60}},
                lineColor={0,0,0},
                textString="%name"), Rectangle(
                extent={{-100,50},{0,-50}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid)}),
          Documentation(info="<html>

</html>"));
    end Transition_out;

    connector CompositeStepStatePort_in
    "Communication port between a CompositeStep and the ordinary steps within the CompositeStep (suspend/resume are inputs)"

      input Boolean suspend
      "= true, if suspend transition of CompositeStep fires";
      input Boolean resume
      "= true, if resume transition of CompositeStep fires";
      Real activeStepsDummy
      "Dummy variable in order that connector fulfills restriction of connector"
                                                                                  annotation(HideResult=true);
      flow Real activeSteps "Number of active steps in the CompositeStep";
      annotation(Documentation(info="<html>

</html>"));
    end CompositeStepStatePort_in;

    connector CompositeStepStatePort_out
    "Communication port between a CompositeStep and the ordinary steps within the CompositeStep (suspend/resume are outputs)"

      output Boolean suspend
      "= true, if suspend transition of CompositeStep fires";
      output Boolean resume
      "= true, if resume transition of CompositeStep fires";
      Real activeStepsDummy
      "Dummy variable in order that connector fulfills restriction of connector"
                                                                                   annotation(HideResult=true);
      flow Real activeSteps "Number of active steps in the CompositeStep";
      annotation (Documentation(info="<html>

</html>"));
    end CompositeStepStatePort_out;

    partial block PartialStep
    "Partial step with one input and one output transition port"

      parameter Integer nIn(min=0) = 1 "Number of input connections";
      parameter Integer nOut(min=0) = 1 "Number of output connections";

      /* localActive is introduced since component 'Step' has Boolean variable 'active'
     and component 'StepWithSignal' has connector instance 'active' defined
     and both components inherit from PartialStep
  */
      output Boolean localActive
      "= true if step is active, otherwise the step is not active"
        annotation (HideResult=true);
      Interfaces.Step_in inPort[nIn] "Vector of step input connectors"
        annotation (Placement(transformation(extent={{-120,10},{-100,-10}},
                rotation=0)));
      Interfaces.Step_out outPort[nOut] "Vector of step output connectors"
        annotation (Placement(transformation(extent={{100,5},{110,-5}}, rotation=
                  0)));
  protected
      outer Interfaces.CompositeStepState stateGraphRoot;
      model OuterStatePort
        CompositeStepStatePort_in subgraphStatePort;
      end OuterStatePort;
      OuterStatePort outerStatePort;

      Boolean newActive "Value of active in the next iteration"
        annotation (HideResult=true);
      Boolean oldActive "Value of active when CompositeStep was aborted";
    initial equation
      pre(newActive) = pre(localActive);
      pre(oldActive) = pre(localActive);
    equation
      connect(outerStatePort.subgraphStatePort, stateGraphRoot.subgraphStatePort);

      // Check that connections to the connector are correct
      for i in 1:nIn loop

      assert(cardinality(inPort[i]) <= 1,
             "Connector is connected to more than one transition (this is not allowed)");
      end for;

      for i in 1:nOut loop

      assert(cardinality(outPort[i]) <= 1,
             "Connector is connected to more than one transition (this is not allowed)");
      end for;

      // set active state
      localActive = pre(newActive);
      newActive = if outerStatePort.subgraphStatePort.resume then
                       oldActive else
                       ( StateGraph.Temporary.anyTrue(inPort.set) or
                            localActive
                         and not StateGraph.Temporary.anyTrue(outPort.reset))
                       and not outerStatePort.subgraphStatePort.suspend;

      // Remember state for suspend action
      when outerStatePort.subgraphStatePort.suspend then
        oldActive = localActive;
      end when;

      // Report state to CompositeStep
      outerStatePort.subgraphStatePort.activeSteps = if localActive then 1.0 else 0.0;

      // Report state to input and output transitions
      for i in 1:nIn loop
        inPort[i].occupied = if i == 1 then localActive else
                                            inPort[i-1].occupied or
                                            inPort[i-1].set;
      end for;

      for i in 1:nOut loop
         outPort[i].available = if i == 1 then localActive else
                                               outPort[i-1].available and not
                                               outPort[i-1].reset;
      end for;

      // Default setting, if an inPort or an outPort is not connected
      for i in 1:nIn loop
        if cardinality(inPort[i]) == 0 then
          inPort[i].set = false;
        end if;
      end for;

      for i in 1:nOut loop
        if cardinality(outPort[i]) == 0 then
          outPort[i].reset = false;
        end if;
      end for;
      annotation(Documentation(info="<html>

</html>"),       Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}),
                         graphics),
        Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}),
             graphics),
        Coordsys(grid=[1,1], component=[20,20]));
    end PartialStep;

    partial block PartialTransition
    "Partial transition with input and output connections"
      input Boolean localCondition "= true, if transition may fire"
        annotation (HideResult=true);
      parameter Boolean enableTimer=false "= true, if timer is enabled"
        annotation (Evaluate=true, Dialog(group="Timer"));
      parameter Modelica.SIunits.Time waitTime(min=0) = 0
      "Wait time before transition fires"
        annotation (Dialog(group="Timer", enable=enableTimer));
      output Modelica.SIunits.Time t
      "= actual waiting time (transition will fire when t > waitTime)";
      output Boolean enableFire "= true, if all firing conditions are true";
      output Boolean fire "= true, if transition fires" annotation (HideResult=true);

      StateGraph.Interfaces.Transition_in inPort
      "Vector of transition input connectors"
        annotation (Placement(transformation(extent={{-50,-10},{-30,10}},
                rotation=0)));
      StateGraph.Interfaces.Transition_out outPort
      "Vector of transition output connectors"
        annotation (Placement(transformation(extent={{10,-5},{20,5}}, rotation=0)));
  protected
      Modelica.SIunits.Time t_start
      "Time instant at which the transition would fire, if waitTime would be zero";
      Real t_dummy;
    initial equation

      pre(enableFire) = false;
    equation
      assert(cardinality(inPort) == 1,
        "Connector inPort is not connected to exactly one other connector");
      assert(cardinality(outPort) == 1,
        "Connector outPort is not connected to exactly one other connector");

      // Handling of Timer
      if enableTimer then
        when enableFire then
          t_start = time;
        end when;
        t_dummy = time - t_start;
        t = if enableFire then t_dummy else 0;
        fire = enableFire and time >= t_start + waitTime;
      else
        t_start = 0;
        t_dummy = 0;
        t = 0;
        fire = enableFire;
      end if;

      // Determine fire setting and report it to the connected step
      enableFire = localCondition and inPort.available and not outPort.occupied;
      inPort.reset = fire;
      outPort.set = fire;
      annotation(Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics),
        Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics),
        Documentation(info="<html>

</html>"));
    end PartialTransition;

    model CompositeStepState
    "Communication channel between CompositeSteps and steps in the CompositeStep"

      output Boolean suspend = false;
      output Boolean resume =  false;
      CompositeStepStatePort_out subgraphStatePort;

    /*
    missingInnerMessage="No \"stateGraphRoot\" component is defined on highest level
of the StateGraph. A stateGraphRoot component is automatically introduced.
In order to get rid of this message, drag StateGraph.StateGraphRoot into the
top level your model.");
*/
    equation
      suspend = subgraphStatePort.suspend;
      resume  = subgraphStatePort.resume;
      subgraphStatePort.activeStepsDummy = 0;
      annotation (
        defaultComponentName="stateGraphRoot",
        defaultComponentPrefixes="inner",
        missingInnerMessage="A \"stateGraphRoot\" component was automatically introduced.",
          Documentation(info="<html>

</html>"));
    end CompositeStepState;
      annotation (Documentation(info="<html>

</html>"));
  end Interfaces;

  block InitialStep
    "Initial step (= step that is active when simulation starts)"

    output Boolean active
      "= true if step is active, otherwise the step is not active";

    extends Interfaces.PartialStep;

  initial equation
    active = true;
  equation
    active = localActive;
    annotation (
      Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}},
            grid={1,1}), graphics={
            Text(
              extent={{-200,110},{200,150}},
              textString="%name",
              lineColor={0,0,255}),
            Rectangle(
              extent={{-100,100},{100,-100}},
              fillColor=DynamicSelect({255,255,255}, if active > 0.5 then {0,255,
                  0} else {255,255,255}),
              lineColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Rectangle(extent={{-80,80},{80,-80}}, lineColor={0,0,0})}),
      Diagram(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}},
            grid={1,1}), graphics={Rectangle(extent={{-100,100},{100,-100}},
                lineColor={0,0,0}), Rectangle(extent={{-80,80},{80,-80}},
                lineColor={0,0,0})}),
        Documentation(info="<html>

</html>"));
  end InitialStep;

  block StepWithSignal
    "Ordinary step (= step that is not active when simulation starts). Connector 'active' is true when the step is active"

    extends Interfaces.PartialStep;

    Modelica.Blocks.Interfaces.BooleanOutput active
      annotation (Placement(transformation(
            origin={0,-110},
            extent={{-10,-10},{10,10}},
            rotation=270)));
  initial equation
    active = false;
  equation
    active = localActive;
    annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                -100},{100,100}}), graphics={Rectangle(extent={{-100,100},{100,-100}},
                lineColor={0,0,0})}),
         Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                100}}), graphics={
            Text(
              extent={{-200,110},{200,150}},
              textString="%name",
              lineColor={0,0,255}),
            Rectangle(
              extent={{-100,100},{100,-100}},
              fillColor=DynamicSelect({255,255,255}, if active > 0.5 then {0,255,
                  0} else {255,255,255}),
              lineColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-92,-74},{94,-92}},
              lineColor={0,0,0},
              textString="active")}),
        Documentation(info="<html>

</html>"));
  end StepWithSignal;

  block Transition
    "Transition where the fire condition is set by a modification of variable condition"

    input Boolean condition=true
      "= true, if transition may fire (time varying expression)"
      annotation (Dialog(group="Fire condition"));

    extends Interfaces.PartialTransition(final localCondition=condition);

    annotation (
      Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}},
            grid={1,1}), graphics={
            Rectangle(
              extent={{-10,100},{10,-100}},
              fillColor=DynamicSelect({0,0,0}, if enableFire > 0.5 then {0,255,0} else
                        {0,0,0}),
              lineColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Line(points={{-30,0},{-10,0}}, color={0,0,0}),
            Text(
              extent={{200,110},{-200,150}},
              textString="%name",
              lineColor={0,0,255}),
            Text(
              extent={{20,20},{200,45}},
              lineColor=DynamicSelect({0,0,0}, if enableTimer < 0.5 then {255,255,
                  255} else {0,0,0}),
              textString="%waitTime"),
            Text(
              extent={{-200,-120},{200,-145}},
              lineColor=DynamicSelect({0,0,0}, if condition > 0.5 then {0,255,0} else
                        {0,0,0}),
              textString="%condition")}),
      Diagram(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}},
            grid={1,1}), graphics={Line(points={{-31,0},{-11,0}}, color={0,0,0}),
              Rectangle(
              extent={{-10,100},{10,-100}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid)}),
        Documentation(info="<html>

</html>"));

  end Transition;

  block TransitionWithSignal
    "Transition where the fire condition is set by a Boolean input signal"

    Modelica.Blocks.Interfaces.BooleanInput condition
      annotation (Placement(transformation(
            origin={0,-120},
            extent={{-20,-20},{20,20}},
            rotation=90)));

    extends Interfaces.PartialTransition(final localCondition=condition);

    annotation (
      Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}},
            grid={1,1}), graphics={
            Text(
              extent={{20,20},{200,45}},
              lineColor=DynamicSelect({0,0,0}, if enableTimer < 0.5 then {255,255,
                  255} else {0,0,0}),
              textString="%waitTime"),
            Rectangle(
              extent={{-10,100},{10,-100}},
              fillColor=DynamicSelect({0,0,0}, if enableFire > 0.5 then {0,255,0} else
                        {0,0,0}),
              lineColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Line(points={{-30,0},{-10,0}}, color={0,0,0}),
            Text(
              extent={{200,110},{-200,150}},
              textString="%name",
              lineColor={0,0,255}),
            Ellipse(
              extent={{7,-81},{-7,-95}},
              lineColor=DynamicSelect({0,0,0}, if condition > 0.5 then {0,255,0} else
                        {0,0,0}),
              fillColor=DynamicSelect({0,0,0}, if condition > 0.5 then {0,255,0} else
                        {0,0,0}),
              fillPattern=FillPattern.Solid)}),
      Diagram(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}},
            grid={1,1}), graphics={Line(points={{-31,0},{-11,0}}, color={0,0,0}),
              Rectangle(
              extent={{-10,100},{10,-100}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid)}),
        Documentation(info="<html>

</html>"));

  end TransitionWithSignal;

  model StateGraphRoot
    "Root of a StateGraph (has to be present on the highest level of a StateGraph)"

    extends StateGraph.Interfaces.CompositeStepState;
    output Integer activeSteps "Number of active steps within the stategraph";

  equation
    activeSteps = -integer(subgraphStatePort.activeSteps);
    annotation (
      defaultComponentName="stateGraphRoot",
      defaultComponentPrefixes="inner",
      Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                100}}), graphics={
            Text(
              extent={{-200,110},{200,150}},
              textString="%name",
              lineColor={0,0,255}),
            Rectangle(
              extent={{-100,100},{100,-100}},
              fillColor=DynamicSelect({255,255,255}, if active > 0.5 then {0,255,
                  0} else {255,255,255}),
              lineColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-92,78},{96,34}},
              lineColor={0,0,0},
              textString="root"),
            Rectangle(extent={{-82,-6},{-44,-40}}, lineColor={0,0,0}),
            Line(points={{0,10},{0,-60}}, color={0,0,0}),
            Rectangle(extent={{48,-6},{86,-40}}, lineColor={0,0,0}),
            Polygon(
              points={{-12,-16},{0,-22},{-12,-28},{-12,-16}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Line(points={{-44,-22},{-12,-22}}, color={0,0,0}),
            Polygon(
              points={{36,-16},{48,-22},{36,-28},{36,-16}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Line(points={{0,-22},{36,-22}}, color={0,0,0})}),
      Documentation(info="<html>
<p>
On the highest level of a StateGraph, an instance of StateGraphRoot
has to be present. If it is not within in a model, it is automatically
included by a Modelica translator due to an appropriate annotation.
Practically, this means that it need not be present in a
StateGraph model.
</p>
<p>
The StateGraphRoot object is needed, since all Step objects have
an \"outer\" reference to communicate with the \"nearest\" CompositeStep
(which inherits from PartialCompositeStep), especially to abort
a CompositeStep via the \"suspend\" port. Even if no \"CompositeStep\" is present,
on highest level a corresponding \"inner\" definition is needed
and is provided by the StateGraphRoot object.
</p>
</html>"));
  end StateGraphRoot;

  package Temporary
    "Components that will be provided by other libraries in the future"
    extends Modelica.Icons.Package;

    function anyTrue
    "Returns true, if at least on element of the Boolean input vector is true"

      extends Modelica.Icons.Function;
      input Boolean b[:];
      output Boolean result;
    algorithm
      result := false;
      for i in 1:size(b,1) loop
         result := result or b[i];
      end for;
        annotation (Documentation(info="<html>

</html>"));
    end anyTrue;
    annotation (Documentation(info="<html>
<p>
This library is just temporarily present. The components of
this library will be present in the future in the Modelica
standard library (with the new block connectors) and in the
UserInteraction library that is currently under development.
</p>
</html>"));
  end Temporary;
  annotation (
    Documentation(info="<html>
<p>
Note, there is a much improved version of this library called
\"Modelica_StateGraph2\". If this library is not yet distributed with your
Modelica tool, you can download it from
<a href=\"http://www.modelica.org/libraries/Modelica_StateGraph2\">http://www.modelica.org/libraries/Modelica_StateGraph2</a>.
In the
<a href=\"modelica://Modelica.StateGraph.UsersGuide.ComparisonWithStateGraph2\">Users Guide</a>
a detailed comparison is given. It is highly recommended to use Modelica_StateGraph2 instead
of Modelica.StateGraph.
</p>

<p>
Library <b>StateGraph</b> is a <b>free</b> Modelica package providing
components to model <b>discrete event</b> and <b>reactive</b>
systems in a convenient
way. It is based on the JGraphChart method and
takes advantage of Modelica features for
the \"action\" language. JGraphChart is a further development of
Grafcet to include elements of StateCharts that are not present
in Grafcet/Sequential Function Charts. Therefore, the StateGraph
library has a similar modeling power as StateCharts but avoids
some deficiences of StateCharts.
</p>
<p>
For an introduction, have especially a look at:
</p>
<ul>
<li> <a href=\"modelica://Modelica.StateGraph.UsersGuide\">StateGraph.UsersGuide</a>
     discusses the most important aspects how to use this library.</li>
<li> <a href=\"modelica://Modelica.StateGraph.Examples\">StateGraph.Examples</a>
     contains examples that demonstrate the usage of this library.</li>
</ul>
<p>
A typical model generated with this library is shown
in the next figure where on the left hand side a two-tank
system with a tank controller and on the right hand side the
top-level part of the tank controller as a StateGraph is shown:
</p>

<img src=\"modelica://Modelica/Resources/Images/StateGraph/Examples/ControlledTanks1_small.png\">

<img src=\"modelica://Modelica/Resources/Images/StateGraph/Examples/ControlledTanks2_small.png\">

<p>
The unique feature of the StateGraph library with respect to JGraphCharts,
Grafcet, Sequential Function Charts, and StateCharts, is Modelica's
\"single assignment rule\" that requires that every variable is defined
by exactly one equation. This leads to a different \"action\" definition
as in these formalisms. The advantage is that the translator can either
determine a useful evaluation sequence by equation sorting or
reports an error if this is not possible, e.g., because a model
would lead to a non-determinism or to a dead-lock. As a side effect,
this leads also to simpler and more easier to understand models and
global variables are no longer needed (whereas in JGraphCharts,
Grafcet, Sequential Function Charts and StateCharts global variables
are nearly always needed).
</p>

<p>
Copyright &copy; 1998-2010, Modelica Association and DLR
</p>
<p>
<i>This Modelica package is <u>free</u> software and the use is completely at <u>your own risk</u>; it can be redistributed and/or modified under the terms of the Modelica License 2. For license conditions (including the disclaimer of warranty) see <a href=\"modelica://Modelica.UsersGuide.ModelicaLicense2\">Modelica.UsersGuide.ModelicaLicense2</a> or visit <a href=\"http://www.modelica.org/licenses/ModelicaLicense2\"> http://www.modelica.org/licenses/ModelicaLicense2</a>.</i>
</p>
</HTML>
"),   Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
              100}}), graphics={
          Rectangle(extent={{-88,-20},{-50,-54}}, lineColor={0,0,0}),
          Line(points={{-50,-38},{-24,-38}}, color={0,0,0}),
          Polygon(
            points={{-24,-32},{-12,-38},{-24,-44},{-24,-32}},
            lineColor={0,0,0},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid),
          Line(points={{-12,-6},{-12,-76}}, color={0,0,0}),
          Line(points={{-12,-38},{14,-38}}, color={0,0,0}),
          Polygon(
            points={{14,-32},{26,-38},{14,-44},{14,-32}},
            lineColor={0,0,0},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid),
          Rectangle(extent={{26,-22},{64,-56}}, lineColor={0,0,0})}));
  end StateGraph;

  package Fluid
  "Library of 1-dim. thermo-fluid flow models using the Modelica.Media media description"
    extends Modelica.Icons.Package;
    import SI = Modelica.SIunits;

    model System
    "System properties and default values (ambient, flow direction, initialization)"

      package Medium = Modelica.Media.Interfaces.PartialMedium
      "Medium model for default start values"
          annotation (choicesAllMatching = true);
      parameter Modelica.SIunits.AbsolutePressure p_ambient=101325
      "Default ambient pressure"
        annotation(Dialog(group="Environment"));
      parameter Modelica.SIunits.Temperature T_ambient=293.15
      "Default ambient temperature"
        annotation(Dialog(group="Environment"));
      parameter Modelica.SIunits.Acceleration g=Modelica.Constants.g_n
      "Constant gravity acceleration"
        annotation(Dialog(group="Environment"));

      // Assumptions
      parameter Boolean allowFlowReversal = true
      "= false to restrict to design flow direction (port_a -> port_b)"
        annotation(Dialog(tab="Assumptions"), Evaluate=true);
      parameter Modelica.Fluid.Types.Dynamics energyDynamics=
        Modelica.Fluid.Types.Dynamics.DynamicFreeInitial
      "Default formulation of energy balances"
        annotation(Evaluate=true, Dialog(tab = "Assumptions", group="Dynamics"));
      parameter Modelica.Fluid.Types.Dynamics massDynamics=
        energyDynamics "Default formulation of mass balances"
        annotation(Evaluate=true, Dialog(tab = "Assumptions", group="Dynamics"));
      final parameter Modelica.Fluid.Types.Dynamics substanceDynamics=
        massDynamics "Default formulation of substance balances"
        annotation(Evaluate=true, Dialog(tab = "Assumptions", group="Dynamics"));
      final parameter Modelica.Fluid.Types.Dynamics traceDynamics=
        massDynamics "Default formulation of trace substance balances"
        annotation(Evaluate=true, Dialog(tab = "Assumptions", group="Dynamics"));
      parameter Modelica.Fluid.Types.Dynamics momentumDynamics=
        Modelica.Fluid.Types.Dynamics.SteadyState
      "Default formulation of momentum balances, if options available"
        annotation(Evaluate=true, Dialog(tab = "Assumptions", group="Dynamics"));

      // Initialization
      parameter Modelica.SIunits.MassFlowRate m_flow_start = 0
      "Default start value for mass flow rates"
        annotation(Dialog(tab = "Initialization"));
      parameter Modelica.SIunits.AbsolutePressure p_start = p_ambient
      "Default start value for pressures"
        annotation(Dialog(tab = "Initialization"));
      parameter Modelica.SIunits.Temperature T_start = T_ambient
      "Default start value for temperatures"
        annotation(Dialog(tab = "Initialization"));

      // Advanced
      parameter Modelica.SIunits.MassFlowRate m_flow_small(min=0) = 0.01
      "Default small laminar mass flow rate for regularization of zero flow"
        annotation(Dialog(tab = "Advanced"));
      parameter Modelica.SIunits.AbsolutePressure dp_small(min=0) = 1
      "Default small pressure drop for regularization of laminar and zero flow"
        annotation(Dialog(tab="Advanced"));

      annotation (
        defaultComponentName="system",
        defaultComponentPrefixes="inner",
        missingInnerMessage="
Your model is using an outer \"system\" component but
an inner \"system\" component is not defined.
For simulation drag Modelica.Fluid.System into your model
to specify system properties. The default System setting
is used for the current simulation.
",      Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                100}}), graphics={
            Rectangle(
              extent={{-100,100},{100,-100}},
              lineColor={0,0,255},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-150,150},{150,110}},
              lineColor={0,0,255},
              textString="%name"),
            Line(points={{-86,-30},{82,-30}}, color={0,0,0}),
            Line(points={{-82,-68},{-52,-30}}, color={0,0,0}),
            Line(points={{-48,-68},{-18,-30}}, color={0,0,0}),
            Line(points={{-14,-68},{16,-30}}, color={0,0,0}),
            Line(points={{22,-68},{52,-30}}, color={0,0,0}),
            Line(points={{74,84},{74,14}}, color={0,0,0}),
            Polygon(
              points={{60,14},{88,14},{74,-18},{60,14}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{16,20},{60,-18}},
              lineColor={0,0,0},
              textString="g"),
            Text(
              extent={{-90,82},{74,50}},
              lineColor={0,0,0},
              textString="defaults"),
            Line(
              points={{-82,14},{-42,-20},{2,30}},
              color={0,0,0},
              thickness=0.5),
            Ellipse(
              extent={{-10,40},{12,18}},
              pattern=LinePattern.None,
              lineColor={0,0,0},
              fillColor={255,0,0},
              fillPattern=FillPattern.Solid)}),
        Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{
                100,100}}),
                graphics),
        Documentation(info="<html>
<p>
 A system component is needed in each fluid model to provide system-wide settings, such as ambient conditions and overall modeling assumptions.
 The system settings are propagated to the fluid models using the inner/outer mechanism.
</p>
<p>
 A model should never directly use system parameters.
 Instead a local parameter should be declared, which uses the global setting as default.
 The only exception currently made is the gravity system.g.
</p>
</html>"));

    end System;

    package Vessels "Devices for storing fluid"
       extends Modelica.Icons.VariantsPackage;

      package BaseClasses
      "Base classes used in the Vessels package (only of interest to build new component models)"
        extends Modelica.Icons.BasesPackage;

        connector VesselFluidPorts_b
        "Fluid connector with outlined, large icon to be used for horizontally aligned vectors of FluidPorts (vector dimensions must be added after dragging)"
          extends Interfaces.FluidPort;
          annotation (defaultComponentName="ports_b",
                      Diagram(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-50,-200},{50,200}},
                grid={1,1},
                initialScale=0.2), graphics={
                Text(extent={{-75,130},{75,100}}, textString="%name"),
                Rectangle(
                  extent={{-25,100},{25,-100}},
                  lineColor={0,0,0}),
                Ellipse(
                  extent={{-22,100},{-10,-100}},
                  lineColor={0,0,0},
                  fillColor={0,127,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-20,-69},{-12,69}},
                  lineColor={0,127,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-6,100},{6,-100}},
                  lineColor={0,0,0},
                  fillColor={0,127,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{10,100},{22,-100}},
                  lineColor={0,0,0},
                  fillColor={0,127,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-4,-69},{4,69}},
                  lineColor={0,127,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{12,-69},{20,69}},
                  lineColor={0,127,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid)}),
               Icon(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-50,-200},{50,200}},
                grid={1,1},
                initialScale=0.2), graphics={
                Rectangle(
                  extent={{-50,200},{50,-200}},
                  lineColor={0,127,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-44,200},{-20,-200}},
                  lineColor={0,0,0},
                  fillColor={0,127,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-12,200},{12,-200}},
                  lineColor={0,0,0},
                  fillColor={0,127,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{20,200},{44,-200}},
                  lineColor={0,0,0},
                  fillColor={0,127,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-39,-118.5},{-25,113}},
                  lineColor={0,127,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-7,-118.5},{7,113}},
                  lineColor={0,127,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{25,-117.5},{39,114}},
                  lineColor={0,127,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid)}));
        end VesselFluidPorts_b;
      end BaseClasses;
      annotation (Documentation(info="<html>

</html>"));
    end Vessels;

    package Sources "Define fixed or prescribed boundary conditions"
      extends Modelica.Icons.SourcesPackage;

      package BaseClasses
      "Base classes used in the Sources package (only of interest to build new component models)"
        extends Modelica.Icons.BasesPackage;

      partial model PartialSource
        "Partial component source with one fluid connector"
          import Modelica.Constants;

        parameter Integer nPorts=0 "Number of ports" annotation(Dialog(connectorSizing=true));

        replaceable package Medium =
            Modelica.Media.Interfaces.PartialMedium
          "Medium model within the source"
           annotation (choicesAllMatching=true);

        Medium.BaseProperties medium "Medium in the source";

        Interfaces.FluidPorts_b ports[nPorts](
                           redeclare each package Medium = Medium,
                           m_flow(each max=if flowDirection==Types.PortFlowDirection.Leaving then 0 else
                                           +Constants.inf,
                                  each min=if flowDirection==Types.PortFlowDirection.Entering then 0 else
                                           -Constants.inf))
          annotation (Placement(transformation(extent={{90,40},{110,-40}})));
      protected
        parameter Types.PortFlowDirection flowDirection=
                         Types.PortFlowDirection.Bidirectional
          "Allowed flow direction"               annotation(Evaluate=true, Dialog(tab="Advanced"));
      equation
        // Only one connection allowed to a port to avoid unwanted ideal mixing
        for i in 1:nPorts loop
          assert(cardinality(ports[i]) <= 1,"
each ports[i] of boundary shall at most be connected to one component.
If two or more connections are present, ideal mixing takes
place with these connections, which is usually not the intention
of the modeller. Increase nPorts to add an additional port.
");

           ports[i].p          = medium.p;
           ports[i].h_outflow  = medium.h;
           ports[i].Xi_outflow = medium.Xi;
        end for;

        annotation (defaultComponentName="boundary", Documentation(info="<html>
<p>
Partial component to model the <b>volume interface</b> of a <b>source</b>
component, such as a mass flow source. The essential
features are:
</p>
<ul>
<li> The pressure in the connection port (= ports.p) is identical to the
     pressure in the volume.</li>
<li> The outflow enthalpy rate (= port.h_outflow) and the composition of the
     substances (= port.Xi_outflow) are identical to the respective values in the volume.</li>
</ul>
</html>"),       Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,
                    -100},{100,100}}),
                               graphics),
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics));
      end PartialSource;
      end BaseClasses;
      annotation (Documentation(info="<html>
<p>
Package <b>Sources</b> contains generic sources for fluid connectors
to define fixed or prescribed ambient conditions.
</p>
</html>"));
    end Sources;

    package Interfaces
    "Interfaces for steady state and unsteady, mixed-phase, multi-substance, incompressible and compressible flow"
      extends Modelica.Icons.InterfacesPackage;

      connector FluidPort
      "Interface for quasi one-dimensional fluid flow in a piping network (incompressible or compressible, one or more phases, one or more substances)"

        replaceable package Medium = Modelica.Media.Interfaces.PartialMedium
        "Medium model"   annotation (choicesAllMatching=true);

        flow Medium.MassFlowRate m_flow
        "Mass flow rate from the connection point into the component";
        Medium.AbsolutePressure p
        "Thermodynamic pressure in the connection point";
        stream Medium.SpecificEnthalpy h_outflow
        "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        stream Medium.MassFraction Xi_outflow[Medium.nXi]
        "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        stream Medium.ExtraProperty C_outflow[Medium.nC]
        "Properties c_i/m close to the connection point if m_flow < 0";
      end FluidPort;

      connector FluidPort_a "Generic fluid connector at design inlet"
        extends FluidPort;
        annotation (defaultComponentName="port_a",
                    Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                  -100},{100,100}}), graphics={Ellipse(
                extent={{-40,40},{40,-40}},
                lineColor={0,0,0},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid), Text(extent={{-150,110},{150,50}},
                  textString="%name")}),
             Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{
                  100,100}}), graphics={Ellipse(
                extent={{-100,100},{100,-100}},
                lineColor={0,127,255},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid), Ellipse(
                extent={{-100,100},{100,-100}},
                lineColor={0,0,0},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid)}));
      end FluidPort_a;

      connector FluidPort_b "Generic fluid connector at design outlet"
        extends FluidPort;
        annotation (defaultComponentName="port_b",
                    Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                  -100},{100,100}}), graphics={
              Ellipse(
                extent={{-40,40},{40,-40}},
                lineColor={0,0,0},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-30,30},{30,-30}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Text(extent={{-150,110},{150,50}}, textString="%name")}),
             Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{
                  100,100}}), graphics={
              Ellipse(
                extent={{-100,100},{100,-100}},
                lineColor={0,127,255},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-100,100},{100,-100}},
                lineColor={0,0,0},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-80,80},{80,-80}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid)}));
      end FluidPort_b;

      connector FluidPorts_b
      "Fluid connector with outlined, large icon to be used for vectors of FluidPorts (vector dimensions must be added after dragging)"
        extends FluidPort;
        annotation (defaultComponentName="ports_b",
                    Diagram(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-50,-200},{50,200}},
              grid={1,1},
              initialScale=0.2), graphics={
              Text(extent={{-75,130},{75,100}}, textString="%name"),
              Rectangle(
                extent={{-25,100},{25,-100}},
                lineColor={0,0,0}),
              Ellipse(
                extent={{-25,90},{25,40}},
                lineColor={0,0,0},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-25,25},{25,-25}},
                lineColor={0,0,0},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-25,-40},{25,-90}},
                lineColor={0,0,0},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-15,-50},{15,-80}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-15,15},{15,-15}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-15,50},{15,80}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid)}),
             Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-50,-200},{50,200}},
              grid={1,1},
              initialScale=0.2), graphics={
              Rectangle(
                extent={{-50,200},{50,-200}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-50,180},{50,80}},
                lineColor={0,0,0},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-50,50},{50,-50}},
                lineColor={0,0,0},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-50,-80},{50,-180}},
                lineColor={0,0,0},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-30,30},{30,-30}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-30,100},{30,160}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-30,-100},{30,-160}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid)}));
      end FluidPorts_b;

      partial model PartialTwoPort "Partial component with two ports"
        import Modelica.Constants;
        outer Modelica.Fluid.System system "System wide properties";

        replaceable package Medium =
            Modelica.Media.Interfaces.PartialMedium "Medium in the component"
            annotation (choicesAllMatching = true);

        parameter Boolean allowFlowReversal = system.allowFlowReversal
        "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)"
          annotation(Dialog(tab="Assumptions"), Evaluate=true);

        Modelica.Fluid.Interfaces.FluidPort_a port_a(
                                      redeclare package Medium = Medium,
                           m_flow(min=if allowFlowReversal then -Constants.inf else 0))
        "Fluid connector a (positive design flow direction is from port_a to port_b)"
          annotation (Placement(transformation(extent={{-110,-10},{-90,10}},
                  rotation=0)));
        Modelica.Fluid.Interfaces.FluidPort_b port_b(
                                      redeclare package Medium = Medium,
                           m_flow(max=if allowFlowReversal then +Constants.inf else 0))
        "Fluid connector b (positive design flow direction is from port_a to port_b)"
          annotation (Placement(transformation(extent={{110,-10},{90,10}}, rotation=
                   0), iconTransformation(extent={{110,-10},{90,10}})));
        // Model structure, e.g., used for visualization
    protected
        parameter Boolean port_a_exposesState = false
        "= true if port_a exposes the state of a fluid volume";
        parameter Boolean port_b_exposesState = false
        "= true if port_b.p exposes the state of a fluid volume";
        parameter Boolean showDesignFlowDirection = true
        "= false to hide the arrow in the model icon";

        annotation (
          Diagram(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-100,-100},{100,100}},
                grid={1,1}), graphics),
          Documentation(info="<html>
<p>
This partial model defines an interface for components with two ports.
The treatment of the design flow direction and of flow reversal are predefined based on the parameter <code><b>allowFlowReversal</b></code>.
The component may transport fluid and may have internal storage for a given fluid <code><b>Medium</b></code>.
</p>
<p>
An extending model providing direct access to internal storage of mass or energy through port_a or port_b
should redefine the protected parameters <code><b>port_a_exposesState</b></code> and <code><b>port_b_exposesState</b></code> appropriately.
This will be visualized at the port icons, in order to improve the understanding of fluid model diagrams.
</p>
</html>"),Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={1,1}), graphics={
              Polygon(
                points={{20,-70},{60,-85},{20,-100},{20,-70}},
                lineColor={0,128,255},
                smooth=Smooth.None,
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid,
                visible=showDesignFlowDirection),
              Polygon(
                points={{20,-75},{50,-85},{20,-95},{20,-75}},
                lineColor={255,255,255},
                smooth=Smooth.None,
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                visible=allowFlowReversal),
              Line(
                points={{55,-85},{-60,-85}},
                color={0,128,255},
                smooth=Smooth.None,
                visible=showDesignFlowDirection),
              Text(
                extent={{-149,-114},{151,-154}},
                lineColor={0,0,255},
                textString="%name"),
              Ellipse(
                extent={{-110,26},{-90,-24}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                visible=port_a_exposesState),
              Ellipse(
                extent={{90,25},{110,-25}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                visible=port_b_exposesState)}));
      end PartialTwoPort;

    partial model PartialTwoPortTransport
      "Partial element transporting fluid between two ports without storage of mass or energy"

      extends PartialTwoPort(
        final port_a_exposesState=false,
        final port_b_exposesState=false);

      // Advanced
      parameter Medium.AbsolutePressure dp_start = 0.01*system.p_start
        "Guess value of dp = port_a.p - port_b.p"
        annotation(Dialog(tab = "Advanced"));
      parameter Medium.MassFlowRate m_flow_start = system.m_flow_start
        "Guess value of m_flow = port_a.m_flow"
        annotation(Dialog(tab = "Advanced"));
      parameter Medium.MassFlowRate m_flow_small = system.m_flow_small
        "Small mass flow rate for regularization of zero flow"
        annotation(Dialog(tab = "Advanced"));

      // Diagnostics
      parameter Boolean show_T = true
        "= true, if temperatures at port_a and port_b are computed"
        annotation(Dialog(tab="Advanced",group="Diagnostics"));
      parameter Boolean show_V_flow = true
        "= true, if volume flow rate at inflowing port is computed"
        annotation(Dialog(tab="Advanced",group="Diagnostics"));

      // Variables
      Medium.MassFlowRate m_flow(
         min=if allowFlowReversal then -Modelica.Constants.inf else 0,
         start = m_flow_start) "Mass flow rate in design flow direction";
      Modelica.SIunits.Pressure dp(start=dp_start)
        "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";

      Modelica.SIunits.VolumeFlowRate V_flow=
          m_flow/Modelica.Fluid.Utilities.regStep(m_flow,
                      Medium.density(state_a),
                      Medium.density(state_b),
                      m_flow_small) if show_V_flow
        "Volume flow rate at inflowing port (positive when flow from port_a to port_b)";

      Medium.Temperature port_a_T=
          Modelica.Fluid.Utilities.regStep(port_a.m_flow,
                      Medium.temperature(state_a),
                      Medium.temperature(Medium.setState_phX(port_a.p, port_a.h_outflow, port_a.Xi_outflow)),
                      m_flow_small) if show_T
        "Temperature close to port_a, if show_T = true";
      Medium.Temperature port_b_T=
          Modelica.Fluid.Utilities.regStep(port_b.m_flow,
                      Medium.temperature(state_b),
                      Medium.temperature(Medium.setState_phX(port_b.p, port_b.h_outflow, port_b.Xi_outflow)),
                      m_flow_small) if show_T
        "Temperature close to port_b, if show_T = true";
    protected
      Medium.ThermodynamicState state_a
        "state for medium inflowing through port_a";
      Medium.ThermodynamicState state_b
        "state for medium inflowing through port_b";
    equation
      // medium states
      state_a = Medium.setState_phX(port_a.p, inStream(port_a.h_outflow), inStream(port_a.Xi_outflow));
      state_b = Medium.setState_phX(port_b.p, inStream(port_b.h_outflow), inStream(port_b.Xi_outflow));

      // Pressure drop in design flow direction
      dp = port_a.p - port_b.p;

      // Design direction of mass flow rate
      m_flow = port_a.m_flow;
      assert(m_flow > -m_flow_small or allowFlowReversal, "Reverting flow occurs even though allowFlowReversal is false");

      // Mass balance (no storage)
      port_a.m_flow + port_b.m_flow = 0;

      // Transport of substances
      port_a.Xi_outflow = inStream(port_b.Xi_outflow);
      port_b.Xi_outflow = inStream(port_a.Xi_outflow);

      port_a.C_outflow = inStream(port_b.C_outflow);
      port_b.C_outflow = inStream(port_a.C_outflow);

      annotation (
        Diagram(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics),
        Documentation(info="<html>
<p>
This component transports fluid between its two ports, without storing mass or energy.
Energy may be exchanged with the environment though, e.g., in the form of work.
<code>PartialTwoPortTransport</code> is intended as base class for devices like orifices, valves and simple fluid machines.
<p>
Three equations need to be added by an extending class using this component:
</p>
<ul>
<li>the momentum balance specifying the relationship between the pressure drop <code>dp</code> and the mass flow rate <code>m_flow</code></li>,
<li><code>port_b.h_outflow</code> for flow in design direction, and</li>
<li><code>port_a.h_outflow</code> for flow in reverse direction.</li>
</ul>
</html>"),
        Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-100,-100},{100,100}},
              grid={1,1})));
    end PartialTwoPortTransport;
      annotation (Documentation(info="<html>

</html>",     revisions="<html>
<ul>
<li><i>June 9th, 2008</i>
       by Michael Sielemann: Introduced stream keyword after decision at 57th Design Meeting (Lund).</li>
<li><i>May 30, 2007</i>
       by Christoph Richter: moved everything back to its original position in Modelica.Fluid.</li>
<li><i>Apr. 20, 2007</i>
       by Christoph Richter: moved parts of the original package from Modelica.Fluid
       to the development branch of Modelica 2.2.2.</li>
<li><i>Nov. 2, 2005</i>
       by Francesco Casella: restructured after 45th Design Meeting.</li>
<li><i>Nov. 20-21, 2002</i>
       by Hilding Elmqvist, Mike Tiller, Allan Watson, John Batteh, Chuck Newman,
       Jonas Eborn: Improved at the 32nd Modelica Design Meeting.
<li><i>Nov. 11, 2002</i>
       by Hilding Elmqvist, Martin Otter: improved version.</li>
<li><i>Nov. 6, 2002</i>
       by Hilding Elmqvist: first version.</li>
<li><i>Aug. 11, 2002</i>
       by Martin Otter: Improved according to discussion with Hilding
       Elmqvist and Hubertus Tummescheit.<br>
       The PortVicinity model is manually
       expanded in the base models.<br>
       The Volume used for components is renamed
       PartialComponentVolume.<br>
       A new volume model \"Fluid.Components.PortVolume\"
       introduced that has the medium properties of the port to which it is
       connected.<br>
       Fluid.Interfaces.PartialTwoPortTransport is a component
       for elementary two port transport elements, whereas PartialTwoPort
       is a component for a container component.</li>
</li>
</ul>
</html>"));
    end Interfaces;

    package Types "Common types for fluid models"
      extends Modelica.Icons.Package;

      type Dynamics = enumeration(
        DynamicFreeInitial
          "DynamicFreeInitial -- Dynamic balance, Initial guess value",
        FixedInitial "FixedInitial -- Dynamic balance, Initial value fixed",
        SteadyStateInitial
          "SteadyStateInitial -- Dynamic balance, Steady state initial with guess value",

        SteadyState "SteadyState -- Steady state balance, Initial guess value")
      "Enumeration to define definition of balance equations"
      annotation (Documentation(info="<html>
<p>
Enumeration to define the formulation of balance equations
(to be selected via choices menu):
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><th><b>Dynamics.</b></th><th><b>Meaning</b></th></tr>
<tr><td>DynamicFreeInitial</td><td>Dynamic balance, Initial guess value</td></tr>

<tr><td>FixedInitial</td><td>Dynamic balance, Initial value fixed</td></tr>

<tr><td>SteadyStateInitial</td><td>Dynamic balance, Steady state initial with guess value</td></tr>

<tr><td>SteadyState</td><td>Steady state balance, Initial guess value</td></tr>
</table>

<p>
The enumeration \"Dynamics\" is used for the mass, energy and momentum balance equations
respectively. The exact meaning for the three balance equations is stated in the following
tables:
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><td colspan=\"3\"><b>Mass balance</b> </td>
<tr><td><b>Dynamics.</b></td>
    <td><b>Balance equation</b></td>
    <td><b>Initial condition</b></td></tr>

<tr><td> DynamicFreeInitial</td>
    <td> no restrictions </td>
    <td> no initial conditions </td></tr>

<tr><td> FixedInitial</td>
    <td> no restrictions </td>
    <td> <b>if</b> Medium.singleState <b>then</b> <br>
         &nbsp;&nbsp;no initial condition<br>
         <b>else</b> p=p_start </td></tr>

<tr><td> SteadyStateInitial</td>
    <td> no restrictions </td>
    <td> <b>if</b> Medium.singleState <b>then</b> <br>
         &nbsp;&nbsp;no initial condition<br>
         <b>else</b> <b>der</b>(p)=0 </td></tr>

<tr><td> SteadyState</td>
    <td> <b>der</b>(m)=0  </td>
    <td> no initial conditions </td></tr>
</table>

&nbsp;<br>

<table border=1 cellspacing=0 cellpadding=2>
<tr><td colspan=\"3\"><b>Energy balance</b> </td>
<tr><td><b>Dynamics.</b></td>
    <td><b>Balance equation</b></td>
    <td><b>Initial condition</b></td></tr>

<tr><td> DynamicFreeInitial</td>
    <td> no restrictions </td>
    <td> no initial conditions </td></tr>

<tr><td> FixedInitial</td>
    <td> no restrictions </td>
    <td> T=T_start or h=h_start </td></tr>

<tr><td> SteadyStateInitial</td>
    <td> no restrictions </td>
    <td> <b>der</b>(T)=0 or <b>der</b>(h)=0 </td></tr>

<tr><td> SteadyState</td>
    <td> <b>der</b>(U)=0  </td>
    <td> no initial conditions </td></tr>
</table>

&nbsp;<br>

<table border=1 cellspacing=0 cellpadding=2>
<tr><td colspan=\"3\"><b>Momentum balance</b> </td>
<tr><td><b>Dynamics.</b></td>
    <td><b>Balance equation</b></td>
    <td><b>Initial condition</b></td></tr>

<tr><td> DynamicFreeInitial</td>
    <td> no restrictions </td>
    <td> no initial conditions </td></tr>

<tr><td> FixedInitial</td>
    <td> no restrictions </td>
    <td> m_flow = m_flow_start </td></tr>

<tr><td> SteadyStateInitial</td>
    <td> no restrictions </td>
    <td> <b>der</b>(m_flow)=0 </td></tr>

<tr><td> SteadyState</td>
    <td> <b>der</b>(m_flow)=0 </td>
    <td> no initial conditions </td></tr>
</table>

<p>
In the tables above, the equations are given for one-substance fluids. For multiple-substance
fluids and for trace substances, equivalent equations hold.
</p>

<p>
Medium.singleState is a medium property and defines whether the medium is only
described by one state (+ the mass fractions in case of a multi-substance fluid). In such
a case one initial condition less must be provided. For example, incompressible
media have Medium.singleState = <b>true</b>.
</p>

</html>"));

      type PortFlowDirection = enumeration(
        Entering "Fluid flow is only entering",
        Leaving "Fluid flow is only leaving",
        Bidirectional "No restrictions on fluid flow (flow reversal possible)")
      "Enumeration to define whether flow reversal is allowed"   annotation (
          Documentation(info="<html>

<p>
Enumeration to define the assumptions on the model for the
direction of fluid flow at a port (to be selected via choices menu):
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><th><b>PortFlowDirection.</b></th>
    <th><b>Meaning</b></th></tr>

<tr><td>Entering</td>
    <td>Fluid flow is only entering the port from the outside</td></tr>

<tr><td>Leaving</td>
    <td>Fluid flow is only leaving the port to the outside</td></tr>

<tr><td>Bidirectional</td>
    <td>No restrictions on fluid flow (flow reversal possible)</td></tr>
</table>

<p>
The default is \"PortFlowDirection.Bidirectional\". If you are completely sure that
the flow is only in one direction, then the other settings may
make the simulation of your model faster.
</p>

</html>"));
      annotation (preferedView="info",
                  Documentation(info="<html>

</html>"));
    end Types;

    package Utilities
    "Utility models to construct fluid components (should not be used directly) "
      extends Modelica.Icons.Package;

      function checkBoundary "Check whether boundary definition is correct"
        extends Modelica.Icons.Function;
        input String mediumName;
        input String substanceNames[:] "Names of substances";
        input Boolean singleState;
        input Boolean define_p;
        input Real X_boundary[:];
        input String modelName = "??? boundary ???";
    protected
        Integer nX = size(X_boundary,1);
        String X_str;
      algorithm
        assert(not singleState or singleState and define_p, "
Wrong value of parameter define_p (= false) in model \""       + modelName + "\":
The selected medium \""     + mediumName + "\" has Medium.singleState=true.
Therefore, an boundary density cannot be defined and
define_p = true is required.
");

        for i in 1:nX loop
          assert(X_boundary[i] >= 0.0, "
Wrong boundary mass fractions in medium \""
      + mediumName + "\" in model \"" + modelName + "\":
The boundary value X_boundary("   + String(i) + ") = " + String(
            X_boundary[i]) + "
is negative. It must be positive.
");
        end for;

        if nX > 0 and abs(sum(X_boundary) - 1.0) > 1.e-10 then
           X_str :="";
           for i in 1:nX loop
              X_str :=X_str + "   X_boundary[" + String(i) + "] = " + String(X_boundary[
              i]) + " \"" + substanceNames[i] + "\"\n";
           end for;
           Modelica.Utilities.Streams.error(
              "The boundary mass fractions in medium \"" + mediumName + "\" in model \"" + modelName + "\"\n" +
              "do not sum up to 1. Instead, sum(X_boundary) = " + String(sum(X_boundary)) + ":\n"
              + X_str);
        end if;
      end checkBoundary;

      function regRoot2
      "Anti-symmetric approximation of square root with discontinuous factor so that the first derivative is finite and continuous"

        extends Modelica.Icons.Function;
        input Real x "abscissa value";
        input Real x_small(min=0)=0.01
        "approximation of function for |x| <= x_small";
        input Real k1(min=0)=1 "y = if x>=0 then sqrt(k1*x) else -sqrt(k2*|x|)";
        input Real k2(min=0)=1 "y = if x>=0 then sqrt(k1*x) else -sqrt(k2*|x|)";
        input Boolean use_yd0 = false "= true, if yd0 shall be used";
        input Real yd0(min=0)=1 "Desired derivative at x=0: dy/dx = yd0";
        output Real y "ordinate value";
    protected
        encapsulated function regRoot2_utility
        "Interpolating with two 3-order polynomials with a prescribed derivative at x=0"
          import Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero;
           input Real x;
           input Real x1 "approximation of function abs(x) < x1";
           input Real k1
          "y = if x>=0 then sqrt(k1*x) else -sqrt(k2*|x|); k1 >= k2";
           input Real k2 "y = if x>=0 then sqrt(k1*x) else -sqrt(k2*|x|))";
           input Boolean use_yd0 "= true, if yd0 shall be used";
           input Real yd0(min=0) "Desired derivative at x=0: dy/dx = yd0";
           output Real y;
      protected
           Real x2;
           Real xsqrt1;
           Real xsqrt2;
           Real y1;
           Real y2;
           Real y1d;
           Real y2d;
           Real w;
           Real y0d;
           Real w1;
           Real w2;
        algorithm
           if k2 > 0 then
              x2 :=-x1*(k2/k1);
           else
              x2 := -x1;
           end if;

           if x <= x2 then
              y := -sqrt(k2*abs(x));
           else
              y1 :=sqrt(k1*x1);
              y2 :=-sqrt(k2*abs(x2));
              y1d :=sqrt(k1/x1)/2;
              y2d :=sqrt(k2/abs(x2))/2;

              if use_yd0 then
                 y0d :=yd0;
              else
                 /* Determine derivative, such that first and second derivative
              of left and right polynomial are identical at x=0:
           _
           Basic equations:
              y_right = a1*(x/x1) + a2*(x/x1)^2 + a3*(x/x1)^3
              y_left  = b1*(x/x2) + b2*(x/x2)^2 + b3*(x/x2)^3
              yd_right*x1 = a1 + 2*a2*(x/x1) + 3*a3*(x/x1)^2
              yd_left *x2 = b1 + 2*b2*(x/x2) + 3*b3*(x/x2)^2
              ydd_right*x1^2 = 2*a2 + 6*a3*(x/x1)
              ydd_left *x2^2 = 2*b2 + 6*b3*(x/x2)
           _
           Conditions (6 equations for 6 unknowns):
                     y1 = a1 + a2 + a3
                     y2 = b1 + b2 + b3
                 y1d*x1 = a1 + 2*a2 + 3*a3
                 y2d*x2 = b1 + 2*b2 + 3*b3
                    y0d = a1/x1 = b1/x2
                   y0dd = 2*a2/x1^2 = 2*b2/x2^2
           _
           Derived equations:
              b1 = a1*x2/x1
              b2 = a2*(x2/x1)^2
              b3 = y2 - b1 - b2
                 = y2 - a1*(x2/x1) - a2*(x2/x1)^2
              a3 = y1 - a1 - a2
           _
           Remaining equations
              y1d*x1 = a1 + 2*a2 + 3*(y1 - a1 - a2)
                     = 3*y1 - 2*a1 - a2
              y2d*x2 = a1*(x2/x1) + 2*a2*(x2/x1)^2 +
                       3*(y2 - a1*(x2/x1) - a2*(x2/x1)^2)
                     = 3*y2 - 2*a1*(x2/x1) - a2*(x2/x1)^2
              y0d    = a1/x1
           _
           Solving these equations results in y0d below
           (note, the denominator "(1-w)" is always non-zero, because w is negative)
           */
                 w :=x2/x1;
                 y0d := ( (3*y2 - x2*y2d)/w - (3*y1 - x1*y1d)*w) /(2*x1*(1 - w));
              end if;

              /* Modify derivative y0d, such that the polynomial is
           monotonically increasing. A sufficient condition is
             0 <= y0d <= sqrt(8.75*k_i/|x_i|)
        */
              w1 :=sqrt(8.75*k1/x1);
              w2 :=sqrt(8.75*k2/abs(x2));
              y0d :=min(y0d, 0.9*min(w1, w2));

              /* Perform interpolation in scaled polynomial:
           y_new = y/y1
           x_new = x/x1
        */
              y := y1*(if x >= 0 then evaluatePoly3_derivativeAtZero(x/x1,1,1,y1d*x1/y1,y0d*x1/y1) else
                                      evaluatePoly3_derivativeAtZero(x/x1,x2/x1,y2/y1,y2d*x1/y1,y0d*x1/y1));
           end if;
           annotation(smoothOrder=2);
        end regRoot2_utility;
      algorithm
        y := smooth(2, if x >= x_small then sqrt(k1*x) else
                       if x <= -x_small then -sqrt(k2*abs(x)) else
                       if k1 >= k2 then regRoot2_utility(x,x_small,k1,k2,use_yd0,yd0) else
                                       -regRoot2_utility(-x,x_small,k2,k1,use_yd0,yd0));
        annotation(smoothOrder=2, Documentation(info="<html>
<p>
Approximates the function
</p>
<pre>
   y = <b>if</b> x &ge; 0 <b>then</b> <b>sqrt</b>(k1*x) <b>else</b> -<b>sqrt</b>(k2*<b>abs</b>(x)), with k1, k2 &ge; 0
</pre>
<p>
in such a way that within the region -x_small &le; x &le; x_small,
the function is described by two polynomials of third order
(one in the region -x_small .. 0 and one within the region 0 .. x_small)
such that
</p>
<ul>
<li> The derivative at x=0 is finite. </li>
<li> The overall function is continuous with a
     continuous first derivative everywhere.</li>
<li> If parameter use_yd0 = <b>false</b>, the two polynomials
     are constructed such that the second derivatives at x=0
     are identical. If use_yd0 = <b>true</b>, the derivative
     at x=0 is explicitly provided via the additional argument
     yd0. If necessary, the derivative yd0 is automatically
     reduced in order that the polynomials are strict monotonically
     increasing <i>[Fritsch and Carlson, 1980]</i>.</li>
</ul>
<p>
Typical screenshots for two different configurations
are shown below. The first one with k1=k2=1:
</p>
<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Components/regRoot2_a.png\">
</p>
<p>
and the second one with k1=1 and k2=3:
</p>
<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Components/regRoot2_b.png\">
</p>

<p>
The (smooth) derivative of the function with
k1=1, k2=3 is shown in the next figure:
<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Components/regRoot2_c.png\">
</p>

<p>
<b>Literature</b>
</p>

<dl>
<dt> Fritsch F.N. and Carlson R.E. (1980):</dt>
<dd> <b>Monotone piecewise cubic interpolation</b>.
     SIAM J. Numerc. Anal., Vol. 17, No. 2, April 1980, pp. 238-246</dd>
</dl>
</html>",     revisions="<html>
<ul>
<li><i>Sept., 2019</i>
    by <a href=\"mailto:Martin.Otter@DLR.de\">Martin Otter</a>:<br>
    Improved so that k1=0 and/or k2=0 is also possible.</li>
<li><i>Nov., 2005</i>
    by <a href=\"mailto:Martin.Otter@DLR.de\">Martin Otter</a>:<br>
    Designed and implemented.</li>
</ul>
</html>"));
      end regRoot2;

      function regSquare2
      "Anti-symmetric approximation of square with discontinuous factor so that the first derivative is non-zero and is continuous"
        extends Modelica.Icons.Function;
        input Real x "abscissa value";
        input Real x_small(min=0)=0.01
        "approximation of function for |x| <= x_small";
        input Real k1(min=0)=1 "y = (if x>=0 then k1 else k2)*x*|x|";
        input Real k2(min=0)=1 "y = (if x>=0 then k1 else k2)*x*|x|";
        input Boolean use_yd0 = false "= true, if yd0 shall be used";
        input Real yd0(min=0)=1 "Desired derivative at x=0: dy/dx = yd0";
        output Real y "ordinate value";
    protected
        encapsulated function regSquare2_utility
        "Interpolating with two 3-order polynomials with a prescribed derivative at x=0"
          import Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero;
           input Real x;
           input Real x1 "approximation of function abs(x) < x1";
           input Real k1 "y = (if x>=0 then k1 else -k2)*x*|x|; k1 >= k2";
           input Real k2 "y = (if x>=0 then k1 else -k2)*x*|x|";
           input Boolean use_yd0 = false "= true, if yd0 shall be used";
           input Real yd0(min=0)=1 "Desired derivative at x=0: dy/dx = yd0";
           output Real y;
      protected
           Real x2;
           Real y1;
           Real y2;
           Real y1d;
           Real y2d;
           Real w;
           Real w1;
           Real w2;
           Real y0d;
           Real ww;
        algorithm
           // x2 :=-x1*(k2/k1)^2;
           x2 := -x1;
           if x <= x2 then
              y := -k2*x^2;
           else
               y1 := k1*x1^2;
               y2 :=-k2*x2^2;
              y1d := k1*2*x1;
              y2d :=-k2*2*x2;
              if use_yd0 then
                 y0d :=yd0;
              else
                 /* Determine derivative, such that first and second derivative
              of left and right polynomial are identical at x=0:
              see derivation in function regRoot2
           */
                 w :=x2/x1;
                 y0d := ( (3*y2 - x2*y2d)/w - (3*y1 - x1*y1d)*w) /(2*x1*(1 - w));
              end if;

              /* Modify derivative y0d, such that the polynomial is
           monotonically increasing. A sufficient condition is
             0 <= y0d <= sqrt(5)*k_i*|x_i|
        */
              w1 :=sqrt(5)*k1*x1;
              w2 :=sqrt(5)*k2*abs(x2);
              // y0d :=min(y0d, 0.9*min(w1, w2));
              ww :=0.9*(if w1 < w2 then w1 else w2);
              if ww < y0d then
                 y0d :=ww;
              end if;
              y := if x >= 0 then evaluatePoly3_derivativeAtZero(x,x1,y1,y1d,y0d) else
                                  evaluatePoly3_derivativeAtZero(x,x2,y2,y2d,y0d);
           end if;
           annotation(smoothOrder=2);
        end regSquare2_utility;
      algorithm
        y := smooth(2,if x >= x_small then k1*x^2 else
                      if x <= -x_small then -k2*x^2 else
                      if k1 >= k2 then regSquare2_utility(x,x_small,k1,k2,use_yd0,yd0) else
                                      -regSquare2_utility(-x,x_small,k2,k1,use_yd0,yd0));
        annotation(smoothOrder=2, Documentation(info="<html>
<p>
Approximates the function
</p>
<pre>
   y = <b>if</b> x &ge; 0 <b>then</b> k1*x*x <b>else</b> -k2*x*x, with k1, k2 > 0
</pre>
<p>
in such a way that within the region -x_small &le; x &le; x_small,
the function is described by two polynomials of third order
(one in the region -x_small .. 0 and one within the region 0 .. x_small)
such that
</p>

<ul>
<li> The derivative at x=0 is non-zero (in order that the
     inverse of the function does not have an infinite derivative). </li>
<li> The overall function is continuous with a
     continuous first derivative everywhere.</li>
<li> If parameter use_yd0 = <b>false</b>, the two polynomials
     are constructed such that the second derivatives at x=0
     are identical. If use_yd0 = <b>true</b>, the derivative
     at x=0 is explicitly provided via the additional argument
     yd0. If necessary, the derivative yd0 is automatically
     reduced in order that the polynomials are strict monotonically
     increasing <i>[Fritsch and Carlson, 1980]</i>.</li>
</ul>

<p>
A typical screenshot for k1=1, k2=3 is shown in the next figure:
</p>
<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Components/regSquare2_b.png\">
</p>

<p>
The (smooth, non-zero) derivative of the function with
k1=1, k2=3 is shown in the next figure:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Components/regSquare2_c.png\">
</p>

<p>
<b>Literature</b>
</p>

<dl>
<dt> Fritsch F.N. and Carlson R.E. (1980):</dt>
<dd> <b>Monotone piecewise cubic interpolation</b>.
     SIAM J. Numerc. Anal., Vol. 17, No. 2, April 1980, pp. 238-246</dd>
</dl>
</html>",     revisions="<html>
<ul>
<li><i>Nov., 2005</i>
    by <a href=\"mailto:Martin.Otter@DLR.de\">Martin Otter</a>:<br>
    Designed and implemented.</li>
</ul>
</html>"));
      end regSquare2;

      function regStep
      "Approximation of a general step, such that the characteristic is continuous and differentiable"
        extends Modelica.Icons.Function;
        input Real x "Abscissa value";
        input Real y1 "Ordinate value for x > 0";
        input Real y2 "Ordinate value for x < 0";
        input Real x_small(min=0) = 1e-5
        "Approximation of step for -x_small <= x <= x_small; x_small >= 0 required";
        output Real y
        "Ordinate value to approximate y = if x > 0 then y1 else y2";
      algorithm
        y := smooth(1, if x >  x_small then y1 else
                       if x < -x_small then y2 else
                       if x_small > 0 then (x/x_small)*((x/x_small)^2 - 3)*(y2-y1)/4 + (y1+y2)/2 else (y1+y2)/2);
        annotation(Documentation(revisions="<html>
<ul>
<li><i>April 29, 2008</i>
    by <a href=\"mailto:Martin.Otter@DLR.de\">Martin Otter</a>:<br>
    Designed and implemented.</li>
<li><i>August 12, 2008</i>
    by <a href=\"mailto:Michael.Sielemann@dlr.de\">Michael Sielemann</a>:<br>
    Minor modification to cover the limit case <code>x_small -> 0</code> without division by zero.</li>
</ul>
</html>",       info="<html>
<p>
This function is used to approximate the equation
</p>
<pre>
    y = <b>if</b> x &gt; 0 <b>then</b> y1 <b>else</b> y2;
</pre>

<p>
by a smooth characteristic, so that the expression is continuous and differentiable:
</p>

<pre>
   y = <b>smooth</b>(1, <b>if</b> x &gt;  x_small <b>then</b> y1 <b>else</b>
                 <b>if</b> x &lt; -x_small <b>then</b> y2 <b>else</b> f(y1, y2));
</pre>

<p>
In the region -x_small &lt; x &lt; x_small a 2nd order polynomial is used
for a smooth transition from y1 to y2.
</p>
</html>"));
      end regStep;

      function evaluatePoly3_derivativeAtZero
      "Evaluate polynomial of order 3 that passes the origin with a predefined derivative"
        extends Modelica.Icons.Function;
        input Real x "Value for which polynomial shall be evaluated";
        input Real x1 "Abscissa value";
        input Real y1 "y1=f(x1)";
        input Real y1d "First derivative at y1";
        input Real y0d "First derivative at f(x=0)";
        output Real y;
    protected
        Real a1;
        Real a2;
        Real a3;
        Real xx;
      algorithm
        a1 := x1*y0d;
        a2 := 3*y1 - x1*y1d - 2*a1;
        a3 := y1 - a2 - a1;
        xx := x/x1;
        y  := xx*(a1 + xx*(a2 + xx*a3));
        annotation(smoothOrder=3, Documentation(info="<html>

</html>"));
      end evaluatePoly3_derivativeAtZero;

      function cubicHermite "Evaluate a cubic Hermite spline"
        input Real x "Abscissa value";
        input Real x1 "Lower abscissa value";
        input Real x2 "Upper abscissa value";
        input Real y1 "Lower ordinate value";
        input Real y2 "Upper ordinate value";
        input Real y1d "Lower gradient";
        input Real y2d "Upper gradient";
        output Real y "Interpolated ordinate value";
    protected
        Real h "Distance between x1 and x2";
        Real t "abscissa scaled with h, i.e., t=[0..1] within x=[x1..x2]";
        Real h00 "Basis function 00 of cubic Hermite spline";
        Real h10 "Basis function 10 of cubic Hermite spline";
        Real h01 "Basis function 01 of cubic Hermite spline";
        Real h11 "Basis function 11 of cubic Hermite spline";
        Real aux3 "t cube";
        Real aux2 "t square";
      algorithm
        h := x2 - x1;
        if abs(h)>0 then
          // Regular case
          t := (x - x1)/h;

          aux3 :=t^3;
          aux2 :=t^2;

          h00 := 2*aux3 - 3*aux2 + 1;
          h10 := aux3 - 2*aux2 + t;
          h01 := -2*aux3 + 3*aux2;
          h11 := aux3 - aux2;
          y := y1*h00 + h*y1d*h10 + y2*h01 + h*y2d*h11;
        else
          // Degenerate case, x1 and x2 are identical, return step function
          y := (y1 + y2)/2;
        end if;
        annotation(smoothOrder=3, Documentation(revisions="<html>
<ul>
<li><i>May 2008</i>
    by <a href=\"mailto:Michael.Sielemann@dlr.de\">Michael Sielemann</a>:<br>
    Designed and implemented.</li>
</ul>
</html>"));
      end cubicHermite;
      annotation (Documentation(info="<html>

</html>"));
    end Utilities;
  annotation (
    preferedView="info",
    __Dymola_classOrder={"UsersGuide","Examples","System","Vessels","Pipes","Machines","Valves",
        "Fittings", "Sources", "Sensors", "Interfaces", "Types", "Utilities", "Icons", "*"},
    Documentation(info="<html>
<p>
Library <b>Modelica.Fluid</b> is a <b>free</b> Modelica package providing components for
<b>1-dimensional thermo-fluid flow</b> in networks of vessels, pipes, fluid machines, valves and fittings.
A unique feature is that the component equations and the media models
as well as pressure loss and heat transfer correlations are decoupled from each other.
All components are implemented such that they can be used for
media from the Modelica.Media library. This means especially that an
incompressible or compressible medium, a single or a multiple
substance medium with one or more phases might be used.
</p>

<p>
In the next figure, several features of the library are demonstrated with
a simple heating system with a closed flow cycle. By just changing one configuration parameter in the system object the equations are changed between steady-state and dynamic simulation with fixed or steady-state initial conditions.
</p>

<img src=\"modelica://Modelica/Resources/Images/Fluid/UsersGuide/HeatingSystem.png\" border=1>

<p>
With respect to previous versions, the design
of the connectors has been changed in a non-backward compatible way,
using the recently developed concept
of stream connectors that results in much more reliable simulations
(see also <a href=\"modelica://Modelica/Resources/Documentation/Fluid/Stream-Connectors-Overview-Rationale.pdf\">Stream-Connectors-Overview-Rationale.pdf</a>).
This extension was included in Modelica 3.1.
As of Jan. 2009, the stream concept is supported in Dymola 7.1.
It is recommended to use Dymola 7.2 (available since Feb. 2009), or a later Dymola version,
since this version supports a new annotation to connect very
conveniently to vectors of connectors.
Other tool vendors will support the stream concept as well.
</p>

<p>
The following parts are useful, when newly starting with this library:
</p>
<ul>
<li> <a href=\"modelica://Modelica.Fluid.UsersGuide\">Modelica.Fluid.UsersGuide</a>.</li>
<li> <a href=\"modelica://Modelica.Fluid.UsersGuide.ReleaseNotes\">Modelica.Fluid.UsersGuide.ReleaseNotes</a>
     summarizes the changes of the library releases.</li>
<li> <a href=\"modelica://Modelica.Fluid.Examples\">Modelica.Fluid.Examples</a>
     contains examples that demonstrate the usage of this library.</li>
</ul>
<p>
<b>Licensed by the Modelica Association under the Modelica License 2</b><br>
Copyright &copy; 2002-2010, ABB, DLR, Dassault Syst&egrave;mes AB, Modelon, TU Braunschweig, TU Hamburg-Harburg, Politecnico di Milano.
</p>
<p>
<i>This Modelica package is <u>free</u> software and the use is completely at <u>your own risk</u>; it can be redistributed and/or modified under the terms of the Modelica License 2. For license conditions (including the disclaimer of warranty) see <a href=\"modelica://Modelica.UsersGuide.ModelicaLicense2\">Modelica.UsersGuide.ModelicaLicense2</a> or visit <a href=\"http://www.modelica.org/licenses/ModelicaLicense2\"> http://www.modelica.org/licenses/ModelicaLicense2</a>.</i>
</p>
</html>"));
  end Fluid;

  package Media "Library of media property models"
  extends Modelica.Icons.Package;
  import SI = Modelica.SIunits;

  package Interfaces "Interfaces for media models"
    extends Modelica.Icons.InterfacesPackage;
    import SI = Modelica.SIunits;

    partial package PartialMedium
    "Partial medium properties (base package of all media packages)"

      import SI = Modelica.SIunits;
      extends Modelica.Icons.MaterialPropertiesPackage;

      // Constants to be set in Medium
      constant
      Modelica.Media.Interfaces.PartialMedium.Choices.IndependentVariables
        ThermoStates "Enumeration type for independent variables";
      constant String mediumName = "unusablePartialMedium" "Name of the medium";
      constant String substanceNames[:]={mediumName}
      "Names of the mixture substances. Set substanceNames={mediumName} if only one substance.";
      constant String extraPropertiesNames[:]=fill("", 0)
      "Names of the additional (extra) transported properties. Set extraPropertiesNames=fill(\"\",0) if unused";
      constant Boolean singleState
      "= true, if u and d are not a function of pressure";
      constant Boolean reducedX=true
      "= true if medium contains the equation sum(X) = 1.0; set reducedX=true if only one substance (see docu for details)";
      constant Boolean fixedX=false
      "= true if medium contains the equation X = reference_X";
      constant AbsolutePressure reference_p=101325
      "Reference pressure of Medium: default 1 atmosphere";
      constant Temperature reference_T=298.15
      "Reference temperature of Medium: default 25 deg Celsius";
      constant MassFraction reference_X[nX]= fill(1/nX, nX)
      "Default mass fractions of medium";
      constant AbsolutePressure p_default=101325
      "Default value for pressure of medium (for initialization)";
      constant Temperature T_default = Modelica.SIunits.Conversions.from_degC(20)
      "Default value for temperature of medium (for initialization)";
      constant SpecificEnthalpy h_default = specificEnthalpy_pTX(p_default, T_default, X_default)
      "Default value for specific enthalpy of medium (for initialization)";
      constant MassFraction X_default[nX]=reference_X
      "Default value for mass fractions of medium (for initialization)";

      final constant Integer nS=size(substanceNames, 1) "Number of substances" annotation(Evaluate=true);
      constant Integer nX = nS "Number of mass fractions"
                                   annotation(Evaluate=true);
      constant Integer nXi=if fixedX then 0 else if reducedX then nS - 1 else nS
      "Number of structurally independent mass fractions (see docu for details)"
        annotation(Evaluate=true);

      final constant Integer nC=size(extraPropertiesNames, 1)
      "Number of extra (outside of standard mass-balance) transported properties"
       annotation(Evaluate=true);
      constant Real C_nominal[nC](min=fill(Modelica.Constants.eps, nC)) = 1.0e-6*ones(nC)
      "Default for the nominal values for the extra properties";
      replaceable record FluidConstants
      "critical, triple, molecular and other standard data of fluid"
        extends Modelica.Icons.Record;
        String iupacName
        "complete IUPAC name (or common name, if non-existent)";
        String casRegistryNumber
        "chemical abstracts sequencing number (if it exists)";
        String chemicalFormula
        "Chemical formula, (brutto, nomenclature according to Hill";
        String structureFormula "Chemical structure formula";
        MolarMass molarMass "molar mass";
      end FluidConstants;

      replaceable record ThermodynamicState
      "Minimal variable set that is available as input argument to every medium function"
        extends Modelica.Icons.Record;
      end ThermodynamicState;

      replaceable partial model BaseProperties
      "Base properties (p, d, T, h, u, R, MM and, if applicable, X and Xi) of a medium"
        InputAbsolutePressure p "Absolute pressure of medium";
        InputMassFraction[nXi] Xi(start=reference_X[1:nXi])
        "Structurally independent mass fractions";
        InputSpecificEnthalpy h "Specific enthalpy of medium";
        Density d "Density of medium";
        Temperature T "Temperature of medium";
        MassFraction[nX] X(start=reference_X)
        "Mass fractions (= (component mass)/total mass  m_i/m)";
        SpecificInternalEnergy u "Specific internal energy of medium";
        SpecificHeatCapacity R "Gas constant (of mixture if applicable)";
        MolarMass MM "Molar mass (of mixture or single fluid)";
        ThermodynamicState state
        "thermodynamic state record for optional functions";
        parameter Boolean preferredMediumStates=false
        "= true if StateSelect.prefer shall be used for the independent property variables of the medium"
          annotation (Evaluate=true, Dialog(tab="Advanced"));
        parameter Boolean standardOrderComponents = true
        "if true, and reducedX = true, the last element of X will be computed from the other ones";
        SI.Conversions.NonSIunits.Temperature_degC T_degC=
            Modelica.SIunits.Conversions.to_degC(T)
        "Temperature of medium in [degC]";
        SI.Conversions.NonSIunits.Pressure_bar p_bar=
         Modelica.SIunits.Conversions.to_bar(p)
        "Absolute pressure of medium in [bar]";

        // Local connector definition, used for equation balancing check
        connector InputAbsolutePressure = input SI.AbsolutePressure
        "Pressure as input signal connector";
        connector InputSpecificEnthalpy = input SI.SpecificEnthalpy
        "Specific enthalpy as input signal connector";
        connector InputMassFraction = input SI.MassFraction
        "Mass fraction as input signal connector";

      equation
        if standardOrderComponents then
          Xi = X[1:nXi];

            if fixedX then
              X = reference_X;
            end if;
            if reducedX and not fixedX then
              X[nX] = 1 - sum(Xi);
            end if;
            for i in 1:nX loop
              assert(X[i] >= -1.e-5 and X[i] <= 1 + 1.e-5, "Mass fraction X[" +
                     String(i) + "] = " + String(X[i]) + "of substance "
                     + substanceNames[i] + "\nof medium " + mediumName + " is not in the range 0..1");
            end for;

        end if;

        assert(p >= 0.0, "Pressure (= " + String(p) + " Pa) of medium \"" +
          mediumName + "\" is negative\n(Temperature = " + String(T) + " K)");
        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Rectangle(
                extent={{-100,100},{100,-100}},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,255}), Text(
                extent={{-152,164},{152,102}},
                textString="%name",
                lineColor={0,0,255})}),
                    Documentation(info="<html>
<p>
Model <b>BaseProperties</b> is a model within package <b>PartialMedium</b>
and contains the <b>declarations</b> of the minimum number of
variables that every medium model is supposed to support.
A specific medium inherits from model <b>BaseProperties</b> and provides
the equations for the basic properties.</p>
<p>
The BaseProperties model contains the following <b>7+nXi variables</b>
(nXi is the number of independent mass fractions defined in package
PartialMedium):
</p>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><td valign=\"top\"><b>Variable</b></td>
      <td valign=\"top\"><b>Unit</b></td>
      <td valign=\"top\"><b>Description</b></td></tr>
  <tr><td valign=\"top\">T</td>
      <td valign=\"top\">K</td>
      <td valign=\"top\">temperature</td></tr>
  <tr><td valign=\"top\">p</td>
      <td valign=\"top\">Pa</td>
      <td valign=\"top\">absolute pressure</td></tr>
  <tr><td valign=\"top\">d</td>
      <td valign=\"top\">kg/m3</td>
      <td valign=\"top\">density</td></tr>
  <tr><td valign=\"top\">h</td>
      <td valign=\"top\">J/kg</td>
      <td valign=\"top\">specific enthalpy</td></tr>
  <tr><td valign=\"top\">u</td>
      <td valign=\"top\">J/kg</td>
      <td valign=\"top\">specific internal energy</td></tr>
  <tr><td valign=\"top\">Xi[nXi]</td>
      <td valign=\"top\">kg/kg</td>
      <td valign=\"top\">independent mass fractions m_i/m</td></tr>
  <tr><td valign=\"top\">R</td>
      <td valign=\"top\">J/kg.K</td>
      <td valign=\"top\">gas constant</td></tr>
  <tr><td valign=\"top\">M</td>
      <td valign=\"top\">kg/mol</td>
      <td valign=\"top\">molar mass</td></tr>
</table>
<p>
In order to implement an actual medium model, one can extend from this
base model and add <b>5 equations</b> that provide relations among
these variables. Equations will also have to be added in order to
set all the variables within the ThermodynamicState record state.</p>
<p>
If standardOrderComponents=true, the full composition vector X[nX]
is determined by the equations contained in this base class, depending
on the independent mass fraction vector Xi[nXi].</p>
<p>Additional <b>2 + nXi</b> equations will have to be provided
when using the BaseProperties model, in order to fully specify the
thermodynamic conditions. The input connector qualifier applied to
p, h, and nXi indirectly declares the number of missing equations,
permitting advanced equation balance checking by Modelica tools.
Please note that this doesn't mean that the additional equations
should be connection equations, nor that exactly those variables
should be supplied, in order to complete the model.
For further information, see the Modelica.Media User's guide, and
Section 4.7 (Balanced Models) of the Modelica 3.0 specification.</p>
</html>"));
      end BaseProperties;

      replaceable partial function setState_pTX
      "Return thermodynamic state as function of p, T and composition X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input Temperature T "Temperature";
        input MassFraction X[:]=reference_X "Mass fractions";
        output ThermodynamicState state "thermodynamic state record";
      end setState_pTX;

      replaceable partial function setState_phX
      "Return thermodynamic state as function of p, h and composition X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        input MassFraction X[:]=reference_X "Mass fractions";
        output ThermodynamicState state "thermodynamic state record";
      end setState_phX;

      replaceable partial function setState_psX
      "Return thermodynamic state as function of p, s and composition X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEntropy s "Specific entropy";
        input MassFraction X[:]=reference_X "Mass fractions";
        output ThermodynamicState state "thermodynamic state record";
      end setState_psX;

      replaceable partial function setState_dTX
      "Return thermodynamic state as function of d, T and composition X or Xi"
        extends Modelica.Icons.Function;
        input Density d "density";
        input Temperature T "Temperature";
        input MassFraction X[:]=reference_X "Mass fractions";
        output ThermodynamicState state "thermodynamic state record";
      end setState_dTX;

      replaceable partial function setSmoothState
      "Return thermodynamic state so that it smoothly approximates: if x > 0 then state_a else state_b"
        extends Modelica.Icons.Function;
        input Real x "m_flow or dp";
        input ThermodynamicState state_a "Thermodynamic state if x > 0";
        input ThermodynamicState state_b "Thermodynamic state if x < 0";
        input Real x_small(min=0)
        "Smooth transition in the region -x_small < x < x_small";
        output ThermodynamicState state
        "Smooth thermodynamic state for all x (continuous and differentiable)";
        annotation(Documentation(info="<html>
<p>
This function is used to approximate the equation
</p>
<pre>
    state = <b>if</b> x &gt; 0 <b>then</b> state_a <b>else</b> state_b;
</pre>

<p>
by a smooth characteristic, so that the expression is continuous and differentiable:
</p>

<pre>
   state := <b>smooth</b>(1, <b>if</b> x &gt;  x_small <b>then</b> state_a <b>else</b>
                      <b>if</b> x &lt; -x_small <b>then</b> state_b <b>else</b> f(state_a, state_b));
</pre>

<p>
This is performed by applying function <b>Media.Common.smoothStep</b>(..)
on every element of the thermodynamic state record.
</p>

<p>
If <b>mass fractions</b> X[:] are approximated with this function then this can be performed
for all <b>nX</b> mass fractions, instead of applying it for nX-1 mass fractions and computing
the last one by the mass fraction constraint sum(X)=1. The reason is that the approximating function has the
property that sum(state.X) = 1, provided sum(state_a.X) = sum(state_b.X) = 1.
This can be shown by evaluating the approximating function in the abs(x) &lt; x_small
region (otherwise state.X is either state_a.X or state_b.X):
</p>

<pre>
    X[1]  = smoothStep(x, X_a[1] , X_b[1] , x_small);
    X[2]  = smoothStep(x, X_a[2] , X_b[2] , x_small);
       ...
    X[nX] = smoothStep(x, X_a[nX], X_b[nX], x_small);
</pre>

<p>
or
</p>

<pre>
    X[1]  = c*(X_a[1]  - X_b[1])  + (X_a[1]  + X_b[1])/2
    X[2]  = c*(X_a[2]  - X_b[2])  + (X_a[2]  + X_b[2])/2;
       ...
    X[nX] = c*(X_a[nX] - X_b[nX]) + (X_a[nX] + X_b[nX])/2;
    c     = (x/x_small)*((x/x_small)^2 - 3)/4
</pre>

<p>
Summing all mass fractions together results in
</p>

<pre>
    sum(X) = c*(sum(X_a) - sum(X_b)) + (sum(X_a) + sum(X_b))/2
           = c*(1 - 1) + (1 + 1)/2
           = 1
</pre>

</html>"));
      end setSmoothState;

      replaceable partial function dynamicViscosity "Return dynamic viscosity"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "thermodynamic state record";
        output DynamicViscosity eta "Dynamic viscosity";
      end dynamicViscosity;

      replaceable partial function thermalConductivity
      "Return thermal conductivity"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "thermodynamic state record";
        output ThermalConductivity lambda "Thermal conductivity";
      end thermalConductivity;

      replaceable function prandtlNumber "Return the Prandtl number"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "thermodynamic state record";
        output PrandtlNumber Pr "Prandtl number";
      algorithm
        Pr := dynamicViscosity(state)*specificHeatCapacityCp(state)/thermalConductivity(
          state);
      end prandtlNumber;

      replaceable partial function pressure "Return pressure"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "thermodynamic state record";
        output AbsolutePressure p "Pressure";
      end pressure;

      replaceable partial function temperature "Return temperature"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "thermodynamic state record";
        output Temperature T "Temperature";
      end temperature;

      replaceable partial function density "Return density"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "thermodynamic state record";
        output Density d "Density";
      end density;

      replaceable partial function specificEnthalpy "Return specific enthalpy"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "thermodynamic state record";
        output SpecificEnthalpy h "Specific enthalpy";
      end specificEnthalpy;

      replaceable partial function specificInternalEnergy
      "Return specific internal energy"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "thermodynamic state record";
        output SpecificEnergy u "Specific internal energy";
      end specificInternalEnergy;

      replaceable partial function specificEntropy "Return specific entropy"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "thermodynamic state record";
        output SpecificEntropy s "Specific entropy";
      end specificEntropy;

      replaceable partial function specificGibbsEnergy
      "Return specific Gibbs energy"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "thermodynamic state record";
        output SpecificEnergy g "Specific Gibbs energy";
      end specificGibbsEnergy;

      replaceable partial function specificHelmholtzEnergy
      "Return specific Helmholtz energy"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "thermodynamic state record";
        output SpecificEnergy f "Specific Helmholtz energy";
      end specificHelmholtzEnergy;

      replaceable partial function specificHeatCapacityCp
      "Return specific heat capacity at constant pressure"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "thermodynamic state record";
        output SpecificHeatCapacity cp
        "Specific heat capacity at constant pressure";
      end specificHeatCapacityCp;

      function heatCapacity_cp = specificHeatCapacityCp
      "alias for deprecated name";

      replaceable partial function specificHeatCapacityCv
      "Return specific heat capacity at constant volume"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "thermodynamic state record";
        output SpecificHeatCapacity cv
        "Specific heat capacity at constant volume";
      end specificHeatCapacityCv;

      function heatCapacity_cv = specificHeatCapacityCv
      "alias for deprecated name";

      replaceable partial function isentropicExponent
      "Return isentropic exponent"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "thermodynamic state record";
        output IsentropicExponent gamma "Isentropic exponent";
      end isentropicExponent;

      replaceable partial function isentropicEnthalpy
      "Return isentropic enthalpy"
        extends Modelica.Icons.Function;
        input AbsolutePressure p_downstream "downstream pressure";
        input ThermodynamicState refState "reference state for entropy";
        output SpecificEnthalpy h_is "Isentropic enthalpy";
        annotation(Documentation(info="<html>
<p>
This function computes an isentropic state transformation:
</p>
<ol>
<li> A medium is in a particular state, refState.</li>
<li> The enhalpy at another state (h_is) shall be computed
     under the assumption that the state transformation from refState to h_is
     is performed with a change of specific entropy ds = 0 and the pressure of state h_is
     is p_downstream and the composition X upstream and downstream is assumed to be the same.</li>
</ol>

</html>"));
      end isentropicEnthalpy;

      replaceable partial function velocityOfSound "Return velocity of sound"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "thermodynamic state record";
        output VelocityOfSound a "Velocity of sound";
      end velocityOfSound;

      replaceable partial function isobaricExpansionCoefficient
      "Return overall the isobaric expansion coefficient beta"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "thermodynamic state record";
        output IsobaricExpansionCoefficient beta
        "Isobaric expansion coefficient";
        annotation(Documentation(info="<html>
<pre>
beta is defined as  1/v * der(v,T), with v = 1/d, at constant pressure p.
</pre>
</html>"));
      end isobaricExpansionCoefficient;

      function beta = isobaricExpansionCoefficient
      "alias for isobaricExpansionCoefficient for user convenience";

      replaceable partial function isothermalCompressibility
      "Return overall the isothermal compressibility factor"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "thermodynamic state record";
        output SI.IsothermalCompressibility kappa "Isothermal compressibility";
        annotation(Documentation(info="<html>
<pre>

kappa is defined as - 1/v * der(v,p), with v = 1/d at constant temperature T.

</pre>
</html>"));
      end isothermalCompressibility;

      function kappa = isothermalCompressibility
      "alias of isothermalCompressibility for user convenience";

      // explicit derivative functions for finite element models
      replaceable partial function density_derp_h
      "Return density derivative w.r.t. pressure at const specific enthalpy"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "thermodynamic state record";
        output DerDensityByPressure ddph "Density derivative w.r.t. pressure";
      end density_derp_h;

      replaceable partial function density_derh_p
      "Return density derivative w.r.t. specific enthalpy at constant pressure"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "thermodynamic state record";
        output DerDensityByEnthalpy ddhp
        "Density derivative w.r.t. specific enthalpy";
      end density_derh_p;

      replaceable partial function density_derp_T
      "Return density derivative w.r.t. pressure at const temperature"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "thermodynamic state record";
        output DerDensityByPressure ddpT "Density derivative w.r.t. pressure";
      end density_derp_T;

      replaceable partial function density_derT_p
      "Return density derivative w.r.t. temperature at constant pressure"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "thermodynamic state record";
        output DerDensityByTemperature ddTp
        "Density derivative w.r.t. temperature";
      end density_derT_p;

      replaceable partial function density_derX
      "Return density derivative w.r.t. mass fraction"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "thermodynamic state record";
        output Density[nX] dddX "Derivative of density w.r.t. mass fraction";
      end density_derX;

      replaceable partial function molarMass
      "Return the molar mass of the medium"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "thermodynamic state record";
        output MolarMass MM "Mixture molar mass";
      end molarMass;

      replaceable function specificEnthalpy_pTX
      "Return specific enthalpy from p, T, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input Temperature T "Temperature";
        input MassFraction X[:]=reference_X "Mass fractions";
        output SpecificEnthalpy h "Specific enthalpy";
      algorithm
        h := specificEnthalpy(setState_pTX(p,T,X));
        annotation(inverse(T = temperature_phX(p,h,X)));
      end specificEnthalpy_pTX;

      replaceable function specificEntropy_pTX
      "Return specific enthalpy from p, T, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input Temperature T "Temperature";
        input MassFraction X[:]=reference_X "Mass fractions";
        output SpecificEntropy s "Specific entropy";
      algorithm
        s := specificEntropy(setState_pTX(p,T,X));

        annotation(inverse(T = temperature_psX(p,s,X)));
      end specificEntropy_pTX;

      replaceable function density_pTX "Return density from p, T, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input Temperature T "Temperature";
        input MassFraction X[:] "Mass fractions";
        output Density d "Density";
      algorithm
        d := density(setState_pTX(p,T,X));
      end density_pTX;

      replaceable function temperature_phX
      "Return temperature from p, h, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        input MassFraction X[:]=reference_X "Mass fractions";
        output Temperature T "Temperature";
      algorithm
        T := temperature(setState_phX(p,h,X));
      end temperature_phX;

      replaceable function density_phX "Return density from p, h, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        input MassFraction X[:]=reference_X "Mass fractions";
        output Density d "Density";
      algorithm
        d := density(setState_phX(p,h,X));
      end density_phX;

      replaceable function temperature_psX
      "Return temperature from p,s, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEntropy s "Specific entropy";
        input MassFraction X[:]=reference_X "Mass fractions";
        output Temperature T "Temperature";
      algorithm
        T := temperature(setState_psX(p,s,X));
        annotation(inverse(s = specificEntropy_pTX(p,T,X)));
      end temperature_psX;

      replaceable function density_psX "Return density from p, s, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEntropy s "Specific entropy";
        input MassFraction X[:]=reference_X "Mass fractions";
        output Density d "Density";
      algorithm
        d := density(setState_psX(p,s,X));
      end density_psX;

      replaceable function specificEnthalpy_psX
      "Return specific enthalpy from p, s, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEntropy s "Specific entropy";
        input MassFraction X[:]=reference_X "Mass fractions";
        output SpecificEnthalpy h "Specific enthalpy";
      algorithm
        h := specificEnthalpy(setState_psX(p,s,X));
      end specificEnthalpy_psX;

      type AbsolutePressure = SI.AbsolutePressure (
          min=0,
          max=1.e8,
          nominal=1.e5,
          start=1.e5)
      "Type for absolute pressure with medium specific attributes";

      type Density = SI.Density (
          min=0,
          max=1.e5,
          nominal=1,
          start=1) "Type for density with medium specific attributes";
      type DynamicViscosity = SI.DynamicViscosity (
          min=0,
          max=1.e8,
          nominal=1.e-3,
          start=1.e-3)
      "Type for dynamic viscosity with medium specific attributes";
      type EnthalpyFlowRate = SI.EnthalpyFlowRate (
          nominal=1000.0,
          min=-1.0e8,
          max=1.e8)
      "Type for enthalpy flow rate with medium specific attributes";
      type MassFlowRate = SI.MassFlowRate (
          quantity="MassFlowRate." + mediumName,
          min=-1.0e5,
          max=1.e5) "Type for mass flow rate with medium specific attributes";
      type MassFraction = Real (
          quantity="MassFraction",
          final unit="kg/kg",
          min=0,
          max=1,
          nominal=0.1) "Type for mass fraction with medium specific attributes";
      type MoleFraction = Real (
          quantity="MoleFraction",
          final unit="mol/mol",
          min=0,
          max=1,
          nominal=0.1) "Type for mole fraction with medium specific attributes";
      type MolarMass = SI.MolarMass (
          min=0.001,
          max=0.25,
          nominal=0.032) "Type for molar mass with medium specific attributes";
      type MolarVolume = SI.MolarVolume (
          min=1e-6,
          max=1.0e6,
          nominal=1.0) "Type for molar volume with medium specific attributes";
      type IsentropicExponent = SI.RatioOfSpecificHeatCapacities (
          min=1,
          max=500000,
          nominal=1.2,
          start=1.2)
      "Type for isentropic exponent with medium specific attributes";
      type SpecificEnergy = SI.SpecificEnergy (
          min=-1.0e8,
          max=1.e8,
          nominal=1.e6)
      "Type for specific energy with medium specific attributes";
      type SpecificInternalEnergy = SpecificEnergy
      "Type for specific internal energy with medium specific attributes";
      type SpecificEnthalpy = SI.SpecificEnthalpy (
          min=-1.0e10,
          max=1.e10,
          nominal=1.e6)
      "Type for specific enthalpy with medium specific attributes";
      type SpecificEntropy = SI.SpecificEntropy (
          min=-1.e7,
          max=1.e7,
          nominal=1.e3)
      "Type for specific entropy with medium specific attributes";
      type SpecificHeatCapacity = SI.SpecificHeatCapacity (
          min=0,
          max=1.e7,
          nominal=1.e3,
          start=1.e3)
      "Type for specific heat capacity with medium specific attributes";
      type SurfaceTension = SI.SurfaceTension
      "Type for surface tension with medium specific attributes";
      type Temperature = SI.Temperature (
          min=1,
          max=1.e4,
          nominal=300,
          start=300) "Type for temperature with medium specific attributes";
      type ThermalConductivity = SI.ThermalConductivity (
          min=0,
          max=500,
          nominal=1,
          start=1)
      "Type for thermal conductivity with medium specific attributes";
      type PrandtlNumber = SI.PrandtlNumber (
          min=1e-3,
          max=1e5,
          nominal=1.0)
      "Type for Prandtl number with medium specific attributes";
      type VelocityOfSound = SI.Velocity (
          min=0,
          max=1.e5,
          nominal=1000,
          start=1000)
      "Type for velocity of sound with medium specific attributes";
      type ExtraProperty = Real (min=0.0, start=1.0)
      "Type for unspecified, mass-specific property transported by flow";
      type CumulativeExtraProperty = Real (min=0.0, start=1.0)
      "Type for conserved integral of unspecified, mass specific property";
      type ExtraPropertyFlowRate = Real(unit="kg/s")
      "Type for flow rate of unspecified, mass-specific property";
      type IsobaricExpansionCoefficient = Real (
          min=0,
          max=1.0e8,
          unit="1/K")
      "Type for isobaric expansion coefficient with medium specific attributes";
      type DipoleMoment = Real (
          min=0.0,
          max=2.0,
          unit="debye",
          quantity="ElectricDipoleMoment")
      "Type for dipole moment with medium specific attributes";

      type DerDensityByPressure = SI.DerDensityByPressure
      "Type for partial derivative of density with resect to pressure with medium specific attributes";
      type DerDensityByEnthalpy = SI.DerDensityByEnthalpy
      "Type for partial derivative of density with resect to enthalpy with medium specific attributes";
      type DerEnthalpyByPressure = SI.DerEnthalpyByPressure
      "Type for partial derivative of enthalpy with resect to pressure with medium specific attributes";
      type DerDensityByTemperature = SI.DerDensityByTemperature
      "Type for partial derivative of density with resect to temperature with medium specific attributes";

      package Choices "Types, constants to define menu choices"

        type IndependentVariables = enumeration(
          T "Temperature",
          pT "Pressure, Temperature",
          ph "Pressure, Specific Enthalpy",
          phX "Pressure, Specific Enthalpy, Mass Fraction",
          pTX "Pressure, Temperature, Mass Fractions",
          dTX "Density, Temperature, Mass Fractions")
        "Enumeration defining the independent variables of a medium";

        type Init = enumeration(
          NoInit "NoInit (no initialization)",
          InitialStates "InitialStates (initialize medium states)",
          SteadyState "SteadyState (initialize in steady state)",
          SteadyMass
            "SteadyMass (initialize density or pressure in steady state)")
        "Enumeration defining initialization for fluid flow"
                  annotation (Evaluate=true);

        type ReferenceEnthalpy = enumeration(
          ZeroAt0K
            "The enthalpy is 0 at 0 K (default), if the enthalpy of formation is excluded",

          ZeroAt25C
            "The enthalpy is 0 at 25 degC, if the enthalpy of formation is excluded",

          UserDefined
            "The user-defined reference enthalpy is used at 293.15 K (25 degC)")
        "Enumeration defining the reference enthalpy of a medium"
            annotation (Evaluate=true);

        type ReferenceEntropy = enumeration(
          ZeroAt0K "The entropy is 0 at 0 K (default)",
          ZeroAt0C "The entropy is 0 at 0 degC",
          UserDefined
            "The user-defined reference entropy is used at 293.15 K (25 degC)")
        "Enumeration defining the reference entropy of a medium"
            annotation (Evaluate=true);

        type pd = enumeration(
          default "Default (no boundary condition for p or d)",
          p_known "p_known (pressure p is known)",
          d_known "d_known (density d is known)")
        "Enumeration defining whether p or d are known for the boundary condition"
            annotation (Evaluate=true);

        type Th = enumeration(
          default "Default (no boundary condition for T or h)",
          T_known "T_known (temperature T is known)",
          h_known "h_known (specific enthalpy h is known)")
        "Enumeration defining whether T or h are known as boundary condition"
            annotation (Evaluate=true);

        annotation (Documentation(info="<html>
<p>
Enumerations and data types for all types of fluids
</p>

<p>
Note: Reference enthalpy might have to be extended with enthalpy of formation.
</p>
</html>"));
      end Choices;

      annotation (Documentation(info="<html>
<p>
<b>PartialMedium</b> is a package and contains all <b>declarations</b> for
a medium. This means that constants, models, and functions
are defined that every medium is supposed to support
(some of them are optional). A medium package
inherits from <b>PartialMedium</b> and provides the
equations for the medium. The details of this package
are described in
<a href=\"modelica://Modelica.Media.UsersGuide\">Modelica.Media.UsersGuide</a>.
</p>
</html>
",   revisions="<html>

</html>"));
    end PartialMedium;

    partial package PartialPureSubstance
    "base class for pure substances of one chemical substance"
      extends PartialMedium(final reducedX = true, final fixedX=true);

     replaceable function setState_pT "Return thermodynamic state from p and T"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input Temperature T "Temperature";
        output ThermodynamicState state "thermodynamic state record";
     algorithm
        state := setState_pTX(p,T,fill(0,0));
     end setState_pT;

      replaceable function setState_ph
      "Return thermodynamic state from p and h"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        output ThermodynamicState state "thermodynamic state record";
      algorithm
        state := setState_phX(p,h,fill(0, 0));
      end setState_ph;

      replaceable function setState_ps
      "Return thermodynamic state from p and s"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEntropy s "Specific entropy";
        output ThermodynamicState state "thermodynamic state record";
      algorithm
        state := setState_psX(p,s,fill(0,0));
      end setState_ps;

      replaceable function setState_dT
      "Return thermodynamic state from d and T"
        extends Modelica.Icons.Function;
        input Density d "density";
        input Temperature T "Temperature";
        output ThermodynamicState state "thermodynamic state record";
      algorithm
        state := setState_dTX(d,T,fill(0,0));
      end setState_dT;

      replaceable function density_ph "Return density from p and h"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        output Density d "Density";
      algorithm
        d := density_phX(p, h, fill(0,0));
      end density_ph;

      replaceable function temperature_ph "Return temperature from p and h"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        output Temperature T "Temperature";
      algorithm
        T := temperature_phX(p, h, fill(0,0));
      end temperature_ph;

      replaceable function pressure_dT "Return pressure from d and T"
        extends Modelica.Icons.Function;
        input Density d "Density";
        input Temperature T "Temperature";
        output AbsolutePressure p "Pressure";
      algorithm
        p := pressure(setState_dTX(d, T, fill(0,0)));
      end pressure_dT;

      replaceable function specificEnthalpy_dT
      "Return specific enthalpy from d and T"
        extends Modelica.Icons.Function;
        input Density d "Density";
        input Temperature T "Temperature";
        output SpecificEnthalpy h "specific enthalpy";
      algorithm
        h := specificEnthalpy(setState_dTX(d, T, fill(0,0)));
      end specificEnthalpy_dT;

      replaceable function specificEnthalpy_ps
      "Return specific enthalpy from p and s"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEntropy s "Specific entropy";
        output SpecificEnthalpy h "specific enthalpy";
      algorithm
        h := specificEnthalpy_psX(p,s,fill(0,0));
      end specificEnthalpy_ps;

      replaceable function temperature_ps "Return temperature from p and s"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEntropy s "Specific entropy";
        output Temperature T "Temperature";
      algorithm
        T := temperature_psX(p,s,fill(0,0));
      end temperature_ps;

      replaceable function density_ps "Return density from p and s"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEntropy s "Specific entropy";
        output Density d "Density";
      algorithm
        d := density_psX(p, s, fill(0,0));
      end density_ps;

      replaceable function specificEnthalpy_pT
      "Return specific enthalpy from p and T"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input Temperature T "Temperature";
        output SpecificEnthalpy h "specific enthalpy";
      algorithm
        h := specificEnthalpy_pTX(p, T, fill(0,0));
      end specificEnthalpy_pT;

      replaceable function density_pT "Return density from p and T"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input Temperature T "Temperature";
        output Density d "Density";
      algorithm
        d := density(setState_pTX(p, T, fill(0,0)));
      end density_pT;

      redeclare replaceable partial model extends BaseProperties(
        final standardOrderComponents=true)
      end BaseProperties;
    end PartialPureSubstance;

  partial package PartialMixtureMedium
    "Base class for pure substances of several chemical substances"
      extends PartialMedium;

      redeclare replaceable record extends ThermodynamicState
      "thermodynamic state variables"
        AbsolutePressure p "Absolute pressure of medium";
        Temperature T "Temperature of medium";
        MassFraction X[nX]
        "Mass fractions (= (component mass)/total mass  m_i/m)";
      end ThermodynamicState;

      redeclare replaceable record extends FluidConstants
      "extended fluid constants"
        Temperature criticalTemperature "critical temperature";
        AbsolutePressure criticalPressure "critical pressure";
        MolarVolume criticalMolarVolume "critical molar Volume";
        Real acentricFactor "Pitzer acentric factor";
        Temperature triplePointTemperature "triple point temperature";
        AbsolutePressure triplePointPressure "triple point pressure";
        Temperature meltingPoint "melting point at 101325 Pa";
        Temperature normalBoilingPoint "normal boiling point (at 101325 Pa)";
        DipoleMoment dipoleMoment
        "dipole moment of molecule in Debye (1 debye = 3.33564e10-30 C.m)";
        Boolean hasIdealGasHeatCapacity=false
        "true if ideal gas heat capacity is available";
        Boolean hasCriticalData=false "true if critical data are known";
        Boolean hasDipoleMoment=false "true if a dipole moment known";
        Boolean hasFundamentalEquation=false "true if a fundamental equation";
        Boolean hasLiquidHeatCapacity=false
        "true if liquid heat capacity is available";
        Boolean hasSolidHeatCapacity=false
        "true if solid heat capacity is available";
        Boolean hasAccurateViscosityData=false
        "true if accurate data for a viscosity function is available";
        Boolean hasAccurateConductivityData=false
        "true if accurate data for thermal conductivity is available";
        Boolean hasVapourPressureCurve=false
        "true if vapour pressure data, e.g., Antoine coefficents are known";
        Boolean hasAcentricFactor=false
        "true if Pitzer accentric factor is known";
        SpecificEnthalpy HCRIT0=0.0
        "Critical specific enthalpy of the fundamental equation";
        SpecificEntropy SCRIT0=0.0
        "Critical specific entropy of the fundamental equation";
        SpecificEnthalpy deltah=0.0
        "Difference between specific enthalpy model (h_m) and f.eq. (h_f) (h_m - h_f)";
        SpecificEntropy deltas=0.0
        "Difference between specific enthalpy model (s_m) and f.eq. (s_f) (s_m - s_f)";
      end FluidConstants;

    constant FluidConstants[nS] fluidConstants "constant data for the fluid";

    replaceable function gasConstant
      "Return the gas constant of the mixture (also for liquids)"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "thermodynamic state";
        output SI.SpecificHeatCapacity R "mixture gas constant";
    end gasConstant;

      function moleToMassFractions
      "Return mass fractions X from mole fractions"
        extends Modelica.Icons.Function;
        input SI.MoleFraction moleFractions[:] "Mole fractions of mixture";
        input MolarMass[:] MMX "molar masses of components";
        output SI.MassFraction X[size(moleFractions, 1)]
        "Mass fractions of gas mixture";
    protected
        MolarMass Mmix =  moleFractions*MMX "molar mass of mixture";
      algorithm
        for i in 1:size(moleFractions, 1) loop
          X[i] := moleFractions[i]*MMX[i] /Mmix;
        end for;
        annotation(smoothOrder=5);
      end moleToMassFractions;

      function massToMoleFractions
      "Return mole fractions from mass fractions X"
        extends Modelica.Icons.Function;
        input SI.MassFraction X[:] "Mass fractions of mixture";
        input SI.MolarMass[:] MMX "molar masses of components";
        output SI.MoleFraction moleFractions[size(X, 1)]
        "Mole fractions of gas mixture";
    protected
        Real invMMX[size(X, 1)] "inverses of molar weights";
        SI.MolarMass Mmix "molar mass of mixture";
      algorithm
        for i in 1:size(X, 1) loop
          invMMX[i] := 1/MMX[i];
        end for;
        Mmix := 1/(X*invMMX);
        for i in 1:size(X, 1) loop
          moleFractions[i] := Mmix*X[i]/MMX[i];
        end for;
        annotation(smoothOrder=5);
      end massToMoleFractions;

  end PartialMixtureMedium;

    partial package PartialCondensingGases
    "Base class for mixtures of condensing and non-condensing gases"
      extends PartialMixtureMedium(
           ThermoStates = Choices.IndependentVariables.pTX);

    replaceable partial function saturationPressure
      "Return saturation pressure of condensing fluid"
      extends Modelica.Icons.Function;
      input Temperature Tsat "saturation temperature";
      output AbsolutePressure psat "saturation pressure";
    end saturationPressure;

    replaceable partial function enthalpyOfVaporization
      "Return vaporization enthalpy of condensing fluid"
      extends Modelica.Icons.Function;
      input Temperature T "temperature";
      output SpecificEnthalpy r0 "vaporization enthalpy";
    end enthalpyOfVaporization;

    replaceable partial function enthalpyOfLiquid
      "Return liquid enthalpy of condensing fluid"
      extends Modelica.Icons.Function;
      input Temperature T "temperature";
      output SpecificEnthalpy h "liquid enthalpy";
    end enthalpyOfLiquid;

    replaceable partial function enthalpyOfGas
      "Return enthalpy of non-condensing gas mixture"
      extends Modelica.Icons.Function;
      input Temperature T "temperature";
      input MassFraction[:] X "vector of mass fractions";
      output SpecificEnthalpy h "specific enthalpy";
    end enthalpyOfGas;

    replaceable partial function enthalpyOfCondensingGas
      "Return enthalpy of condensing gas (most often steam)"
      extends Modelica.Icons.Function;
      input Temperature T "temperature";
      output SpecificEnthalpy h "specific enthalpy";
    end enthalpyOfCondensingGas;

    replaceable partial function enthalpyOfNonCondensingGas
      "Return enthalpy of the non-condensing species"
      extends Modelica.Icons.Function;
      input Temperature T "temperature";
      output SpecificEnthalpy h "specific enthalpy";
    end enthalpyOfNonCondensingGas;
    end PartialCondensingGases;
    annotation (Documentation(info="<HTML>
<p>
This package provides basic interfaces definitions of media models for different
kind of media.
</p>
</HTML>"));
  end Interfaces;

  package Common
    "data structures and fundamental functions for fluid properties"
    extends Modelica.Icons.Package;

    function smoothStep
    "Approximation of a general step, such that the characteristic is continuous and differentiable"
      extends Modelica.Icons.Function;
      input Real x "Abszissa value";
      input Real y1 "Ordinate value for x > 0";
      input Real y2 "Ordinate value for x < 0";
      input Real x_small(min=0) = 1e-5
      "Approximation of step for -x_small <= x <= x_small; x_small > 0 required";
      output Real y
      "Ordinate value to approximate y = if x > 0 then y1 else y2";
    algorithm
      y := smooth(1, if x >  x_small then y1 else
                     if x < -x_small then y2 else
                     if abs(x_small)>0 then (x/x_small)*((x/x_small)^2 - 3)*(y2-y1)/4 + (y1+y2)/2 else (y1+y2)/2);

      annotation(Documentation(revisions="<html>
<ul>
<li><i>April 29, 2008</i>
    by <a href=\"mailto:Martin.Otter@DLR.de\">Martin Otter</a>:<br>
    Designed and implemented.</li>
<li><i>August 12, 2008</i>
    by <a href=\"mailto:Michael.Sielemann@dlr.de\">Michael Sielemann</a>:<br>
    Minor modification to cover the limit case <code>x_small -> 0</code> without division by zero.</li>
</ul>
</html>",   info="<html>
<p>
This function is used to approximate the equation
</p>
<pre>
    y = <b>if</b> x &gt; 0 <b>then</b> y1 <b>else</b> y2;
</pre>

<p>
by a smooth characteristic, so that the expression is continuous and differentiable:
</p>

<pre>
   y = <b>smooth</b>(1, <b>if</b> x &gt;  x_small <b>then</b> y1 <b>else</b>
                 <b>if</b> x &lt; -x_small <b>then</b> y2 <b>else</b> f(y1, y2));
</pre>

<p>
In the region -x_small &lt; x &lt; x_small a 2nd order polynomial is used
for a smooth transition from y1 to y2.
</p>

<p>
If <b>mass fractions</b> X[:] are approximated with this function then this can be performed
for all <b>nX</b> mass fractions, instead of applying it for nX-1 mass fractions and computing
the last one by the mass fraction constraint sum(X)=1. The reason is that the approximating function has the
property that sum(X) = 1, provided sum(X_a) = sum(X_b) = 1
(and y1=X_a[i], y2=X_b[i]).
This can be shown by evaluating the approximating function in the abs(x) &lt; x_small
region (otherwise X is either X_a or X_b):
</p>

<pre>
    X[1]  = smoothStep(x, X_a[1] , X_b[1] , x_small);
    X[2]  = smoothStep(x, X_a[2] , X_b[2] , x_small);
       ...
    X[nX] = smoothStep(x, X_a[nX], X_b[nX], x_small);
</pre>

<p>
or
</p>

<pre>
    X[1]  = c*(X_a[1]  - X_b[1])  + (X_a[1]  + X_b[1])/2
    X[2]  = c*(X_a[2]  - X_b[2])  + (X_a[2]  + X_b[2])/2;
       ...
    X[nX] = c*(X_a[nX] - X_b[nX]) + (X_a[nX] + X_b[nX])/2;
    c     = (x/x_small)*((x/x_small)^2 - 3)/4
</pre>

<p>
Summing all mass fractions together results in
</p>

<pre>
    sum(X) = c*(sum(X_a) - sum(X_b)) + (sum(X_a) + sum(X_b))/2
           = c*(1 - 1) + (1 + 1)/2
           = 1
</pre>
</html>"));
    end smoothStep;

   package OneNonLinearEquation
    "Determine solution of a non-linear algebraic equation in one unknown without derivatives in a reliable and efficient way"
     extends Modelica.Icons.Package;

      replaceable record f_nonlinear_Data
      "Data specific for function f_nonlinear"
        extends Modelica.Icons.Record;
      end f_nonlinear_Data;

      replaceable partial function f_nonlinear
      "Nonlinear algebraic equation in one unknown: y = f_nonlinear(x,p,X)"
        extends Modelica.Icons.Function;
        input Real x "Independent variable of function";
        input Real p = 0.0
        "disregaded variables (here always used for pressure)";
        input Real[:] X = fill(0,0)
        "disregaded variables (her always used for composition)";
        input f_nonlinear_Data f_nonlinear_data
        "Additional data for the function";
        output Real y "= f_nonlinear(x)";
        // annotation(derivative(zeroDerivative=y)); // this must hold for all replaced functions
      end f_nonlinear;

      replaceable function solve
      "Solve f_nonlinear(x_zero)=y_zero; f_nonlinear(x_min) - y_zero and f_nonlinear(x_max)-y_zero must have different sign"
        import Modelica.Utilities.Streams.error;
        extends Modelica.Icons.Function;
        input Real y_zero
        "Determine x_zero, such that f_nonlinear(x_zero) = y_zero";
        input Real x_min "Minimum value of x";
        input Real x_max "Maximum value of x";
        input Real pressure = 0.0
        "disregaded variables (here always used for pressure)";
        input Real[:] X = fill(0,0)
        "disregaded variables (here always used for composition)";
         input f_nonlinear_Data f_nonlinear_data
        "Additional data for function f_nonlinear";
         input Real x_tol =  100*Modelica.Constants.eps
        "Relative tolerance of the result";
         output Real x_zero "f_nonlinear(x_zero) = y_zero";
    protected
         constant Real eps = Modelica.Constants.eps "machine epsilon";
         constant Real x_eps = 1e-10
        "Slight modification of x_min, x_max, since x_min, x_max are usually exactly at the borders T_min/h_min and then small numeric noise may make the interval invalid";
         Real x_min2 = x_min - x_eps;
         Real x_max2 = x_max + x_eps;
         Real a = x_min2 "Current best minimum interval value";
         Real b = x_max2 "Current best maximum interval value";
         Real c "Intermediate point a <= c <= b";
         Real d;
         Real e "b - a";
         Real m;
         Real s;
         Real p;
         Real q;
         Real r;
         Real tol;
         Real fa "= f_nonlinear(a) - y_zero";
         Real fb "= f_nonlinear(b) - y_zero";
         Real fc;
         Boolean found = false;
      algorithm
         // Check that f(x_min) and f(x_max) have different sign
         fa :=f_nonlinear(x_min2, pressure, X, f_nonlinear_data) - y_zero;
         fb :=f_nonlinear(x_max2, pressure, X, f_nonlinear_data) - y_zero;
         fc := fb;
         if fa > 0.0 and fb > 0.0 or
            fa < 0.0 and fb < 0.0 then
            error("The arguments x_min and x_max to OneNonLinearEquation.solve(..)\n" +
                  "do not bracket the root of the single non-linear equation:\n" +
                  "  x_min  = " + String(x_min2) + "\n" +
                  "  x_max  = " + String(x_max2) + "\n" +
                  "  y_zero = " + String(y_zero) + "\n" +
                  "  fa = f(x_min) - y_zero = " + String(fa) + "\n" +
                  "  fb = f(x_max) - y_zero = " + String(fb) + "\n" +
                  "fa and fb must have opposite sign which is not the case");
         end if;

         // Initialize variables
         c :=a;
         fc :=fa;
         e :=b - a;
         d :=e;

         // Search loop
         while not found loop
            if abs(fc) < abs(fb) then
               a :=b;
               b :=c;
               c :=a;
               fa :=fb;
               fb :=fc;
               fc :=fa;
            end if;

            tol :=2*eps*abs(b) + x_tol;
            m :=(c - b)/2;

            if abs(m) <= tol or fb == 0.0 then
               // root found (interval is small enough)
               found :=true;
               x_zero :=b;
            else
               // Determine if a bisection is needed
               if abs(e) < tol or abs(fa) <= abs(fb) then
                  e :=m;
                  d :=e;
               else
                  s :=fb/fa;
                  if a == c then
                     // linear interpolation
                     p :=2*m*s;
                     q :=1 - s;
                  else
                     // inverse quadratic interpolation
                     q :=fa/fc;
                     r :=fb/fc;
                     p :=s*(2*m*q*(q - r) - (b - a)*(r - 1));
                     q :=(q - 1)*(r - 1)*(s - 1);
                  end if;

                  if p > 0 then
                     q :=-q;
                  else
                     p :=-p;
                  end if;

                  s :=e;
                  e :=d;
                  if 2*p < 3*m*q-abs(tol*q) and p < abs(0.5*s*q) then
                     // interpolation successful
                     d :=p/q;
                  else
                     // use bi-section
                     e :=m;
                     d :=e;
                  end if;
               end if;

               // Best guess value is defined as "a"
               a :=b;
               fa :=fb;
               b :=b + (if abs(d) > tol then d else if m > 0 then tol else -tol);
               fb :=f_nonlinear(b, pressure, X, f_nonlinear_data) - y_zero;

               if fb > 0 and fc > 0 or
                  fb < 0 and fc < 0 then
                  // initialize variables
                  c :=a;
                  fc :=fa;
                  e :=b - a;
                  d :=e;
               end if;
            end if;
         end while;
      end solve;

      annotation (Documentation(info="<html>
<p>
This function should currently only be used in Modelica.Media,
since it might be replaced in the future by another strategy,
where the tool is responsible for the solution of the non-linear
equation.
</p>

<p>
This library determines the solution of one non-linear algebraic equation \"y=f(x)\"
in one unknown \"x\" in a reliable way. As input, the desired value y of the
non-linear function has to be given, as well as an interval x_min, x_max that
contains the solution, i.e., \"f(x_min) - y\" and \"f(x_max) - y\" must
have a different sign. If possible, a smaller interval is computed by
inverse quadratic interpolation (interpolating with a quadratic polynomial
through the last 3 points and computing the zero). If this fails,
bisection is used, which always reduces the interval by a factor of 2.
The inverse quadratic interpolation method has superlinear convergence.
This is roughly the same convergence rate as a globally convergent Newton
method, but without the need to compute derivatives of the non-linear
function. The solver function is a direct mapping of the Algol 60 procedure
\"zero\" to Modelica, from:
</p>

<dl>
<dt> Brent R.P.:</dt>
<dd> <b>Algorithms for Minimization without derivatives</b>.
     Prentice Hall, 1973, pp. 58-59.</dd>
</dl>

<p>
Due to current limitations of the
Modelica language (not possible to pass a function reference to a function),
the construction to use this solver on a user-defined function is a bit
complicated (this method is from Hans Olsson, Dassault Syst&egrave;mes AB). A user has to
provide a package in the following way:
</p>

<pre>
  <b>package</b> MyNonLinearSolver
    <b>extends</b> OneNonLinearEquation;

    <b>redeclare record extends</b> Data
      // Define data to be passed to user function
      ...
    <b>end</b> Data;

    <b>redeclare function extends</b> f_nonlinear
    <b>algorithm</b>
       // Compute the non-linear equation: y = f(x, Data)
    <b>end</b> f_nonlinear;

    // Dummy definition that has to be present for current Dymola
    <b>redeclare function extends</b> solve
    <b>end</b> solve;
  <b>end</b> MyNonLinearSolver;

  x_zero = MyNonLinearSolver.solve(y_zero, x_min, x_max, data=data);
</pre>
</html>"));
   end OneNonLinearEquation;
    annotation (Documentation(info="<HTML><h4>Package description</h4>
      <p>Package Modelica.Media.Common provides records and functions shared by many of the property sub-packages.
      High accuracy fluid property models share a lot of common structure, even if the actual models are different.
      Common data structures and computations shared by these property models are collected in this library.
   </p>

</HTML>
",   revisions="<html>
      <ul>
      <li>First implemented: <i>July, 2000</i>
      by <a href=\"http://www.control.lth.se/~hubertus/\">Hubertus Tummescheit</a>
      for the ThermoFluid Library with help from Jonas Eborn and Falko Jens Wagner
      </li>
      <li>Code reorganization, enhanced documentation, additional functions: <i>December, 2002</i>
      by <a href=\"http://www.control.lth.se/~hubertus/\">Hubertus Tummescheit</a> and move to Modelica
                            properties library.</li>
      <li>Inclusion into Modelica.Media: September 2003 </li>
      </ul>

      <address>Author: Hubertus Tummescheit, <br>
      Lund University<br>
      Department of Automatic Control<br>
      Box 118, 22100 Lund, Sweden<br>
      email: hubertus@control.lth.se
      </address>
</html>"));
  end Common;

    package Air "Medium models for air"
      extends Modelica.Icons.MaterialPropertiesPackage;

      package MoistAir "Air: Moist air model (240 ... 400 K)"
        extends Interfaces.PartialCondensingGases(
           mediumName="Moist air",
           substanceNames={"water", "air"},
           final reducedX=true,
           final singleState=false,
           reference_X={0.01,0.99},
           fluidConstants = {IdealGases.Common.FluidData.H2O,IdealGases.Common.FluidData.N2});

        constant Integer Water=1
        "Index of water (in substanceNames, massFractions X, etc.)";

        constant Integer Air=2
        "Index of air (in substanceNames, massFractions X, etc.)";

        constant Real k_mair =  steam.MM/dryair.MM "ratio of molar weights";

        constant IdealGases.Common.DataRecord dryair = IdealGases.Common.SingleGasesData.Air;

        constant IdealGases.Common.DataRecord steam = IdealGases.Common.SingleGasesData.H2O;

        constant SI.MolarMass[2] MMX = {steam.MM,dryair.MM}
        "Molar masses of components";
        import Modelica.Media.Interfaces;
        import Modelica.Math;
        import SI = Modelica.SIunits;
        import Cv = Modelica.SIunits.Conversions;
        import Modelica.Constants;
        import Modelica.Media.IdealGases.Common.SingleGasNasa;

        redeclare record extends ThermodynamicState
        "ThermodynamicState record for moist air"
        end ThermodynamicState;

        redeclare replaceable model extends BaseProperties(
          T(stateSelect=if preferredMediumStates then StateSelect.prefer else StateSelect.default),
          p(stateSelect=if preferredMediumStates then StateSelect.prefer else StateSelect.default),
          Xi(stateSelect=if preferredMediumStates then StateSelect.prefer else StateSelect.default),
          redeclare final constant Boolean standardOrderComponents=true)
        "Moist air base properties record"

          /* p, T, X = X[Water] are used as preferred states, since only then all
     other quantities can be computed in a recursive sequence.
     If other variables are selected as states, static state selection
     is no longer possible and non-linear algebraic equations occur.
      */
          MassFraction x_water "Mass of total water/mass of dry air";
          Real phi "Relative humidity";

      protected
          MassFraction X_liquid "Mass fraction of liquid or solid water";
          MassFraction X_steam "Mass fraction of steam water";
          MassFraction X_air "Mass fraction of air";
          MassFraction X_sat
          "Steam water mass fraction of saturation boundary in kg_water/kg_moistair";
          MassFraction x_sat
          "Steam water mass content of saturation boundary in kg_water/kg_dryair";
          AbsolutePressure p_steam_sat "Partial saturation pressure of steam";
        equation
          assert(T >= 200.0 and T <= 423.15, "
Temperature T is not in the allowed range
200.0 K <= (T ="     + String(T) + " K) <= 423.15 K
required from medium model \""           + mediumName + "\".");
          MM = 1/(Xi[Water]/MMX[Water]+(1.0-Xi[Water])/MMX[Air]);

          p_steam_sat = min(saturationPressure(T),0.999*p);
          X_sat = min(p_steam_sat * k_mair/max(100*Constants.eps, p - p_steam_sat)*(1 - Xi[Water]), 1.0)
          "Water content at saturation with respect to actual water content";
          X_liquid = max(Xi[Water] - X_sat, 0.0);
          X_steam  = Xi[Water]-X_liquid;
          X_air    = 1-Xi[Water];

          h = specificEnthalpy_pTX(p,T,Xi);
          R = dryair.R*(X_air/(1 - X_liquid)) + steam.R*X_steam/(1 - X_liquid);
          //
          u = h - R*T;
          d = p/(R*T);
          /* Note, u and d are computed under the assumption that the volume of the liquid
         water is neglible with respect to the volume of air and of steam
      */
          state.p = p;
          state.T = T;
          state.X = X;

          // these x are per unit mass of DRY air!
          x_sat    = k_mair*p_steam_sat/max(100*Constants.eps,p - p_steam_sat);
          x_water = Xi[Water]/max(X_air,100*Constants.eps);
          phi = p/p_steam_sat*Xi[Water]/(Xi[Water] + k_mair*X_air);
          annotation(Documentation(info="<html>
<p>This model computes thermodynamic properties of moist air from three independent (thermodynamic or/and numerical) state variables. Preferred numerical states are temperature T, pressure p and the reduced composition vector Xi, which contains the water mass fraction only. As an EOS the <b>ideal gas law</b> is used and associated restrictions apply. The model can also be used in the <b>fog region</b>, when moisture is present in its liquid state. However, it is assumed that the liquid water volume is negligible compared to that of the gas phase. Computation of thermal properties is based on property data of <a href=\"modelica://Modelica.Media.Air.DryAirNasa\"> dry air</a> and water (source: VDI-W&auml;rmeatlas), respectively. Besides the standard thermodynamic variables <b>absolute and relative humidity</b>, x_water and phi, respectively, are given by the model. Upper case X denotes absolute humidity with respect to mass of moist air while absolute humidity with respect to mass of dry air only is denoted by a lower case x throughout the model. See <a href=\"modelica://Modelica.Media.Air.MoistAir\">package description</a> for further information.</p>
</html>"));
        end BaseProperties;

        redeclare function setState_pTX
        "Return thermodynamic state as function of pressure p, temperature T and composition X"
          extends Modelica.Icons.Function;
          input AbsolutePressure p "Pressure";
          input Temperature T "Temperature";
          input MassFraction X[:]=reference_X "Mass fractions";
          output ThermodynamicState state "Thermodynamic state";
        algorithm
          state := if size(X,1) == nX then ThermodynamicState(p=p,T=T, X=X) else
                 ThermodynamicState(p=p,T=T, X=cat(1,X,{1-sum(X)}));
          annotation(smoothOrder=2,
                      Documentation(info="<html>
The <a href=\"modelica://Modelica.Media.Air.MoistAir.ThermodynamicState\">thermodynamic state record</a> is computed from pressure p, temperature T and composition X.
</html>"));
        end setState_pTX;

        redeclare function setState_phX
        "Return thermodynamic state as function of pressure p, specific enthalpy h and composition X"
          extends Modelica.Icons.Function;
          input AbsolutePressure p "Pressure";
          input SpecificEnthalpy h "Specific enthalpy";
          input MassFraction X[:]=reference_X "Mass fractions";
          output ThermodynamicState state "Thermodynamic state";
        algorithm
          state := if size(X,1) == nX then ThermodynamicState(p=p,T=T_phX(p,h,X),X=X) else
                 ThermodynamicState(p=p,T=T_phX(p,h,X), X=cat(1,X,{1-sum(X)}));
          annotation(smoothOrder=2,
                      Documentation(info="<html>
The <a href=\"modelica://Modelica.Media.Air.MoistAir.ThermodynamicState\">thermodynamic state record</a> is computed from pressure p, specific enthalpy h and composition X.
</html>"));
        end setState_phX;

        redeclare function setState_dTX
        "Return thermodynamic state as function of density d, temperature T and composition X"
          extends Modelica.Icons.Function;
          input Density d "density";
          input Temperature T "Temperature";
          input MassFraction X[:]=reference_X "Mass fractions";
          output ThermodynamicState state "Thermodynamic state";
        algorithm
          state := if size(X,1) == nX then ThermodynamicState(p=d*({steam.R,dryair.R}*X)*T,T=T,X=X) else
                 ThermodynamicState(p=d*({steam.R,dryair.R}*cat(1,X,{1-sum(X)}))*T,T=T, X=cat(1,X,{1-sum(X)}));
          annotation(smoothOrder=2,
                      Documentation(info="<html>
The <a href=\"modelica://Modelica.Media.Air.MoistAir.ThermodynamicState\">thermodynamic state record</a> is computed from density d, temperature T and composition X.
</html>"));
        end setState_dTX;

      redeclare function extends setSmoothState
        "Return thermodynamic state so that it smoothly approximates: if x > 0 then state_a else state_b"
      algorithm
        state := ThermodynamicState(p=Media.Common.smoothStep(x, state_a.p, state_b.p, x_small),
                                    T=Media.Common.smoothStep(x, state_a.T, state_b.T, x_small),
                                    X=Media.Common.smoothStep(x, state_a.X, state_b.X, x_small));
      end setSmoothState;

        function Xsaturation
        "Return absolute humitity per unit mass of moist air at saturation as a function of the thermodynamic state record"
          input ThermodynamicState state "Thermodynamic state record";
          output MassFraction X_sat "Steam mass fraction of sat. boundary";
        algorithm
          X_sat := k_mair/(state.p/min(saturationPressure(state.T),0.999*state.p) - 1 + k_mair);
          annotation(smoothOrder=2,
                      Documentation(info="<html>
Absolute humidity per unit mass of moist air at saturation is computed from pressure and temperature in the state record. Note, that unlike X_sat in the BaseProperties model this mass fraction refers to mass of moist air at saturation.
</html>"));
        end Xsaturation;

        redeclare function extends gasConstant
        "Return ideal gas constant as a function from thermodynamic state, only valid for phi<1"

        algorithm
          R := dryair.R*(1-state.X[Water]) + steam.R*state.X[Water];
          annotation(smoothOrder=2,
                      Documentation(info="<html>
The ideal gas constant for moist air is computed from <a href=\"modelica://Modelica.Media.Air.MoistAir.ThermodynamicState\">thermodynamic state</a> assuming that all water is in the gas phase.
</html>"));
        end gasConstant;

        function saturationPressureLiquid
        "Return saturation pressure of water as a function of temperature T in the range of 273.16 to 373.16 K"

          extends Modelica.Icons.Function;
          input SI.Temperature Tsat "saturation temperature";
          output SI.AbsolutePressure psat "saturation pressure";
        algorithm
          psat := 611.657*Math.exp(17.2799 - 4102.99/(Tsat - 35.719));
          annotation(Inline=false,smoothOrder=5,derivative=saturationPressureLiquid_der,
            Documentation(info="<html>
Saturation pressure of water above the triple point temperature is computed from temperature. It's range of validity is between
273.16 and 373.16 K. Outside these limits a less accurate result is returned.
</html>"));
        end saturationPressureLiquid;

        function saturationPressureLiquid_der
        "Time derivative of saturationPressureLiquid"

          extends Modelica.Icons.Function;
          input SI.Temperature Tsat "Saturation temperature";
          input Real dTsat(unit="K/s") "Saturation temperature derivative";
          output Real psat_der(unit="Pa/s") "Saturation pressure";
        algorithm
        /*psat := 611.657*Math.exp(17.2799 - 4102.99/(Tsat - 35.719));*/
          psat_der:=611.657*Math.exp(17.2799 - 4102.99/(Tsat - 35.719))*4102.99*dTsat/(Tsat - 35.719)/(Tsat - 35.719);

          annotation(Inline=false,smoothOrder=5,
            Documentation(info="<html>
Derivative function of <a href=\"modelica://Modelica.Media.Air.MoistAir.saturationPressureLiquid\">saturationPressureLiquid</a>
</html>"));
        end saturationPressureLiquid_der;

        function sublimationPressureIce
        "Return sublimation pressure of water as a function of temperature T between 223.16 and 273.16 K"

          extends Modelica.Icons.Function;
          input SI.Temperature Tsat "sublimation temperature";
          output SI.AbsolutePressure psat "sublimation pressure";
        algorithm
          psat := 611.657*Math.exp(22.5159*(1.0 - 273.16/Tsat));
          annotation(Inline=false,smoothOrder=5,derivative=sublimationPressureIce_der,
            Documentation(info="<html>
Sublimation pressure of water below the triple point temperature is computed from temperature. It's range of validity is between
 223.16 and 273.16 K. Outside of these limits a less accurate result is returned.
</html>"));
        end sublimationPressureIce;

        function sublimationPressureIce_der
        "Derivative function for 'sublimationPressureIce'"

          extends Modelica.Icons.Function;
          input SI.Temperature Tsat "Sublimation temperature";
          input Real dTsat(unit="K/s")
          "Time derivative of sublimation temperature";
          output Real psat_der(unit="Pa/s") "Sublimation pressure";
        algorithm
          /*psat := 611.657*Math.exp(22.5159*(1.0 - 273.16/Tsat));*/
          psat_der:=611.657*Math.exp(22.5159*(1.0 - 273.16/Tsat))*22.5159*273.16*dTsat/Tsat/Tsat;
          annotation(Inline=false,smoothOrder=5,
            Documentation(info="<html>
Derivative function of <a href=\"modelica://Modelica.Media.Air.MoistAir.sublimationPressureIce\">saturationPressureIce</a>
</html>"));
        end sublimationPressureIce_der;

        redeclare function extends saturationPressure
        "Return saturation pressure of water as a function of temperature T between 223.16 and 373.16 K"

        algorithm
          psat := Utilities.spliceFunction(saturationPressureLiquid(Tsat),sublimationPressureIce(Tsat),Tsat-273.16,1.0);
          annotation(Inline=false,smoothOrder=5,derivative=saturationPressure_der,
            Documentation(info="<html>
Saturation pressure of water in the liquid and the solid region is computed using an Antoine-type correlation. It's range of validity is between 223.16 and 373.16 K. Outside of these limits a (less accurate) result is returned. Functions for the
<a href=\"modelica://Modelica.Media.Air.MoistAir.sublimationPressureIce\">solid</a> and the <a href=\"modelica://Modelica.Media.Air.MoistAir.saturationPressureLiquid\"> liquid</a> region, respectively, are combined using the first derivative continuous <a href=\"modelica://Modelica.Media.Air.MoistAir.Utilities.spliceFunction\">spliceFunction</a>.
</html>"));
        end saturationPressure;

        function saturationPressure_der
        "Derivative function for 'saturationPressure'"
          input Temperature Tsat "Saturation temperature";
          input Real dTsat(unit="K/s")
          "Time derivative of saturation temperature";
          output Real psat_der(unit="Pa/s") "Saturation pressure";

        algorithm
          /*psat := Utilities.spliceFunction(saturationPressureLiquid(Tsat),sublimationPressureIce(Tsat),Tsat-273.16,1.0);*/
          psat_der := Utilities.spliceFunction_der(
            saturationPressureLiquid(Tsat),
            sublimationPressureIce(Tsat),
            Tsat - 273.16,
            1.0,
            saturationPressureLiquid_der(Tsat=Tsat, dTsat=dTsat),
            sublimationPressureIce_der(Tsat=Tsat, dTsat=dTsat),
            dTsat,
            0);
          annotation(Inline=false,smoothOrder=5,
            Documentation(info="<html>
Derivative function of <a href=\"modelica://Modelica.Media.Air.MoistAir.saturationPressure\">saturationPressure</a>
</html>"));
        end saturationPressure_der;

       redeclare function extends enthalpyOfVaporization
        "Return enthalpy of vaporization of water as a function of temperature T, 0 - 130 degC"

       algorithm
        /*r0 := 1e3*(2501.0145 - (T - 273.15)*(2.3853 + (T - 273.15)*(0.002969 - (T
      - 273.15)*(7.5293e-5 + (T - 273.15)*4.6084e-7))));*/
       //katrin: replaced by linear correlation, simpler and more accurate in the entire region
       //source VDI-Waermeatlas, linear inter- and extrapolation between values for 0.01 &deg;C and 40 &deg;C.
       r0:=(2405900-2500500)/(40-0)*(T-273.16)+2500500;
         annotation(smoothOrder=2,
                      Documentation(info="<html>
Enthalpy of vaporization of water is computed from temperature in the region of 0 to 130 &deg;C.
</html>"));
       end enthalpyOfVaporization;

       redeclare function extends enthalpyOfLiquid
        "Return enthalpy of liquid water as a function of temperature T(use enthalpyOfWater instead)"

       algorithm
         h := (T - 273.15)*1e3*(4.2166 - 0.5*(T - 273.15)*(0.0033166 + 0.333333*(T - 273.15)*(0.00010295
            - 0.25*(T - 273.15)*(1.3819e-6 + 0.2*(T - 273.15)*7.3221e-9))));
         annotation(Inline=false,smoothOrder=5,
            Documentation(info="<html>
Specific enthalpy of liquid water is computed from temperature using a polynomial approach. Kept for compatibility reasons, better use <a href=\"modelica://Modelica.Media.Air.MoistAir.enthalpyOfWater\">enthalpyOfWater</a> instead.
</html>"));
       end enthalpyOfLiquid;

       redeclare function extends enthalpyOfGas
        "Return specific enthalpy of gas (air and steam) as a function of temperature T and composition X"

       algorithm
         h := SingleGasNasa.h_Tlow(data=steam, T=T, refChoice=3, h_off=46479.819+2501014.5)*X[Water]
              + SingleGasNasa.h_Tlow(data=dryair, T=T, refChoice=3, h_off=25104.684)*(1.0-X[Water]);
         annotation(Inline=false,smoothOrder=5,
            Documentation(info="<html>
Specific enthalpy of moist air is computed from temperature, provided all water is in the gaseous state. The first entry in the composition vector X must be the mass fraction of steam. For a function that also covers the fog region please refer to <a href=\"modelica://Modelica.Media.Air.MoistAir.h_pTX\">h_pTX</a>.
</html>"));
       end enthalpyOfGas;

       redeclare function extends enthalpyOfCondensingGas
        "Return specific enthalpy of steam as a function of temperature T"

       algorithm
         h := SingleGasNasa.h_Tlow(data=steam, T=T, refChoice=3, h_off=46479.819+2501014.5);
         annotation(Inline=false,smoothOrder=5,
            Documentation(info="<html>
Specific enthalpy of steam is computed from temperature.
</html>"));
       end enthalpyOfCondensingGas;

       redeclare function extends enthalpyOfNonCondensingGas
        "Return specific enthalpy of dry air as a function of temperature T"

       algorithm
         h := SingleGasNasa.h_Tlow(data=dryair, T=T, refChoice=3, h_off=25104.684);
         annotation(Inline=false,smoothOrder=1,
            Documentation(info="<html>
Specific enthalpy of dry air is computed from temperature.
</html>"));
       end enthalpyOfNonCondensingGas;

      function enthalpyOfWater
        "Computes specific enthalpy of water (solid/liquid) near atmospheric pressure from temperature T"
        input SIunits.Temperature T "Temperature";
        output SIunits.SpecificEnthalpy h "Specific enthalpy of water";
      algorithm
      /*simple model assuming constant properties:
  heat capacity of liquid water:4200 J/kg
  heat capacity of solid water: 2050 J/kg
  enthalpy of fusion (liquid=>solid): 333000 J/kg*/

        h:=Utilities.spliceFunction(4200*(T-273.15),2050*(T-273.15)-333000,T-273.16,0.1);
      annotation (derivative=enthalpyOfWater_der, Documentation(info="<html>
Specific enthalpy of water (liquid and solid) is computed from temperature using constant properties as follows:<br>
<ul>
<li>  heat capacity of liquid water:4200 J/kg
<li>  heat capacity of solid water: 2050 J/kg
<li>  enthalpy of fusion (liquid=>solid): 333000 J/kg
</ul>
Pressure is assumed to be around 1 bar. This function is usually used to determine the specific enthalpy of the liquid or solid fraction of moist air.
</html>"));
      end enthalpyOfWater;

      function enthalpyOfWater_der "Derivative function of enthalpyOfWater"
        input SIunits.Temperature T "Temperature";
        input Real dT(unit="K/s") "Time derivative of temperature";
        output Real dh(unit="J/(kg.s)") "Time derivative of specific enthalpy";
      algorithm
      /*simple model assuming constant properties:
  heat capacity of liquid water:4200 J/kg
  heat capacity of solid water: 2050 J/kg
  enthalpy of fusion (liquid=>solid): 333000 J/kg*/

        //h:=Utilities.spliceFunction(4200*(T-273.15),2050*(T-273.15)-333000,T-273.16,0.1);
        dh:=Utilities.spliceFunction_der(4200*(T-273.15),2050*(T-273.15)-333000,T-273.16,0.1,4200*dT,2050*dT,dT,0);
          annotation (Documentation(info="<html>
Derivative function for <a href=\"modelica://Modelica.Media.Air.MoistAir.enthalpyOfWater\">enthalpyOfWater</a>.

</html>"));
      end enthalpyOfWater_der;

       redeclare function extends pressure
        "Returns pressure of ideal gas as a function of the thermodynamic state record"

       algorithm
        p := state.p;
         annotation(smoothOrder=2,
                      Documentation(info="<html>
Pressure is returned from the thermodynamic state record input as a simple assignment.
</html>"));
       end pressure;

       redeclare function extends temperature
        "Return temperature of ideal gas as a function of the thermodynamic state record"

       algorithm
         T := state.T;
         annotation(smoothOrder=2,
                      Documentation(info="<html>
Temperature is returned from the thermodynamic state record input as a simple assignment.
</html>"));
       end temperature;

      function T_phX
        "Return temperature as a function of pressure p, specific enthalpy h and composition X"
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        input MassFraction[:] X "Mass fractions of composition";
        output Temperature T "Temperature";

      protected
      package Internal
          "Solve h(data,T) for T with given h (use only indirectly via temperature_phX)"
        extends Modelica.Media.Common.OneNonLinearEquation;
        redeclare record extends f_nonlinear_Data
            "Data to be passed to non-linear function"
          extends Modelica.Media.IdealGases.Common.DataRecord;
        end f_nonlinear_Data;

        redeclare function extends f_nonlinear
        algorithm
            y := h_pTX(p,x,X);
        end f_nonlinear;

        // Dummy definition has to be added for current Dymola
        redeclare function extends solve
        end solve;
      end Internal;

      algorithm
        T := Internal.solve(h, 240, 400, p, X[1:nXi], steam);
          annotation (Documentation(info="<html>
Temperature is computed from pressure, specific enthalpy and composition via numerical inversion of function <a href=\"modelica://Modelica.Media.Air.MoistAir.h_pTX\">h_pTX</a>.
</html>"));
      end T_phX;

       redeclare function extends density
        "Returns density of ideal gas as a function of the thermodynamic state record"

       algorithm
         d := state.p/(gasConstant(state)*state.T);
         annotation(smoothOrder=2,
                      Documentation(info="<html>
Density is computed from pressure, temperature and composition in the thermodynamic state record applying the ideal gas law.
</html>"));
       end density;

      redeclare function extends specificEnthalpy
        "Return specific enthalpy of moist air as a function of the thermodynamic state record"

      algorithm
        h := h_pTX(state.p, state.T, state.X);
        annotation(smoothOrder=2,
                      Documentation(info="<html>
Specific enthalpy of moist air is computed from the thermodynamic state record. The fog region is included for both, ice and liquid fog.
</html>"));
      end specificEnthalpy;

      function h_pTX
        "Return specific enthalpy of moist air as a function of pressure p, temperature T and composition X"
        extends Modelica.Icons.Function;
        input SI.Pressure p "Pressure";
        input SI.Temperature T "Temperature";
        input SI.MassFraction X[:] "Mass fractions of moist air";
        output SI.SpecificEnthalpy h "Specific enthalpy at p, T, X";
      protected
        SI.AbsolutePressure p_steam_sat "Partial saturation pressure of steam";
        SI.MassFraction X_sat "Absolute humidity per unit mass of moist air";
        SI.MassFraction X_liquid "mass fraction of liquid water";
        SI.MassFraction X_steam "mass fraction of steam water";
        SI.MassFraction X_air "mass fraction of air";
      algorithm
        p_steam_sat :=saturationPressure(T);
        //p_steam_sat :=min(saturationPressure(T), 0.999*p);
        X_sat:=min(p_steam_sat*k_mair/max(100*Constants.eps, p - p_steam_sat)*(1 - X[
          Water]), 1.0);
        X_liquid :=max(X[Water] - X_sat, 0.0);
        X_steam  :=X[Water] - X_liquid;
        X_air    :=1 - X[Water];
       /* h        := {SingleGasNasa.h_Tlow(data=steam,  T=T, refChoice=3, h_off=46479.819+2501014.5),
               SingleGasNasa.h_Tlow(data=dryair, T=T, refChoice=3, h_off=25104.684)}*
    {X_steam, X_air} + enthalpyOfLiquid(T)*X_liquid;*/
         h        := {SingleGasNasa.h_Tlow(data=steam,  T=T, refChoice=3, h_off=46479.819+2501014.5),
                     SingleGasNasa.h_Tlow(data=dryair, T=T, refChoice=3, h_off=25104.684)}*
          {X_steam, X_air} + enthalpyOfWater(T)*X_liquid;
        annotation(derivative=h_pTX_der, Inline=false,
            Documentation(info="<html>
Specific enthalpy of moist air is computed from pressure, temperature and composition with X[1] as the total water mass fraction. The fog region is included for both, ice and liquid fog.
</html>"));
      end h_pTX;

      function h_pTX_der "Derivative function of h_pTX"
        extends Modelica.Icons.Function;
        input SI.Pressure p "Pressure";
        input SI.Temperature T "Temperature";
        input SI.MassFraction X[:] "Mass fractions of moist air";
        input Real dp(unit="Pa/s") "Pressure derivative";
        input Real dT(unit="K/s") "Temperature derivative";
        input Real dX[:](each unit="1/s") "Composition derivative";
        output Real h_der(unit="J/(kg.s)")
          "Time derivative of specific enthalpy";
      protected
        SI.AbsolutePressure p_steam_sat "Partial saturation pressure of steam";
        SI.MassFraction X_sat "Absolute humidity per unit mass of moist air";
        SI.MassFraction X_liquid "Mass fraction of liquid water";
        SI.MassFraction X_steam "Mass fraction of steam water";
        SI.MassFraction X_air "Mass fraction of air";
        SI.MassFraction x_sat
          "Absolute humidity per unit mass of dry air at saturation";
        Real dX_steam(unit="1/s") "Time deriveative of steam mass fraction";
        Real dX_air(unit="1/s") "Time derivative of dry air mass fraction";
        Real dX_liq(unit="1/s")
          "Time derivative of liquid/solid water mass fraction";
        Real dps(unit="Pa/s") "Time derivative of saturation pressure";
        Real dx_sat(unit="1/s")
          "Time derivative of abolute humidity per unit mass of dry air";
      algorithm
        p_steam_sat :=saturationPressure(T);
        x_sat:=p_steam_sat*k_mair/max(100*Modelica.Constants.eps, p - p_steam_sat);
        X_sat:=min(x_sat*(1 - X[Water]), 1.0);
        X_liquid :=Utilities.spliceFunction(X[Water] - X_sat, 0.0, X[Water] - X_sat,1e-6);
        X_steam  :=X[Water] - X_liquid;
        X_air    :=1 - X[Water];

        dX_air:=-dX[Water];
        dps:=saturationPressure_der(Tsat=T, dTsat=dT);
        dx_sat:=k_mair*(dps*(p-p_steam_sat)-p_steam_sat*(dp-dps))/(p-p_steam_sat)/(p-p_steam_sat);
        dX_liq:=Utilities.spliceFunction_der(X[Water] - X_sat, 0.0, X[Water] - X_sat,1e-6,(1+x_sat)*dX[Water]-(1-X[Water])*dx_sat,0.0,(1+x_sat)*dX[Water]-(1-X[Water])*dx_sat,0.0);
        //dX_liq:=if X[Water]>=X_sat then (1+x_sat)*dX[Water]-(1-X[Water])*dx_sat else 0;
        dX_steam:=dX[Water]-dX_liq;

        h_der:= X_steam*Modelica.Media.IdealGases.Common.SingleGasNasa.h_Tlow_der(data=steam, T=T, refChoice=3, h_off=46479.819+2501014.5, dT=dT)+
                dX_steam*Modelica.Media.IdealGases.Common.SingleGasNasa.h_Tlow(data=steam,  T=T, refChoice=3, h_off=46479.819+2501014.5) +
                X_air*Modelica.Media.IdealGases.Common.SingleGasNasa.h_Tlow_der(data=dryair, T=T, refChoice=3, h_off=25104.684, dT=dT) +
                dX_air*Modelica.Media.IdealGases.Common.SingleGasNasa.h_Tlow(data=dryair, T=T, refChoice=3, h_off=25104.684) +
                X_liquid*enthalpyOfWater_der(T=T, dT=dT) +
                dX_liq*enthalpyOfWater(T);

        annotation(Inline=false,smoothOrder=1,
            Documentation(info="<html>
Derivative function for <a href=\"modelica://Modelica.Media.Air.MoistAir.h_pTX\">h_pTX</a>.
</html>"));
      end h_pTX_der;

      redeclare function extends isentropicExponent
        "Return isentropic exponent (only for gas fraction!)"
      algorithm
        gamma := specificHeatCapacityCp(state)/specificHeatCapacityCv(state);
      end isentropicExponent;

      redeclare function extends specificInternalEnergy
        "Return specific internal energy of moist air as a function of the thermodynamic state record"
        extends Modelica.Icons.Function;
        output SI.SpecificInternalEnergy u "Specific internal energy";
      algorithm
         u := specificInternalEnergy_pTX(state.p,state.T,state.X);

        annotation(smoothOrder=2,
                      Documentation(info="<html>
Specific internal energy is determined from the thermodynamic state record, assuming that the liquid or solid water volume is negligible.
</html>"));
      end specificInternalEnergy;

      function specificInternalEnergy_pTX
        "Return specific internal energy of moist air as a function of pressure p, temperature T and composition X"
        input SI.Pressure p "Pressure";
        input SI.Temperature T "Temperature";
        input SI.MassFraction X[:] "Mass fractions of moist air";
        output SI.SpecificInternalEnergy u "Specific internal energy";
      protected
        SI.AbsolutePressure p_steam_sat "Partial saturation pressure of steam";
        SI.MassFraction X_liquid "Mass fraction of liquid water";
        SI.MassFraction X_steam "Mass fraction of steam water";
        SI.MassFraction X_air "Mass fraction of air";
        SI.MassFraction X_sat "Absolute humidity per unit mass of moist air";
        Real R_gas "Ideal gas constant";
      algorithm
        p_steam_sat :=saturationPressure(T);
        X_sat:=min(p_steam_sat*k_mair/max(100*Constants.eps, p - p_steam_sat)*(1 - X[
          Water]), 1.0);
        X_liquid :=max(X[Water] - X_sat, 0.0);
        X_steam  :=X[Water] - X_liquid;
        X_air    :=1 - X[Water];
        R_gas:= dryair.R*X_air/(1-X_liquid)+steam.R* X_steam/(1-X_liquid);
        u       := X_steam*SingleGasNasa.h_Tlow(data=steam,  T=T, refChoice=3, h_off=46479.819+2501014.5)+
                   X_air*SingleGasNasa.h_Tlow(data=dryair, T=T, refChoice=3, h_off=25104.684)
                   + enthalpyOfWater(T)*X_liquid-R_gas*T;

          annotation (derivative=specificInternalEnergy_pTX_der, Documentation(info="<html>
Specific internal energy is determined from pressure p, temperature T and composition X, assuming that the liquid or solid water volume is negligible.
</html>"));
      end specificInternalEnergy_pTX;

      function specificInternalEnergy_pTX_der
        "Derivative function for specificInternalEnergy_pTX"
        input SI.Pressure p "Pressure";
        input SI.Temperature T "Temperature";
        input SI.MassFraction X[:] "Mass fractions of moist air";
        input Real dp(unit="Pa/s") "Pressure derivative";
        input Real dT(unit="K/s") "Temperature derivative";
        input Real dX[:](each unit="1/s") "Mass fraction derivatives";
        output Real u_der(unit="J/(kg.s)")
          "Specific internal energy derivative";
      protected
        SI.AbsolutePressure p_steam_sat "Partial saturation pressure of steam";
        SI.MassFraction X_liquid "Mass fraction of liquid water";
        SI.MassFraction X_steam "Mass fraction of steam water";
        SI.MassFraction X_air "Mass fraction of air";
        SI.MassFraction X_sat "Absolute humidity per unit mass of moist air";
        SI.SpecificHeatCapacity R_gas "Ideal gas constant";

        SI.MassFraction x_sat
          "Absolute humidity per unit mass of dry air at saturation";
        Real dX_steam(unit="1/s") "Time deriveative of steam mass fraction";
        Real dX_air(unit="1/s") "Time derivative of dry air mass fraction";
        Real dX_liq(unit="1/s")
          "Time derivative of liquid/solid water mass fraction";
        Real dps(unit="Pa/s") "Time derivative of saturation pressure";
        Real dx_sat(unit="1/s")
          "Time derivative of abolute humidity per unit mass of dry air";
        Real dR_gas(unit="J/(kg.K.s)") "Time derivative of ideal gas constant";
      algorithm
        p_steam_sat :=saturationPressure(T);
        x_sat:=p_steam_sat*k_mair/max(100*Modelica.Constants.eps, p - p_steam_sat);
        X_sat:=min(x_sat*(1 - X[Water]), 1.0);
        X_liquid :=Utilities.spliceFunction(X[Water] - X_sat, 0.0, X[Water] - X_sat,1e-6);
        X_steam  :=X[Water] - X_liquid;
        X_air    :=1 - X[Water];
        R_gas:= steam.R*X_steam/(1-X_liquid)+dryair.R* X_air/(1-X_liquid);

        dX_air:=-dX[Water];
        dps:=saturationPressure_der(Tsat=T, dTsat=dT);
        dx_sat:=k_mair*(dps*(p-p_steam_sat)-p_steam_sat*(dp-dps))/(p-p_steam_sat)/(p-p_steam_sat);
        dX_liq:=Utilities.spliceFunction_der(X[Water] - X_sat, 0.0, X[Water] - X_sat,1e-6,(1+x_sat)*dX[Water]-(1-X[Water])*dx_sat,0.0,(1+x_sat)*dX[Water]-(1-X[Water])*dx_sat,0.0);
        dX_steam:=dX[Water]-dX_liq;
        dR_gas:=(steam.R*(dX_steam*(1-X_liquid)+dX_liq*X_steam)+dryair.R*(dX_air*(1-X_liquid)+dX_liq*X_air))/(1-X_liquid)/(1-X_liquid);

        u_der:=X_steam*SingleGasNasa.h_Tlow_der(data=steam, T=T, refChoice=3, h_off=46479.819+2501014.5, dT=dT)+
               dX_steam*SingleGasNasa.h_Tlow(data=steam,  T=T, refChoice=3, h_off=46479.819+2501014.5) +
               X_air*SingleGasNasa.h_Tlow_der(data=dryair, T=T, refChoice=3, h_off=25104.684, dT=dT) +
               dX_air*SingleGasNasa.h_Tlow(data=dryair, T=T, refChoice=3, h_off=25104.684) +
               X_liquid*enthalpyOfWater_der(T=T, dT=dT) +
               dX_liq*enthalpyOfWater(T) - dR_gas*T-R_gas*dT;
          annotation (Documentation(info="<html>
Derivative function for <a href=\"modelica://Modelica.Media.Air.MoistAir.specificInternalEnergy_pTX\">specificInternalEnergy_pTX</a>.
</html>"));
      end specificInternalEnergy_pTX_der;

       redeclare function extends specificEntropy
        "Return specific entropy from thermodynamic state record, only valid for phi<1"

      protected
          MoleFraction[2] Y = massToMoleFractions(state.X,{steam.MM,dryair.MM})
          "molar fraction";
       algorithm
         s:=SingleGasNasa.s0_Tlow(dryair, state.T)*(1-state.X[Water])
           + SingleGasNasa.s0_Tlow(steam, state.T)*state.X[Water]
           - (state.X[Water]*Modelica.Constants.R/MMX[Water]*(if state.X[Water]<Modelica.Constants.eps then state.X[Water] else Modelica.Math.log(Y[Water]*state.p/reference_p))
             + (1-state.X[Water])*Modelica.Constants.R/MMX[Air]*(if (1-state.X[Water])<Modelica.Constants.eps then (1-state.X[Water]) else Modelica.Math.log(Y[Air]*state.p/reference_p)));
           annotation(Inline=false,smoothOrder=2,
            Documentation(info="<html>
Specific entropy is calculated from the thermodynamic state record, assuming ideal gas behavior and including entropy of mixing. Liquid or solid water is not taken into account, the entire water content X[1] is assumed to be in the vapor state (relative humidity below 1.0).
</html>"));
       end specificEntropy;

      redeclare function extends specificGibbsEnergy
        "Return specific Gibbs energy as a function of the thermodynamic state record, only valid for phi<1"
        extends Modelica.Icons.Function;
      algorithm
        g := h_pTX(state.p,state.T,state.X) - state.T*specificEntropy(state);
        annotation(smoothOrder=2,
                      Documentation(info="<html>
The Gibbs Energy is computed from the thermodynamic state record for moist air with a water content below saturation.
</html>"));
      end specificGibbsEnergy;

      redeclare function extends specificHelmholtzEnergy
        "Return specific Helmholtz energy as a function of the thermodynamic state record, only valid for phi<1"
        extends Modelica.Icons.Function;
      algorithm
        f := h_pTX(state.p,state.T,state.X) - gasConstant(state)*state.T - state.T*specificEntropy(state);
        annotation(smoothOrder=2,
                      Documentation(info="<html>
The Specific Helmholtz Energy is computed from the thermodynamic state record for moist air with a water content below saturation.
</html>"));
      end specificHelmholtzEnergy;

       redeclare function extends specificHeatCapacityCp
        "Return specific heat capacity at constant pressure as a function of the thermodynamic state record"

      protected
         Real dT(unit="s/K") = 1.0;
       algorithm
         cp := h_pTX_der(state.p,state.T,state.X, 0.0, 1.0, zeros(size(state.X,1)))*dT
          "Definition of cp: dh/dT @ constant p";
         //      cp:= SingleGasNasa.cp_Tlow(dryair, state.T)*(1-state.X[Water])
         //        + SingleGasNasa.cp_Tlow(steam, state.T)*state.X[Water];
         annotation(Inline=false,smoothOrder=2,
            Documentation(info="<html>
The specific heat capacity at constant pressure <b>cp</b> is computed from temperature and composition for a mixture of steam (X[1]) and dry air. All water is assumed to be in the vapor state.
</html>"));
       end specificHeatCapacityCp;

      redeclare function extends specificHeatCapacityCv
        "Return specific heat capacity at constant volume as a function of the thermodynamic state record"

      algorithm
        cv:= SingleGasNasa.cp_Tlow(dryair, state.T)*(1-state.X[Water]) +
          SingleGasNasa.cp_Tlow(steam, state.T)*state.X[Water]
          - gasConstant(state);
         annotation(Inline=false,smoothOrder=2,
            Documentation(info="<html>
The specific heat capacity at constant density <b>cv</b> is computed from temperature and composition for a mixture of steam (X[1]) and dry air. All water is assumed to be in the vapor state.
</html>"));
      end specificHeatCapacityCv;

      redeclare function extends dynamicViscosity
        "Return dynamic viscosity as a function of the thermodynamic state record, valid from 73.15 K to 373.15 K"

          import Modelica.Media.Incompressible.TableBased.Polynomials_Temp;
      algorithm
        eta := Polynomials_Temp.evaluate({(-4.96717436974791E-011), 5.06626785714286E-008, 1.72937731092437E-005},
             Cv.to_degC(state.T));
        annotation(smoothOrder=2,
                      Documentation(info="<html>
Dynamic viscosity is computed from temperature using a simple polynomial for dry air, assuming that moisture influence is small. Range of  validity is from 73.15 K to 373.15 K.
</html>"));
      end dynamicViscosity;

      redeclare function extends thermalConductivity
        "Return thermal conductivity as a function of the thermodynamic state record, valid from 73.15 K to 373.15 K"

          import Modelica.Media.Incompressible.TableBased.Polynomials_Temp;
      algorithm
        lambda := Polynomials_Temp.evaluate({(-4.8737307422969E-008), 7.67803133753502E-005, 0.0241814385504202},
         Cv.to_degC(state.T));
        annotation(smoothOrder=2,
                      Documentation(info="<html>
Thermal conductivity is computed from temperature using a simple polynomial for dry air, assuming that moisture influence is small. Range of  validity is from 73.15 K to 373.15 K.
</html>"));
      end thermalConductivity;

        package Utilities "utility functions"

          function spliceFunction "Spline interpolation of two functions"
              input Real pos "Returned value for x-deltax >= 0";
              input Real neg "Returned value for x+deltax <= 0";
              input Real x "Function argument";
              input Real deltax=1 "Region around x with spline interpolation";
              output Real out;
        protected
              Real scaledX;
              Real scaledX1;
              Real y;
          algorithm
              scaledX1 := x/deltax;
              scaledX := scaledX1*Modelica.Math.asin(1);
              if scaledX1 <= -0.999999999 then
                y := 0;
              elseif scaledX1 >= 0.999999999 then
                y := 1;
              else
                y := (Modelica.Math.tanh(Modelica.Math.tan(scaledX)) + 1)/2;
              end if;
              out := pos*y + (1 - y)*neg;
              annotation (derivative=spliceFunction_der);
          end spliceFunction;

          function spliceFunction_der "Derivative of spliceFunction"
              input Real pos;
              input Real neg;
              input Real x;
              input Real deltax=1;
              input Real dpos;
              input Real dneg;
              input Real dx;
              input Real ddeltax=0;
              output Real out;
        protected
              Real scaledX;
              Real scaledX1;
              Real dscaledX1;
              Real y;
          algorithm
              scaledX1 := x/deltax;
              scaledX := scaledX1*Modelica.Math.asin(1);
              dscaledX1 := (dx - scaledX1*ddeltax)/deltax;
              if scaledX1 <= -0.99999999999 then
                y := 0;
              elseif scaledX1 >= 0.9999999999 then
                y := 1;
              else
                y := (Modelica.Math.tanh(Modelica.Math.tan(scaledX)) + 1)/2;
              end if;
              out := dpos*y + (1 - y)*dneg;
              if (abs(scaledX1) < 1) then
                out := out + (pos - neg)*dscaledX1*Modelica.Math.asin(1)/2/(
                  Modelica.Math.cosh(Modelica.Math.tan(scaledX))*Modelica.Math.cos(
                  scaledX))^2;
              end if;
          end spliceFunction_der;
        end Utilities;
        annotation (Documentation(info="<html>
<h4>Thermodynamic Model</h4>
<p>This package provides a full thermodynamic model of moist air including the fog region and temperatures below zero degC.
The governing assumptions in this model are:</p>
<ul>
<li>the perfect gas law applies</li>
<li>water volume other than that of steam is neglected</li></ul>
<p>All extensive properties are expressed in terms of the total mass in order to comply with other media in this libary. However, for moist air it is rather common to express the absolute humidity in terms of mass of dry air only, which has advantages when working with charts. In addition, care must be taken, when working with mass fractions with respect to total mass, that all properties refer to the same water content when being used in mathematical operations (which is always the case if based on dry air only). Therefore two absolute humidities are computed in the <b>BaseProperties</b> model: <b>X</b> denotes the absolute humidity in terms of the total mass while <b>x</b> denotes the absolute humitity per unit mass of dry air. In addition, the relative humidity <b>phi</b> is also computed.</p>
<p>At the triple point temperature of water of 0.01 &deg;C or 273.16 K and a relative humidity greater than 1 fog may be present as liquid and as ice resulting in a specific enthalpy somewhere between those of the two isotherms for solid and liquid fog, respectively. For numerical reasons a coexisting mixture of 50% solid and 50% liquid fog is assumed in the fog region at the triple point in this model.</p>

<h4>Range of validity</h4>
<p>From the assumptions mentioned above it follows that the <b>pressure</b> should be in the region around <b>atmospheric</b> conditions or below (a few bars may still be fine though). Additionally a very high water content at low temperatures would yield incorrect densities, because the volume of the liquid or solid phase would not be negligible anymore. The model does not provide information on limits for water drop size in the fog region or transport information for the actual condensation or evaporation process in combination with surfaces. All excess water which is not in its vapour state is assumed to be still present in the air regarding its energy but not in terms of its spatial extent.<br><br>
The thermodynamic model may be used for <b>temperatures</b> ranging from <b>240 - 400 K</b>. This holds for all functions unless otherwise stated in their description. However, although the model works at temperatures above the saturation temperature it is questionable to use the term \"relative humidity\" in this region. Please note, that although several functions compute pure water properties, they are designed to be used within the moist air medium model where properties are dominated by air and steam in their vapor states, and not for pure liquid water applications.</p>

<h4>Transport Properties</h4>
<p>Several additional functions that are not needed to describe the thermodynamic system, but are required to model transport processes, like heat and mass transfer, may be called. They usually neglect the moisture influence unless otherwise stated.</p>

<h4>Application</h4>
<p>The model's main area of application is all processes that involve moist air cooling under near atmospheric pressure with possible moisture condensation. This is the case in all domestic and industrial air conditioning applications. Another large domain of moist air applications covers all processes that deal with dehydration of bulk material using air as a transport medium. Engineering tasks involving moist air are often performed (or at least visualized) by using charts that contain all relevant thermodynamic data for a moist air system. These so called psychrometric charts can be generated from the medium properties in this package. The model <a href=\"modelica://Modelica.Media.Air.MoistAir.PsychrometricData\">PsychrometricData</a> may be used for this purpose in order to obtain data for figures like those below (the plotting itself is not part of the model though).</p>

<img src=\"modelica://Modelica/Resources/Images/Media/Air/Mollier.png\">

<img src=\"modelica://Modelica/Resources/Images/Media/Air/PsycroChart.png\">

<p>
<b>Legend:</b> blue - constant specific enthalpy, red - constant temperature, black - constant relative humidity</p>

</html>"));
      end MoistAir;
      annotation (Documentation(info="<html>
  <p>This package contains different medium models for air:</p>
<ul>
<li><b>SimpleAir</b><br>
    Simple dry air medium in a limited temperature range.</li>
<li><b>DryAirNasa</b><br>
    Dry air as an ideal gas from Media.IdealGases.MixtureGases.Air.</li>
<li><b>MoistAir</b><br>
    Moist air as an ideal gas mixture of steam and dry air with fog below and above the triple point temperature.</li>
</ul>
</html>"));
    end Air;

    package IdealGases
    "Data and models of ideal gases (single, fixed and dynamic mixtures) from NASA source"
      extends Modelica.Icons.MaterialPropertiesPackage;

      package Common "Common packages and data for the ideal gas models"
      extends Modelica.Icons.Package;

      record DataRecord
        "Coefficient data record for properties of ideal gases based on NASA source"
        extends Modelica.Icons.Record;
        String name "Name of ideal gas";
        SI.MolarMass MM "Molar mass";
        SI.SpecificEnthalpy Hf "Enthalpy of formation at 298.15K";
        SI.SpecificEnthalpy H0 "H0(298.15K) - H0(0K)";
        SI.Temperature Tlimit
          "Temperature limit between low and high data sets";
        Real alow[7] "Low temperature coefficients a";
        Real blow[2] "Low temperature constants b";
        Real ahigh[7] "High temperature coefficients a";
        Real bhigh[2] "High temperature constants b";
        SI.SpecificHeatCapacity R "Gas constant";
        annotation (Documentation(info="<HTML>
<p>
This data record contains the coefficients for the
ideal gas equations according to:
</p>
<blockquote>
  <p>McBride B.J., Zehe M.J., and Gordon S. (2002): <b>NASA Glenn Coefficients
  for Calculating Thermodynamic Properties of Individual Species</b>. NASA
  report TP-2002-211556</p>
</blockquote>
<p>
The equations have the following structure:
</p>
<IMG src=\"modelica://Modelica/Resources/Images/Media/IdealGases/singleEquations.png\">
<p>
The polynomials for h(T) and s0(T) are derived via integration from the one for cp(T)  and contain the integration constants b1, b2 that define the reference specific enthalpy and entropy. For entropy differences the reference pressure p0 is arbitrary, but not for absolute entropies. It is chosen as 1 standard atmosphere (101325 Pa).
</p>
<p>
For most gases, the region of validity is from 200 K to 6000 K.
The equations are splitted into two regions that are separated
by Tlimit (usually 1000 K). In both regions the gas is described
by the data above. The two branches are continuous and in most
gases also differentiable at Tlimit.
</p>
</HTML>"));
      end DataRecord;

      partial package SingleGasNasa
        "Medium model of an ideal gas based on NASA source"

        extends Interfaces.PartialPureSubstance(
           ThermoStates = Choices.IndependentVariables.pT,
           mediumName=data.name,
           substanceNames={data.name},
           singleState=false,
           Temperature(min=200, max=6000, start=500, nominal=500),
           SpecificEnthalpy(start=if referenceChoice==ReferenceEnthalpy.ZeroAt0K then data.H0 else
              if referenceChoice==ReferenceEnthalpy.UserDefined then h_offset else 0, nominal=1.0e5),
           Density(start=10, nominal=10),
           AbsolutePressure(start=10e5, nominal=10e5));

        redeclare record extends ThermodynamicState
          "thermodynamic state variables for ideal gases"
          AbsolutePressure p "Absolute pressure of medium";
          Temperature T "Temperature of medium";
        end ThermodynamicState;

        redeclare record extends FluidConstants "Extended fluid constants"
          Temperature criticalTemperature "critical temperature";
          AbsolutePressure criticalPressure "critical pressure";
          MolarVolume criticalMolarVolume "critical molar Volume";
          Real acentricFactor "Pitzer acentric factor";
          Temperature triplePointTemperature "triple point temperature";
          AbsolutePressure triplePointPressure "triple point pressure";
          Temperature meltingPoint "melting point at 101325 Pa";
          Temperature normalBoilingPoint "normal boiling point (at 101325 Pa)";
          DipoleMoment dipoleMoment
            "dipole moment of molecule in Debye (1 debye = 3.33564e10-30 C.m)";
          Boolean hasIdealGasHeatCapacity=false
            "true if ideal gas heat capacity is available";
          Boolean hasCriticalData=false "true if critical data are known";
          Boolean hasDipoleMoment=false "true if a dipole moment known";
          Boolean hasFundamentalEquation=false "true if a fundamental equation";
          Boolean hasLiquidHeatCapacity=false
            "true if liquid heat capacity is available";
          Boolean hasSolidHeatCapacity=false
            "true if solid heat capacity is available";
          Boolean hasAccurateViscosityData=false
            "true if accurate data for a viscosity function is available";
          Boolean hasAccurateConductivityData=false
            "true if accurate data for thermal conductivity is available";
          Boolean hasVapourPressureCurve=false
            "true if vapour pressure data, e.g., Antoine coefficents are known";
          Boolean hasAcentricFactor=false
            "true if Pitzer accentric factor is known";
          SpecificEnthalpy HCRIT0=0.0
            "Critical specific enthalpy of the fundamental equation";
          SpecificEntropy SCRIT0=0.0
            "Critical specific entropy of the fundamental equation";
          SpecificEnthalpy deltah=0.0
            "Difference between specific enthalpy model (h_m) and f.eq. (h_f) (h_m - h_f)";
          SpecificEntropy deltas=0.0
            "Difference between specific enthalpy model (s_m) and f.eq. (s_f) (s_m - s_f)";
        end FluidConstants;

          import SI = Modelica.SIunits;
          import Modelica.Math;
          import
          Modelica.Media.Interfaces.PartialMedium.Choices.ReferenceEnthalpy;

        constant Boolean excludeEnthalpyOfFormation=true
          "If true, enthalpy of formation Hf is not included in specific enthalpy h";
        constant ReferenceEnthalpy referenceChoice=Choices.
              ReferenceEnthalpy.ZeroAt0K "Choice of reference enthalpy";
        constant SpecificEnthalpy h_offset=0.0
          "User defined offset for reference enthalpy, if referenceChoice = UserDefined";

        constant IdealGases.Common.DataRecord data
          "Data record of ideal gas substance";

        constant FluidConstants[nS] fluidConstants
          "constant data for the fluid";

        redeclare model extends BaseProperties(
         T(stateSelect=if preferredMediumStates then StateSelect.prefer else StateSelect.default),
         p(stateSelect=if preferredMediumStates then StateSelect.prefer else StateSelect.default))
          "Base properties of ideal gas medium"
        equation
          assert(T >= 200 and T <= 6000, "
Temperature T (= "       + String(T) + " K) is not in the allowed range
200 K <= T <= 6000 K required from medium model \""       + mediumName + "\".
");
          MM = data.MM;
          R = data.R;
          h = h_T(data, T, excludeEnthalpyOfFormation, referenceChoice, h_offset);
          u = h - R*T;

          // Has to be written in the form d=f(p,T) in order that static
          // state selection for p and T is possible
          d = p/(R*T);
          // connect state with BaseProperties
          state.T = T;
          state.p = p;
        end BaseProperties;

          redeclare function setState_pTX
          "Return thermodynamic state as function of p, T and composition X"
            extends Modelica.Icons.Function;
            input AbsolutePressure p "Pressure";
            input Temperature T "Temperature";
            input MassFraction X[:]=reference_X "Mass fractions";
            output ThermodynamicState state;
          algorithm
            state := ThermodynamicState(p=p,T=T);
          end setState_pTX;

          redeclare function setState_phX
          "Return thermodynamic state as function of p, h and composition X"
            extends Modelica.Icons.Function;
            input AbsolutePressure p "Pressure";
            input SpecificEnthalpy h "Specific enthalpy";
            input MassFraction X[:]=reference_X "Mass fractions";
            output ThermodynamicState state;
          algorithm
            state := ThermodynamicState(p=p,T=T_h(h));
          end setState_phX;

          redeclare function setState_psX
          "Return thermodynamic state as function of p, s and composition X"
            extends Modelica.Icons.Function;
            input AbsolutePressure p "Pressure";
            input SpecificEntropy s "Specific entropy";
            input MassFraction X[:]=reference_X "Mass fractions";
            output ThermodynamicState state;
          algorithm
            state := ThermodynamicState(p=p,T=T_ps(p,s));
          end setState_psX;

          redeclare function setState_dTX
          "Return thermodynamic state as function of d, T and composition X"
            extends Modelica.Icons.Function;
            input Density d "density";
            input Temperature T "Temperature";
            input MassFraction X[:]=reference_X "Mass fractions";
            output ThermodynamicState state;
          algorithm
            state := ThermodynamicState(p=d*data.R*T,T=T);
          end setState_dTX;

            redeclare function extends setSmoothState
          "Return thermodynamic state so that it smoothly approximates: if x > 0 then state_a else state_b"
            algorithm
              state := ThermodynamicState(p=Media.Common.smoothStep(x, state_a.p, state_b.p, x_small),
                                          T=Media.Common.smoothStep(x, state_a.T, state_b.T, x_small));
            end setSmoothState;

        redeclare function extends pressure "return pressure of ideal gas"
        algorithm
          p := state.p;
        end pressure;

        redeclare function extends temperature
          "return temperature of ideal gas"
        algorithm
          T := state.T;
        end temperature;

        redeclare function extends density "return density of ideal gas"
        algorithm
          d := state.p/(data.R*state.T);
        end density;

        redeclare function extends specificEnthalpy "Return specific enthalpy"
          extends Modelica.Icons.Function;
        algorithm
          h := h_T(data,state.T);
        end specificEnthalpy;

        redeclare function extends specificInternalEnergy
          "Return specific internal energy"
          extends Modelica.Icons.Function;
        algorithm
          u := h_T(data,state.T) - data.R*state.T;
        end specificInternalEnergy;

        redeclare function extends specificEntropy "Return specific entropy"
          extends Modelica.Icons.Function;
        algorithm
          s := s0_T(data, state.T) - data.R*Modelica.Math.log(state.p/reference_p);
        end specificEntropy;

        redeclare function extends specificGibbsEnergy
          "Return specific Gibbs energy"
          extends Modelica.Icons.Function;
        algorithm
          g := h_T(data,state.T) - state.T*specificEntropy(state);
        end specificGibbsEnergy;

        redeclare function extends specificHelmholtzEnergy
          "Return specific Helmholtz energy"
          extends Modelica.Icons.Function;
        algorithm
          f := h_T(data,state.T) - data.R*state.T - state.T*specificEntropy(state);
        end specificHelmholtzEnergy;

        redeclare function extends specificHeatCapacityCp
          "Return specific heat capacity at constant pressure"
        algorithm
          cp := cp_T(data, state.T);
        end specificHeatCapacityCp;

        redeclare function extends specificHeatCapacityCv
          "Compute specific heat capacity at constant volume from temperature and gas data"
        algorithm
          cv := cp_T(data, state.T) - data.R;
        end specificHeatCapacityCv;

        redeclare function extends isentropicExponent
          "Return isentropic exponent"
        algorithm
          gamma := specificHeatCapacityCp(state)/specificHeatCapacityCv(state);
        end isentropicExponent;

        redeclare function extends velocityOfSound "Return velocity of sound"
          extends Modelica.Icons.Function;
        algorithm
          a := sqrt(max(0,data.R*state.T*cp_T(data, state.T)/specificHeatCapacityCv(state)));
        end velocityOfSound;

        function isentropicEnthalpyApproximation
          "approximate method of calculating h_is from upstream properties and downstream pressure"
          extends Modelica.Icons.Function;
          input SI.Pressure p2 "downstream pressure";
          input ThermodynamicState state "properties at upstream location";
          input Boolean exclEnthForm=excludeEnthalpyOfFormation
            "If true, enthalpy of formation Hf is not included in specific enthalpy h";
          input ReferenceEnthalpy refChoice=referenceChoice
            "Choice of reference enthalpy";
          input SpecificEnthalpy h_off=h_offset
            "User defined offset for reference enthalpy, if referenceChoice = UserDefined";
          output SI.SpecificEnthalpy h_is "isentropic enthalpy";
        protected
          IsentropicExponent gamma =  isentropicExponent(state)
            "Isentropic exponent";
        algorithm
          h_is := h_T(data,state.T,exclEnthForm,refChoice,h_off) +
            gamma/(gamma - 1.0)*state.p/density(state)*((p2/state.p)^((gamma - 1)/gamma) - 1.0);
        end isentropicEnthalpyApproximation;

        redeclare function extends isentropicEnthalpy
          "Return isentropic enthalpy"
        input Boolean exclEnthForm=excludeEnthalpyOfFormation
            "If true, enthalpy of formation Hf is not included in specific enthalpy h";
        input ReferenceEnthalpy refChoice=referenceChoice
            "Choice of reference enthalpy";
        input SpecificEnthalpy h_off=h_offset
            "User defined offset for reference enthalpy, if referenceChoice = UserDefined";
        algorithm
          h_is := isentropicEnthalpyApproximation(p_downstream,refState,exclEnthForm,refChoice,h_off);
        end isentropicEnthalpy;

        redeclare function extends isobaricExpansionCoefficient
          "Returns overall the isobaric expansion coefficient beta"
        algorithm
          beta := 1/state.T;
        end isobaricExpansionCoefficient;

        redeclare function extends isothermalCompressibility
          "Returns overall the isothermal compressibility factor"
        algorithm
          kappa := 1.0/state.p;
        end isothermalCompressibility;

        redeclare function extends density_derp_T
          "Returns the partial derivative of density with respect to pressure at constant temperature"
        algorithm
          ddpT := 1/(state.T*data.R);
        end density_derp_T;

        redeclare function extends density_derT_p
          "Returns the partial derivative of density with respect to temperature at constant pressure"
        algorithm
          ddTp := -state.p/(state.T*state.T*data.R);
        end density_derT_p;

        redeclare function extends density_derX
          "Returns the partial derivative of density with respect to mass fractions at constant pressure and temperature"
        algorithm
          dddX := fill(0,nX);
        end density_derX;

        function cp_T
          "Compute specific heat capacity at constant pressure from temperature and gas data"
          extends Modelica.Icons.Function;
          input IdealGases.Common.DataRecord data "Ideal gas data";
          input SI.Temperature T "Temperature";
          output SI.SpecificHeatCapacity cp
            "Specific heat capacity at temperature T";
        algorithm
          cp := smooth(0,if T < data.Tlimit then data.R*(1/(T*T)*(data.alow[1] + T*(
            data.alow[2] + T*(1.*data.alow[3] + T*(data.alow[4] + T*(data.alow[5] + T
            *(data.alow[6] + data.alow[7]*T))))))) else data.R*(1/(T*T)*(data.ahigh[1]
             + T*(data.ahigh[2] + T*(1.*data.ahigh[3] + T*(data.ahigh[4] + T*(data.
            ahigh[5] + T*(data.ahigh[6] + data.ahigh[7]*T))))))));
          annotation (InlineNoEvent=false,smoothOrder=2);
        end cp_T;

        function cp_Tlow
          "Compute specific heat capacity at constant pressure, low T region"
          extends Modelica.Icons.Function;
          input IdealGases.Common.DataRecord data "Ideal gas data";
          input SI.Temperature T "Temperature";
          output SI.SpecificHeatCapacity cp
            "Specific heat capacity at temperature T";
        algorithm
          cp := data.R*(1/(T*T)*(data.alow[1] + T*(
            data.alow[2] + T*(1.*data.alow[3] + T*(data.alow[4] + T*(data.alow[5] + T
            *(data.alow[6] + data.alow[7]*T)))))));
          annotation (Inline=false, derivative(zeroDerivative=data) = cp_Tlow_der);
        end cp_Tlow;

        function cp_Tlow_der
          "Compute specific heat capacity at constant pressure, low T region"
          extends Modelica.Icons.Function;
          input IdealGases.Common.DataRecord data "Ideal gas data";
          input SI.Temperature T "Temperature";
          input Real dT "Temperature derivative";
          output Real cp_der "Derivative of specific heat capacity";
        algorithm
          cp_der := dT*data.R/(T*T*T)*(-2*data.alow[1] + T*(
            -data.alow[2] + T*T*(data.alow[4] + T*(2.*data.alow[5] + T
            *(3.*data.alow[6] + 4.*data.alow[7]*T)))));
        end cp_Tlow_der;

        function h_T "Compute specific enthalpy from temperature and gas data; reference is decided by the
    refChoice input, or by the referenceChoice package constant by default"
            import Modelica.Media.Interfaces.PartialMedium.Choices;
          extends Modelica.Icons.Function;
          input IdealGases.Common.DataRecord data "Ideal gas data";
          input SI.Temperature T "Temperature";
          input Boolean exclEnthForm=excludeEnthalpyOfFormation
            "If true, enthalpy of formation Hf is not included in specific enthalpy h";
          input Choices.ReferenceEnthalpy refChoice=referenceChoice
            "Choice of reference enthalpy";
          input SI.SpecificEnthalpy h_off=h_offset
            "User defined offset for reference enthalpy, if referenceChoice = UserDefined";
          output SI.SpecificEnthalpy h "Specific enthalpy at temperature T";
            //     annotation (InlineNoEvent=false, Inline=false,
            //                 derivative(zeroDerivative=data,
            //                            zeroDerivative=exclEnthForm,
            //                            zeroDerivative=refChoice,
            //                            zeroDerivative=h_off) = h_T_der);
        algorithm
          h := smooth(0,(if T < data.Tlimit then data.R*((-data.alow[1] + T*(data.
            blow[1] + data.alow[2]*Math.log(T) + T*(1.*data.alow[3] + T*(0.5*data.
            alow[4] + T*(1/3*data.alow[5] + T*(0.25*data.alow[6] + 0.2*data.alow[7]*T))))))
            /T) else data.R*((-data.ahigh[1] + T*(data.bhigh[1] + data.ahigh[2]*
            Math.log(T) + T*(1.*data.ahigh[3] + T*(0.5*data.ahigh[4] + T*(1/3*data.
            ahigh[5] + T*(0.25*data.ahigh[6] + 0.2*data.ahigh[7]*T))))))/T)) + (if
            exclEnthForm then -data.Hf else 0.0) + (if (refChoice
             == Choices.ReferenceEnthalpy.ZeroAt0K) then data.H0 else 0.0) + (if
            refChoice == Choices.ReferenceEnthalpy.UserDefined then h_off else
                  0.0));
          annotation (Inline=false,smoothOrder=2);
        end h_T;

        function h_T_der "derivative function for h_T"
            import Modelica.Media.Interfaces.PartialMedium.Choices;
          extends Modelica.Icons.Function;
          input IdealGases.Common.DataRecord data "Ideal gas data";
          input SI.Temperature T "Temperature";
          input Boolean exclEnthForm=excludeEnthalpyOfFormation
            "If true, enthalpy of formation Hf is not included in specific enthalpy h";
          input Choices.ReferenceEnthalpy refChoice=referenceChoice
            "Choice of reference enthalpy";
          input SI.SpecificEnthalpy h_off=h_offset
            "User defined offset for reference enthalpy, if referenceChoice = UserDefined";
          input Real dT "Temperature derivative";
          output Real h_der "Specific enthalpy at temperature T";
        algorithm
          h_der := dT*cp_T(data,T);
        end h_T_der;

        function h_Tlow "Compute specific enthalpy, low T region; reference is decided by the
    refChoice input, or by the referenceChoice package constant by default"
            import Modelica.Media.Interfaces.PartialMedium.Choices;
          extends Modelica.Icons.Function;
          input IdealGases.Common.DataRecord data "Ideal gas data";
          input SI.Temperature T "Temperature";
          input Boolean exclEnthForm=excludeEnthalpyOfFormation
            "If true, enthalpy of formation Hf is not included in specific enthalpy h";
          input Choices.ReferenceEnthalpy refChoice=referenceChoice
            "Choice of reference enthalpy";
          input SI.SpecificEnthalpy h_off=h_offset
            "User defined offset for reference enthalpy, if referenceChoice = UserDefined";
          output SI.SpecificEnthalpy h "Specific enthalpy at temperature T";
            //     annotation (Inline=false,InlineNoEvent=false, derivative(zeroDerivative=data,
            //                                zeroDerivative=exclEnthForm,
            //                                zeroDerivative=refChoice,
            //                                zeroDerivative=h_off) = h_Tlow_der);
        algorithm
          h := data.R*((-data.alow[1] + T*(data.
            blow[1] + data.alow[2]*Math.log(T) + T*(1.*data.alow[3] + T*(0.5*data.
            alow[4] + T*(1/3*data.alow[5] + T*(0.25*data.alow[6] + 0.2*data.alow[7]*T))))))
            /T) + (if
            exclEnthForm then -data.Hf else 0.0) + (if (refChoice
             == Choices.ReferenceEnthalpy.ZeroAt0K) then data.H0 else 0.0) + (if
            refChoice == Choices.ReferenceEnthalpy.UserDefined then h_off else
                  0.0);
          annotation(Inline=false,InlineNoEvent=false,smoothOrder=2);
        end h_Tlow;

        function h_Tlow_der "Compute specific enthalpy, low T region; reference is decided by the
    refChoice input, or by the referenceChoice package constant by default"
            import Modelica.Media.Interfaces.PartialMedium.Choices;
          extends Modelica.Icons.Function;
          input IdealGases.Common.DataRecord data "Ideal gas data";
          input SI.Temperature T "Temperature";
          input Boolean exclEnthForm=excludeEnthalpyOfFormation
            "If true, enthalpy of formation Hf is not included in specific enthalpy h";
          input Choices.ReferenceEnthalpy refChoice=referenceChoice
            "Choice of reference enthalpy";
          input SI.SpecificEnthalpy h_off=h_offset
            "User defined offset for reference enthalpy, if referenceChoice = UserDefined";
          input Real dT(unit="K/s") "Temperature derivative";
          output Real h_der(unit="J/(kg.s)")
            "Derivative of specific enthalpy at temperature T";
        algorithm
          h_der := dT*cp_Tlow(data,T);
        end h_Tlow_der;

        function s0_T "Compute specific entropy from temperature and gas data"
          extends Modelica.Icons.Function;
          input IdealGases.Common.DataRecord data "Ideal gas data";
          input SI.Temperature T "Temperature";
          output SI.SpecificEntropy s "Specific entropy at temperature T";
        algorithm
          s := noEvent(if T < data.Tlimit then data.R*(data.blow[2] - 0.5*data.alow[
            1]/(T*T) - data.alow[2]/T + data.alow[3]*Math.log(T) + T*(
            data.alow[4] + T*(0.5*data.alow[5] + T*(1/3*data.alow[6] + 0.25*data.alow[
            7]*T)))) else data.R*(data.bhigh[2] - 0.5*data.ahigh[1]/(T*T) - data.
            ahigh[2]/T + data.ahigh[3]*Math.log(T) + T*(data.ahigh[4]
             + T*(0.5*data.ahigh[5] + T*(1/3*data.ahigh[6] + 0.25*data.ahigh[7]*T)))));
          annotation (InlineNoEvent=false,smoothOrder=1);
        end s0_T;

        function s0_Tlow "Compute specific entropy, low T region"
          extends Modelica.Icons.Function;
          input IdealGases.Common.DataRecord data "Ideal gas data";
          input SI.Temperature T "Temperature";
          output SI.SpecificEntropy s "Specific entropy at temperature T";
        algorithm
          s := data.R*(data.blow[2] - 0.5*data.alow[
            1]/(T*T) - data.alow[2]/T + data.alow[3]*Math.log(T) + T*(
            data.alow[4] + T*(0.5*data.alow[5] + T*(1/3*data.alow[6] + 0.25*data.alow[
            7]*T))));
          annotation (InlineNoEvent=false,smoothOrder=1);
        end s0_Tlow;

        function dynamicViscosityLowPressure
          "Dynamic viscosity of low pressure gases"
          extends Modelica.Icons.Function;
          input SI.Temp_K T "Gas temperature";
          input SI.Temp_K Tc "Critical temperature of gas";
          input SI.MolarMass M "Molar mass of gas";
          input SI.MolarVolume Vc "Critical molar volume of gas";
          input Real w "Acentric factor of gas";
          input DipoleMoment mu "Dipole moment of gas molecule";
          input Real k =  0.0 "Special correction for highly polar substances";
          output SI.DynamicViscosity eta "Dynamic viscosity of gas";
        protected
          parameter Real Const1_SI=40.785*10^(-9.5)
            "Constant in formula for eta converted to SI units";
          parameter Real Const2_SI=131.3/1000.0
            "Constant in formula for mur converted to SI units";
          Real mur=Const2_SI*mu/sqrt(Vc*Tc)
            "Dimensionless dipole moment of gas molecule";
          Real Fc=1 - 0.2756*w + 0.059035*mur^4 + k
            "Factor to account for molecular shape and polarities of gas";
          Real Tstar "Dimensionless temperature defined by equation below";
          Real Ov "Viscosity collision integral for the gas";

        algorithm
          Tstar := 1.2593*T/Tc;
          Ov := 1.16145*Tstar^(-0.14874) + 0.52487*exp(-0.7732*Tstar) + 2.16178*exp(-2.43787
            *Tstar);
          eta := Const1_SI*Fc*sqrt(M*T)/(Vc^(2/3)*Ov);
          annotation (smoothOrder=2,
                      Documentation(info="<html>
<p>
The used formula are based on the method of Chung et al (1984, 1988) referred to in ref [1] chapter 9.
The formula 9-4.10 is the one being used. The Formula is given in non-SI units, the follwong onversion constants were used to
transform the formula to SI units:
</p>

<ul>
<li> <b>Const1_SI:</b> The factor 10^(-9.5) =10^(-2.5)*1e-7 where the
     factor 10^(-2.5) originates from the conversion of g/mol->kg/mol + cm^3/mol->m^3/mol
      and the factor 1e-7 is due to conversionfrom microPoise->Pa.s.</li>
<li>  <b>Const2_SI:</b> The factor 1/3.335641e-27 = 1e-3/3.335641e-30
      where the factor 3.335641e-30 comes from debye->C.m and
      1e-3 is due to conversion from cm^3/mol->m^3/mol</li>
</ul>

<h4>References:</h4>
<p>
[1] Bruce E. Poling, John E. Prausnitz, John P. O'Connell, \"The Properties of Gases and Liquids\" 5th Ed. Mc Graw Hill.
</p>

<h4>Author</h4>
<p>T. Skoglund, Lund, Sweden, 2004-08-31</p>

</html>"));
        end dynamicViscosityLowPressure;

        redeclare replaceable function extends dynamicViscosity
          "dynamic viscosity"
        algorithm
          assert(fluidConstants[1].hasCriticalData,
          "Failed to compute dynamicViscosity: For the species \"" + mediumName + "\" no critical data is available.");
          assert(fluidConstants[1].hasDipoleMoment,
          "Failed to compute dynamicViscosity: For the species \"" + mediumName + "\" no critical data is available.");
          eta := dynamicViscosityLowPressure(state.T,
                             fluidConstants[1].criticalTemperature,
                             fluidConstants[1].molarMass,
                             fluidConstants[1].criticalMolarVolume,
                             fluidConstants[1].acentricFactor,
                             fluidConstants[1].dipoleMoment);
          annotation (smoothOrder=2);
        end dynamicViscosity;

        function thermalConductivityEstimate
          "Thermal conductivity of polyatomic gases(Eucken and Modified Eucken correlation)"
          extends Modelica.Icons.Function;
          input SpecificHeatCapacity Cp "Constant pressure heat capacity";
          input DynamicViscosity eta "Dynamic viscosity";
          input Integer method(min=1,max=2)=1
            "1: Eucken Method, 2: Modified Eucken Method";
          output ThermalConductivity lambda "Thermal conductivity [W/(m.k)]";
        algorithm
          lambda := if method == 1 then eta*(Cp - data.R + (9/4)*data.R) else eta*(Cp
             - data.R)*(1.32 + 1.77/((Cp/Modelica.Constants.R) - 1.0));
          annotation (smoothOrder=2,
                      Documentation(info="<html>
<p>
This function provides two similar methods for estimating the
thermal conductivity of polyatomic gases.
The Eucken method (input method == 1) gives good results for low temperatures,
but it tends to give an underestimated value of the thermal conductivity
(lambda) at higher temperatures.<br>
The Modified Eucken method (input method == 2) gives good results for
high-temperatures, but it tends to give an overestimated value of the
thermal conductivity (lambda) at low temperatures.
</p>
</html>"));
        end thermalConductivityEstimate;

        redeclare replaceable function extends thermalConductivity
          "thermal conductivity of gas"
          input Integer method=1 "1: Eucken Method, 2: Modified Eucken Method";
        algorithm
          assert(fluidConstants[1].hasCriticalData,
          "Failed to compute thermalConductivity: For the species \"" + mediumName + "\" no critical data is available.");
          lambda := thermalConductivityEstimate(specificHeatCapacityCp(state),
            dynamicViscosity(state), method=method);
          annotation (smoothOrder=2);
        end thermalConductivity;

        redeclare function extends molarMass
          "return the molar mass of the medium"
        algorithm
          MM := data.MM;
        end molarMass;

        function T_h "Compute temperature from specific enthalpy"
          input SpecificEnthalpy h "Specific enthalpy";
          output Temperature T "Temperature";

        protected
        package Internal
            "Solve h(data,T) for T with given h (use only indirectly via temperature_phX)"
          extends Modelica.Media.Common.OneNonLinearEquation;
          redeclare record extends f_nonlinear_Data
              "Data to be passed to non-linear function"
            extends Modelica.Media.IdealGases.Common.DataRecord;
          end f_nonlinear_Data;

          redeclare function extends f_nonlinear
          algorithm
              y := h_T(f_nonlinear_data,x);
          end f_nonlinear;

          // Dummy definition has to be added for current Dymola
          redeclare function extends solve
          end solve;
        end Internal;

        algorithm
          T := Internal.solve(h, 200, 6000, 1.0e5, {1}, data);
        end T_h;

        function T_ps "Compute temperature from pressure and specific entropy"
          input AbsolutePressure p "Pressure";
          input SpecificEntropy s "Specific entropy";
          output Temperature T "Temperature";

        protected
        package Internal
            "Solve h(data,T) for T with given h (use only indirectly via temperature_phX)"
          extends Modelica.Media.Common.OneNonLinearEquation;
          redeclare record extends f_nonlinear_Data
              "Data to be passed to non-linear function"
            extends Modelica.Media.IdealGases.Common.DataRecord;
          end f_nonlinear_Data;

          redeclare function extends f_nonlinear
          algorithm
              y := s0_T(f_nonlinear_data,x)- data.R*Modelica.Math.log(p/reference_p);
          end f_nonlinear;

          // Dummy definition has to be added for current Dymola
          redeclare function extends solve
          end solve;
        end Internal;

        algorithm
          T := Internal.solve(s, 200, 6000, p, {1}, data);
        end T_ps;

        annotation (
          Documentation(info="<HTML>
<p>
This model calculates medium properties
for an ideal gas of a single substance, or for an ideal
gas consisting of several substances where the
mass fractions are fixed. Independent variables
are temperature <b>T</b> and pressure <b>p</b>.
Only density is a function of T and p. All other quantities
are solely a function of T. The properties
are valid in the range:
</p>
<pre>
   200 K &le; T &le; 6000 K
</pre>
<p>
The following quantities are always computed:
</p>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><td valign=\"top\"><b>Variable</b></td>
      <td valign=\"top\"><b>Unit</b></td>
      <td valign=\"top\"><b>Description</b></td></tr>
  <tr><td valign=\"top\">h</td>
      <td valign=\"top\">J/kg</td>
      <td valign=\"top\">specific enthalpy h = h(T)</td></tr>
  <tr><td valign=\"top\">u</td>
      <td valign=\"top\">J/kg</td>
      <td valign=\"top\">specific internal energy u = u(T)</b></td></tr>
  <tr><td valign=\"top\">d</td>
      <td valign=\"top\">kg/m^3</td>
      <td valign=\"top\">density d = d(p,T)</td></tr>
</table>
<p>
For the other variables, see the functions in
Modelica.Media.IdealGases.Common.SingleGasNasa.
Note, dynamic viscosity and thermal conductivity are only provided
for gases that use a data record from Modelica.Media.IdealGases.FluidData.
Currently these are the following gases:
</p>
<pre>
  Ar
  C2H2_vinylidene
  C2H4
  C2H5OH
  C2H6
  C3H6_propylene
  C3H7OH
  C3H8
  C4H8_1_butene
  C4H9OH
  C4H10_n_butane
  C5H10_1_pentene
  C5H12_n_pentane
  C6H6
  C6H12_1_hexene
  C6H14_n_heptane
  C7H14_1_heptene
  C8H10_ethylbenz
  CH3OH
  CH4
  CL2
  CO
  CO2
  F2
  H2
  H2O
  He
  N2
  N2O
  NH3
  NO
  O2
  SO2
  SO3
</pre>
<p>
<b>Sources for model and literature:</b><br>
Original Data: Computer program for calculation of complex chemical
equilibrium compositions and applications. Part 1: Analysis
Document ID: 19950013764 N (95N20180) File Series: NASA Technical Reports
Report Number: NASA-RP-1311  E-8017  NAS 1.61:1311
Authors: Gordon, Sanford (NASA Lewis Research Center)
 Mcbride, Bonnie J. (NASA Lewis Research Center)
Published: Oct 01, 1994.
</p>
<p><b>Known limits of validity:</b></br>
The data is valid for
temperatures between 200 K and 6000 K.  A few of the data sets for
monatomic gases have a discontinuous 1st derivative at 1000 K, but
this never caused problems so far.
</p>
<p>
This model has been copied from the ThermoFluid library
and adapted to the Modelica.Media package.
</p>
</HTML>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}),
               graphics),
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}),
                      graphics));
      end SingleGasNasa;

        package FluidData "Critical data, dipole moments and related data"
          extends Modelica.Icons.Package;
          import Modelica.Media.Interfaces.PartialMedium;
          import Modelica.Media.IdealGases.Common.SingleGasesData;

          constant SingleGasNasa.FluidConstants N2(
                               chemicalFormula =        "N2",
                               iupacName =              "unknown",
                               structureFormula =       "unknown",
                               casRegistryNumber =      "7727-37-9",
                               meltingPoint =            63.15,
                               normalBoilingPoint =      77.35,
                               criticalTemperature =    126.20,
                               criticalPressure =        33.98e5,
                               criticalMolarVolume =     90.10e-6,
                               acentricFactor =           0.037,
                               dipoleMoment =             0.0,
                               molarMass =              SingleGasesData.N2.MM,
                               hasDipoleMoment =       true,
                               hasIdealGasHeatCapacity=true,
                               hasCriticalData =       true,
                               hasAcentricFactor =     true);

          constant SingleGasNasa.FluidConstants H2O(
                               chemicalFormula =        "H2O",
                               iupacName =              "unknown",
                               structureFormula =       "unknown",
                               casRegistryNumber =      "7732-18-5",
                               meltingPoint =           273.15,
                               normalBoilingPoint =     373.15,
                               criticalTemperature =    647.14,
                               criticalPressure =       220.64e5,
                               criticalMolarVolume =     55.95e-6,
                               acentricFactor =           0.344,
                               dipoleMoment =             1.8,
                               molarMass =              SingleGasesData.H2O.MM,
                               hasDipoleMoment =       true,
                               hasIdealGasHeatCapacity=true,
                               hasCriticalData =       true,
                               hasAcentricFactor =     true);
          annotation (Documentation(info="<html>
<p>
This package contains FluidConstants data records for the following 37 gases
(see also the description in
<a href=\"modelica://Modelica.Media.IdealGases\">Modelica.Media.IdealGases</a>):
</p>
<pre>
Argon             Methane          Methanol       Carbon Monoxide  Carbon Dioxide
Acetylene         Ethylene         Ethanol        Ethane           Propylene
Propane           1-Propanol       1-Butene       N-Butane         1-Pentene
N-Pentane         Benzene          1-Hexene       N-Hexane         1-Heptane
N-Heptane         Ethylbenzene     N-Octane       Chlorine         Fluorine
Hydrogen          Steam            Helium         Ammonia          Nitric Oxide
Nitrogen Dioxide  Nitrogen         Nitrous        Oxide            Neon Oxygen
Sulfur Dioxide    Sulfur Trioxide
</pre>

</html>"));
        end FluidData;

        package SingleGasesData
        "Ideal gas data based on the NASA Glenn coefficients"
          extends Modelica.Icons.Package;

          constant IdealGases.Common.DataRecord Air(
            name="Air",
            MM=0.0289651159,
            Hf=-4333.833858403446,
            H0=298609.6803431054,
            Tlimit=1000,
            alow={10099.5016,-196.827561,5.00915511,-0.00576101373,1.06685993e-005,-7.94029797e-009,
                2.18523191e-012},
            blow={-176.796731,-3.921504225},
            ahigh={241521.443,-1257.8746,5.14455867,-0.000213854179,7.06522784e-008,-1.07148349e-011,
                6.57780015e-016},
            bhigh={6462.26319,-8.147411905},
            R=287.0512249529787);

          constant IdealGases.Common.DataRecord H2O(
            name="H2O",
            MM=0.01801528,
            Hf=-13423382.81725291,
            H0=549760.6476280135,
            Tlimit=1000,
            alow={-39479.6083,575.573102,0.931782653,0.00722271286,-7.34255737e-006,
                4.95504349e-009,-1.336933246e-012},
            blow={-33039.7431,17.24205775},
            ahigh={1034972.096,-2412.698562,4.64611078,0.002291998307,-6.836830479999999e-007,
                9.426468930000001e-011,-4.82238053e-015},
            bhigh={-13842.86509,-7.97814851},
            R=461.5233290850878);

          constant IdealGases.Common.DataRecord N2(
            name="N2",
            MM=0.0280134,
            Hf=0,
            H0=309498.4543111511,
            Tlimit=1000,
            alow={22103.71497,-381.846182,6.08273836,-0.00853091441,1.384646189e-005,-9.62579362e-009,
                2.519705809e-012},
            blow={710.846086,-10.76003744},
            ahigh={587712.406,-2239.249073,6.06694922,-0.00061396855,1.491806679e-007,-1.923105485e-011,
                1.061954386e-015},
            bhigh={12832.10415,-15.86640027},
            R=296.8033869505308);
          annotation ( Documentation(info="<HTML>
<p>This package contains ideal gas models for the 1241 ideal gases from</p>
<blockquote>
  <p>McBride B.J., Zehe M.J., and Gordon S. (2002): <b>NASA Glenn Coefficients
  for Calculating Thermodynamic Properties of Individual Species</b>. NASA
  report TP-2002-211556</p>
</blockquote>

<pre>
 Ag        BaOH+           C2H4O_ethylen_o DF      In2I4    Nb      ScO2
 Ag+       Ba_OH_2         CH3CHO_ethanal  DOCl    In2I6    Nb+     Sc2O
 Ag-       BaS             CH3COOH         DO2     In2O     Nb-     Sc2O2
 Air       Ba2             OHCH2COOH       DO2-    K        NbCl5   Si
 Al        Be              C2H5            D2      K+       NbO     Si+
 Al+       Be+             C2H5Br          D2+     K-       NbOCl3  Si-
 Al-       Be++            C2H6            D2-     KAlF4    NbO2    SiBr
 AlBr      BeBr            CH3N2CH3        D2O     KBO2     Ne      SiBr2
 AlBr2     BeBr2           C2H5OH          D2O2    KBr      Ne+     SiBr3
 AlBr3     BeCl            CH3OCH3         D2S     KCN      Ni      SiBr4
 AlC       BeCl2           CH3O2CH3        e-      KCl      Ni+     SiC
 AlC2      BeF             CCN             F       KF       Ni-     SiC2
 AlCl      BeF2            CNC             F+      KH       NiCl    SiCl
 AlCl+     BeH             OCCN            F-      KI       NiCl2   SiCl2
 AlCl2     BeH+            C2N2            FCN     Kli      NiO     SiCl3
 AlCl3     BeH2            C2O             FCO     KNO2     NiS     SiCl4
 AlF       BeI             C3              FO      KNO3     O       SiF
 AlF+      BeI2            C3H3_1_propynl  FO2_FOO KNa      O+      SiFCl
 AlFCl     BeN             C3H3_2_propynl  FO2_OFO KO       O-      SiF2
 AlFCl2    BeO             C3H4_allene     F2      KOH      OD      SiF3
 AlF2      BeOH            C3H4_propyne    F2O     K2       OD-     SiF4
 AlF2-     BeOH+           C3H4_cyclo      F2O2    K2+      OH      SiH
 AlF2Cl    Be_OH_2         C3H5_allyl      FS2F    K2Br2    OH+     SiH+
 AlF3      BeS             C3H6_propylene  Fe      K2CO3    OH-     SiHBr3
 AlF4-     Be2             C3H6_cyclo      Fe+     K2C2N2   O2      SiHCl
 AlH       Be2Cl4          C3H6O_propylox  Fe_CO_5 K2Cl2    O2+     SiHCl3
 AlHCl     Be2F4           C3H6O_acetone   FeCl    K2F2     O2-     SiHF
 AlHCl2    Be2O            C3H6O_propanal  FeCl2   K2I2     O3      SiHF3
 AlHF      Be2OF2          C3H7_n_propyl   FeCl3   K2O      P       SiHI3
 AlHFCl    Be2O2           C3H7_i_propyl   FeO     K2O+     P+      SiH2
 AlHF2     Be3O3           C3H8            Fe_OH_2 K2O2     P-      SiH2Br2
 AlH2      Be4O4           C3H8O_1propanol Fe2Cl4  K2O2H2   PCl     SiH2Cl2
 AlH2Cl    Br              C3H8O_2propanol Fe2Cl6  K2SO4    PCl2    SiH2F2
 AlH2F     Br+             CNCOCN          Ga      Kr       PCl2-   SiH2I2
 AlH3      Br-             C3O2            Ga+     Kr+      PCl3    SiH3
 AlI       BrCl            C4              GaBr    li       PCl5    SiH3Br
 AlI2      BrF             C4H2_butadiyne  GaBr2   li+      PF      SiH3Cl
 AlI3      BrF3            C4H4_1_3-cyclo  GaBr3   li-      PF+     SiH3F
 AlN       BrF5            C4H6_butadiene  GaCl    liAlF4   PF-     SiH3I
 AlO       BrO             C4H6_1butyne    GaCl2   liBO2    PFCl    SiH4
 AlO+      OBrO            C4H6_2butyne    GaCl3   liBr     PFCl-   SiI
 AlO-      BrOO            C4H6_cyclo      GaF     liCl     PFCl2   SiI2
 AlOCl     BrO3            C4H8_1_butene   GaF2    liF      PFCl4   SiN
 AlOCl2    Br2             C4H8_cis2_buten GaF3    liH      PF2     SiO
 AlOF      BrBrO           C4H8_isobutene  GaH     liI      PF2-    SiO2
 AlOF2     BrOBr           C4H8_cyclo      GaI     liN      PF2Cl   SiS
 AlOF2-    C               C4H9_n_butyl    GaI2    liNO2    PF2Cl3  SiS2
 AlOH      C+              C4H9_i_butyl    GaI3    liNO3    PF3     Si2
 AlOHCl    C-              C4H9_s_butyl    GaO     liO      PF3Cl2  Si2C
 AlOHCl2   CBr             C4H9_t_butyl    GaOH    liOF     PF4Cl   Si2F6
 AlOHF     CBr2            C4H10_n_butane  Ga2Br2  liOH     PF5     Si2N
 AlOHF2    CBr3            C4H10_isobutane Ga2Br4  liON     PH      Si3
 AlO2      CBr4            C4N2            Ga2Br6  li2      PH2     Sn
 AlO2-     CCl             C5              Ga2Cl2  li2+     PH2-    Sn+
 Al_OH_2   CCl2            C5H6_1_3cyclo   Ga2Cl4  li2Br2   PH3     Sn-
 Al_OH_2Cl CCl2Br2         C5H8_cyclo      Ga2Cl6  li2F2    PN      SnBr
 Al_OH_2F  CCl3            C5H10_1_pentene Ga2F2   li2I2    PO      SnBr2
 Al_OH_3   CCl3Br          C5H10_cyclo     Ga2F4   li2O     PO-     SnBr3
 AlS       CCl4            C5H11_pentyl    Ga2F6   li2O+    POCl3   SnBr4
 AlS2      CF              C5H11_t_pentyl  Ga2I2   li2O2    POFCl2  SnCl
 Al2       CF+             C5H12_n_pentane Ga2I4   li2O2H2  POF2Cl  SnCl2
 Al2Br6    CFBr3           C5H12_i_pentane Ga2I6   li2SO4   POF3    SnCl3
 Al2C2     CFCl            CH3C_CH3_2CH3   Ga2O    li3+     PO2     SnCl4
 Al2Cl6    CFClBr2         C6D5_phenyl     Ge      li3Br3   PO2-    SnF
 Al2F6     CFCl2           C6D6            Ge+     li3Cl3   PS      SnF2
 Al2I6     CFCl2Br         C6H2            Ge-     li3F3    P2      SnF3
 Al2O      CFCl3           C6H5_phenyl     GeBr    li3I3    P2O3    SnF4
 Al2O+     CF2             C6H5O_phenoxy   GeBr2   Mg       P2O4    SnI
 Al2O2     CF2+            C6H6            GeBr3   Mg+      P2O5    SnI2
 Al2O2+    CF2Br2          C6H5OH_phenol   GeBr4   MgBr     P3      SnI3
 Al2O3     CF2Cl           C6H10_cyclo     GeCl    MgBr2    P3O6    SnI4
 Al2S      CF2ClBr         C6H12_1_hexene  GeCl2   MgCl     P4      SnO
 Al2S2     CF2Cl2          C6H12_cyclo     GeCl3   MgCl+    P4O6    SnO2
 Ar        CF3             C6H13_n_hexyl   GeCl4   MgCl2    P4O7    SnS
 Ar+       CF3+            C6H14_n_hexane  GeF     MgF      P4O8    SnS2
 B         CF3Br           C7H7_benzyl     GeF2    MgF+     P4O9    Sn2
 B+        CF3Cl           C7H8            GeF3    MgF2     P4O10   Sr
 B-        CF4             C7H8O_cresol_mx GeF4    MgF2+    Pb      Sr+
 BBr       CH+             C7H14_1_heptene GeH4    MgH      Pb+     SrBr
 BBr2      CHBr3           C7H15_n_heptyl  GeI     MgI      Pb-     SrBr2
 BBr3      CHCl            C7H16_n_heptane GeO     MgI2     PbBr    SrCl
 BC        CHClBr2         C7H16_2_methylh GeO2    MgN      PbBr2   SrCl+
 BC2       CHCl2           C8H8_styrene    GeS     MgO      PbBr3   SrCl2
 BCl       CHCl2Br         C8H10_ethylbenz GeS2    MgOH     PbBr4   SrF
 BCl+      CHCl3           C8H16_1_octene  Ge2     MgOH+    PbCl    SrF+
 BClOH     CHF             C8H17_n_octyl   H       Mg_OH_2  PbCl2   SrF2
 BCl_OH_2  CHFBr2          C8H18_n_octane  H+      MgS      PbCl3   SrH
 BCl2      CHFCl           C8H18_isooctane H-      Mg2      PbCl4   SrI
 BCl2+     CHFClBr         C9H19_n_nonyl   HAlO    Mg2F4    PbF     SrI2
 BCl2OH    CHFCl2          C10H8_naphthale HAlO2   Mn       PbF2    SrO
 BF        CHF2            C10H21_n_decyl  HBO     Mn+      PbF3    SrOH
 BFCl      CHF2Br          C12H9_o_bipheny HBO+    Mo       PbF4    SrOH+
 BFCl2     CHF2Cl          C12H10_biphenyl HBO2    Mo+      PbI     Sr_OH_2
 BFOH      CHF3            Ca              HBS     Mo-      PbI2    SrS
 BF_OH_2   CHI3            Ca+             HBS+    MoO      PbI3    Sr2
 BF2       CH2             CaBr            HCN     MoO2     PbI4    Ta
 BF2+      CH2Br2          CaBr2           HCO     MoO3     PbO     Ta+
 BF2-      CH2Cl           CaCl            HCO+    MoO3-    PbO2    Ta-
 BF2Cl     CH2ClBr         CaCl+           HCCN    Mo2O6    PbS     TaCl5
 BF2OH     CH2Cl2          CaCl2           HCCO    Mo3O9    PbS2    TaO
 BF3       CH2F            CaF             HCl     Mo4O12   Rb      TaO2
 BF4-      CH2FBr          CaF+            HD      Mo5O15   Rb+     Ti
 BH        CH2FCl          CaF2            HD+     N        Rb-     Ti+
 BHCl      CH2F2           CaH             HDO     N+       RbBO2   Ti-
 BHCl2     CH2I2           CaI             HDO2    N-       RbBr    TiCl
 BHF       CH3             CaI2            HF      NCO      RbCl    TiCl2
 BHFCl     CH3Br           CaO             HI      ND       RbF     TiCl3
 BHF2      CH3Cl           CaO+            HNC     ND2      RbH     TiCl4
 BH2       CH3F            CaOH            HNCO    ND3      RbI     TiO
 BH2Cl     CH3I            CaOH+           HNO     NF       RbK     TiO+
 BH2F      CH2OH           Ca_OH_2         HNO2    NF2      Rbli    TiOCl
 BH3       CH2OH+          CaS             HNO3    NF3      RbNO2   TiOCl2
 BH3NH3    CH3O            Ca2             HOCl    NH       RbNO3   TiO2
 BH4       CH4             Cd              HOF     NH+      RbNa    U
 BI        CH3OH           Cd+             HO2     NHF      RbO     UF
 BI2       CH3OOH          Cl              HO2-    NHF2     RbOH    UF+
 BI3       CI              Cl+             HPO     NH2      Rb2Br2  UF-
 BN        CI2             Cl-             HSO3F   NH2F     Rb2Cl2  UF2
 BO        CI3             ClCN            H2      NH3      Rb2F2   UF2+
 BO-       CI4             ClF             H2+     NH2OH    Rb2I2   UF2-
 BOCl      CN              ClF3            H2-     NH4+     Rb2O    UF3
 BOCl2     CN+             ClF5            HBOH    NO       Rb2O2   UF3+
 BOF       CN-             ClO             HCOOH   NOCl     Rb2O2H2 UF3-
 BOF2      CNN             ClO2            H2F2    NOF      Rb2SO4  UF4
 BOH       CO              Cl2             H2O     NOF3     Rn      UF4+
 BO2       CO+             Cl2O            H2O+    NO2      Rn+     UF4-
 BO2-      COCl            Co              H2O2    NO2-     S       UF5
 B_OH_2    COCl2           Co+             H2S     NO2Cl    S+      UF5+
 BS        COFCl           Co-             H2SO4   NO2F     S-      UF5-
 BS2       COF2            Cr              H2BOH   NO3      SCl     UF6
 B2        COHCl           Cr+             HB_OH_2 NO3-     SCl2    UF6-
 B2C       COHF            Cr-             H3BO3   NO3F     SCl2+   UO
 B2Cl4     COS             CrN             H3B3O3  N2       SD      UO+
 B2F4      CO2             CrO             H3B3O6  N2+      SF      UOF
 B2H       CO2+            CrO2            H3F3    N2-      SF+     UOF2
 B2H2      COOH            CrO3            H3O+    NCN      SF-     UOF3
 B2H3      CP              CrO3-           H4F4    N2D2_cis SF2     UOF4
 B2H3_db   CS              Cs              H5F5    N2F2     SF2+    UO2
 B2H4      CS2             Cs+             H6F6    N2F4     SF2-    UO2+
 B2H4_db   C2              Cs-             H7F7    N2H2     SF3     UO2-
 B2H5      C2+             CsBO2           He      NH2NO2   SF3+    UO2F
 B2H5_db   C2-             CsBr            He+     N2H4     SF3-    UO2F2
 B2H6      C2Cl            CsCl            Hg      N2O      SF4     UO3
 B2O       C2Cl2           CsF             Hg+     N2O+     SF4+    UO3-
 B2O2      C2Cl3           CsH             HgBr2   N2O3     SF4-    V
 B2O3      C2Cl4           CsI             I       N2O4     SF5     V+
 B2_OH_4   C2Cl6           Csli            I+      N2O5     SF5+    V-
 B2S       C2F             CsNO2           I-      N3       SF5-    VCl4
 B2S2      C2FCl           CsNO3           IF5     N3H      SF6     VN
 B2S3      C2FCl3          CsNa            IF7     Na       SF6-    VO
 B3H7_C2v  C2F2            CsO             I2      Na+      SH      VO2
 B3H7_Cs   C2F2Cl2         CsOH            In      Na-      SH-     V4O10
 B3H9      C2F3            CsRb            In+     NaAlF4   SN      W
 B3N3H6    C2F3Cl          Cs2             InBr    NaBO2    SO      W+
 B3O3Cl3   C2F4            Cs2Br2          InBr2   NaBr     SO-     W-
 B3O3FCl2  C2F6            Cs2CO3          InBr3   NaCN     SOF2    WCl6
 B3O3F2Cl  C2H             Cs2Cl2          InCl    NaCl     SO2     WO
 B3O3F3    C2HCl           Cs2F2           InCl2   NaF      SO2-    WOCl4
 B4H4      C2HCl3          Cs2I2           InCl3   NaH      SO2Cl2  WO2
 B4H10     C2HF            Cs2O            InF     NaI      SO2FCl  WO2Cl2
 B4H12     C2HFCl2         Cs2O+           InF2    Nali     SO2F2   WO3
 B5H9      C2HF2Cl         Cs2O2           InF3    NaNO2    SO3     WO3-
 Ba        C2HF3           Cs2O2H2         InH     NaNO3    S2      Xe
 Ba+       C2H2_vinylidene Cs2SO4          InI     NaO      S2-     Xe+
 BaBr      C2H2Cl2         Cu              InI2    NaOH     S2Cl2   Zn
 BaBr2     C2H2FCl         Cu+             InI3    NaOH+    S2F2    Zn+
 BaCl      C2H2F2          Cu-             InO     Na2      S2O     Zr
 BaCl+     CH2CO_ketene    CuCl            InOH    Na2Br2   S3      Zr+
 BaCl2     O_CH_2O         CuF             In2Br2  Na2Cl2   S4      Zr-
 BaF       HO_CO_2OH       CuF2            In2Br4  Na2F2    S5      ZrN
 BaF+      C2H3_vinyl      CuO             In2Br6  Na2I2    S6      ZrO
 BaF2      CH2Br-COOH      Cu2             In2Cl2  Na2O     S7      ZrO+
 BaH       C2H3Cl          Cu3Cl3          In2Cl4  Na2O+    S8      ZrO2
 BaI       CH2Cl-COOH      D               In2Cl6  Na2O2    Sc
 BaI2      C2H3F           D+              In2F2   Na2O2H2  Sc+
 BaO       CH3CN           D-              In2F4   Na2SO4   Sc-
 BaO+      CH3CO_acetyl    DBr             In2F6   Na3Cl3   ScO
 BaOH      C2H4            DCl             In2I2   Na3F3    ScO+
</pre>

</HTML>"));
        end SingleGasesData;
      annotation (Documentation(info="<html>

</html>"));
      end Common;
    annotation (
      __Dymola_classOrder={"Common", "SingleGases", "MixtureGases"},
    Documentation(info="<HTML>
<p>This package contains data for the 1241 ideal gases from</p>
<blockquote>
  <p>McBride B.J., Zehe M.J., and Gordon S. (2002): <b>NASA Glenn Coefficients
  for Calculating Thermodynamic Properties of Individual Species</b>. NASA
  report TP-2002-211556</p>
</blockquote>
<p>Medium models for some of these gases are available in package
<a href=\"modelica://Modelica.Media.IdealGases.SingleGases\">IdealGases.SingleGases</a>
and some examples for mixtures are available in package <a href=\"modelica://Modelica.Media.IdealGases.MixtureGases\">IdealGases.MixtureGases</a>
</p>
<h4>Using and Adapting Medium Models</h4>
<p>
The data records allow computing the ideal gas specific enthalpy, specific entropy and heat capacity of the substances listed below. From them, even the Gibbs energy and equilibrium constants for reactions can be computed. Critical data that is needed for computing the viscosity and thermal conductivity is not included. In order to add mixtures or single substance medium packages that are
subtypes of
<a href=\"modelica://Modelica.Media.Interfaces.PartialMedium\">Interfaces.PartialMedium</a>
(i.e., can be utilized at all places where PartialMedium is defined),
a few additional steps have to be performed:
<ol>
<li>
All single gas media need to define a constant instance of record
<a href=\"modelica://Modelica.Media.IdealGases.Common.SingleGasNasa.FluidConstants\">IdealGases.Common.SingleGasNasa.FluidConstants</a>.
For 37 ideal gases such records are provided in package
<a href=\"modelica://Modelica.Media.IdealGases.Common.FluidData\">IdealGases.Common.FluidData</a>.
For the other gases, such a record instance has to be provided by the user, e.g., by getting
the data from a commercial or public data base. A public source of the needed data is for example the <a href=\"http://webbook.nist.gov/chemistry/\"> NIST Chemistry WebBook</a></li>

<li>When the data is available, and a user has an instance of a
<a href=\"modelica://Modelica.Media.IdealGases.Common.SingleGasNasa.FluidConstants\">FluidConstants</a> record filled with data, a medium package has to be written. Note that only the dipole moment, the accentric factor and critical data are necessary for the viscosity and thermal conductivity functions.</li>
<ul>
<li>For single components, a new package following the pattern in
<a href=\"modelica://Modelica.Media.IdealGases.SingleGases\">IdealGases.SingleGases</a> has to be created, pointing both to a data record for cp and to a user-defined fluidContants record.</li>
<li>For mixtures of several components, a new package following the pattern in
<a href=\"modelica://Modelica.Media.IdealGases.MixtureGases\">IdealGases.MixtureGases</a> has to be created, building an array of data records for cp and an array of (partly) user-defined fluidContants records.</li>
</ul>
</ol>
<p>Note that many properties can computed for the full set of 1241 gases listed below, but due to the missing viscosity and thermal conductivity functions, no fully Modelica.Media-compliant media can be defined.</p>
</p>
<p>
Data records for heat capacity, specific enthalpy and specific entropy exist for the following substances and ions:
</p>
<pre>
 Ag        BaOH+           C2H4O_ethylen_o DF      In2I4    Nb      ScO2
 Ag+       Ba_OH_2         CH3CHO_ethanal  DOCl    In2I6    Nb+     Sc2O
 Ag-       BaS             CH3COOH         DO2     In2O     Nb-     Sc2O2
 Air       Ba2             OHCH2COOH       DO2-    K        NbCl5   Si
 Al        Be              C2H5            D2      K+       NbO     Si+
 Al+       Be+             C2H5Br          D2+     K-       NbOCl3  Si-
 Al-       Be++            C2H6            D2-     KAlF4    NbO2    SiBr
 AlBr      BeBr            CH3N2CH3        D2O     KBO2     Ne      SiBr2
 AlBr2     BeBr2           C2H5OH          D2O2    KBr      Ne+     SiBr3
 AlBr3     BeCl            CH3OCH3         D2S     KCN      Ni      SiBr4
 AlC       BeCl2           CH3O2CH3        e-      KCl      Ni+     SiC
 AlC2      BeF             CCN             F       KF       Ni-     SiC2
 AlCl      BeF2            CNC             F+      KH       NiCl    SiCl
 AlCl+     BeH             OCCN            F-      KI       NiCl2   SiCl2
 AlCl2     BeH+            C2N2            FCN     Kli      NiO     SiCl3
 AlCl3     BeH2            C2O             FCO     KNO2     NiS     SiCl4
 AlF       BeI             C3              FO      KNO3     O       SiF
 AlF+      BeI2            C3H3_1_propynl  FO2_FOO KNa      O+      SiFCl
 AlFCl     BeN             C3H3_2_propynl  FO2_OFO KO       O-      SiF2
 AlFCl2    BeO             C3H4_allene     F2      KOH      OD      SiF3
 AlF2      BeOH            C3H4_propyne    F2O     K2       OD-     SiF4
 AlF2-     BeOH+           C3H4_cyclo      F2O2    K2+      OH      SiH
 AlF2Cl    Be_OH_2         C3H5_allyl      FS2F    K2Br2    OH+     SiH+
 AlF3      BeS             C3H6_propylene  Fe      K2CO3    OH-     SiHBr3
 AlF4-     Be2             C3H6_cyclo      Fe+     K2C2N2   O2      SiHCl
 AlH       Be2Cl4          C3H6O_propylox  Fe_CO_5 K2Cl2    O2+     SiHCl3
 AlHCl     Be2F4           C3H6O_acetone   FeCl    K2F2     O2-     SiHF
 AlHCl2    Be2O            C3H6O_propanal  FeCl2   K2I2     O3      SiHF3
 AlHF      Be2OF2          C3H7_n_propyl   FeCl3   K2O      P       SiHI3
 AlHFCl    Be2O2           C3H7_i_propyl   FeO     K2O+     P+      SiH2
 AlHF2     Be3O3           C3H8            Fe_OH_2 K2O2     P-      SiH2Br2
 AlH2      Be4O4           C3H8O_1propanol Fe2Cl4  K2O2H2   PCl     SiH2Cl2
 AlH2Cl    Br              C3H8O_2propanol Fe2Cl6  K2SO4    PCl2    SiH2F2
 AlH2F     Br+             CNCOCN          Ga      Kr       PCl2-   SiH2I2
 AlH3      Br-             C3O2            Ga+     Kr+      PCl3    SiH3
 AlI       BrCl            C4              GaBr    li       PCl5    SiH3Br
 AlI2      BrF             C4H2_butadiyne  GaBr2   li+      PF      SiH3Cl
 AlI3      BrF3            C4H4_1_3-cyclo  GaBr3   li-      PF+     SiH3F
 AlN       BrF5            C4H6_butadiene  GaCl    liAlF4   PF-     SiH3I
 AlO       BrO             C4H6_1butyne    GaCl2   liBO2    PFCl    SiH4
 AlO+      OBrO            C4H6_2butyne    GaCl3   liBr     PFCl-   SiI
 AlO-      BrOO            C4H6_cyclo      GaF     liCl     PFCl2   SiI2
 AlOCl     BrO3            C4H8_1_butene   GaF2    liF      PFCl4   SiN
 AlOCl2    Br2             C4H8_cis2_buten GaF3    liH      PF2     SiO
 AlOF      BrBrO           C4H8_isobutene  GaH     liI      PF2-    SiO2
 AlOF2     BrOBr           C4H8_cyclo      GaI     liN      PF2Cl   SiS
 AlOF2-    C               C4H9_n_butyl    GaI2    liNO2    PF2Cl3  SiS2
 AlOH      C+              C4H9_i_butyl    GaI3    liNO3    PF3     Si2
 AlOHCl    C-              C4H9_s_butyl    GaO     liO      PF3Cl2  Si2C
 AlOHCl2   CBr             C4H9_t_butyl    GaOH    liOF     PF4Cl   Si2F6
 AlOHF     CBr2            C4H10_n_butane  Ga2Br2  liOH     PF5     Si2N
 AlOHF2    CBr3            C4H10_isobutane Ga2Br4  liON     PH      Si3
 AlO2      CBr4            C4N2            Ga2Br6  li2      PH2     Sn
 AlO2-     CCl             C5              Ga2Cl2  li2+     PH2-    Sn+
 Al_OH_2   CCl2            C5H6_1_3cyclo   Ga2Cl4  li2Br2   PH3     Sn-
 Al_OH_2Cl CCl2Br2         C5H8_cyclo      Ga2Cl6  li2F2    PN      SnBr
 Al_OH_2F  CCl3            C5H10_1_pentene Ga2F2   li2I2    PO      SnBr2
 Al_OH_3   CCl3Br          C5H10_cyclo     Ga2F4   li2O     PO-     SnBr3
 AlS       CCl4            C5H11_pentyl    Ga2F6   li2O+    POCl3   SnBr4
 AlS2      CF              C5H11_t_pentyl  Ga2I2   li2O2    POFCl2  SnCl
 Al2       CF+             C5H12_n_pentane Ga2I4   li2O2H2  POF2Cl  SnCl2
 Al2Br6    CFBr3           C5H12_i_pentane Ga2I6   li2SO4   POF3    SnCl3
 Al2C2     CFCl            CH3C_CH3_2CH3   Ga2O    li3+     PO2     SnCl4
 Al2Cl6    CFClBr2         C6D5_phenyl     Ge      li3Br3   PO2-    SnF
 Al2F6     CFCl2           C6D6            Ge+     li3Cl3   PS      SnF2
 Al2I6     CFCl2Br         C6H2            Ge-     li3F3    P2      SnF3
 Al2O      CFCl3           C6H5_phenyl     GeBr    li3I3    P2O3    SnF4
 Al2O+     CF2             C6H5O_phenoxy   GeBr2   Mg       P2O4    SnI
 Al2O2     CF2+            C6H6            GeBr3   Mg+      P2O5    SnI2
 Al2O2+    CF2Br2          C6H5OH_phenol   GeBr4   MgBr     P3      SnI3
 Al2O3     CF2Cl           C6H10_cyclo     GeCl    MgBr2    P3O6    SnI4
 Al2S      CF2ClBr         C6H12_1_hexene  GeCl2   MgCl     P4      SnO
 Al2S2     CF2Cl2          C6H12_cyclo     GeCl3   MgCl+    P4O6    SnO2
 Ar        CF3             C6H13_n_hexyl   GeCl4   MgCl2    P4O7    SnS
 Ar+       CF3+            C6H14_n_hexane  GeF     MgF      P4O8    SnS2
 B         CF3Br           C7H7_benzyl     GeF2    MgF+     P4O9    Sn2
 B+        CF3Cl           C7H8            GeF3    MgF2     P4O10   Sr
 B-        CF4             C7H8O_cresol_mx GeF4    MgF2+    Pb      Sr+
 BBr       CH+             C7H14_1_heptene GeH4    MgH      Pb+     SrBr
 BBr2      CHBr3           C7H15_n_heptyl  GeI     MgI      Pb-     SrBr2
 BBr3      CHCl            C7H16_n_heptane GeO     MgI2     PbBr    SrCl
 BC        CHClBr2         C7H16_2_methylh GeO2    MgN      PbBr2   SrCl+
 BC2       CHCl2           C8H8_styrene    GeS     MgO      PbBr3   SrCl2
 BCl       CHCl2Br         C8H10_ethylbenz GeS2    MgOH     PbBr4   SrF
 BCl+      CHCl3           C8H16_1_octene  Ge2     MgOH+    PbCl    SrF+
 BClOH     CHF             C8H17_n_octyl   H       Mg_OH_2  PbCl2   SrF2
 BCl_OH_2  CHFBr2          C8H18_n_octane  H+      MgS      PbCl3   SrH
 BCl2      CHFCl           C8H18_isooctane H-      Mg2      PbCl4   SrI
 BCl2+     CHFClBr         C9H19_n_nonyl   HAlO    Mg2F4    PbF     SrI2
 BCl2OH    CHFCl2          C10H8_naphthale HAlO2   Mn       PbF2    SrO
 BF        CHF2            C10H21_n_decyl  HBO     Mn+      PbF3    SrOH
 BFCl      CHF2Br          C12H9_o_bipheny HBO+    Mo       PbF4    SrOH+
 BFCl2     CHF2Cl          C12H10_biphenyl HBO2    Mo+      PbI     Sr_OH_2
 BFOH      CHF3            Ca              HBS     Mo-      PbI2    SrS
 BF_OH_2   CHI3            Ca+             HBS+    MoO      PbI3    Sr2
 BF2       CH2             CaBr            HCN     MoO2     PbI4    Ta
 BF2+      CH2Br2          CaBr2           HCO     MoO3     PbO     Ta+
 BF2-      CH2Cl           CaCl            HCO+    MoO3-    PbO2    Ta-
 BF2Cl     CH2ClBr         CaCl+           HCCN    Mo2O6    PbS     TaCl5
 BF2OH     CH2Cl2          CaCl2           HCCO    Mo3O9    PbS2    TaO
 BF3       CH2F            CaF             HCl     Mo4O12   Rb      TaO2
 BF4-      CH2FBr          CaF+            HD      Mo5O15   Rb+     Ti
 BH        CH2FCl          CaF2            HD+     N        Rb-     Ti+
 BHCl      CH2F2           CaH             HDO     N+       RbBO2   Ti-
 BHCl2     CH2I2           CaI             HDO2    N-       RbBr    TiCl
 BHF       CH3             CaI2            HF      NCO      RbCl    TiCl2
 BHFCl     CH3Br           CaO             HI      ND       RbF     TiCl3
 BHF2      CH3Cl           CaO+            HNC     ND2      RbH     TiCl4
 BH2       CH3F            CaOH            HNCO    ND3      RbI     TiO
 BH2Cl     CH3I            CaOH+           HNO     NF       RbK     TiO+
 BH2F      CH2OH           Ca_OH_2         HNO2    NF2      Rbli    TiOCl
 BH3       CH2OH+          CaS             HNO3    NF3      RbNO2   TiOCl2
 BH3NH3    CH3O            Ca2             HOCl    NH       RbNO3   TiO2
 BH4       CH4             Cd              HOF     NH+      RbNa    U
 BI        CH3OH           Cd+             HO2     NHF      RbO     UF
 BI2       CH3OOH          Cl              HO2-    NHF2     RbOH    UF+
 BI3       CI              Cl+             HPO     NH2      Rb2Br2  UF-
 BN        CI2             Cl-             HSO3F   NH2F     Rb2Cl2  UF2
 BO        CI3             ClCN            H2      NH3      Rb2F2   UF2+
 BO-       CI4             ClF             H2+     NH2OH    Rb2I2   UF2-
 BOCl      CN              ClF3            H2-     NH4+     Rb2O    UF3
 BOCl2     CN+             ClF5            HBOH    NO       Rb2O2   UF3+
 BOF       CN-             ClO             HCOOH   NOCl     Rb2O2H2 UF3-
 BOF2      CNN             ClO2            H2F2    NOF      Rb2SO4  UF4
 BOH       CO              Cl2             H2O     NOF3     Rn      UF4+
 BO2       CO+             Cl2O            H2O+    NO2      Rn+     UF4-
 BO2-      COCl            Co              H2O2    NO2-     S       UF5
 B_OH_2    COCl2           Co+             H2S     NO2Cl    S+      UF5+
 BS        COFCl           Co-             H2SO4   NO2F     S-      UF5-
 BS2       COF2            Cr              H2BOH   NO3      SCl     UF6
 B2        COHCl           Cr+             HB_OH_2 NO3-     SCl2    UF6-
 B2C       COHF            Cr-             H3BO3   NO3F     SCl2+   UO
 B2Cl4     COS             CrN             H3B3O3  N2       SD      UO+
 B2F4      CO2             CrO             H3B3O6  N2+      SF      UOF
 B2H       CO2+            CrO2            H3F3    N2-      SF+     UOF2
 B2H2      COOH            CrO3            H3O+    NCN      SF-     UOF3
 B2H3      CP              CrO3-           H4F4    N2D2_cis SF2     UOF4
 B2H3_db   CS              Cs              H5F5    N2F2     SF2+    UO2
 B2H4      CS2             Cs+             H6F6    N2F4     SF2-    UO2+
 B2H4_db   C2              Cs-             H7F7    N2H2     SF3     UO2-
 B2H5      C2+             CsBO2           He      NH2NO2   SF3+    UO2F
 B2H5_db   C2-             CsBr            He+     N2H4     SF3-    UO2F2
 B2H6      C2Cl            CsCl            Hg      N2O      SF4     UO3
 B2O       C2Cl2           CsF             Hg+     N2O+     SF4+    UO3-
 B2O2      C2Cl3           CsH             HgBr2   N2O3     SF4-    V
 B2O3      C2Cl4           CsI             I       N2O4     SF5     V+
 B2_OH_4   C2Cl6           Csli            I+      N2O5     SF5+    V-
 B2S       C2F             CsNO2           I-      N3       SF5-    VCl4
 B2S2      C2FCl           CsNO3           IF5     N3H      SF6     VN
 B2S3      C2FCl3          CsNa            IF7     Na       SF6-    VO
 B3H7_C2v  C2F2            CsO             I2      Na+      SH      VO2
 B3H7_Cs   C2F2Cl2         CsOH            In      Na-      SH-     V4O10
 B3H9      C2F3            CsRb            In+     NaAlF4   SN      W
 B3N3H6    C2F3Cl          Cs2             InBr    NaBO2    SO      W+
 B3O3Cl3   C2F4            Cs2Br2          InBr2   NaBr     SO-     W-
 B3O3FCl2  C2F6            Cs2CO3          InBr3   NaCN     SOF2    WCl6
 B3O3F2Cl  C2H             Cs2Cl2          InCl    NaCl     SO2     WO
 B3O3F3    C2HCl           Cs2F2           InCl2   NaF      SO2-    WOCl4
 B4H4      C2HCl3          Cs2I2           InCl3   NaH      SO2Cl2  WO2
 B4H10     C2HF            Cs2O            InF     NaI      SO2FCl  WO2Cl2
 B4H12     C2HFCl2         Cs2O+           InF2    Nali     SO2F2   WO3
 B5H9      C2HF2Cl         Cs2O2           InF3    NaNO2    SO3     WO3-
 Ba        C2HF3           Cs2O2H2         InH     NaNO3    S2      Xe
 Ba+       C2H2_vinylidene Cs2SO4          InI     NaO      S2-     Xe+
 BaBr      C2H2Cl2         Cu              InI2    NaOH     S2Cl2   Zn
 BaBr2     C2H2FCl         Cu+             InI3    NaOH+    S2F2    Zn+
 BaCl      C2H2F2          Cu-             InO     Na2      S2O     Zr
 BaCl+     CH2CO_ketene    CuCl            InOH    Na2Br2   S3      Zr+
 BaCl2     O_CH_2O         CuF             In2Br2  Na2Cl2   S4      Zr-
 BaF       HO_CO_2OH       CuF2            In2Br4  Na2F2    S5      ZrN
 BaF+      C2H3_vinyl      CuO             In2Br6  Na2I2    S6      ZrO
 BaF2      CH2Br-COOH      Cu2             In2Cl2  Na2O     S7      ZrO+
 BaH       C2H3Cl          Cu3Cl3          In2Cl4  Na2O+    S8      ZrO2
 BaI       CH2Cl-COOH      D               In2Cl6  Na2O2    Sc
 BaI2      C2H3F           D+              In2F2   Na2O2H2  Sc+
 BaO       CH3CN           D-              In2F4   Na2SO4   Sc-
 BaO+      CH3CO_acetyl    DBr             In2F6   Na3Cl3   ScO
 BaOH      C2H4            DCl             In2I2   Na3F3    ScO+
</pre></HTML>"));
    end IdealGases;

    package Incompressible
    "Medium model for T-dependent properties, defined by tables or polynomials"
      extends Modelica.Icons.MaterialPropertiesPackage;
      import SI = Modelica.SIunits;
      import Cv = Modelica.SIunits.Conversions;
      import Modelica.Constants;
      import Modelica.Math;

      package Common "Common data structures"
        extends Modelica.Icons.Package;

        record BaseProps_Tpoly "Fluid state record"
          extends Modelica.Icons.Record;
          SI.Temperature T "temperature";
          SI.Pressure p "pressure";
          //    SI.Density d "density";
        end BaseProps_Tpoly;
      end Common;

      package TableBased "Incompressible medium properties based on tables"
        import Poly = Modelica.Media.Incompressible.TableBased.Polynomials_Temp;
        extends Modelica.Media.Interfaces.PartialMedium(
           ThermoStates = if enthalpyOfT then Choices.IndependentVariables.T else Choices.IndependentVariables.pT,
           final reducedX=true,
           final fixedX = true,
           mediumName="tableMedium",
           redeclare record ThermodynamicState=Common.BaseProps_Tpoly,
           singleState=true);

        constant Boolean enthalpyOfT=true
        "true if enthalpy is approximated as a function of T only, (p-dependence neglected)";

        constant Boolean densityOfT = size(tableDensity,1) > 1
        "true if density is a function of temperature";

        constant Temperature T_min "Minimum temperature valid for medium model";

        constant Temperature T_max "Maximum temperature valid for medium model";

        constant Temperature T0=273.15 "reference Temperature";

        constant SpecificEnthalpy h0=0 "reference enthalpy at T0, reference_p";

        constant SpecificEntropy s0=0 "reference entropy at T0, reference_p";

        constant MolarMass MM_const=0.1 "Molar mass";

        constant Integer npol=2 "degree of polynomial used for fitting";

        constant Integer neta=size(tableViscosity,1)
        "number of data points for viscosity";

        constant Real[:,2] tableDensity "Table for rho(T)";

        constant Real[:,2] tableHeatCapacity "Table for Cp(T)";

        constant Real[:,2] tableViscosity "Table for eta(T)";

        constant Real[:,2] tableConductivity "Table for lambda(T)";

        constant Boolean TinK "true if T[K],Kelvin used for table temperatures";

        constant Boolean hasDensity = not (size(tableDensity,1)==0)
        "true if table tableDensity is present";

        constant Boolean hasHeatCapacity = not (size(tableHeatCapacity,1)==0)
        "true if table tableHeatCapacity is present";

        constant Boolean hasViscosity = not (size(tableViscosity,1)==0)
        "true if table tableViscosity is present";

        final constant Real invTK[neta] = if size(tableViscosity,1) > 0 then
            invertTemp(tableViscosity[:,1],TinK) else fill(0,0);

        final constant Real poly_rho[:] = if hasDensity then
                                             Poly.fitting(tableDensity[:,1],tableDensity[:,2],npol) else
                                               zeros(npol+1) annotation(__Dymola_keepConstant = true);

        final constant Real poly_Cp[:] = if hasHeatCapacity then
                                             Poly.fitting(tableHeatCapacity[:,1],tableHeatCapacity[:,2],npol) else
                                               zeros(npol+1) annotation(__Dymola_keepConstant = true);

        final constant Real poly_eta[:] = if hasViscosity then
                                             Poly.fitting(invTK, Math.log(tableViscosity[:,2]),npol) else
                                               zeros(npol+1) annotation(__Dymola_keepConstant = true);

        final constant Real poly_lam[:] = if size(tableConductivity,1)>0 then
                                             Poly.fitting(tableConductivity[:,1],tableConductivity[:,2],npol) else
                                               zeros(npol+1) annotation(__Dymola_keepConstant = true);

        function invertTemp "function to invert temperatures"
          input Real[:] table "table temperature data";
          input Boolean Tink "flag for Celsius or Kelvin";
          output Real invTable[size(table,1)] "inverted temperatures";
        algorithm
          for i in 1:size(table,1) loop
            invTable[i] := if TinK then 1/table[i] else 1/Cv.from_degC(table[i]);
          end for;
        end invertTemp;

        redeclare model extends BaseProperties(
          final standardOrderComponents=true,
          p_bar=Cv.to_bar(p),
          T_degC(start = T_start-273.15)=Cv.to_degC(T),
          T(start = T_start,
            stateSelect=if preferredMediumStates then StateSelect.prefer else StateSelect.default))
        "Base properties of T dependent medium"
        //  redeclare parameter SpecificHeatCapacity R=Modelica.Constants.R,

          SI.SpecificHeatCapacity cp "specific heat capacity";
          parameter SI.Temperature T_start = 298.15 "initial temperature";
        equation
          assert(hasDensity,"Medium " + mediumName +
                            " can not be used without assigning tableDensity.");
          assert(T >= T_min and T <= T_max, "Temperature T (= " + String(T) +
                 " K) is not in the allowed range (" + String(T_min) +
                 " K <= T <= " + String(T_max) + " K) required from medium model \""
                 + mediumName + "\".");
          R = Modelica.Constants.R;
          cp = Poly.evaluate(poly_Cp,if TinK then T else T_degC);
          h = if enthalpyOfT then h_T(T) else  h_pT(p,T,densityOfT);
          if singleState then
            u = h_T(T) - reference_p/d;
          else
            u = h - p/d;
          end if;
          d = Poly.evaluate(poly_rho,if TinK then T else T_degC);
          state.T = T;
          state.p = p;
          MM = MM_const;
          annotation(Documentation(info="<html>
<p>
Note that the inner energy neglects the pressure dependence, which is only
true for an incompressible medium with d = constant. The neglected term is
p-reference_p)/rho*(T/rho)*(partial rho /partial T). This is very small for
liquids due to proportionality to 1/d^2, but can be problematic for gases that are
modeled incompressible.
</p>
<p>It should be noted that incompressible media only have 1 state per control volume (usually T),
but have both T and p as inputs for fully correct properties. The error of using only T-dependent
properties is small, therefore a Boolean flag enthalpyOfT exists. If it is true, the
enumeration Choices.independentVariables  is set to  Choices.independentVariables.T otherwise
it is set to Choices.independentVariables.pT.</p>
<p>
Enthalpy is never a function of T only (h = h(T) + (p-reference_p)/d), but the
error is also small and non-linear systems can be avoided. In particular,
non-linear systems are small and local as opposed to large and over all volumes.
</p>

<p>
Entropy is calculated as
</p>
<pre>
  s = s0 + integral(Cp(T)/T,dt)
</pre>
<p>
which is only exactly true for a fluid with constant density d=d0.
</p>
</html>
      "));
        end BaseProperties;

        redeclare function extends setState_pTX
        "Returns state record, given pressure and temperature"
        algorithm
          state := ThermodynamicState(p=p,T=T);
        end setState_pTX;

        redeclare function extends setState_dTX
        "Returns state record, given pressure and temperature"
        algorithm
          assert(false, "for incompressible media with d(T) only, state can not be set from density and temperature");
        end setState_dTX;

        redeclare function extends setState_phX
        "Returns state record, given pressure and specific enthalpy"
        algorithm
          state :=ThermodynamicState(p=p,T=T_ph(p,h));
        end setState_phX;

        redeclare function extends setState_psX
        "Returns state record, given pressure and specific entropy"
        algorithm
          state :=ThermodynamicState(p=p,T=T_ps(p,s));
        end setState_psX;

            redeclare function extends setSmoothState
        "Return thermodynamic state so that it smoothly approximates: if x > 0 then state_a else state_b"
            algorithm
              state :=ThermodynamicState(p=Media.Common.smoothStep(x, state_a.p, state_b.p, x_small),
                                         T=Media.Common.smoothStep(x, state_a.T, state_b.T, x_small));
            end setSmoothState;

        redeclare function extends specificHeatCapacityCv
        "Specific heat capacity at constant volume (or pressure) of medium"

        algorithm
          assert(hasHeatCapacity,"Specific Heat Capacity, Cv, is not defined for medium "
                                                 + mediumName + ".");
          cv := Poly.evaluate(poly_Cp,if TinK then state.T else state.T - 273.15);
         annotation(smoothOrder=2);
        end specificHeatCapacityCv;

        redeclare function extends specificHeatCapacityCp
        "Specific heat capacity at constant volume (or pressure) of medium"

        algorithm
          assert(hasHeatCapacity,"Specific Heat Capacity, Cv, is not defined for medium "
                                                 + mediumName + ".");
          cp := Poly.evaluate(poly_Cp,if TinK then state.T else state.T - 273.15);
         annotation(smoothOrder=2);
        end specificHeatCapacityCp;

        redeclare function extends dynamicViscosity
        "Return dynamic viscosity as a function of the thermodynamic state record"

        algorithm
          assert(size(tableViscosity,1)>0,"DynamicViscosity, eta, is not defined for medium "
                                                 + mediumName + ".");
          eta := Math.exp(Poly.evaluate(poly_eta, 1/state.T));
         annotation(smoothOrder=2);
        end dynamicViscosity;

        redeclare function extends thermalConductivity
        "Return thermal conductivity as a function of the thermodynamic state record"

        algorithm
          assert(size(tableConductivity,1)>0,"ThermalConductivity, lambda, is not defined for medium "
                                                 + mediumName + ".");
          lambda := Poly.evaluate(poly_lam,if TinK then state.T else Cv.to_degC(state.T));
         annotation(smoothOrder=2);
        end thermalConductivity;

        function s_T "compute specific entropy"
          input Temperature T "temperature";
          output SpecificEntropy s "specific entropy";
        algorithm
          s := s0 + (if TinK then
            Poly.integralValue(poly_Cp[1:npol],T, T0) else
            Poly.integralValue(poly_Cp[1:npol],Cv.to_degC(T),Cv.to_degC(T0)))
            + Modelica.Math.log(T/T0)*
            Poly.evaluate(poly_Cp,if TinK then 0 else Modelica.Constants.T_zero);
         annotation(smoothOrder=2);
        end s_T;

        redeclare function extends specificEntropy "Return specific entropy
 as a function of the thermodynamic state record"

      protected
          Integer npol=size(poly_Cp,1)-1;
        algorithm
          assert(hasHeatCapacity,"Specific Entropy, s(T), is not defined for medium "
                                                 + mediumName + ".");
          s := s_T(state.T);
         annotation(smoothOrder=2);
        end specificEntropy;

        function h_T "Compute specific enthalpy from temperature"
          import Modelica.SIunits.Conversions.to_degC;
          extends Modelica.Icons.Function;
          input SI.Temperature T "Temperature";
          output SI.SpecificEnthalpy h "Specific enthalpy at p, T";
        algorithm
          h :=h0 + Poly.integralValue(poly_Cp, if TinK then T else Cv.to_degC(T), if TinK then
          T0 else Cv.to_degC(T0));
         annotation(derivative=h_T_der);
        end h_T;

        function h_T_der "Compute specific enthalpy from temperature"
          import Modelica.SIunits.Conversions.to_degC;
          extends Modelica.Icons.Function;
          input SI.Temperature T "Temperature";
          input Real dT "temperature derivative";
          output Real dh "derivative of Specific enthalpy at T";
        algorithm
          dh :=Poly.evaluate(poly_Cp, if TinK then T else Cv.to_degC(T))*dT;
         annotation(smoothOrder=1);
        end h_T_der;

        function h_pT "Compute specific enthalpy from pressure and temperature"
          import Modelica.SIunits.Conversions.to_degC;
          extends Modelica.Icons.Function;
          input SI.Pressure p "Pressure";
          input SI.Temperature T "Temperature";
          input Boolean densityOfT = false
          "include or neglect density derivative dependence of enthalpy"   annotation(Evaluate);
          output SI.SpecificEnthalpy h "Specific enthalpy at p, T";
        algorithm
          h :=h0 + Poly.integralValue(poly_Cp, if TinK then T else Cv.to_degC(T), if TinK then
          T0 else Cv.to_degC(T0)) + (p - reference_p)/Poly.evaluate(poly_rho, if TinK then
                  T else Cv.to_degC(T))
            *(if densityOfT then (1 + T/Poly.evaluate(poly_rho, if TinK then T else Cv.to_degC(T))
          *Poly.derivativeValue(poly_rho,if TinK then T else Cv.to_degC(T))) else 1.0);
         annotation(smoothOrder=2);
        end h_pT;

        redeclare function extends temperature
        "Return temperature as a function of the thermodynamic state record"
        algorithm
         T := state.T;
         annotation(smoothOrder=2);
        end temperature;

        redeclare function extends pressure
        "Return pressure as a function of the thermodynamic state record"
        algorithm
         p := state.p;
         annotation(smoothOrder=2);
        end pressure;

        redeclare function extends density
        "Return density as a function of the thermodynamic state record"
        algorithm
          d := Poly.evaluate(poly_rho,if TinK then state.T else Cv.to_degC(state.T));
         annotation(smoothOrder=2);
        end density;

        redeclare function extends specificEnthalpy
        "Return specific enthalpy as a function of the thermodynamic state record"
        algorithm
          h := if enthalpyOfT then h_T(state.T) else h_pT(state.p,state.T);
         annotation(smoothOrder=2);
        end specificEnthalpy;

        redeclare function extends specificInternalEnergy
        "Return specific internal energy as a function of the thermodynamic state record"
        algorithm
          u := if enthalpyOfT then h_T(state.T) else h_pT(state.p,state.T)
            - (if singleState then  reference_p/density(state) else state.p/density(state));
         annotation(smoothOrder=2);
        end specificInternalEnergy;

        function T_ph "Compute temperature from pressure and specific enthalpy"
          input AbsolutePressure p "pressure";
          input SpecificEnthalpy h "specific enthalpy";
          output Temperature T "temperature";
      protected
          package Internal
          "Solve h(T) for T with given h (use only indirectly via temperature_phX)"
            extends Modelica.Media.Common.OneNonLinearEquation;

            redeclare record extends f_nonlinear_Data
            "superfluous record, fix later when better structure of inverse functions exists"
                constant Real[5] dummy = {1,2,3,4,5};
            end f_nonlinear_Data;

            redeclare function extends f_nonlinear
            "p is smuggled in via vector"
            algorithm
              y := if singleState then h_T(x) else h_pT(p,x);
            end f_nonlinear;

            // Dummy definition has to be added for current Dymola
            redeclare function extends solve
            end solve;
          end Internal;
        algorithm
         T := Internal.solve(h, T_min, T_max, p, {1}, Internal.f_nonlinear_Data());
          annotation(Inline=false, LateInline=true, inverse=h_pT(p,T));
        end T_ph;

        function T_ps "Compute temperature from pressure and specific enthalpy"
          input AbsolutePressure p "pressure";
          input SpecificEntropy s "specific entropy";
          output Temperature T "temperature";
      protected
          package Internal
          "Solve h(T) for T with given h (use only indirectly via temperature_phX)"
            extends Modelica.Media.Common.OneNonLinearEquation;

            redeclare record extends f_nonlinear_Data
            "superfluous record, fix later when better structure of inverse functions exists"
                constant Real[5] dummy = {1,2,3,4,5};
            end f_nonlinear_Data;

            redeclare function extends f_nonlinear
            "p is smuggled in via vector"
            algorithm
              y := s_T(x);
            end f_nonlinear;

            // Dummy definition has to be added for current Dymola
            redeclare function extends solve
            end solve;
          end Internal;
        algorithm
         T := Internal.solve(s, T_min, T_max, p, {1}, Internal.f_nonlinear_Data());
        end T_ps;

        package Polynomials_Temp
        "Temporary Functions operating on polynomials (including polynomial fitting); only to be used in Modelica.Media.Incompressible.TableBased"
          extends Modelica.Icons.Package;

          function evaluate "Evaluate polynomial at a given abszissa value"
            extends Modelica.Icons.Function;
            input Real p[:]
            "Polynomial coefficients (p[1] is coefficient of highest power)";
            input Real u "Abszissa value";
            output Real y "Value of polynomial at u";
          algorithm
            y := p[1];
            for j in 2:size(p, 1) loop
              y := p[j] + u*y;
            end for;
            annotation(derivative(zeroDerivative=p)=evaluate_der);
          end evaluate;

          function derivativeValue
          "Value of derivative of polynomial at abszissa value u"
            extends Modelica.Icons.Function;
            input Real p[:]
            "Polynomial coefficients (p[1] is coefficient of highest power)";
            input Real u "Abszissa value";
            output Real y "Value of derivative of polynomial at u";
        protected
            Integer n=size(p, 1);
          algorithm
            y := p[1]*(n - 1);
            for j in 2:size(p, 1)-1 loop
              y := p[j]*(n - j) + u*y;
            end for;
            annotation(derivative(zeroDerivative=p)=derivativeValue_der);
          end derivativeValue;

          function secondDerivativeValue
          "Value of 2nd derivative of polynomial at abszissa value u"
            extends Modelica.Icons.Function;
            input Real p[:]
            "Polynomial coefficients (p[1] is coefficient of highest power)";
            input Real u "Abszissa value";
            output Real y "Value of 2nd derivative of polynomial at u";
        protected
            Integer n=size(p, 1);
          algorithm
            y := p[1]*(n - 1)*(n - 2);
            for j in 2:size(p, 1)-2 loop
              y := p[j]*(n - j)*(n - j - 1) + u*y;
            end for;
          end secondDerivativeValue;

          function integralValue
          "Integral of polynomial p(u) from u_low to u_high"
            extends Modelica.Icons.Function;
            input Real p[:] "Polynomial coefficients";
            input Real u_high "High integrand value";
            input Real u_low=0 "Low integrand value, default 0";
            output Real integral=0.0
            "Integral of polynomial p from u_low to u_high";
        protected
            Integer n=size(p, 1) "degree of integrated polynomial";
            Real y_low=0 "value at lower integrand";
          algorithm
            for j in 1:n loop
              integral := u_high*(p[j]/(n - j + 1) + integral);
              y_low := u_low*(p[j]/(n - j + 1) + y_low);
            end for;
            integral := integral - y_low;
            annotation(derivative(zeroDerivative=p)=integralValue_der);
          end integralValue;

          function fitting
          "Computes the coefficients of a polynomial that fits a set of data points in a least-squares sense"
            extends Modelica.Icons.Function;
            input Real u[:] "Abscissa data values";
            input Real y[size(u, 1)] "Ordinate data values";
            input Integer n(min=1)
            "Order of desired polynomial that fits the data points (u,y)";
            output Real p[n + 1]
            "Polynomial coefficients of polynomial that fits the date points";
        protected
            Real V[size(u, 1), n + 1] "Vandermonde matrix";
          algorithm
            // Construct Vandermonde matrix
            V[:, n + 1] := ones(size(u, 1));
            for j in n:-1:1 loop
              V[:, j] := {u[i] * V[i, j + 1] for i in 1:size(u,1)};
            end for;

            // Solve least squares problem
            p :=Modelica.Math.Matrices.leastSquares(V, y);
            annotation (Documentation(info="<HTML>
<p>
Polynomials.fitting(u,y,n) computes the coefficients of a polynomial
p(u) of degree \"n\" that fits the data \"p(u[i]) - y[i]\"
in a least squares sense. The polynomial is
returned as a vector p[n+1] that has the following definition:
</p>
<pre>
  p(u) = p[1]*u^n + p[2]*u^(n-1) + ... + p[n]*u + p[n+1];
</pre>
</HTML>"));
          end fitting;

          function evaluate_der "Evaluate polynomial at a given abszissa value"
            extends Modelica.Icons.Function;
            input Real p[:]
            "Polynomial coefficients (p[1] is coefficient of highest power)";
            input Real u "Abszissa value";
            input Real du "Abszissa value";
            output Real dy "Value of polynomial at u";
        protected
            Integer n=size(p, 1);
          algorithm
            dy := p[1]*(n - 1);
            for j in 2:size(p, 1)-1 loop
              dy := p[j]*(n - j) + u*dy;
            end for;
            dy := dy*du;
          end evaluate_der;

          function integralValue_der
          "Time derivative of integral of polynomial p(u) from u_low to u_high, assuming only u_high as time-dependent (Leibnitz rule)"
            extends Modelica.Icons.Function;
            input Real p[:] "Polynomial coefficients";
            input Real u_high "High integrand value";
            input Real u_low=0 "Low integrand value, default 0";
            input Real du_high "High integrand value";
            input Real du_low=0 "Low integrand value, default 0";
            output Real dintegral=0.0
            "Integral of polynomial p from u_low to u_high";
          algorithm
            dintegral := evaluate(p,u_high)*du_high;
          end integralValue_der;

          function derivativeValue_der
          "time derivative of derivative of polynomial"
            extends Modelica.Icons.Function;
            input Real p[:]
            "Polynomial coefficients (p[1] is coefficient of highest power)";
            input Real u "Abszissa value";
            input Real du "delta of abszissa value";
            output Real dy
            "time-derivative of derivative of polynomial w.r.t. input variable at u";
        protected
            Integer n=size(p, 1);
          algorithm
            dy := secondDerivativeValue(p,u)*du;
          end derivativeValue_der;
          annotation (Documentation(info="<HTML>
<p>
This package contains functions to operate on polynomials,
in particular to determine the derivative and the integral
of a polynomial and to use a polynomial to fit a given set
of data points.
</p>
<p>

<p><b>Copyright &copy; 2004-2010, Modelica Association and DLR.</b></p>

<p><i>
This package is <b>free</b> software. It can be redistributed and/or modified
under the terms of the <b>Modelica license</b>, see the license conditions
and the accompanying <b>disclaimer</b> in the documentation of package
Modelica in file \"Modelica/package.mo\".
</i>
</p>

</HTML>
",         revisions="<html>
<ul>
<li><i>Oct. 22, 2004</i> by Martin Otter (DLR):<br>
       Renamed functions to not have abbrevations.<br>
       Based fitting on LAPACK<br>
       New function to return the polynomial of an indefinite integral<li>
<li><i>Sept. 3, 2004</i> by Jonas Eborn (Scynamics):<br>
       polyderval, polyintval added<li>
<li><i>March 1, 2004</i> by Martin Otter (DLR):<br>
       first version implemented
</li>
</ul>
</html>"));
        end Polynomials_Temp;
      annotation(__Dymola_keepConstant = true, Documentation(info="<HTML>
<p>
This is the base package for medium models of incompressible fluids based on
tables. The minimal data to provide for a useful medium description is tables
of density and heat capacity as functions of temperature.
</p>

<p>It should be noted that incompressible media only have 1 state per control volume (usually T),
but have both T and p as inputs for fully correct properties. The error of using only T-dependent
properties is small, therefore a Boolean flag enthalpyOfT exists. If it is true, the
enumeration Choices.independentVariables  is set to  Choices.independentVariables.T otherwise
it is set to Choices.independentVariables.pT.</p>

<h4>Using the package TableBased</h4>
<p>
To implement a new medium model, create a package that <b>extends</b> TableBased
and provides one or more of the constant tables:
</p>

<pre>
tableDensity        = [T, d];
tableHeatCapacity   = [T, Cp];
tableConductivity   = [T, lam];
tableViscosity      = [T, eta];
tableVaporPressure  = [T, pVap];
</pre>

<p>
The table data is used to fit constant polynomials of order <b>npol</b>, the
temperature data points do not need to be same for different properties. Properties
like enthalpy, inner energy and entropy are calculated consistently from integrals
and derivatives of d(T) and Cp(T). The minimal
data for a useful medium model is thus density and heat capacity. Transport
properties and vapor pressure are optional, if the data tables are empty the corresponding
function calls can not be used.
</p>
</HTML>"),
        Documentation(info="<HTML>
<h4>Table based media</h4>
<p>
This is the base package for medium models of incompressible fluids based on
tables. The minimal data to provide for a useful medium description is tables
of density and heat capacity as functions of temperature.
</p>
<h4>Using the package TableBased</h4>
<p>
To implement a new medium model, create a package that <b>extends</b> TableBased
and provides one or more of the constant tables:
<pre>
tableDensity        = [T, d];
tableHeatCapacity   = [T, Cp];
tableConductivity   = [T, lam];
tableViscosity      = [T, eta];
tableVaporPressure  = [T, pVap];
</pre>
The table data is used to fit constant polynomials of order <b>npol</b>, the
temperature data points do not need to be same for different properties. Properties
like enthalpy, inner energy and entropy are calculated consistently from integrals
and derivatives of d(T) and Cp(T). The minimal
data for a useful medium model is thus density and heat capacity. Transport
properties and vapor pressure are optional, if the data tables are empty the corresponding
function calls can not be used.
</HTML>"));
      end TableBased;
      annotation (
        Documentation(info="<HTML>
<h4>Incompressible media package</h4>
<p>
This package provides a structure and examples of how to create simple
medium models of incompressible fluids, meaning fluids with very little
pressure influence on density. The medium properties is typically described
in terms of tables, functions or polynomial coefficients.
</p>
<h4>Definitions</h4>
<p>
The common meaning of <em>incompressible</em> is that properties like density
and enthalpy are independent of pressure. Thus properties are conveniently
described as functions of temperature, e.g., as polynomials density(T) and cp(T).
However, enthalpy can not be independent of pressure since h = u - p/d. For liquids
it is anyway
common to neglect this dependence since for constant density the neglected term
is (p - p0)/d, which in comparison with cp is very small for most liquids. For
water, the equivalent change of temperature to increasing pressure 1 bar is
0.025 Kelvin.
</p>
<p>
Two boolean flags are used to choose how enthalpy and inner energy is calculated:
<ul>
<li><b>enthalpyOfT</b>=true, means assuming that enthalpy is only a function
of temperature, neglecting the pressure dependent term.</li>
<li><b>singleState</b>=true, means also neglect the pressure influence on inner
energy, which makes all medium properties pure functions of temperature.</li>
</ul>
The default setting for both these flags is true, which enables the simulation tool
to choose temperature as the only medium state and avoids non-linear equation
systems, see the section about
<a href=\"modelica://Modelica.Media.UsersGuide.MediumDefinition.StaticStateSelection\">Static
state selection</a> in the Modelica.Media User's Guide.

</p>
<h4>Contents</h4>
<p>
Currently, the package contains the following parts:
</p>
<ol>
<li> <a href=\"modelica://Modelica.Media.Incompressible.TableBased\">
      Table based medium models</a></li>
<li> <a href=\"modelica://Modelica.Media.Incompressible.Examples\">
      Example medium models</a></li>
</ol>

<p>
A few examples are given in the Examples package. The model
<a href=\"modelica://Modelica.Media.Incompressible.Examples.Glycol47\">
Examples.Glycol47</a> shows how the medium models can be used. For more
realistic examples of how to implement volume models with medium properties
look in the <a href=\"modelica://Modelica.Media.UsersGuide.MediumUsage\">Medium
usage section</a> of the User's Guide.
</p>

</HTML>"));
    end Incompressible;

    package Water "Medium models for water"
      extends Modelica.Icons.MaterialPropertiesPackage;

      constant Interfaces.PartialMedium.FluidConstants[1] simpleWaterConstants(
         each chemicalFormula = "H2O",
         each structureFormula="H2O",
         each casRegistryNumber="7732-18-5",
         each iupacName="oxidane",
         each molarMass=0.018015268);
    annotation (Documentation(info="<html>
<p>This package contains different medium models for water:</p>
<ul>
<li><b>ConstantPropertyLiquidWater</b><br>
    Simple liquid water medium (incompressible, constant data).</li>
<li><b>IdealSteam</b><br>
    Steam water medium as ideal gas from Media.IdealGases.SingleGases.H2O</li>
<li><b>WaterIF97 derived models</b><br>
    High precision water model according to the IAPWS/IF97 standard
    (liquid, steam, two phase region). Models with different independent
    variables are provided as well as models valid only
    for particular regions. The <b>WaterIF97_ph</b> model is valid
    in all regions and is the recommended one to use.</li>
</ul>
<h4>Overview of WaterIF97 derived water models</h4>
<p>
The WaterIF97 models calculate medium properties
for water in the <b>liquid</b>, <b>gas</b> and <b>two phase</b> regions
according to the IAPWS/IF97 standard, i.e., the accepted industrial standard
and best compromise between accuracy and computation time.
It has been part of the ThermoFluid Modelica library and been extended,
reorganized and documented to become part of the Modelica Standard library.</p>
<p>An important feature that distinguishes this implementation of the IF97 steam property standard
is that this implementation has been explicitly designed to work well in dynamic simulations. Computational
performance has been of high importance. This means that there often exist several ways to get the same result
from different functions if one of the functions is called often but can be optimized for that purpose.
</p>
<p>Three variable pairs can be the independent variables of the model:
</p>
<ol>
<li>Pressure <b>p</b> and specific enthalpy <b>h</b> are
    the most natural choice for general applications.
    This is the recommended choice for most general purpose
    applications, in particular for power plants.</li>
<li>Pressure <b>p</b> and temperature <b>T</b> are the most natural
    choice for applications where water is always in the same phase,
    both for liquid water and steam.</li>
<li>Density <b>d</b> and temperature <b>T</b> are explicit
    variables of the Helmholtz function in the near-critical
    region and can be the best choice for applications with
    super-critical or near-critial states.</li>
</ol>
<p>
The following quantities are always computed in Medium.Baseproperties:
</p>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><td valign=\"top\"><b>Variable</b></td>
      <td valign=\"top\"><b>Unit</b></td>
      <td valign=\"top\"><b>Description</b></td></tr>
  <tr><td valign=\"top\">T</td>
      <td valign=\"top\">K</td>
      <td valign=\"top\">temperature</td></tr>
  <tr><td valign=\"top\">u</td>
      <td valign=\"top\">J/kg</td>
      <td valign=\"top\">specific internal energy</b></td></tr>
  <tr><td valign=\"top\">d</td>
      <td valign=\"top\">kg/m^3</td>
      <td valign=\"top\">density</td></tr>
  <tr><td valign=\"top\">p</td>
      <td valign=\"top\">Pa</td>
      <td valign=\"top\">pressure</td></tr>
  <tr><td valign=\"top\">h</td>
      <td valign=\"top\">J/kg</td>
      <td valign=\"top\">specific enthalpy</b></td></tr>
</table>
<p>
In some cases additional medium properties are needed.
A component that needs these optional properties has to call
one of the following functions:
</p>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><td valign=\"top\"><b>Function call</b></td>
      <td valign=\"top\"><b>Unit</b></td>
      <td valign=\"top\"><b>Description</b></td></tr>
  <tr><td valign=\"top\">Medium.dynamicViscosity(medium.state)</b></td>
      <td valign=\"top\">Pa.s</td>
      <td valign=\"top\">dynamic viscosity</td></tr>
  <tr><td valign=\"top\">Medium.thermalConductivity(medium.state)</td>
      <td valign=\"top\">W/(m.K)</td>
      <td valign=\"top\">thermal conductivity</td></tr>
  <tr><td valign=\"top\">Medium.prandtlNumber(medium.state)</td>
      <td valign=\"top\">1</td>
      <td valign=\"top\">Prandtl number</td></tr>
  <tr><td valign=\"top\">Medium.specificEntropy(medium.state)</td>
      <td valign=\"top\">J/(kg.K)</td>
      <td valign=\"top\">specific entropy</td></tr>
  <tr><td valign=\"top\">Medium.heatCapacity_cp(medium.state)</td>
      <td valign=\"top\">J/(kg.K)</td>
      <td valign=\"top\">specific heat capacity at constant pressure</td></tr>
  <tr><td valign=\"top\">Medium.heatCapacity_cv(medium.state)</td>
      <td valign=\"top\">J/(kg.K)</td>
      <td valign=\"top\">specific heat capacity at constant density</td></tr>
  <tr><td valign=\"top\">Medium.isentropicExponent(medium.state)</td>
      <td valign=\"top\">1</td>
      <td valign=\"top\">isentropic exponent</td></tr>
  <tr><td valign=\"top\">Medium.isentropicEnthalpy(pressure, medium.state)</td>
      <td valign=\"top\">J/kg</td>
      <td valign=\"top\">isentropic enthalpy</td></tr>
  <tr><td valign=\"top\">Medium.velocityOfSound(medium.state)</td>
      <td valign=\"top\">m/s</td>
      <td valign=\"top\">velocity of sound</td></tr>
  <tr><td valign=\"top\">Medium.isobaricExpansionCoefficient(medium.state)</td>
      <td valign=\"top\">1/K</td>
      <td valign=\"top\">isobaric expansion coefficient</td></tr>
  <tr><td valign=\"top\">Medium.isothermalCompressibility(medium.state)</td>
      <td valign=\"top\">1/Pa</td>
      <td valign=\"top\">isothermal compressibility</td></tr>
  <tr><td valign=\"top\">Medium.density_derp_h(medium.state)</td>
      <td valign=\"top\">kg/(m3.Pa)</td>
      <td valign=\"top\">derivative of density by pressure at constant enthalpy</td></tr>
  <tr><td valign=\"top\">Medium.density_derh_p(medium.state)</td>
      <td valign=\"top\">kg2/(m3.J)</td>
      <td valign=\"top\">derivative of density by enthalpy at constant pressure</td></tr>
  <tr><td valign=\"top\">Medium.density_derp_T(medium.state)</td>
      <td valign=\"top\">kg/(m3.Pa)</td>
      <td valign=\"top\">derivative of density by pressure at constant temperature</td></tr>
  <tr><td valign=\"top\">Medium.density_derT_p(medium.state)</td>
      <td valign=\"top\">kg/(m3.K)</td>
      <td valign=\"top\">derivative of density by temperature at constant pressure</td></tr>
  <tr><td valign=\"top\">Medium.density_derX(medium.state)</td>
      <td valign=\"top\">kg/m3</td>
      <td valign=\"top\">derivative of density by mass fraction</td></tr>
  <tr><td valign=\"top\">Medium.molarMass(medium.state)</td>
      <td valign=\"top\">kg/mol</td>
      <td valign=\"top\">molar mass</td></tr>
</table>
<p>More details are given in
<a href=\"modelica://Modelica.Media.UsersGuide.MediumUsage.OptionalProperties\">
Modelica.Media.UsersGuide.MediumUsage.OptionalProperties</a>.

Many additional optional functions are defined to compute properties of
saturated media, either liquid (bubble point) or vapour (dew point).
The argument to such functions is a SaturationProperties record, which can be
set starting from either the saturation pressure or the saturation temperature.
With reference to a model defining a pressure p, a temperature T, and a
SaturationProperties record sat, the following functions are provided:
</p>
<p>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><td valign=\"top\"><b>Function call</b></td>
      <td valign=\"top\"><b>Unit</b></td>
      <td valign=\"top\"><b>Description</b></td></tr>
  <tr><td valign=\"top\">Medium.saturationPressure(T)</b></td>
      <td valign=\"top\">Pa</td>
      <td valign=\"top\">Saturation pressure at temperature T</td></tr>
  <tr><td valign=\"top\">Medium.saturationTemperature(p)</b></td>
      <td valign=\"top\">K</td>
      <td valign=\"top\">Saturation temperature at pressure p</td></tr>
  <tr><td valign=\"top\">Medium.saturationTemperature_derp(p)</b></td>
      <td valign=\"top\">K/Pa</td>
      <td valign=\"top\">Derivative of saturation temperature with respect to pressure</td></tr>
  <tr><td valign=\"top\">Medium.bubbleEnthalpy(sat)</b></td>
      <td valign=\"top\">J/kg</td>
      <td valign=\"top\">Specific enthalpy at bubble point</td></tr>
  <tr><td valign=\"top\">Medium.dewEnthalpy(sat)</b></td>
      <td valign=\"top\">J/kg</td>
      <td valign=\"top\">Specific enthalpy at dew point</td></tr>
  <tr><td valign=\"top\">Medium.bubbleEntropy(sat)</b></td>
      <td valign=\"top\">J/(kg.K)</td>
      <td valign=\"top\">Specific entropy at bubble point</td></tr>
  <tr><td valign=\"top\">Medium.dewEntropy(sat)</b></td>
      <td valign=\"top\">J/(kg.K)</td>
      <td valign=\"top\">Specific entropy at dew point</td></tr>
  <tr><td valign=\"top\">Medium.bubbleDensity(sat)</b></td>
      <td valign=\"top\">kg/m3</td>
      <td valign=\"top\">Density at bubble point</td></tr>
  <tr><td valign=\"top\">Medium.dewDensity(sat)</b></td>
      <td valign=\"top\">kg/m3</td>
      <td valign=\"top\">Density at dew point</td></tr>
  <tr><td valign=\"top\">Medium.dBubbleDensity_dPressure(sat)</b></td>
      <td valign=\"top\">kg/(m3.Pa)</td>
      <td valign=\"top\">Derivative of density at bubble point with respect to pressure</td></tr>
  <tr><td valign=\"top\">Medium.dDewDensity_dPressure(sat)</b></td>
      <td valign=\"top\">kg/(m3.Pa)</td>
      <td valign=\"top\">Derivative of density at dew point with respect to pressure</td></tr>
  <tr><td valign=\"top\">Medium.dBubbleEnthalpy_dPressure(sat)</b></td>
      <td valign=\"top\">J/(kg.Pa)</td>
      <td valign=\"top\">Derivative of specific enthalpy at bubble point with respect to pressure</td></tr>
  <tr><td valign=\"top\">Medium.dDewEnthalpy_dPressure(sat)</b></td>
      <td valign=\"top\">J/(kg.Pa)</td>
      <td valign=\"top\">Derivative of specific enthalpy at dew point with respect to pressure</td></tr>
  <tr><td valign=\"top\">Medium.surfaceTension(sat)</b></td>
      <td valign=\"top\">N/m</td>
      <td valign=\"top\">Surface tension between liquid and vapour phase</td></tr>
</table>

<p>Details on usage and some examples are given in:
<a href=\"modelica://Modelica.Media.UsersGuide.MediumUsage.TwoPhase\">
Modelica.Media.UsersGuide.MediumUsage.TwoPhase</a>.
</p>

<p>Many further properties can be computed. Using the well-known Bridgman's Tables,
all first partial derivatives of the standard thermodynamic variables can be computed easily.
</p>
<p>
The documentation of the IAPWS/IF97 steam properties can be freely
distributed with computer implementations and are included here
(in directory Modelica/Resources/Documentation/Media/Water/IF97documentation):
<ul>
<li><a href=\"modelica://Modelica/Resources/Documentation/Media/Water/IF97documentation/IF97.pdf\">IF97.pdf</a> The standards document for the main part of the IF97.</li>
<li><a href=\"modelica://Modelica/Resources/Documentation/Media/Water/IF97documentation/Back3.pdf\">Back3.pdf</a> The backwards equations for region 3.</li>
<li><a href=\"modelica://Modelica/Resources/Documentation/Media/Water/IF97documentation/crits.pdf\">crits.pdf</a> The critical point data.</li>
<li><a href=\"modelica://Modelica/Resources/Documentation/Media/Water/IF97documentation/meltsub.pdf\">meltsub.pdf</a> The melting- and sublimation line formulation (not implemented)</li>
<li><a href=\"modelica://Modelica/Resources/Documentation/Media/Water/IF97documentation/surf.pdf\">surf.pdf</a> The surface tension standard definition</li>
<li><a href=\"modelica://Modelica/Resources/Documentation/Media/Water/IF97documentation/thcond.pdf\">thcond.pdf</a> The thermal conductivity standard definition</li>
<li><a href=\"modelica://Modelica/Resources/Documentation/Media/Water/IF97documentation/visc.pdf\">visc.pdf</a> The viscosity standard definition</li>
</ul>
</html>"));
    end Water;
  annotation (
    Documentation(info="<HTML>
<p>
This library contains <a href=\"modelica://Modelica.Media.Interfaces\">interface</a>
definitions for media and the following <b>property</b> models for
single and multiple substance fluids with one and multiple phases:
</p>
<ul>
<li> <a href=\"modelica://Modelica.Media.IdealGases\">Ideal gases:</a><br>
     1241 high precision gas models based on the
     NASA Glenn coefficients, plus ideal gas mixture models based
     on the same data.</li>
<li> <a href=\"modelica://Modelica.Media.Water\">Water models:</a><br>
     ConstantPropertyLiquidWater, WaterIF97 (high precision
     water model according to the IAPWS/IF97 standard)</li>
<li> <a href=\"modelica://Modelica.Media.Air\">Air models:</a><br>
     SimpleAir, DryAirNasa, and MoistAir</li>
<li> <a href=\"modelica://Modelica.Media.Incompressible\">
     Incompressible media:</a><br>
     TableBased incompressible fluid models (properties are defined by tables rho(T),
     HeatCapacity_cp(T), etc.)</li>
<li> <a href=\"modelica://Modelica.Media.CompressibleLiquids\">
     Compressible liquids:</a><br>
     Simple liquid models with linear compressibility</li>
</ul>
<p>
The following parts are useful, when newly starting with this library:
<ul>
<li> <a href=\"modelica://Modelica.Media.UsersGuide\">Modelica.Media.UsersGuide</a>.</li>
<li> <a href=\"modelica://Modelica.Media.UsersGuide.MediumUsage\">Modelica.Media.UsersGuide.MediumUsage</a>
     describes how to use a medium model in a component model.</li>
<li> <a href=\"modelica://Modelica.Media.UsersGuide.MediumDefinition\">
     Modelica.Media.UsersGuide.MediumDefinition</a>
     describes how a new fluid medium model has to be implemented.</li>
<li> <a href=\"modelica://Modelica.Media.UsersGuide.ReleaseNotes\">Modelica.Media.UsersGuide.ReleaseNotes</a>
     summarizes the changes of the library releases.</li>
<li> <a href=\"modelica://Modelica.Media.Examples\">Modelica.Media.Examples</a>
     contains examples that demonstrate the usage of this library.</li>
</ul>
<p>
Copyright &copy; 1998-2010, Modelica Association.
</p>
<p>
<i>This Modelica package is <u>free</u> software and the use is completely at <u>your own risk</u>; it can be redistributed and/or modified under the terms of the Modelica License 2. For license conditions (including the disclaimer of warranty) see <a href=\"modelica://Modelica.UsersGuide.ModelicaLicense2\">Modelica.UsersGuide.ModelicaLicense2</a> or visit <a href=\"http://www.modelica.org/licenses/ModelicaLicense2\"> http://www.modelica.org/licenses/ModelicaLicense2</a>.</i>
</p>
</HTML>"));
  end Media;

  package Thermal
  "Library of thermal system components to model heat transfer and simple thermo-fluid pipe flow"
    extends Modelica.Icons.Package;

    package HeatTransfer
    "Library of 1-dimensional heat transfer with lumped elements"
      import Modelica.SIunits.Conversions.*;
      extends Modelica.Icons.Package;

      package Components "Lumped thermal components"
      extends Modelica.Icons.Package;

        model HeatCapacitor "Lumped thermal element storing heat"
          parameter Modelica.SIunits.HeatCapacity C
          "Heat capacity of element (= cp*m)";
          Modelica.SIunits.Temperature T(start=293.15, displayUnit="degC")
          "Temperature of element";
          Modelica.SIunits.TemperatureSlope der_T(start=0)
          "Time derivative of temperature (= der(T))";
          Interfaces.HeatPort_a port annotation (Placement(transformation(
                origin={0,-100},
                extent={{-10,-10},{10,10}},
                rotation=90)));
        equation
          T = port.T;
          der_T = der(T);
          C*der(T) = port.Q_flow;
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Text(
                  extent={{-150,110},{150,70}},
                  textString="%name",
                  lineColor={0,0,255}),
                Polygon(
                  points={{0,67},{-20,63},{-40,57},{-52,43},{-58,35},{-68,25},{-72,
                      13},{-76,-1},{-78,-15},{-76,-31},{-76,-43},{-76,-53},{-70,-65},
                      {-64,-73},{-48,-77},{-30,-83},{-18,-83},{-2,-85},{8,-89},{22,
                      -89},{32,-87},{42,-81},{54,-75},{56,-73},{66,-61},{68,-53},{
                      70,-51},{72,-35},{76,-21},{78,-13},{78,3},{74,15},{66,25},{54,
                      33},{44,41},{36,57},{26,65},{0,67}},
                  lineColor={160,160,164},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-58,35},{-68,25},{-72,13},{-76,-1},{-78,-15},{-76,-31},{
                      -76,-43},{-76,-53},{-70,-65},{-64,-73},{-48,-77},{-30,-83},{-18,
                      -83},{-2,-85},{8,-89},{22,-89},{32,-87},{42,-81},{54,-75},{42,
                      -77},{40,-77},{30,-79},{20,-81},{18,-81},{10,-81},{2,-77},{-12,
                      -73},{-22,-73},{-30,-71},{-40,-65},{-50,-55},{-56,-43},{-58,-35},
                      {-58,-25},{-60,-13},{-60,-5},{-60,7},{-58,17},{-56,19},{-52,
                      27},{-48,35},{-44,45},{-40,57},{-58,35}},
                  lineColor={0,0,0},
                  fillColor={160,160,164},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-69,7},{71,-24}},
                  lineColor={0,0,0},
                  textString="%C")}),
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={
                Polygon(
                  points={{0,67},{-20,63},{-40,57},{-52,43},{-58,35},{-68,25},{-72,
                      13},{-76,-1},{-78,-15},{-76,-31},{-76,-43},{-76,-53},{-70,-65},
                      {-64,-73},{-48,-77},{-30,-83},{-18,-83},{-2,-85},{8,-89},{22,
                      -89},{32,-87},{42,-81},{54,-75},{56,-73},{66,-61},{68,-53},{
                      70,-51},{72,-35},{76,-21},{78,-13},{78,3},{74,15},{66,25},{54,
                      33},{44,41},{36,57},{26,65},{0,67}},
                  lineColor={160,160,164},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-58,35},{-68,25},{-72,13},{-76,-1},{-78,-15},{-76,-31},{
                      -76,-43},{-76,-53},{-70,-65},{-64,-73},{-48,-77},{-30,-83},{-18,
                      -83},{-2,-85},{8,-89},{22,-89},{32,-87},{42,-81},{54,-75},{42,
                      -77},{40,-77},{30,-79},{20,-81},{18,-81},{10,-81},{2,-77},{-12,
                      -73},{-22,-73},{-30,-71},{-40,-65},{-50,-55},{-56,-43},{-58,-35},
                      {-58,-25},{-60,-13},{-60,-5},{-60,7},{-58,17},{-56,19},{-52,
                      27},{-48,35},{-44,45},{-40,57},{-58,35}},
                  lineColor={0,0,0},
                  fillColor={160,160,164},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-6,-1},{6,-12}},
                  lineColor={255,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{11,13},{50,-25}},
                  lineColor={0,0,0},
                  textString="T"),
                Line(points={{0,-12},{0,-96}}, color={255,0,0})}),
            Documentation(info="<HTML>
<p>
This is a generic model for the heat capacity of a material.
No specific geometry is assumed beyond a total volume with
uniform temperature for the entire volume.
Furthermore, it is assumed that the heat capacity
is constant (indepedent of temperature).
</p>
<p>
The temperature T [Kelvin] of this component is a <b>state</b>.
A default of T = 25 degree Celsius (= SIunits.Conversions.from_degC(25))
is used as start value for initialization.
This usually means that at start of integration the temperature of this
component is 25 degrees Celsius. You may, of course, define a different
temperature as start value for initialization. Alternatively, it is possible
to set parameter <b>steadyStateStart</b> to <b>true</b>. In this case
the additional equation '<b>der</b>(T) = 0' is used during
initialization, i.e., the temperature T is computed in such a way that
the component starts in <b>steady state</b>. This is useful in cases,
where one would like to start simulation in a suitable operating
point without being forced to integrate for a long time to arrive
at this point.
</p>
<p>
Note, that parameter <b>steadyStateStart</b> is not available in
the parameter menue of the simulation window, because its value
is utilized during translation to generate quite different
equations depending on its setting. Therefore, the value of this
parameter can only be changed before translating the model.
</p>
<p>
This component may be used for complicated geometries where
the heat capacity C is determined my measurements. If the component
consists mainly of one type of material, the <b>mass m</b> of the
component may be measured or calculated and multiplied with the
<b>specific heat capacity cp</b> of the component material to
compute C:
</p>
<pre>
   C = cp*m.
   Typical values for cp at 20 degC in J/(kg.K):
      aluminium   896
      concrete    840
      copper      383
      iron        452
      silver      235
      steel       420 ... 500 (V2A)
      wood       2500
</pre>
</HTML>
"));
        end HeatCapacitor;

        model ThermalConductor
        "Lumped thermal element transporting heat without storing it"
          extends Interfaces.Element1D;
          parameter Modelica.SIunits.ThermalConductance G
          "Constant thermal conductance of material";

        equation
          Q_flow = G*dT;
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Rectangle(
                  extent={{-90,70},{90,-70}},
                  lineColor={0,0,0},
                  pattern=LinePattern.None,
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Backward),
                Line(
                  points={{-90,70},{-90,-70}},
                  color={0,0,0},
                  thickness=0.5),
                Line(
                  points={{90,70},{90,-70}},
                  color={0,0,0},
                  thickness=0.5),
                Text(
                  extent={{-150,115},{150,75}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-150,-75},{150,-105}},
                  lineColor={0,0,0},
                  textString="G=%G")}),
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={
                Line(
                  points={{-80,0},{80,0}},
                  color={255,0,0},
                  thickness=0.5,
                  arrow={Arrow.None,Arrow.Filled}),
                Text(
                  extent={{-26,-10},{27,-39}},
                  lineColor={255,0,0},
                  textString="Q_flow"),
                Text(
                  extent={{-80,50},{80,20}},
                  lineColor={0,0,0},
                  textString="dT = port_a.T - port_b.T")}),
            Documentation(info="<HTML>
<p>
This is a model for transport of heat without storing it.
It may be used for complicated geometries where
the thermal conductance G (= inverse of thermal resistance)
is determined by measurements and is assumed to be constant
over the range of operations. If the component consists mainly of
one type of material and a regular geometry, it may be calculated,
e.g., with one of the following equations:
</p>
<ul>
<li><p>
    Conductance for a <b>box</b> geometry under the assumption
    that heat flows along the box length:</p>
    <pre>
    G = k*A/L
    k: Thermal conductivity (material constant)
    A: Area of box
    L: Length of box
    </pre>
    </li>
<li><p>
    Conductance for a <b>cylindrical</b> geometry under the assumption
    that heat flows from the inside to the outside radius
    of the cylinder:</p>
    <pre>
    G = 2*pi*k*L/log(r_out/r_in)
    pi   : Modelica.Constants.pi
    k    : Thermal conductivity (material constant)
    L    : Length of cylinder
    log  : Modelica.Math.log;
    r_out: Outer radius of cylinder
    r_in : Inner radius of cylinder
    </pre>
    </li>
</li>
</ul>
<pre>
    Typical values for k at 20 degC in W/(m.K):
      aluminium   220
      concrete      1
      copper      384
      iron         74
      silver      407
      steel        45 .. 15 (V2A)
      wood         0.1 ... 0.2
</pre>
</HTML>
"));
        end ThermalConductor;

        model Convection
        "Lumped thermal element for heat convection (Q_flow = Gc*dT)"
          Modelica.SIunits.HeatFlowRate Q_flow
          "Heat flow rate from solid -> fluid";
          Modelica.SIunits.TemperatureDifference dT "= solid.T - fluid.T";
          Modelica.Blocks.Interfaces.RealInput Gc
          "Signal representing the convective thermal conductance in [W/K]"
            annotation (Placement(transformation(
                origin={0,100},
                extent={{-20,-20},{20,20}},
                rotation=270)));
          Interfaces.HeatPort_a solid annotation (Placement(transformation(extent={{
                    -110,-10},{-90,10}}, rotation=0)));
          Interfaces.HeatPort_b fluid annotation (Placement(transformation(extent={{
                    90,-10},{110,10}}, rotation=0)));
        equation
          dT = solid.T - fluid.T;
          solid.Q_flow = Q_flow;
          fluid.Q_flow = -Q_flow;
          Q_flow = Gc*dT;
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Rectangle(
                  extent={{-62,80},{98,-80}},
                  lineColor={255,255,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-90,80},{-60,-80}},
                  lineColor={0,0,0},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Backward),
                Text(
                  extent={{-150,-90},{150,-130}},
                  textString="%name",
                  lineColor={0,0,255}),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Line(points={{-60,20},{76,20}}, color={191,0,0}),
                Line(points={{-60,-20},{76,-20}}, color={191,0,0}),
                Line(points={{-34,80},{-34,-80}}, color={0,127,255}),
                Line(points={{6,80},{6,-80}}, color={0,127,255}),
                Line(points={{40,80},{40,-80}}, color={0,127,255}),
                Line(points={{76,80},{76,-80}}, color={0,127,255}),
                Line(points={{-34,-80},{-44,-60}}, color={0,127,255}),
                Line(points={{-34,-80},{-24,-60}}, color={0,127,255}),
                Line(points={{6,-80},{-4,-60}}, color={0,127,255}),
                Line(points={{6,-80},{16,-60}}, color={0,127,255}),
                Line(points={{40,-80},{30,-60}}, color={0,127,255}),
                Line(points={{40,-80},{50,-60}}, color={0,127,255}),
                Line(points={{76,-80},{66,-60}}, color={0,127,255}),
                Line(points={{76,-80},{86,-60}}, color={0,127,255}),
                Line(points={{56,-30},{76,-20}}, color={191,0,0}),
                Line(points={{56,-10},{76,-20}}, color={191,0,0}),
                Line(points={{56,10},{76,20}}, color={191,0,0}),
                Line(points={{56,30},{76,20}}, color={191,0,0}),
                Text(
                  extent={{22,124},{92,98}},
                  lineColor={0,0,0},
                  textString="Gc")}),
            Documentation(info="<HTML>
<p>
This is a model of linear heat convection, e.g., the heat transfer
between a plate and the surrounding air. It may be used for complicated
solid geometries and fluid flow over the solid by determining the
convective thermal conductance Gc by measurements. The basic constitutive
equation for convection is
</p>
<pre>
   Q_flow = Gc*(solid.T - fluid.T);
   Q_flow: Heat flow rate from connector 'solid' (e.g., a plate)
      to connector 'fluid' (e.g., the surrounding air)
</pre>
<p>
Gc = G.signal[1] is an input signal to the component, since Gc is
nearly never constant in practice. For example, Gc may be a function
of the speed of a cooling fan. For simple situations,
Gc may be <i>calculated</i> according to
</p>
<pre>
   Gc = A*h
   A: Convection area (e.g., perimeter*length of a box)
   h: Heat transfer coefficient
</pre>
<p>
where the heat transfer coefficient h is calculated
from properties of the fluid flowing over the solid. Examples:
</p>
<p>
<b>Machines cooled by air</b> (empirical, very rough approximation according
to R. Fischer: Elektrische Maschinen, 10th edition, Hanser-Verlag 1999,
p. 378):
</p>
<pre>
    h = 7.8*v^0.78 [W/(m2.K)] (forced convection)
      = 12         [W/(m2.K)] (free convection)
    where
      v: Air velocity in [m/s]
</pre>
<p><b>Laminar</b> flow with constant velocity of a fluid along a
<b>flat plate</b> where the heat flow rate from the plate
to the fluid (= solid.Q_flow) is kept constant
(according to J.P.Holman: Heat Transfer, 8th edition,
McGraw-Hill, 1997, p.270):
</p>
<pre>
   h  = Nu*k/x;
   Nu = 0.453*Re^(1/2)*Pr^(1/3);
   where
      h  : Heat transfer coefficient
      Nu : = h*x/k       (Nusselt number)
      Re : = v*x*rho/mue (Reynolds number)
      Pr : = cp*mue/k    (Prandtl number)
      v  : Absolute velocity of fluid
      x  : distance from leading edge of flat plate
      rho: density of fluid (material constant
      mue: dynamic viscosity of fluid (material constant)
      cp : specific heat capacity of fluid (material constant)
      k  : thermal conductivity of fluid (material constant)
   and the equation for h holds, provided
      Re < 5e5 and 0.6 < Pr < 50
</pre>
</HTML>
"),         Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={
                Rectangle(
                  extent={{-90,80},{-60,-80}},
                  lineColor={0,0,0},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Backward),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Text(
                  extent={{-35,42},{-5,20}},
                  lineColor={255,0,0},
                  textString="Q_flow"),
                Line(points={{-60,20},{76,20}}, color={191,0,0}),
                Line(points={{-60,-20},{76,-20}}, color={191,0,0}),
                Line(points={{-34,80},{-34,-80}}, color={0,127,255}),
                Line(points={{6,80},{6,-80}}, color={0,127,255}),
                Line(points={{40,80},{40,-80}}, color={0,127,255}),
                Line(points={{76,80},{76,-80}}, color={0,127,255}),
                Line(points={{-34,-80},{-44,-60}}, color={0,127,255}),
                Line(points={{-34,-80},{-24,-60}}, color={0,127,255}),
                Line(points={{6,-80},{-4,-60}}, color={0,127,255}),
                Line(points={{6,-80},{16,-60}}, color={0,127,255}),
                Line(points={{40,-80},{30,-60}}, color={0,127,255}),
                Line(points={{40,-80},{50,-60}}, color={0,127,255}),
                Line(points={{76,-80},{66,-60}}, color={0,127,255}),
                Line(points={{76,-80},{86,-60}}, color={0,127,255}),
                Line(points={{56,-30},{76,-20}}, color={191,0,0}),
                Line(points={{56,-10},{76,-20}}, color={191,0,0}),
                Line(points={{56,10},{76,20}}, color={191,0,0}),
                Line(points={{56,30},{76,20}}, color={191,0,0})}));
        end Convection;

        model ThermalCollector "Collects m heat flows"
          parameter Integer m(min=1)=3 "Number of collected heat flows";
          Interfaces.HeatPort_a port_a[m]
            annotation (Placement(transformation(extent={{-10,110},{10,90}})));
          Interfaces.HeatPort_b port_b
            annotation (Placement(transformation(extent={{-10,-110},{10,-90}})));

        equation
          port_b.Q_flow + sum(port_a.Q_flow) = 0;
          port_a.T = fill(port_b.T, m);
          annotation (Diagram(coordinateSystem(preserveAspectRatio=true,  extent={{-100,
                    -100},{100,100}}), graphics),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Text(
                  extent={{-150,-30},{150,-70}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-150,80},{150,50}},
                  lineColor={0,0,0},
                  textString="m=%m"),
                Line(
                  points={{0,90},{0,40}},
                  color={181,0,0},
                  smooth=Smooth.None),
                Rectangle(
                  extent={{-60,40},{60,30}},
                  lineColor={181,0,0},
                  fillColor={181,0,0},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-60,30},{0,-30},{0,-90}},
                  color={181,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{0,-30},{-20,30}},
                  color={181,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{0,-30},{20,30}},
                  color={181,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{0,-30},{60,30}},
                  color={181,0,0},
                  smooth=Smooth.None)}),
            Documentation(info="<html>
<p>
This is a model to collect the heat flows from <i>m</i> heatports to one single heatport.
</p>
</html>"));
        end ThermalCollector;
        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={
              Rectangle(
                extent={{-100,18},{-70,-100}},
                lineColor={0,0,0},
                fillColor={192,192,192},
                fillPattern=FillPattern.Backward),
              Line(points={{-44,16},{-44,-100}}, color={0,127,255}),
              Line(points={{-4,16},{-4,-100}}, color={0,127,255}),
              Line(points={{30,18},{30,-100}}, color={0,127,255}),
              Line(points={{66,18},{66,-100}}, color={0,127,255}),
              Line(points={{66,-100},{76,-80}}, color={0,127,255}),
              Line(points={{66,-100},{56,-80}}, color={0,127,255}),
              Line(points={{30,-100},{40,-80}}, color={0,127,255}),
              Line(points={{30,-100},{20,-80}}, color={0,127,255}),
              Line(points={{-4,-100},{6,-80}}, color={0,127,255}),
              Line(points={{-4,-100},{-14,-80}}, color={0,127,255}),
              Line(points={{-44,-100},{-34,-80}}, color={0,127,255}),
              Line(points={{-44,-100},{-54,-80}}, color={0,127,255}),
              Line(points={{-70,-60},{66,-60}}, color={191,0,0}),
              Line(points={{46,-70},{66,-60}}, color={191,0,0}),
              Line(points={{46,-50},{66,-60}}, color={191,0,0}),
              Line(points={{46,-30},{66,-20}}, color={191,0,0}),
              Line(points={{46,-10},{66,-20}}, color={191,0,0}),
              Line(points={{-70,-20},{66,-20}}, color={191,0,0})}), Documentation(
              info="<html>

</html>"));
      end Components;

      package Sensors "Thermal sensors"
      extends Modelica.Icons.SensorsPackage;

        model TemperatureSensor "Absolute temperature sensor in Kelvin"

          Modelica.Blocks.Interfaces.RealOutput T annotation (Placement(
                transformation(extent={{90,-10},{110,10}}, rotation=0)));
          Interfaces.HeatPort_a port annotation (Placement(transformation(extent={{
                    -110,-10},{-90,10}}, rotation=0)));
        equation
          T = port.T;
          port.Q_flow = 0;
          annotation (
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Ellipse(
                  extent={{-20,-98},{20,-60}},
                  lineColor={0,0,0},
                  lineThickness=0.5,
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-12,40},{12,-68}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Line(points={{12,0},{90,0}}, color={0,0,255}),
                Line(points={{-94,0},{-14,0}}, color={191,0,0}),
                Polygon(
                  points={{-12,40},{-12,80},{-10,86},{-6,88},{0,90},{6,88},{10,86},{
                      12,80},{12,40},{-12,40}},
                  lineColor={0,0,0},
                  lineThickness=0.5),
                Line(
                  points={{-12,40},{-12,-64}},
                  color={0,0,0},
                  thickness=0.5),
                Line(
                  points={{12,40},{12,-64}},
                  color={0,0,0},
                  thickness=0.5),
                Line(points={{-40,-20},{-12,-20}}, color={0,0,0}),
                Line(points={{-40,20},{-12,20}}, color={0,0,0}),
                Line(points={{-40,60},{-12,60}}, color={0,0,0}),
                Text(
                  extent={{102,-28},{60,-78}},
                  lineColor={0,0,0},
                  textString="K")}),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Ellipse(
                  extent={{-20,-98},{20,-60}},
                  lineColor={0,0,0},
                  lineThickness=0.5,
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-12,40},{12,-68}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Line(points={{12,0},{90,0}}, color={0,0,255}),
                Line(points={{-90,0},{-12,0}}, color={191,0,0}),
                Polygon(
                  points={{-12,40},{-12,80},{-10,86},{-6,88},{0,90},{6,88},{10,86},
                      {12,80},{12,40},{-12,40}},
                  lineColor={0,0,0},
                  lineThickness=0.5),
                Line(
                  points={{-12,40},{-12,-64}},
                  color={0,0,0},
                  thickness=0.5),
                Line(
                  points={{12,40},{12,-64}},
                  color={0,0,0},
                  thickness=0.5),
                Line(points={{-40,-20},{-12,-20}}, color={0,0,0}),
                Line(points={{-40,20},{-12,20}}, color={0,0,0}),
                Line(points={{-40,60},{-12,60}}, color={0,0,0}),
                Text(
                  extent={{126,-20},{26,-120}},
                  lineColor={0,0,0},
                  textString="K"),
                Text(
                  extent={{-150,130},{150,90}},
                  textString="%name",
                  lineColor={0,0,255})}),
            Documentation(info="<HTML>
<p>
This is an ideal absolute temperature sensor which returns
the temperature of the connected port in Kelvin as an output
signal.  The sensor itself has no thermal interaction with
whatever it is connected to.  Furthermore, no
thermocouple-like lags are associated with this
sensor model.
</p>
</HTML>
"));
        end TemperatureSensor;

        model HeatFlowSensor "Heat flow rate sensor"
          extends Modelica.Icons.RotationalSensor;
          Modelica.Blocks.Interfaces.RealOutput Q_flow
          "Heat flow from port_a to port_b"                                              annotation (Placement(
                transformation(
                origin={0,-100},
                extent={{-10,-10},{10,10}},
                rotation=270)));
          Interfaces.HeatPort_a port_a annotation (Placement(transformation(extent={{
                    -110,-10},{-90,10}}, rotation=0)));
          Interfaces.HeatPort_b port_b annotation (Placement(transformation(extent={{
                    90,-10},{110,10}}, rotation=0)));
        equation
          port_a.T = port_b.T;
          port_a.Q_flow + port_b.Q_flow = 0;
          Q_flow = port_a.Q_flow;
          annotation (
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Line(points={{-70,0},{-95,0}}, color={191,0,0}),
                Line(points={{0,-70},{0,-90}}, color={0,0,255}),
                Line(points={{94,0},{69,0}}, color={191,0,0})}),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Text(
                  extent={{5,-86},{116,-110}},
                  lineColor={0,0,0},
                  textString="Q_flow"),
                Line(points={{-70,0},{-90,0}}, color={191,0,0}),
                Line(points={{69,0},{90,0}}, color={191,0,0}),
                Line(points={{0,-70},{0,-90}}, color={0,0,255}),
                Text(
                  extent={{-150,125},{150,85}},
                  textString="%name",
                  lineColor={0,0,255})}),
            Documentation(info="<HTML>
<p>
This model is capable of monitoring the heat flow rate flowing through
this component. The sensed value of heat flow rate is the amount that
passes through this sensor while keeping the temperature drop across the
sensor zero.  This is an ideal model so it does not absorb any energy
and it has no direct effect on the thermal response of a system it is included in.
The output signal is positive, if the heat flows from port_a
to port_b.
</p>
</HTML>
"));
        end HeatFlowSensor;
        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics),   Documentation(info="<html>

</html>"));
      end Sensors;

      package Interfaces "Connectors and partial models"
        extends Modelica.Icons.InterfacesPackage;

        partial connector HeatPort "Thermal port for 1-dim. heat transfer"
          Modelica.SIunits.Temperature T "Port temperature";
          flow Modelica.SIunits.HeatFlowRate Q_flow
          "Heat flow rate (positive if flowing from outside into the component)";
          annotation (Documentation(info="<html>

</html>"));
        end HeatPort;

        connector HeatPort_a
        "Thermal port for 1-dim. heat transfer (filled rectangular icon)"

          extends HeatPort;

          annotation(defaultComponentName = "port_a",
            Documentation(info="<HTML>
<p>This connector is used for 1-dimensional heat flow between components.
The variables in the connector are:</p>
<pre>
   T       Temperature in [Kelvin].
   Q_flow  Heat flow rate in [Watt].
</pre>
<p>According to the Modelica sign convention, a <b>positive</b> heat flow
rate <b>Q_flow</b> is considered to flow <b>into</b> a component. This
convention has to be used whenever this connector is used in a model
class.</p>
<p>Note, that the two connector classes <b>HeatPort_a</b> and
<b>HeatPort_b</b> are identical with the only exception of the different
<b>icon layout</b>.</p></HTML>
"),         Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid)}),
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={Rectangle(
                  extent={{-50,50},{50,-50}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid), Text(
                  extent={{-120,120},{100,60}},
                  lineColor={191,0,0},
                  textString="%name")}));
        end HeatPort_a;

        connector HeatPort_b
        "Thermal port for 1-dim. heat transfer (unfilled rectangular icon)"

          extends HeatPort;

          annotation(defaultComponentName = "port_b",
            Documentation(info="<HTML>
<p>This connector is used for 1-dimensional heat flow between components.
The variables in the connector are:</p>
<pre>
   T       Temperature in [Kelvin].
   Q_flow  Heat flow rate in [Watt].
</pre>
<p>According to the Modelica sign convention, a <b>positive</b> heat flow
rate <b>Q_flow</b> is considered to flow <b>into</b> a component. This
convention has to be used whenever this connector is used in a model
class.</p>
<p>Note, that the two connector classes <b>HeatPort_a</b> and
<b>HeatPort_b</b> are identical with the only exception of the different
<b>icon layout</b>.</p></HTML>
"),         Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={Rectangle(
                  extent={{-50,50},{50,-50}},
                  lineColor={191,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid), Text(
                  extent={{-100,120},{120,60}},
                  lineColor={191,0,0},
                  textString="%name")}),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={191,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid)}));
        end HeatPort_b;

        partial model Element1D
        "Partial heat transfer element with two HeatPort connectors that does not store energy"

          Modelica.SIunits.HeatFlowRate Q_flow
          "Heat flow rate from port_a -> port_b";
          Modelica.SIunits.TemperatureDifference dT "port_a.T - port_b.T";
      public
          HeatPort_a port_a annotation (Placement(transformation(extent={{-110,-10},
                    {-90,10}}, rotation=0)));
          HeatPort_b port_b annotation (Placement(transformation(extent={{90,-10},{
                    110,10}}, rotation=0)));
        equation
          dT = port_a.T - port_b.T;
          port_a.Q_flow = Q_flow;
          port_b.Q_flow = -Q_flow;
          annotation (Documentation(info="<HTML>
<p>
This partial model contains the basic connectors and variables to
allow heat transfer models to be created that <b>do not store energy</b>,
This model defines and includes equations for the temperature
drop across the element, <b>dT</b>, and the heat flow rate
through the element from port_a to port_b, <b>Q_flow</b>.
</p>
<p>
By extending this model, it is possible to write simple
constitutive equations for many types of heat transfer components.
</p>
</HTML>
"),     Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}),
             graphics),
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}),
                    graphics));
        end Element1D;
        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics),
                                   Documentation(info="<html>

</html>"));
      end Interfaces;
      annotation (
         Icon(coordinateSystem(preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
            Polygon(
              points={{-54,-6},{-61,-7},{-75,-15},{-79,-24},{-80,-34},{-78,-42},{-73,
                  -49},{-64,-51},{-57,-51},{-47,-50},{-41,-43},{-38,-35},{-40,-27},
                  {-40,-20},{-42,-13},{-47,-7},{-54,-5},{-54,-6}},
              lineColor={128,128,128},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{-75,-15},{-79,-25},{-80,-34},{-78,-42},{-72,-49},{-64,-51},{
                  -57,-51},{-47,-50},{-57,-47},{-65,-45},{-71,-40},{-74,-33},{-76,-23},
                  {-75,-15},{-75,-15}},
              lineColor={0,0,0},
              fillColor={160,160,164},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{39,-6},{32,-7},{18,-15},{14,-24},{13,-34},{15,-42},{20,-49},
                  {29,-51},{36,-51},{46,-50},{52,-43},{55,-35},{53,-27},{53,-20},{
                  51,-13},{46,-7},{39,-5},{39,-6}},
              lineColor={160,160,164},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{18,-15},{14,-25},{13,-34},{15,-42},{21,-49},{29,-51},{36,-51},
                  {46,-50},{36,-47},{28,-45},{22,-40},{19,-33},{17,-23},{18,-15},{
                  18,-15}},
              lineColor={0,0,0},
              fillColor={160,160,164},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{-9,-23},{-9,-10},{18,-17},{-9,-23}},
              lineColor={191,0,0},
              fillColor={191,0,0},
              fillPattern=FillPattern.Solid),
            Line(
              points={{-41,-17},{-9,-17}},
              color={191,0,0},
              thickness=0.5),
            Line(
              points={{-17,-40},{15,-40}},
              color={191,0,0},
              thickness=0.5),
            Polygon(
              points={{-17,-46},{-17,-34},{-40,-40},{-17,-46}},
              lineColor={191,0,0},
              fillColor={191,0,0},
              fillPattern=FillPattern.Solid)}),
                                Documentation(info="<HTML>
<p>
This package contains components to model <b>1-dimensional heat transfer</b>
with lumped elements. This allows especially to model heat transfer in
machines provided the parameters of the lumped elements, such as
the heat capacity of a part, can be determined by measurements
(due to the complex geometries and many materials used in machines,
calculating the lumped element parameters from some basic analytic
formulas is usually not possible).
</p>
<p>
Example models how to use this library are given in subpackage <b>Examples</b>.<br>
For a first simple example, see <b>Examples.TwoMasses</b> where two masses
with different initial temperatures are getting in contact to each
other and arriving after some time at a common temperature.<br>
<b>Examples.ControlledTemperature</b> shows how to hold a temperature
within desired limits by switching on and off an electric resistor.<br>
A more realistic example is provided in <b>Examples.Motor</b> where the
heating of an electrical motor is modelled, see the following screen shot
of this example:
</p>
<img src=\"modelica://Modelica/Resources/Images/Thermal/HeatTransfer/driveWithHeatTransfer.png\" ALT=\"driveWithHeatTransfer\">
<p>
The <b>filled</b> and <b>non-filled red squares</b> at the left and
right side of a component represent <b>thermal ports</b> (connector HeatPort).
Drawing a line between such squares means that they are thermally connected.
The variables of a HeatPort connector are the temperature <b>T</b> at the port
and the heat flow rate <b>Q_flow</b> flowing into the component (if Q_flow is positive,
the heat flows into the element, otherwise it flows out of the element):
</p>
<pre>   Modelica.SIunits.Temperature  T  \"absolute temperature at port in Kelvin\";
   Modelica.SIunits.HeatFlowRate Q_flow  \"flow rate at the port in Watt\";
</pre>
<p>
Note, that all temperatures of this package, including initial conditions,
are given in Kelvin. For convenience, in subpackages <b>HeatTransfer.Celsius</b>,
 <b>HeatTransfer.Fahrenheit</b> and <b>HeatTransfer.Rankine</b> components are provided such that source and
sensor information is available in degree Celsius, degree Fahrenheit, or degree Rankine,
respectively. Additionally, in package <b>SIunits.Conversions</b> conversion
functions between the units Kelvin and Celsius, Fahrenheit, Rankine are
provided. These functions may be used in the following way:
</p>
<pre>  <b>import</b> SI=Modelica.SIunits;
  <b>import</b> Modelica.SIunits.Conversions.*;
     ...
  <b>parameter</b> SI.Temperature T = from_degC(25);  // convert 25 degree Celsius to Kelvin
</pre>

<p>
There are several other components available, such as AxialConduction (discretized PDE in
axial direction), which have been temporarily removed from this library. The reason is that
these components reference material properties, such as thermal conductivity, and currently
the Modelica design group is discussing a general scheme to describe material properties.
</p>
<p>
For technical details in the design of this library, see the following reference:<br>
<b>Michael Tiller (2001)</b>: <a href=\"http://www.amazon.de\">
Introduction to Physical Modeling with Modelica</a>.
Kluwer Academic Publishers Boston.
</p>
<p>
<b>Acknowledgements:</b><br>
Several helpful remarks from the following persons are acknowledged:
John Batteh, Ford Motors, Dearborn, U.S.A;
<a href=\"http://www.haumer.at/\">Anton Haumer</a>, Technical Consulting &amp; Electrical Engineering, Austria;
Ludwig Marvan, VA TECH ELIN EBG Elektronik GmbH, Wien, Austria;
Hans Olsson, Dassault Syst&egrave;mes AB, Sweden;
Hubertus Tummescheit, Lund Institute of Technology, Lund, Sweden.
</p>
<dl>
  <dt><b>Main Authors:</b></dt>
  <dd>
  <p>
  <a href=\"http://www.haumer.at/\">Anton Haumer</a><br>
  Technical Consulting &amp; Electrical Engineering<br>
  A-3423 St.Andrae-Woerdern, Austria<br>
  email: <a href=\"mailto:a.haumer@haumer.at\">a.haumer@haumer.at</a>
</p>
  </dd>
</dl>
<p><b>Copyright &copy; 2001-2010, Modelica Association, Michael Tiller and DLR.</b></p>

<p>
<i>This Modelica package is <u>free</u> software and the use is completely at <u>your own risk</u>; it can be redistributed and/or modified under the terms of the Modelica License 2. For license conditions (including the disclaimer of warranty) see <a href=\"modelica://Modelica.UsersGuide.ModelicaLicense2\">Modelica.UsersGuide.ModelicaLicense2</a> or visit <a href=\"http://www.modelica.org/licenses/ModelicaLicense2\"> http://www.modelica.org/licenses/ModelicaLicense2</a>.</i>
</p>
</HTML>
",     revisions="<html>
<ul>
<li><i>July 15, 2002</i>
       by Michael Tiller, <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
       and <a href=\"http://www.robotic.dlr.de/Nikolaus.Schuermann/\">Nikolaus Sch&uuml;rmann</a>:<br>
       Implemented.
</li>
<li><i>June 13, 2005</i>
       by <a href=\"http://www.haumer.at/\">Anton Haumer</a><br>
       Refined placing of connectors (cosmetic).<br>
       Refined all Examples; removed Examples.FrequencyInverter, introducing Examples.Motor<br>
       Introduced temperature dependent correction (1 + alpha*(T - T_ref)) in Fixed/PrescribedHeatFlow<br>
</li>
  <li> v1.1.1 2007/11/13 Anton Haumer<br>
       componentes moved to sub-packages</li>
  <li> v1.2.0 2009/08/26 Anton Haumer<br>
       added component ThermalCollector</li>

</ul>
</html>"));
    end HeatTransfer;
  annotation (Documentation(info="<html>
<p>
This package contains libraries to model heat transfer
and fluid heat flow.
</p>
</html>"));
  end Thermal;

  package Math
  "Library of mathematical functions (e.g., sin, cos) and of functions operating on vectors and matrices"
  import SI = Modelica.SIunits;
  extends Modelica.Icons.Package;

  package Matrices "Library of functions operating on matrices"
    extends Modelica.Icons.Package;

    function leastSquares
    "Solve linear equation A*x = b (exactly if possible, or otherwise in a least square sense; A may be non-square and may be rank deficient)"
      extends Modelica.Icons.Function;
      input Real A[:, :] "Matrix A";
      input Real b[size(A, 1)] "Vector b";
      input Real rcond=100*Modelica.Constants.eps
      "Reciprocal condition number to estimate the rank of A";
      output Real x[size(A, 2)]
      "Vector x such that min|A*x-b|^2 if size(A,1) >= size(A,2) or min|x|^2 and A*x=b, if size(A,1) < size(A,2)";
      output Integer rank "Rank of A";
  protected
      Integer info;
      Real xx[max(size(A,1),size(A,2))];
    algorithm
      if min(size(A)) > 0 then
        (xx,info,rank) := LAPACK.dgelsx_vec(A, b, rcond);
         x := xx[1:size(A,2)];
         assert(info == 0, "Solving an overdetermined or underdetermined linear system\n" +
                           "of equations with function \"Matrices.leastSquares\" failed.");
      else
         x := fill(0.0, size(A, 2));
      end if;
      annotation (
        Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
x = Matrices.<b>leastSquares</b>(A,b);
</pre></blockquote>
<h4>Description</h4>
<p>
Returns a solution of equation A*x = b in a least
square sense (A may be rank deficient):
</p>
<pre>
  minimize | A*x - b |
</pre>

<p>
Several different cases can be distinguished (note, <b>rank</b> is an
output argument of this function):
</p>

<p>
<b>size(A,1) = size(A,2)</b>
</p>

<p> A solution is returned for a regular, as well as a singular matrix A:
</p>

<ul>
<li> <b>rank</b> = size(A,1):<br>
     A is <b>regular</b> and the returned solution x fulfills the equation
     A*x = b uniquely.</li>

<li> <b>rank</b> &lt; size(A,1):<br>
     A is <b>singular</b> and no unique solution for equation A*x = b exists.
     <ul>
     <li>  If an infinite number of solutions exists, the one is selected that fulfills
           the equation and at the same time has the minimum norm |x| for all solution
           vectors that fulfill the equation.</li>
     <li>  If no solution exists, x is selected such that |A*x - b| is as small as
           possible (but A*x - b is not zero).</li>
     </ul>
</ul>

<p>
<b>size(A,1) &gt; size(A,2):</b>
</p>

<p>
The equation A*x = b has no unique solution. The solution x is selected such that
|A*x - b| is as small as possible. If rank = size(A,2), this minimum norm solution is
unique. If rank &lt; size(A,2), there are an infinite number of solutions leading to the
same minimum value of |A*x - b|. From these infinite number of solutions, the one with the
minimum norm |x| is selected. This gives a unique solution that minimizes both
|A*x - b| and |x|.
</p>

<p>
<b>size(A,1) &lt; size(A,2):</b>
</p>

<ul>
<li> <b>rank</b> = size(A,1):<br>
     There are an infinite number of solutions that fulfill the equation A*x = b.
     From this infinite number, the unique solution is selected that minimizes |x|.
     </li>

<li> <b>rank</b> &lt; size(A,1):<br>
     There is either no solution of equation A*x = b, or there are again an infinite
     number of solutions. The unique solution x is returned that minimizes
      both |A*x - b| and |x|.</li>
</ul>

<p>
Note, the solution is computed with the LAPACK function \"dgelsx\",
i.e., QR or LQ factorization of A with column pivoting.
</p>

<h4>Algorithmic details</h4>

<p>
The function first computes a QR factorization with column pivoting:
</p>

<pre>
      A * P = Q * [ R11 R12 ]
                  [  0  R22 ]
</pre>

<p>
with R11 defined as the largest leading submatrix whose estimated
condition number is less than 1/rcond.  The order of R11, <b>rank</b>,
is the effective rank of A.
</p>

<p>
Then, R22 is considered to be negligible, and R12 is annihilated
by orthogonal transformations from the right, arriving at the
complete orthogonal factorization:
</p>

<pre>
     A * P = Q * [ T11 0 ] * Z
                 [  0  0 ]
</pre>

<p>
The minimum-norm solution is then
</p>

<pre>
     x = P * Z' [ inv(T11)*Q1'*b ]
                [        0       ]
</pre>

<p>
where Q1 consists of the first \"rank\" columns of Q.
</p>

<h4>See also</h4>

<p>
<a href=\"modelica://Modelica.Math.Matrices.leastSquares2\">Matrices.leastSquares2</a>
(same as leastSquares, but with a right hand side matrix), <br>
<a href=\"modelica://Modelica.Math.Matrices.solve\">Matrices.solve</a>
(for square, regular matrices A)
</p>

</html>"));
    end leastSquares;

    package LAPACK
    "Interface to LAPACK library (should usually not directly be used but only indirectly via Modelica.Math.Matrices)"
      extends Modelica.Icons.Package;

      function dgelsx_vec
      "Computes the minimum-norm solution to a real linear least squares problem with rank deficient A"

        extends Modelica.Icons.Function;
        input Real A[:, :];
        input Real b[size(A,1)];
        input Real rcond=0.0 "Reciprocal condition number to estimate rank";
        output Real x[max(nrow,ncol)]= cat(1,b,zeros(max(nrow,ncol)-nrow))
        "solution is in first size(A,2) rows";
        output Integer info;
        output Integer rank "Effective rank of A";
    protected
        Integer nrow=size(A,1);
        Integer ncol=size(A,2);
        Integer nx=max(nrow,ncol);
        Integer lwork=max( min(nrow,ncol)+3*ncol, 2*min(nrow,ncol)+1);
        Real work[lwork];
        Real Awork[nrow,ncol]=A;
        Integer jpvt[ncol]=zeros(ncol);
        external "FORTRAN 77" dgelsx(nrow, ncol, 1, Awork, nrow, x, nx, jpvt,
                                    rcond, rank, work, lwork, info) annotation (Library="Lapack");

        annotation (
          Documentation(info="Lapack documentation
  Purpose
  =======

  DGELSX computes the minimum-norm solution to a real linear least
  squares problem:
      minimize || A * X - B ||
  using a complete orthogonal factorization of A.  A is an M-by-N
  matrix which may be rank-deficient.

  Several right hand side vectors b and solution vectors x can be
  handled in a single call; they are stored as the columns of the
  M-by-NRHS right hand side matrix B and the N-by-NRHS solution
  matrix X.

  The routine first computes a QR factorization with column pivoting:
      A * P = Q * [ R11 R12 ]
                  [  0  R22 ]
  with R11 defined as the largest leading submatrix whose estimated
  condition number is less than 1/RCOND.  The order of R11, RANK,
  is the effective rank of A.

  Then, R22 is considered to be negligible, and R12 is annihilated
  by orthogonal transformations from the right, arriving at the
  complete orthogonal factorization:
     A * P = Q * [ T11 0 ] * Z
                 [  0  0 ]
  The minimum-norm solution is then
     X = P * Z' [ inv(T11)*Q1'*B ]
                [        0       ]
  where Q1 consists of the first RANK columns of Q.

  Arguments
  =========

  M       (input) INTEGER
          The number of rows of the matrix A.  M >= 0.

  N       (input) INTEGER
          The number of columns of the matrix A.  N >= 0.

  NRHS    (input) INTEGER
          The number of right hand sides, i.e., the number of
          columns of matrices B and X. NRHS >= 0.

  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
          On entry, the M-by-N matrix A.
          On exit, A has been overwritten by details of its
          complete orthogonal factorization.

  LDA     (input) INTEGER
          The leading dimension of the array A.  LDA >= max(1,M).

  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
          On entry, the M-by-NRHS right hand side matrix B.
          On exit, the N-by-NRHS solution matrix X.
          If m >= n and RANK = n, the residual sum-of-squares for
          the solution in the i-th column is given by the sum of
          squares of elements N+1:M in that column.

  LDB     (input) INTEGER
          The leading dimension of the array B. LDB >= max(1,M,N).

  JPVT    (input/output) INTEGER array, dimension (N)
          On entry, if JPVT(i) .ne. 0, the i-th column of A is an
          initial column, otherwise it is a free column.  Before
          the QR factorization of A, all initial columns are
          permuted to the leading positions; only the remaining
          free columns are moved as a result of column pivoting
          during the factorization.
          On exit, if JPVT(i) = k, then the i-th column of A*P
          was the k-th column of A.

  RCOND   (input) DOUBLE PRECISION
          RCOND is used to determine the effective rank of A, which
          is defined as the order of the largest leading triangular
          submatrix R11 in the QR factorization with pivoting of A,
          whose estimated condition number < 1/RCOND.

  RANK    (output) INTEGER
          The effective rank of A, i.e., the order of the submatrix
          R11.  This is the same as the order of the submatrix T11
          in the complete orthogonal factorization of A.

  WORK    (workspace) DOUBLE PRECISION array, dimension
                      (max( min(M,N)+3*N, 2*min(M,N)+NRHS )),

  INFO    (output) INTEGER
          = 0:  successful exit
          < 0:  if INFO = -i, the i-th argument had an illegal value    "));

      end dgelsx_vec;
        annotation (Documentation(info="<html>
<p>
This package contains external Modelica functions as interface to the
LAPACK library
(<a href=\"http://www.netlib.org/lapack\">http://www.netlib.org/lapack</a>)
that provides FORTRAN subroutines to solve linear algebra
tasks. Usually, these functions are not directly called, but only via
the much more convenient interface of
<a href=\"modelica://Modelica.Math.Matrices\">Modelica.Math.Matrices</a>.
The documentation of the LAPACK functions is a copy of the original
FORTRAN code. The details of LAPACK are described in:
</p>

<dl>
<dt>Anderson E., Bai Z., Bischof C., Blackford S., Demmel J., Dongarra J.,
    Du Croz J., Greenbaum A., Hammarling S., McKenney A., and Sorensen D.:</dt>
<dd> <a href=\"http://www.netlib.org/lapack/lug/lapack_lug.html\">Lapack Users' Guide</a>.
     Third Edition, SIAM, 1999.</dd>
</dl>

<p>
See also <a href=\"http://en.wikipedia.org/wiki/Lapack\">http://en.wikipedia.org/wiki/Lapack</a>.
</p>

<p>
This package contains a direct interface to the LAPACK subroutines
</p>

</html>"));
    end LAPACK;
    annotation (
      Documentation(info="<HTML>
<h4>Library content</h4>
<p>
This library provides functions operating on matrices. Below, the
functions are ordered according to categories and a typical
call of the respective function is shown.
Most functions are solely an interface to the external
<a href=\"modelica://Modelica.Math.Matrices.LAPACK\">LAPACK</a> library.
</p>

<p>
Note: A' is a short hand notation of transpose(A):
</p>

<p><b>Basic Information</b></p>
<ul>
<li> <a href=\"modelica://Modelica.Math.Matrices.toString\">toString</a>(A)
     - returns the string representation of matrix A.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.isEqual\">isEqual</a>(M1, M2)
     - returns true if matrices M1 and M2 have the same size and the same elements.</li>
</ul>

<p><b>Linear Equations</b></p>
<ul>
<li> <a href=\"modelica://Modelica.Math.Matrices.solve\">solve</a>(A,b)
     - returns solution x of the linear equation A*x=b (where b is a vector,
       and A is a square matrix that must be regular).</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.solve2\">solve2</a>(A,B)
     - returns solution X of the linear equation A*X=B (where B is a matrix,
       and A is a square matrix that must be regular)</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.leastSquares\">leastSquares</a>(A,b)
     - returns solution x of the linear equation A*x=b in a least squares sense
       (where b is a vector and A may be non-square and may be rank deficient)</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.leastSquares2\">leastSquares2</a>(A,B)
     - returns solution X of the linear equation A*X=B in a least squares sense
       (where B is a matrix and A may be non-square and may be rank deficient)</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.equalityLeastSquares\">equalityLeastSquares</a>(A,a,B,b)
     - returns solution x of a linear equality constrained least squares problem:
       min|A*x-a|^2 subject to B*x=b</<li>

<li> (LU,p,info) = <a href=\"modelica://Modelica.Math.Matrices.LU\">LU</a>(A)
     - returns the LU decomposition with row pivoting of a rectangular matrix A.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.LU_solve\">LU_solve</a>(LU,p,b)
     - returns solution x of the linear equation L*U*x[p]=b with a b
       vector and an LU decomposition from \"LU(..)\".</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.LU_solve2\">LU_solve2</a>(LU,p,B)
     - returns solution X of the linear equation L*U*X[p,:]=B with a B
       matrix and an LU decomposition from \"LU(..)\".</li>
</ul>

<p><b>Matrix Factorizations</b></p>
<ul>
<li> (eval,evec) = <a href=\"modelica://Modelica.Math.Matrices.eigenValues\">eigenValues</a>(A)
     - returns eigen values \"eval\" and eigen vectors \"evec\" for a real,
       nonsymmetric matrix A in a Real representation.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.eigenValueMatrix\">eigenValueMatrix</a>(eval)
     - returns real valued block diagonal matrix of the eigenvalues \"eval\" of matrix A.</li>

<li> (sigma,U,VT) = <a href=\"modelica://Modelica.Math.Matrices.singularValues\">singularValues</a>(A)
     - returns singular values \"sigma\" and left and right singular vectors U and VT
       of a rectangular matrix A.</li>

<li> (Q,R,p) = <a href=\"modelica://Modelica.Math.Matrices.QR\">QR</a>(A)
     - returns the QR decomposition with column pivoting of a rectangular matrix A
       such that Q*R = A[:,p].</li>

<li> (H,U) = <a href=\"modelica://Modelica.Math.Matrices.hessenberg\">hessenberg</a>(A)
     - returns the upper Hessenberg form H and the orthogonal transformation matrix U
       of a square matrix A such that H = U'*A*U.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.realSchur\">realSchur</a>(A)
     - returns the real Schur form of a square matrix A.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.cholesky\">cholesky</a>(A)
     - returns the cholesky factor H of a real symmetric positive definite matrix A so that A = H'*H.</li>

<li> (D,Aimproved) = <a href=\"modelica://Modelica.Math.Matrices.balance\">balance</a>(A)
     - returns an improved form Aimproved of a square matrix A that has a smaller condition as A,
       with Aimproved = inv(diagonal(D))*A*diagonal(D).</li>
</ul>

<p><b>Matrix Properties</b></p>
<ul>
<li> <a href=\"modelica://Modelica.Math.Matrices.trace\">trace</a>(A)
     - returns the trace of square matrix A, i.e., the sum of the diagonal elements.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.det\">det</a>(A)
     - returns the determinant of square matrix A (using LU decomposition; try to avoid det(..))</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.inv\">inv</a>(A)
     - returns the inverse of square matrix A (try to avoid, use instead \"solve2(..) with B=identity(..))</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.rank\">rank</a>(A)
     - returns the rank of square matrix A (computed with singular value decomposition)</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.conditionNumber\">conditionNumber</a>(A)
     - returns the condition number norm(A)*norm(inv(A)) of a square matrix A in the range 1..&infin;.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.rcond\">rcond</a>(A)
     - returns the reciprocal condition number 1/conditionNumber(A) of a square matrix A in the range 0..1.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.norm\">norm</a>(A)
     - returns the 1-, 2-, or infinity-norm of matrix A.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.frobeniusNorm\">frobeniusNorm</a>(A)
     - returns the Frobenius norm of matrix A.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.nullSpace\">nullSpace</a>(A)
     - returns the null space of matrix A.</li>
</ul>

<p><b>Matrix Exponentials</b></p>
<ul>
<li> <a href=\"modelica://Modelica.Math.Matrices.exp\">exp</a>(A)
     - returns the exponential e^A of a matrix A by adaptive Taylor series
       expansion with scaling and balancing</li>

<li> (phi, gamma) = <a href=\"modelica://Modelica.Math.Matrices.integralExp\">integralExp</a>(A,B)
     - returns the exponential phi=e^A and the integral gamma=integral(exp(A*t)*dt)*B as needed
       for a discretized system with zero order hold.</li>

<li> (phi, gamma, gamma1) = <a href=\"modelica://Modelica.Math.Matrices.integralExpT\">integralExpT</a>(A,B)
     - returns the exponential phi=e^A, the integral gamma=integral(exp(A*t)*dt)*B,
       and the time-weighted integral gamma1 = integral((T-t)*exp(A*t)*dt)*B as needed
       for a discretized system with first order hold.</li>
</ul>

<p><b>Matrix Equations</b></p>
<ul>
<li> <a href=\"modelica://Modelica.Math.Matrices.continuousLyapunov\">continuousLyapunov</a>(A,C)
     - returns solution X of the continuous-time Lyapunov equation X*A + A'*X = C</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.continuousSylvester\">continuousSylvester</a>(A,B,C)
     - returns solution X of the continuous-time Sylvester equation A*X + X*B = C</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.continuousRiccati\">continuousRiccati</a>(A,B,R,Q)
     - returns solution X of the continuous-time algebraic Riccat equation
       A'*X + X*A - X*B*inv(R)*B'*X + Q = 0</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.discreteLyapunov\">discreteLyapunov</a>(A,C)
     - returns solution X of the discretes-time Lyapunov equation A'*X*A + sgn*X = C</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.discreteSylvester\">discreteSylvester</a>(A,B,C)
     - returns solution X of the discrete-time Sylvester equation A*X*B + sgn*X = C</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.discreteRiccati\">discreteRiccati</a>(A,B,R,Q)
     - returns solution X of the discrete-time algebraic Riccat equation
       A'*X*A - X - A'*X*B*inv(R + B'*X*B)*B'*X*A + Q = 0</li>
</ul>

<p><b>Matrix Manipulation</b></p>
<ul>
<li> <a href=\"modelica://Modelica.Math.Matrices.sort\">sort</a>(M)
     - returns the sorted rows or columns of matrix M in ascending or descending order.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.flipLeftRight\">flipLeftRight</a>(M)
     - returns matrix M so that the columns of M are flipped in left/right direction.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.flipUpDown\">flipUpDown</a>(M)
     - returns matrix M so that the rows of M are flipped in up/down direction.</li>
</ul>

<h4>See also</h4>
<a href=\"modelica://Modelica.Math.Vectors\">Vectors</a>

</HTML>
"));
  end Matrices;

    package BooleanVectors "Library of functions operating on Boolean vectors"
     extends Modelica.Icons.Package;

    function allTrue
      "Returns true, if all elements of the Boolean input vector are true ('and')"
      extends Modelica.Icons.Function;
      input Boolean b[:] "Boolean vector";
      output Boolean result "= true, if all elements of b are true";
    algorithm
      result := size(b,1) > 0;
      for i in 1:size(b,1) loop
         result := result and b[i];
      end for;
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
<b>allTrue</b>(b);
</pre></blockquote>

<h4>Description</h4>
<p>
Returns <b>true</b> if all elements of the Boolean input vector b are <b>true</b>.
Otherwise the function returns <b>false</b>. If b is an empty vector, 
i.e., size(b,1)=0, the function returns <b>false</b>. 
</p>

<h4>Example</h4>
<blockquote><pre>
  Boolean b1[3] = {true, true, true};
  Boolean b2[3] = {false, true, false};
  Boolean r1, r2;
<b>algorithm</b>
  r1 = allTrue(b1);  // r1 = true
  r2 = allTrue(b2);  // r2 = false
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Math.BooleanVectors.anyTrue\">anyTrue</a>,
<a href=\"modelica://Modelica.Math.BooleanVectors.oneTrue\">oneTrue</a>,
<a href=\"modelica://Modelica.Math.BooleanVectors.firstTrueIndex\">firstTrueIndex</a>.
</p>

</html>"));
    end allTrue;
      annotation (Documentation(info="<html>
<p>
This library provides functions operating on vectors that have
a Boolean vector as input argument.
</p>
</html>"));
    end BooleanVectors;

  function sin "Sine"
    extends baseIcon1;
    input Modelica.SIunits.Angle u;
    output Real y;

  external "builtin" y=  sin(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}},
          grid={2,2}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,0},{-68.7,34.2},{-61.5,53.1},{-55.1,66.4},{-49.4,74.6},
                {-43.8,79.1},{-38.2,79.8},{-32.6,76.6},{-26.9,69.7},{-21.3,59.4},
                {-14.9,44.1},{-6.83,21.2},{10.1,-30.8},{17.3,-50.2},{23.7,-64.2},
                {29.3,-73.1},{35,-78.4},{40.6,-80},{46.2,-77.6},{51.9,-71.5},{
                57.5,-61.9},{63.9,-47.2},{72,-24.8},{80,0}}, color={0,0,0}),
          Text(
            extent={{12,84},{84,36}},
            lineColor={192,192,192},
            textString="sin")}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}},
          grid={2,2}), graphics={
          Line(points={{-100,0},{84,0}}, color={95,95,95}),
          Polygon(
            points={{100,0},{84,6},{84,-6},{100,0}},
            lineColor={95,95,95},
            fillColor={95,95,95},
            fillPattern=FillPattern.Solid),
          Line(
            points={{-80,0},{-68.7,34.2},{-61.5,53.1},{-55.1,66.4},{-49.4,74.6},{
                -43.8,79.1},{-38.2,79.8},{-32.6,76.6},{-26.9,69.7},{-21.3,59.4},{
                -14.9,44.1},{-6.83,21.2},{10.1,-30.8},{17.3,-50.2},{23.7,-64.2},{
                29.3,-73.1},{35,-78.4},{40.6,-80},{46.2,-77.6},{51.9,-71.5},{57.5,
                -61.9},{63.9,-47.2},{72,-24.8},{80,0}},
            color={0,0,255},
            thickness=0.5),
          Text(
            extent={{-105,72},{-85,88}},
            textString="1",
            lineColor={0,0,255}),
          Text(
            extent={{70,25},{90,5}},
            textString="2*pi",
            lineColor={0,0,255}),
          Text(
            extent={{-103,-72},{-83,-88}},
            textString="-1",
            lineColor={0,0,255}),
          Text(
            extent={{82,-6},{102,-26}},
            lineColor={95,95,95},
            textString="u"),
          Line(
            points={{-80,80},{-28,80}},
            color={175,175,175},
            smooth=Smooth.None),
          Line(
            points={{-80,-80},{50,-80}},
            color={175,175,175},
            smooth=Smooth.None)}),
      Documentation(info="<html>
<p>
This function returns y = sin(u), with -&infin; &lt; u &lt; &infin;:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/sin.png\">
</p>
</html>"),   Library="ModelicaExternalC");
  end sin;

  function cos "Cosine"
    extends baseIcon1;
    input SI.Angle u;
    output Real y;

  external "builtin" y=  cos(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}},
          grid={2,2}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,80},{-74.4,78.1},{-68.7,72.3},{-63.1,63},{-56.7,48.7},
                {-48.6,26.6},{-29.3,-32.5},{-22.1,-51.7},{-15.7,-65.3},{-10.1,-73.8},
                {-4.42,-78.8},{1.21,-79.9},{6.83,-77.1},{12.5,-70.6},{18.1,-60.6},
                {24.5,-45.7},{32.6,-23},{50.3,31.3},{57.5,50.7},{63.9,64.6},{69.5,
                73.4},{75.2,78.6},{80,80}}, color={0,0,0}),
          Text(
            extent={{-36,82},{36,34}},
            lineColor={192,192,192},
            textString="cos")}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}},
          grid={2,2}), graphics={
          Text(
            extent={{-103,72},{-83,88}},
            textString="1",
            lineColor={0,0,255}),
          Text(
            extent={{-103,-72},{-83,-88}},
            textString="-1",
            lineColor={0,0,255}),
          Text(
            extent={{70,25},{90,5}},
            textString="2*pi",
            lineColor={0,0,255}),
          Line(points={{-100,0},{84,0}}, color={95,95,95}),
          Polygon(
            points={{98,0},{82,6},{82,-6},{98,0}},
            lineColor={95,95,95},
            fillColor={95,95,95},
            fillPattern=FillPattern.Solid),
          Line(
            points={{-80,80},{-74.4,78.1},{-68.7,72.3},{-63.1,63},{-56.7,48.7},{-48.6,
                26.6},{-29.3,-32.5},{-22.1,-51.7},{-15.7,-65.3},{-10.1,-73.8},{-4.42,
                -78.8},{1.21,-79.9},{6.83,-77.1},{12.5,-70.6},{18.1,-60.6},{24.5,
                -45.7},{32.6,-23},{50.3,31.3},{57.5,50.7},{63.9,64.6},{69.5,73.4},
                {75.2,78.6},{80,80}},
            color={0,0,255},
            thickness=0.5),
          Text(
            extent={{78,-6},{98,-26}},
            lineColor={95,95,95},
            textString="u"),
          Line(
            points={{-80,-80},{18,-80}},
            color={175,175,175},
            smooth=Smooth.None)}),
      Documentation(info="<html>
<p>
This function returns y = cos(u), with -&infin; &lt; u &lt; &infin;:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/cos.png\">
</p>
</html>"),   Library="ModelicaExternalC");
  end cos;

  function tan "Tangent (u shall not be -pi/2, pi/2, 3*pi/2, ...)"
    extends baseIcon2;
    input SI.Angle u;
    output Real y;

  external "builtin" y=  tan(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}},
          grid={2,2}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,-80},{-78.4,-68.4},{-76.8,-59.7},{-74.4,-50},{-71.2,-40.9},
                {-67.1,-33},{-60.7,-24.8},{-51.1,-17.2},{-35.8,-9.98},{-4.42,-1.07},
                {33.4,9.12},{49.4,16.2},{59.1,23.2},{65.5,30.6},{70.4,39.1},{73.6,
                47.4},{76,56.1},{77.6,63.8},{80,80}}, color={0,0,0}),
          Text(
            extent={{-90,72},{-18,24}},
            lineColor={192,192,192},
            textString="tan")}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}},
          grid={2,2}), graphics={
          Text(
            extent={{-37,-72},{-17,-88}},
            textString="-5.8",
            lineColor={0,0,255}),
          Text(
            extent={{-33,86},{-13,70}},
            textString=" 5.8",
            lineColor={0,0,255}),
          Text(
            extent={{68,-13},{88,-33}},
            textString="1.4",
            lineColor={0,0,255}),
          Line(points={{-100,0},{84,0}}, color={95,95,95}),
          Polygon(
            points={{98,0},{82,6},{82,-6},{98,0}},
            lineColor={95,95,95},
            fillColor={95,95,95},
            fillPattern=FillPattern.Solid),
          Line(
            points={{-80,-80},{-78.4,-68.4},{-76.8,-59.7},{-74.4,-50},{-71.2,-40.9},
                {-67.1,-33},{-60.7,-24.8},{-51.1,-17.2},{-35.8,-9.98},{-4.42,-1.07},
                {33.4,9.12},{49.4,16.2},{59.1,23.2},{65.5,30.6},{70.4,39.1},{73.6,
                47.4},{76,56.1},{77.6,63.8},{80,80}},
            color={0,0,255},
            thickness=0.5),
          Text(
            extent={{82,22},{102,2}},
            lineColor={95,95,95},
            textString="u"),
          Line(
            points={{0,80},{86,80}},
            color={175,175,175},
            smooth=Smooth.None),
          Line(
            points={{80,88},{80,-16}},
            color={175,175,175},
            smooth=Smooth.None)}),
      Documentation(info="<html>
<p>
This function returns y = tan(u), with -&infin; &lt; u &lt; &infin;
(if u is a multiple of (2n-1)*pi/2, y = tan(u) is +/- infinity).
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/tan.png\">
</p>
</html>"),   Library="ModelicaExternalC");
  end tan;

  function asin "Inverse sine (-1 <= u <= 1)"
    extends baseIcon2;
    input Real u;
    output SI.Angle y;

  external "builtin" y=  asin(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}},
          grid={2,2}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,-80},{-79.2,-72.8},{-77.6,-67.5},{-73.6,-59.4},{-66.3,
                -49.8},{-53.5,-37.3},{-30.2,-19.7},{37.4,24.8},{57.5,40.8},{68.7,
                52.7},{75.2,62.2},{77.6,67.5},{80,80}}, color={0,0,0}),
          Text(
            extent={{-88,78},{-16,30}},
            lineColor={192,192,192},
            textString="asin")}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}},
          grid={2,2}), graphics={
          Text(
            extent={{-40,-72},{-15,-88}},
            textString="-pi/2",
            lineColor={0,0,255}),
          Text(
            extent={{-38,88},{-13,72}},
            textString=" pi/2",
            lineColor={0,0,255}),
          Text(
            extent={{68,-9},{88,-29}},
            textString="+1",
            lineColor={0,0,255}),
          Text(
            extent={{-90,21},{-70,1}},
            textString="-1",
            lineColor={0,0,255}),
          Line(points={{-100,0},{84,0}}, color={95,95,95}),
          Polygon(
            points={{98,0},{82,6},{82,-6},{98,0}},
            lineColor={95,95,95},
            fillColor={95,95,95},
            fillPattern=FillPattern.Solid),
          Line(
            points={{-80,-80},{-79.2,-72.8},{-77.6,-67.5},{-73.6,-59.4},{-66.3,-49.8},
                {-53.5,-37.3},{-30.2,-19.7},{37.4,24.8},{57.5,40.8},{68.7,52.7},{
                75.2,62.2},{77.6,67.5},{80,80}},
            color={0,0,255},
            thickness=0.5),
          Text(
            extent={{82,24},{102,4}},
            lineColor={95,95,95},
            textString="u"),
          Line(
            points={{0,80},{86,80}},
            color={175,175,175},
            smooth=Smooth.None),
          Line(
            points={{80,86},{80,-10}},
            color={175,175,175},
            smooth=Smooth.None)}),
      Documentation(info="<html>
<p>
This function returns y = asin(u), with -1 &le; u &le; +1:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/asin.png\">
</p>
</html>"),   Library="ModelicaExternalC");
  end asin;

  function acos "Inverse cosine (-1 <= u <= 1)"
    extends baseIcon2;
    input Real u;
    output SI.Angle y;

  external "builtin" y=  acos(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}},
          grid={2,2}), graphics={
          Line(points={{-90,-80},{68,-80}}, color={192,192,192}),
          Polygon(
            points={{90,-80},{68,-72},{68,-88},{90,-80}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,80},{-79.2,72.8},{-77.6,67.5},{-73.6,59.4},{-66.3,
                49.8},{-53.5,37.3},{-30.2,19.7},{37.4,-24.8},{57.5,-40.8},{68.7,-52.7},
                {75.2,-62.2},{77.6,-67.5},{80,-80}}, color={0,0,0}),
          Text(
            extent={{-86,-14},{-14,-62}},
            lineColor={192,192,192},
            textString="acos")}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}},
          grid={2,2}), graphics={
          Line(points={{-100,-80},{84,-80}}, color={95,95,95}),
          Polygon(
            points={{98,-80},{82,-74},{82,-86},{98,-80}},
            lineColor={95,95,95},
            fillColor={95,95,95},
            fillPattern=FillPattern.Solid),
          Line(
            points={{-80,80},{-79.2,72.8},{-77.6,67.5},{-73.6,59.4},{-66.3,49.8},
                {-53.5,37.3},{-30.2,19.7},{37.4,-24.8},{57.5,-40.8},{68.7,-52.7},
                {75.2,-62.2},{77.6,-67.5},{80,-80}},
            color={0,0,255},
            thickness=0.5),
          Text(
            extent={{-30,88},{-5,72}},
            textString=" pi",
            lineColor={0,0,255}),
          Text(
            extent={{-94,-57},{-74,-77}},
            textString="-1",
            lineColor={0,0,255}),
          Text(
            extent={{60,-81},{80,-101}},
            textString="+1",
            lineColor={0,0,255}),
          Text(
            extent={{82,-56},{102,-76}},
            lineColor={95,95,95},
            textString="u"),
          Line(
            points={{-2,80},{84,80}},
            color={175,175,175},
            smooth=Smooth.None),
          Line(
            points={{80,82},{80,-86}},
            color={175,175,175},
            smooth=Smooth.None)}),
      Documentation(info="<html>
<p>
This function returns y = acos(u), with -1 &le; u &le; +1:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/acos.png\">
</p>
</html>"),   Library="ModelicaExternalC");
  end acos;

  function cosh "Hyperbolic cosine"
    extends baseIcon2;
    input Real u;
    output Real y;

  external "builtin" y=  cosh(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}},
          grid={2,2}), graphics={
          Line(points={{-90,-86.083},{68,-86.083}}, color={192,192,192}),
          Polygon(
            points={{90,-86.083},{68,-78.083},{68,-94.083},{90,-86.083}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,80},{-77.6,61.1},{-74.4,39.3},{-71.2,20.7},{-67.1,
                1.29},{-63.1,-14.6},{-58.3,-29.8},{-52.7,-43.5},{-46.2,-55.1},{-39,
                -64.3},{-30.2,-71.7},{-18.9,-77.1},{-4.42,-79.9},{10.9,-79.1},{
                23.7,-75.2},{34.2,-68.7},{42.2,-60.6},{48.6,-51.2},{54.3,-40},{
                59.1,-27.5},{63.1,-14.6},{67.1,1.29},{71.2,20.7},{74.4,39.3},{
                77.6,61.1},{80,80}}, color={0,0,0}),
          Text(
            extent={{4,66},{66,20}},
            lineColor={192,192,192},
            textString="cosh")}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}},
          grid={2,2}), graphics={
          Line(points={{-100,-84.083},{84,-84.083}}, color={95,95,95}),
          Polygon(
            points={{98,-84.083},{82,-78.083},{82,-90.083},{98,-84.083}},
            lineColor={95,95,95},
            fillColor={95,95,95},
            fillPattern=FillPattern.Solid),
          Line(
            points={{-80,80},{-77.6,61.1},{-74.4,39.3},{-71.2,20.7},{-67.1,1.29},
                {-63.1,-14.6},{-58.3,-29.8},{-52.7,-43.5},{-46.2,-55.1},{-39,-64.3},
                {-30.2,-71.7},{-18.9,-77.1},{-4.42,-79.9},{10.9,-79.1},{23.7,-75.2},
                {34.2,-68.7},{42.2,-60.6},{48.6,-51.2},{54.3,-40},{59.1,-27.5},{
                63.1,-14.6},{67.1,1.29},{71.2,20.7},{74.4,39.3},{77.6,61.1},{80,
                80}},
            color={0,0,255},
            thickness=0.5),
          Text(
            extent={{-31,72},{-11,88}},
            textString="27",
            lineColor={0,0,255}),
          Text(
            extent={{64,-83},{84,-103}},
            textString="4",
            lineColor={0,0,255}),
          Text(
            extent={{-94,-63},{-74,-83}},
            textString="-4",
            lineColor={0,0,255}),
          Text(
            extent={{80,-60},{100,-80}},
            lineColor={95,95,95},
            textString="u"),
          Line(
            points={{0,80},{88,80}},
            color={175,175,175},
            smooth=Smooth.None),
          Line(
            points={{80,84},{80,-90}},
            color={175,175,175},
            smooth=Smooth.None)}),
      Documentation(info="<html>
<p>
This function returns y = cosh(u), with -&infin; &lt; u &lt; &infin;:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/cosh.png\">
</p>
</html>"),   Library="ModelicaExternalC");
  end cosh;

  function tanh "Hyperbolic tangent"
    extends baseIcon2;
    input Real u;
    output Real y;

  external "builtin" y=  tanh(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}},
          grid={0.5,0.5}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,-80},{-47.8,-78.7},{-35.8,-75.7},{-27.7,-70.6},{-22.1,
                -64.2},{-17.3,-55.9},{-12.5,-44.3},{-7.64,-29.2},{-1.21,-4.82},{
                6.83,26.3},{11.7,42},{16.5,54.2},{21.3,63.1},{26.9,69.9},{34.2,75},
                {45.4,78.4},{72,79.9},{80,80}}, color={0,0,0}),
          Text(
            extent={{-88,72},{-16,24}},
            lineColor={192,192,192},
            textString="tanh")}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}},
          grid={0.5,0.5}), graphics={
          Line(points={{-100,0},{84,0}}, color={95,95,95}),
          Polygon(
            points={{96,0},{80,6},{80,-6},{96,0}},
            lineColor={95,95,95},
            fillColor={95,95,95},
            fillPattern=FillPattern.Solid),
          Line(
            points={{-80,-80.5},{-47.8,-79.2},{-35.8,-76.2},{-27.7,-71.1},{-22.1,
                -64.7},{-17.3,-56.4},{-12.5,-44.8},{-7.64,-29.7},{-1.21,-5.32},{
                6.83,25.8},{11.7,41.5},{16.5,53.7},{21.3,62.6},{26.9,69.4},{34.2,
                74.5},{45.4,77.9},{72,79.4},{80,79.5}},
            color={0,0,255},
            thickness=0.5),
          Text(
            extent={{-29,72},{-9,88}},
            textString="1",
            lineColor={0,0,255}),
          Text(
            extent={{3,-72},{23,-88}},
            textString="-1",
            lineColor={0,0,255}),
          Text(
            extent={{82,-2},{102,-22}},
            lineColor={95,95,95},
            textString="u"),
          Line(
            points={{0,80},{88,80}},
            color={175,175,175},
            smooth=Smooth.None)}),
      Documentation(info="<html>
<p>
This function returns y = tanh(u), with -&infin; &lt; u &lt; &infin;:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/tanh.png\">
</p>
</html>"),   Library="ModelicaExternalC");
  end tanh;

  function exp "Exponential, base e"
    extends baseIcon2;
    input Real u;
    output Real y;

  external "builtin" y=  exp(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}},
          grid={2,2}), graphics={
          Line(points={{-90,-80.3976},{68,-80.3976}}, color={192,192,192}),
          Polygon(
            points={{90,-80.3976},{68,-72.3976},{68,-88.3976},{90,-80.3976}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,-80},{-31,-77.9},{-6.03,-74},{10.9,-68.4},{23.7,-61},
                {34.2,-51.6},{43,-40.3},{50.3,-27.8},{56.7,-13.5},{62.3,2.23},{
                67.1,18.6},{72,38.2},{76,57.6},{80,80}}, color={0,0,0}),
          Text(
            extent={{-86,50},{-14,2}},
            lineColor={192,192,192},
            textString="exp")}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}},
          grid={2,2}), graphics={
          Line(points={{-100,-80.3976},{84,-80.3976}}, color={95,95,95}),
          Polygon(
            points={{98,-80.3976},{82,-74.3976},{82,-86.3976},{98,-80.3976}},
            lineColor={95,95,95},
            fillColor={95,95,95},
            fillPattern=FillPattern.Solid),
          Line(
            points={{-80,-80},{-31,-77.9},{-6.03,-74},{10.9,-68.4},{23.7,-61},{
                34.2,-51.6},{43,-40.3},{50.3,-27.8},{56.7,-13.5},{62.3,2.23},{
                67.1,18.6},{72,38.2},{76,57.6},{80,80}},
            color={0,0,255},
            thickness=0.5),
          Text(
            extent={{-31,72},{-11,88}},
            textString="20",
            lineColor={0,0,255}),
          Text(
            extent={{-92,-81},{-72,-101}},
            textString="-3",
            lineColor={0,0,255}),
          Text(
            extent={{66,-81},{86,-101}},
            textString="3",
            lineColor={0,0,255}),
          Text(
            extent={{2,-69},{22,-89}},
            textString="1",
            lineColor={0,0,255}),
          Text(
            extent={{78,-54},{98,-74}},
            lineColor={95,95,95},
            textString="u"),
          Line(
            points={{0,80},{88,80}},
            color={175,175,175},
            smooth=Smooth.None),
          Line(
            points={{80,84},{80,-84}},
            color={175,175,175},
            smooth=Smooth.None)}),
      Documentation(info="<html>
<p>
This function returns y = exp(u), with -&infin; &lt; u &lt; &infin;:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/exp.png\">
</p>
</html>"),   Library="ModelicaExternalC");
  end exp;

  function log "Natural (base e) logarithm (u shall be > 0)"
    extends baseIcon1;
    input Real u;
    output Real y;

  external "builtin" y=  log(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}},
          grid={2,2}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,-80},{-79.2,-50.6},{-78.4,-37},{-77.6,-28},{-76.8,-21.3},
                {-75.2,-11.4},{-72.8,-1.31},{-69.5,8.08},{-64.7,17.9},{-57.5,28},
                {-47,38.1},{-31.8,48.1},{-10.1,58},{22.1,68},{68.7,78.1},{80,80}},
              color={0,0,0}),
          Text(
            extent={{-6,-24},{66,-72}},
            lineColor={192,192,192},
            textString="log")}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}},
          grid={2,2}), graphics={
          Line(points={{-100,0},{84,0}}, color={95,95,95}),
          Polygon(
            points={{100,0},{84,6},{84,-6},{100,0}},
            lineColor={95,95,95},
            fillColor={95,95,95},
            fillPattern=FillPattern.Solid),
          Line(
            points={{-78,-80},{-77.2,-50.6},{-76.4,-37},{-75.6,-28},{-74.8,-21.3},
                {-73.2,-11.4},{-70.8,-1.31},{-67.5,8.08},{-62.7,17.9},{-55.5,28},
                {-45,38.1},{-29.8,48.1},{-8.1,58},{24.1,68},{70.7,78.1},{82,80}},
            color={0,0,255},
            thickness=0.5),
          Text(
            extent={{-105,72},{-85,88}},
            textString="3",
            lineColor={0,0,255}),
          Text(
            extent={{60,-3},{80,-23}},
            textString="20",
            lineColor={0,0,255}),
          Text(
            extent={{-78,-7},{-58,-27}},
            textString="1",
            lineColor={0,0,255}),
          Text(
            extent={{84,26},{104,6}},
            lineColor={95,95,95},
            textString="u"),
          Text(
            extent={{-100,9},{-80,-11}},
            textString="0",
            lineColor={0,0,255}),
          Line(
            points={{-80,80},{84,80}},
            color={175,175,175},
            smooth=Smooth.None),
          Line(
            points={{82,82},{82,-6}},
            color={175,175,175},
            smooth=Smooth.None)}),
      Documentation(info="<html>
<p>
This function returns y = log(10) (the natural logarithm of u),
with u &gt; 0:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/log.png\">
</p>
</html>"),   Library="ModelicaExternalC");
  end log;

  partial function baseIcon1
    "Basic icon for mathematical function with y-axis on left side"

    annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
              -100},{100,100}}), graphics={
          Rectangle(
            extent={{-100,100},{100,-100}},
            lineColor={0,0,0},
            fillColor={255,255,255},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,-80},{-80,68}}, color={192,192,192}),
          Polygon(
            points={{-80,90},{-88,68},{-72,68},{-80,90}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Text(
            extent={{-150,150},{150,110}},
            textString="%name",
            lineColor={0,0,255})}),                          Diagram(
          coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
              100}}), graphics={
          Line(points={{-80,80},{-88,80}}, color={95,95,95}),
          Line(points={{-80,-80},{-88,-80}}, color={95,95,95}),
          Line(points={{-80,-90},{-80,84}}, color={95,95,95}),
          Text(
            extent={{-75,104},{-55,84}},
            lineColor={95,95,95},
            textString="y"),
          Polygon(
            points={{-80,98},{-86,82},{-74,82},{-80,98}},
            lineColor={95,95,95},
            fillColor={95,95,95},
            fillPattern=FillPattern.Solid)}),
      Documentation(info="<html>
<p>
Icon for a mathematical function, consisting of an y-axis on the left side.
It is expected, that an x-axis is added and a plot of the function.
</p>
</html>"));
  end baseIcon1;

  partial function baseIcon2
    "Basic icon for mathematical function with y-axis in middle"

    annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
              -100},{100,100}}), graphics={
          Rectangle(
            extent={{-100,100},{100,-100}},
            lineColor={0,0,0},
            fillColor={255,255,255},
            fillPattern=FillPattern.Solid),
          Line(points={{0,-80},{0,68}}, color={192,192,192}),
          Polygon(
            points={{0,90},{-8,68},{8,68},{0,90}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Text(
            extent={{-150,150},{150,110}},
            textString="%name",
            lineColor={0,0,255})}),                          Diagram(graphics={
          Line(points={{0,80},{-8,80}}, color={95,95,95}),
          Line(points={{0,-80},{-8,-80}}, color={95,95,95}),
          Line(points={{0,-90},{0,84}}, color={95,95,95}),
          Text(
            extent={{5,104},{25,84}},
            lineColor={95,95,95},
            textString="y"),
          Polygon(
            points={{0,98},{-6,82},{6,82},{0,98}},
            lineColor={95,95,95},
            fillColor={95,95,95},
            fillPattern=FillPattern.Solid)}),
      Documentation(info="<html>
<p>
Icon for a mathematical function, consisting of an y-axis in the middle.
It is expected, that an x-axis is added and a plot of the function.
</p>
</html>"));
  end baseIcon2;
  annotation (
    Invisible=true,
    Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,100}}),
        graphics={Text(
          extent={{-59,-9},{42,-56}},
          lineColor={0,0,0},
          textString="f(x)")}),
    Documentation(info="<HTML>
<p>
This package contains <b>basic mathematical functions</b> (such as sin(..)),
as well as functions operating on
<a href=\"modelica://Modelica.Math.Vectors\">vectors</a>,
<a href=\"modelica://Modelica.Math.Matrices\">matrices</a>,
<a href=\"modelica://Modelica.Math.Nonlinear\">nonlinear functions</a>, and
<a href=\"modelica://Modelica.Math.BooleanVectors\">Boolean vectors</a>.
</p>

<dl>
<dt><b>Main Authors:</b>
<dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a> and
    Marcus Baur<br>
    Deutsches Zentrum f&uuml;r Luft und Raumfahrt e.V. (DLR)<br>
    Institut f&uuml;r Robotik und Mechatronik<br>
    Postfach 1116<br>
    D-82230 Wessling<br>
    Germany<br>
    email: <A HREF=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</A><br>
</dl>

<p>
Copyright &copy; 1998-2010, Modelica Association and DLR.
</p>
<p>
<i>This Modelica package is <u>free</u> software and the use is completely at <u>your own risk</u>; it can be redistributed and/or modified under the terms of the Modelica License 2. For license conditions (including the disclaimer of warranty) see <a href=\"modelica://Modelica.UsersGuide.ModelicaLicense2\">Modelica.UsersGuide.ModelicaLicense2</a> or visit <a href=\"http://www.modelica.org/licenses/ModelicaLicense2\"> http://www.modelica.org/licenses/ModelicaLicense2</a>.</i>
</p>
</HTML>
",   revisions="<html>
<ul>
<li><i>October 21, 2002</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
       and <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
       Function tempInterpol2 added.</li>
<li><i>Oct. 24, 1999</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Icons for icon and diagram level introduced.</li>
<li><i>June 30, 1999</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Realized.</li>
</ul>

</html>"));
  end Math;

  package Utilities
  "Library of utility functions dedicated to scripting (operating on files, streams, strings, system)"
    extends Modelica.Icons.Package;

    package Streams "Read from files and write to files"
      extends Modelica.Icons.Package;

      function print "Print string to terminal or file"
        extends Modelica.Icons.Function;
        input String string="" "String to be printed";
        input String fileName=""
        "File where to print (empty string is the terminal)"
                     annotation(Dialog(__Dymola_saveSelector(filter="Text files (*.txt)",
                            caption="Text file to store the output of print(..)")));
      external "C" ModelicaInternal_print(string, fileName);
        annotation (Library="ModelicaExternalC",
      Documentation(info="<HTML>
<h4>Syntax</h4>
<blockquote><pre>
Streams.<b>print</b>(string);
Streams.<b>print</b>(string,fileName);
</pre></blockquote>
<h4>Description</h4>
<p>
Function <b>print</b>(..) opens automatically the given file, if
it is not yet open. If the file does not exist, it is created.
If the file does exist, the given string is appended to the file.
If this is not desired, call \"Files.remove(fileName)\" before calling print
(\"remove(..)\" is silent, if the file does not exist).
The Modelica environment may close the file whenever appropriate.
This can be enforced by calling <b>Streams.close</b>(fileName).
After every call of \"print(..)\" a \"new line\" is printed automatically.
</p>
<h4>Example</h4>
<blockquote><pre>
  Streams.print(\"x = \" + String(x));
  Streams.print(\"y = \" + String(y));
  Streams.print(\"x = \" + String(y), \"mytestfile.txt\");
</pre></blockquote>
<p>
<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Utilities.Streams\">Streams</a>,
<a href=\"modelica://Modelica.Utilities.Streams.error\">Streams.error</a>,
<a href=\"modelica://ModelicaReference.Operators.string\">String</a>
</p>
</HTML>"));
      end print;

      function readLine
      "Reads a line of text from a file and returns it in a string"
        extends Modelica.Icons.Function;
        input String fileName "Name of the file that shall be read"
                            annotation(Dialog(__Dymola_loadSelector(filter="Text files (*.txt)",
                            caption="Open text file for reading")));
        input Integer lineNumber(min=1) "Number of line to read";
        output String string "Line of text";
        output Boolean endOfFile
        "If true, end-of-file was reached when trying to read line";
       external "C" string = ModelicaInternal_readLine(fileName,lineNumber,endOfFile);
        annotation (Library="ModelicaExternalC",Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(string, endOfFile) = Streams.<b>readLine</b>(fileName, lineNumber)
</pre></blockquote>
<h4>Description</h4>
<p>
Function <b>readLine</b>(..) opens the given file, reads enough of the
content to get the requested line, and returns the line as a string.
Lines are separated by LF or CR-LF; the returned string does not
contain the line separator. The file might remain open after
the call.
</p>
<p>
If lineNumber > countLines(fileName), an empty string is returned
and endOfFile=true. Otherwise endOfFile=false.
</p>
</html>"));
      end readLine;

      function error "Print error message and cancel all actions"
        extends Modelica.Icons.Function;
        input String string "String to be printed to error message window";
        external "C" ModelicaError(string);
        annotation (Library="ModelicaExternalC",
      Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Streams.<b>error</b>(string);
</pre></blockquote>
<h4>Description</h4>
<p>
Print the string \"string\" as error message and
cancel all actions. Line breaks are characterized
by \"\\n\" in the string.
</p>
<h4>Example</h4>
<blockquote><pre>
  Streams.error(\"x (= \" + String(x) + \")\\nhas to be in the range 0 .. 1\");
</pre></blockquote>
<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Utilities.Streams\">Streams</a>,
<a href=\"modelica://Modelica.Utilities.Streams.print\">Streams.print</a>,
<a href=\"modelica://ModelicaReference.Operators.string\">String</a>
</p>
</html>"));
      end error;
      annotation (
        Documentation(info="<HTML>
<h4>Library content</h4>
<p>
Package <b>Streams</b> contains functions to input and output strings
to a message window or on files. Note that a string is interpreted
and displayed as html text (e.g., with print(..) or error(..))
if it is enclosed with the Modelica html quotation, e.g.,
</p>
<center>
string = \"&lt;html&gt; first line &lt;br&gt; second line &lt;/html&gt;\".
</center>
<p>
It is a quality of implementation, whether (a) all tags of html are supported
or only a subset, (b) how html tags are interpreted if the output device
does not allow to display formatted text.
</p>
<p>
In the table below an example call to every function is given:
</p>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><th><b><i>Function/type</i></b></th><th><b><i>Description</i></b></th></tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Utilities.Streams.print\">print</a>(string)<br>
          <a href=\"modelica://Modelica.Utilities.Streams.print\">print</a>(string,fileName)</td>
      <td valign=\"top\"> Print string \"string\" or vector of strings to message window or on
           file \"fileName\".</td>
  </tr>
  <tr><td valign=\"top\">stringVector =
         <a href=\"modelica://Modelica.Utilities.Streams.readFile\">readFile</a>(fileName)</td>
      <td valign=\"top\"> Read complete text file and return it as a vector of strings.</td>
  </tr>
  <tr><td valign=\"top\">(string, endOfFile) =
         <a href=\"modelica://Modelica.Utilities.Streams.readLine\">readLine</a>(fileName, lineNumber)</td>
      <td valign=\"top\">Returns from the file the content of line lineNumber.</td>
  </tr>
  <tr><td valign=\"top\">lines =
         <a href=\"modelica://Modelica.Utilities.Streams.countLines\">countLines</a>(fileName)</td>
      <td valign=\"top\">Returns the number of lines in a file.</td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Utilities.Streams.error\">error</a>(string)</td>
      <td valign=\"top\"> Print error message \"string\" to message window
           and cancel all actions</td>
  </tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Utilities.Streams.close\">close</a>(fileName)</td>
      <td valign=\"top\"> Close file if it is still open. Ignore call if
           file is already closed or does not exist. </td>
  </tr>
</table>
<p>
Use functions <b>scanXXX</b> from package
<a href=\"modelica://Modelica.Utilities.Strings\">Strings</a>
to parse a string.
</p>
<p>
If Real, Integer or Boolean values shall be printed
or used in an error message, they have to be first converted
to strings with the builtin operator
<a href=\"modelica://ModelicaReference.Operators.string\">String</a>(...).
Example:
</p>
<pre>
  <b>if</b> x &lt; 0 <b>or</b> x &gt; 1 <b>then</b>
     Streams.error(\"x (= \" + String(x) + \") has to be in the range 0 .. 1\");
  <b>end if</b>;
</pre>
</HTML>
"));
    end Streams;

    package Strings "Operations on strings"
      extends Modelica.Icons.Package;

      function length "Returns length of string"
        extends Modelica.Icons.Function;
        input String string;
        output Integer result "Number of characters of string";
      external "C" result = ModelicaStrings_length(string);
        annotation (Library="ModelicaExternalC", Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Strings.<b>length</b>(string);
</pre></blockquote>
<h4>Description</h4>
<p>
Returns the number of characters of \"string\".
</p>
</html>"));
      end length;

      function substring "Returns a substring defined by start and end index"

        extends Modelica.Icons.Function;
        input String string "String from which a substring is inquired";
        input Integer startIndex(min=1)
        "Character position of substring begin (index=1 is first character in string)";
        input Integer endIndex(min=1) "Character position of substring end";
        output String result
        "String containing substring string[startIndex:endIndex]";
      external "C" result =
                          ModelicaStrings_substring(string,startIndex,endIndex);
        annotation (Library="ModelicaExternalC",
      Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
string2 = Strings.<b>substring</b>(string, startIndex, endIndex);
</pre></blockquote>
<h4>Description</h4>
<p>
This function returns
the substring from position startIndex
up to and including position endIndex of \"string\" .
</p>
<p>
If index, startIndex, or endIndex are not correct, e.g.,
if endIndex &gt; length(string), an assert is triggered.
</p>
<h4>Example</h4>
<blockquote><pre>
  string1 := \"This is line 111\";
  string2 := Strings.substring(string1,9,12); // string2 = \"line\"
</pre></blockquote>
</html>"));
      end substring;

      function compare "Compare two strings lexicographically"
        extends Modelica.Icons.Function;
        input String string1;
        input String string2;
        input Boolean caseSensitive=true
        "= false, if case of letters is ignored";
        output Modelica.Utilities.Types.Compare result "Result of comparison";
      external "C" result = ModelicaStrings_compare(string1, string2, caseSensitive);
        annotation (Library="ModelicaExternalC", Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
result = Strings.<b>compare</b>(string1, string2);
result = Strings.<b>compare</b>(string1, string2, caseSensitive=true);
</pre></blockquote>
<h4>Description</h4>
<p>
Compares two strings. If the optional argument caseSensitive=false,
upper case letters are treated as if they would be lower case letters.
The result of the comparison is returned as:
</p>
<pre>
  result = Modelica.Utilities.Types.Compare.Less     // string1 &lt; string2
         = Modelica.Utilities.Types.Compare.Equal    // string1 = string2
         = Modelica.Utilities.Types.Compare.Greater  // string1 &gt; string2
</pre>
<p>
Comparison is with regards to lexicographical order,
e.g., \"a\" &lt; \"b\";
</p>
</html>"));
      end compare;

      function isEqual "Determine whether two strings are identical"
        extends Modelica.Icons.Function;
        input String string1;
        input String string2;
        input Boolean caseSensitive=true
        "= false, if lower and upper case are ignored for the comparison";
        output Boolean identical "True, if string1 is identical to string2";
      algorithm
        identical :=compare(string1, string2, caseSensitive) == Types.Compare.Equal;
        annotation (
      Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Strings.<b>isEqual</b>(string1, string2);
Strings.<b>isEqual</b>(string1, string2, caseSensitive=true);
</pre></blockquote>
<h4>Description</h4>
<p>
Compare whether two strings are identical,
optionally ignoring case.
</p>
</html>"));
      end isEqual;

      function find "Find first occurrence of a string within another string"
        extends Modelica.Icons.Function;
        input String string "String that is analyzed";
        input String searchString "String that is searched for in string";
        input Integer startIndex(min=1)=1 "Start search at index startIndex";
        input Boolean caseSensitive=true
        "= false, if lower and upper case are ignored for the search";
         output Integer index
        "Index of the beginning of the first occurrence of 'searchString' within 'string', or zero if not present";
    protected
        Integer lengthSearchString = length(searchString);
        Integer len = lengthSearchString-1;
        Integer i = startIndex;
        Integer i_max = length(string) - lengthSearchString + 1;
      algorithm
        index := 0;
        while i <= i_max loop
           if isEqual(substring(string,i,i+len),
                      searchString, caseSensitive) then
              index := i;
              i := i_max + 1;
           else
              i := i+1;
           end if;
        end while;
        annotation (
      Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
index = Strings.<b>find</b>(string, searchString);
index = Strings.<b>find</b>(string, searchString, startIndex=1,
                     caseSensitive=true);
</pre></blockquote>
<h4>Description</h4>
<p>
Finds first occurence of \"searchString\" within \"string\"
and return the corresponding index.
Start search at index \"startIndex\" (default = 1).
If the optional argument \"caseSensitive\" is false, lower
and upper case are ignored for the search.
If \"searchString\" is not found, a value of \"0\" is returned.
</p>
</html>
"));
      end find;

      package Advanced "Advanced scanning functions"

        function scanReal "Scans a signed real number"
          extends Modelica.Icons.Function;
          input String string;
          input Integer startIndex(min=1)=1 "Index where scanning starts";
          input Boolean unsigned=false
          "= true, if number shall not start with '+' or '-'";
          output Integer nextIndex
          "Index after the found token (success=true) or index at which scanning failed (success=false)";
          output Real number "Value of Real number";
          external "C" ModelicaStrings_scanReal(string, startIndex, unsigned, nextIndex, number);
          annotation (Library="ModelicaExternalC",Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(nextIndex, realNumber) = <b>scanReal</b>(string, startIndex=1, unsigned=false);
</pre></blockquote>
<h4>Description</h4>
<p>
Starts scanning of \"string\" at position \"startIndex\".
First skips white space and scans afterwards a number
of type Real with an optional sign according to the Modelica grammar:
</p>
<pre>
    real     ::= [sign] unsigned [fraction] [exponent]
    sign     ::= '+' | '-'
    unsigned ::= digit [unsigned]
    fraction ::= '.' [unsigned]
    exponent ::= ('e' | 'E') [sign] unsigned
    digit    ::= '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
</pre>
<p>
If successful, the function returns nextIndex = index of character
directly after the found real number, as well as the value
in the second output argument.
</p>
<p>
If not successful, on return nextIndex = startIndex and
the second output argument is zero.
</p>
<p>
If the optional argument \"unsigned\" is <b>true</b>, the number
shall not start with '+' or '-'. The default of \"unsigned\" is <b>false</b>.
</p>
<h4>See also</h4>
<a href=\"modelica://Modelica.Utilities.Strings.Advanced\">Strings.Advanced</a>.
</html>
"));
        end scanReal;
        annotation (Documentation(info="<html>
<h4>Library content</h4>
<p>
Package <b>Strings.Advanced</b> contains basic scanning
functions. These functions should be <b>not called</b> directly, because
it is much simpler to utilize the higher level functions \"Strings.scanXXX\".
The functions of the \"Strings.Advanced\" library provide
the basic interface in order to implement the higher level
functions in package \"Strings\".
</p>
<p>
Library \"Advanced\" provides the following functions:
</p>
<pre>
  (nextIndex, realNumber)    = <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanReal\">scanReal</a>        (string, startIndex, unsigned=false);
  (nextIndex, integerNumber) = <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanInteger\">scanInteger</a>     (string, startIndex, unsigned=false);
  (nextIndex, string2)       = <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanString\">scanString</a>      (string, startIndex);
  (nextIndex, identifier)    = <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanIdentifier\">scanIdentifier</a>  (string, startIndex);
   nextIndex                 = <a href=\"modelica://Modelica.Utilities.Strings.Advanced.skipWhiteSpace\">skipWhiteSpace</a>  (string, startIndex);
   nextIndex                 = <a href=\"modelica://Modelica.Utilities.Strings.Advanced.skipLineComments\">skipLineComments</a>(string, startIndex);
</pre>
<p>
All functions perform the following actions:
</p>
<ol>
<li> Scanning starts at character position \"startIndex\" of
     \"string\" (startIndex has a default of 1).
<li> First, white space is skipped, such as blanks (\" \"), tabs (\"\\t\"), or newline (\"\\n\")</li>
<li> Afterwards, the required token is scanned.</li>
<li> If successful, on return nextIndex = index of character
     directly after the found token and the token value is returned
     as second output argument.<br>
     If not successful, on return nextIndex = startIndex.
     </li>
</ol>
<p>
The following additional rules apply for the scanning:
</p>
<ul>
<li> Function <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanReal\">scanReal</a>:<br>
     Scans a full number including one optional leading \"+\" or \"-\" (if unsigned=false)
     according to the Modelica grammar. For example, \"+1.23e-5\", \"0.123\" are
     Real numbers, but \".1\" is not.
     Note, an Integer number, such as \"123\" is also treated as a Real number.<br>&nbsp;</li>
<li> Function <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanInteger\">scanInteger</a>:<br>
     Scans an Integer number including one optional leading \"+\"
     or \"-\" (if unsigned=false) according to the Modelica (and C/C++) grammar.
     For example, \"+123\", \"20\" are Integer numbers.
     Note, a Real number, such as \"123.4\" is not an Integer and
     scanInteger returns nextIndex = startIndex.<br>&nbsp;</li>
<li> Function <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanString\">scanString</a>:<br>
     Scans a String according to the Modelica (and C/C++) grammar, e.g.,
     \"This is a \"string\"\" is a valid string token.<br>&nbsp;</li>
<li> Function <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanIdentifier\">scanIdentifier</a>:<br>
     Scans a Modelica identifier, i.e., the identifier starts either
     with a letter, followed by letters, digits or \"_\".
     For example, \"w_rel\", \"T12\".<br>&nbsp;</li>
<li> Function <a href=\"modelica://Modelica.Utilities.Strings.Advanced.skipLineComments\">skipLineComments</a><br>
     Skips white space and Modelica (C/C++) line comments iteratively.
     A line comment starts with \"//\" and ends either with an
     end-of-line (\"\\n\") or the end of the \"string\". </li>
</ul>
</html>
"));
      end Advanced;
      annotation (
        Documentation(info="<HTML>
<h4>Library content</h4>
<p>
Package <b>Strings</b> contains functions to manipulate strings.
</p>
<p>
In the table below an example
call to every function is given using the <b>default</b> options.
</p>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><th><b><i>Function</i></b></th><th><b><i>Description</i></b></th></tr>
  <tr><td valign=\"top\">len = <a href=\"modelica://Modelica.Utilities.Strings.length\">length</a>(string)</td>
      <td valign=\"top\">Returns length of string</td></tr>
  <tr><td valign=\"top\">string2 = <a href=\"modelica://Modelica.Utilities.Strings.substring\">substring</a>(string1,startIndex,endIndex)
       </td>
      <td valign=\"top\">Returns a substring defined by start and end index</td></tr>
  <tr><td valign=\"top\">result = <a href=\"modelica://Modelica.Utilities.Strings.repeat\">repeat</a>(n)<br>
 result = <a href=\"modelica://Modelica.Utilities.Strings.repeat\">repeat</a>(n,string)</td>
      <td valign=\"top\">Repeat a blank or a string n times.</td></tr>
  <tr><td valign=\"top\">result = <a href=\"modelica://Modelica.Utilities.Strings.compare\">compare</a>(string1, string2)</td>
      <td valign=\"top\">Compares two substrings with regards to alphabetical order</td></tr>
  <tr><td valign=\"top\">identical =
<a href=\"modelica://Modelica.Utilities.Strings.isEqual\">isEqual</a>(string1,string2)</td>
      <td valign=\"top\">Determine whether two strings are identical</td></tr>
  <tr><td valign=\"top\">result = <a href=\"modelica://Modelica.Utilities.Strings.count\">count</a>(string,searchString)</td>
      <td valign=\"top\">Count the number of occurrences of a string</td></tr>
  <tr>
<td valign=\"top\">index = <a href=\"modelica://Modelica.Utilities.Strings.find\">find</a>(string,searchString)</td>
      <td valign=\"top\">Find first occurrence of a string in another string</td></tr>
<tr>
<td valign=\"top\">index = <a href=\"modelica://Modelica.Utilities.Strings.findLast\">findLast</a>(string,searchString)</td>
      <td valign=\"top\">Find last occurrence of a string in another string</td></tr>
  <tr><td valign=\"top\">string2 = <a href=\"modelica://Modelica.Utilities.Strings.replace\">replace</a>(string,searchString,replaceString)</td>
      <td valign=\"top\">Replace one or all occurrences of a string</td></tr>
  <tr><td valign=\"top\">stringVector2 = <a href=\"modelica://Modelica.Utilities.Strings.sort\">sort</a>(stringVector1)</td>
      <td valign=\"top\">Sort vector of strings in alphabetic order</td></tr>
  <tr><td valign=\"top\">(token, index) = <a href=\"modelica://Modelica.Utilities.Strings.scanToken\">scanToken</a>(string,startIndex)</td>
      <td valign=\"top\">Scan for a token (Real/Integer/Boolean/String/Identifier/Delimiter/NoToken)</td></tr>
  <tr><td valign=\"top\">(number, index) = <a href=\"modelica://Modelica.Utilities.Strings.scanReal\">scanReal</a>(string,startIndex)</td>
      <td valign=\"top\">Scan for a Real constant</td></tr>
  <tr><td valign=\"top\">(number, index) = <a href=\"modelica://Modelica.Utilities.Strings.scanInteger\">scanInteger</a>(string,startIndex)</td>
      <td valign=\"top\">Scan for an Integer constant</td></tr>
  <tr><td valign=\"top\">(boolean, index) = <a href=\"modelica://Modelica.Utilities.Strings.scanBoolean\">scanBoolean</a>(string,startIndex)</td>
      <td valign=\"top\">Scan for a Boolean constant</td></tr>
  <tr><td valign=\"top\">(string2, index) = <a href=\"modelica://Modelica.Utilities.Strings.scanString\">scanString</a>(string,startIndex)</td>
      <td valign=\"top\">Scan for a String constant</td></tr>
  <tr><td valign=\"top\">(identifier, index) = <a href=\"modelica://Modelica.Utilities.Strings.scanIdentifier\">scanIdentifier</a>(string,startIndex)</td>
      <td valign=\"top\">Scan for an identifier</td></tr>
  <tr><td valign=\"top\">(delimiter, index) = <a href=\"modelica://Modelica.Utilities.Strings.scanDelimiter\">scanDelimiter</a>(string,startIndex)</td>
      <td valign=\"top\">Scan for delimiters</td></tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Utilities.Strings.scanNoToken\">scanNoToken</a>(string,startIndex)</td>
      <td valign=\"top\">Check that remaining part of string consists solely of <br>
          white space or line comments (\"// ...\\n\").</td></tr>
  <tr><td valign=\"top\"><a href=\"modelica://Modelica.Utilities.Strings.syntaxError\">syntaxError</a>(string,index,message)</td>
      <td valign=\"top\"> Print a \"syntax error message\" as well as a string and the <br>
           index at which scanning detected an error</td></tr>
</table>
<p>
The functions \"compare\", \"isEqual\", \"count\", \"find\", \"findLast\", \"replace\", \"sort\"
have the optional
input argument <b>caseSensitive</b> with default <b>true</b>.
If <b>false</b>, the operation is carried out without taking
into account whether a character is upper or lower case.
</p>
</HTML>"));
    end Strings;

    package Types "Type definitions used in package Modelica.Utilities"
      extends Modelica.Icons.Package;

      type Compare = enumeration(
        Less "String 1 is lexicographically less than string 2",
        Equal "String 1 is identical to string 2",
        Greater "String 1 is lexicographically greater than string 2")
      "Enumeration defining comparision of two strings";
      annotation (Documentation(info="<html>
<p>
This package contains type definitions used in Modelica.Utilities.
</p>

</html>"));
    end Types;
      annotation (
  Documentation(info="<html>
<p>
This package contains Modelica <b>functions</b> that are
especially suited for <b>scripting</b>. The functions might
be used to work with strings, read data from file, write data
to file or copy, move and remove files.
</p>
<p>
For an introduction, have especially a look at:
</p>
<ul>
<li> <a href=\"modelica://Modelica.Utilities.UsersGuide\">Modelica.Utilities.User's Guide</a>
     discusses the most important aspects of this library.</li>
<li> <a href=\"modelica://Modelica.Utilities.Examples\">Modelica.Utilities.Examples</a>
     contains examples that demonstrate the usage of this library.</li>
</ul>
<p>
The following main sublibraries are available:
</p>
<ul>
<li> <a href=\"modelica://Modelica.Utilities.Files\">Files</a>
     provides functions to operate on files and directories, e.g.,
     to copy, move, remove files.</li>
<li> <a href=\"modelica://Modelica.Utilities.Streams\">Streams</a>
     provides functions to read from files and write to files.</li>
<li> <a href=\"modelica://Modelica.Utilities.Strings\">Strings</a>
     provides functions to operate on strings. E.g.
     substring, find, replace, sort, scanToken.</li>
<li> <a href=\"modelica://Modelica.Utilities.System\">System</a>
     provides functions to interact with the environment.
     E.g., get or set the working directory or environment
     variables and to send a command to the default shell.</li>
</ul>

<p>
Copyright &copy; 1998-2010, Modelica Association, DLR, and Dassault Syst&egrave;mes AB.
</p>

<p>
<i>This Modelica package is <u>free</u> software and the use is completely at <u>your own risk</u>; it can be redistributed and/or modified under the terms of the Modelica License 2. For license conditions (including the disclaimer of warranty) see <a href=\"modelica://Modelica.UsersGuide.ModelicaLicense2\">Modelica.UsersGuide.ModelicaLicense2</a> or visit <a href=\"http://www.modelica.org/licenses/ModelicaLicense2\"> http://www.modelica.org/licenses/ModelicaLicense2</a>.</i>
</p>

</html>
"));
  end Utilities;

  package Constants
  "Library of mathematical constants and constants of nature (e.g., pi, eps, R, sigma)"
    import SI = Modelica.SIunits;
    import NonSI = Modelica.SIunits.Conversions.NonSIunits;
    extends Modelica.Icons.Package;

    final constant Real pi=2*Modelica.Math.asin(1.0);

    final constant Real eps=1.e-15 "Biggest number such that 1.0 + eps = 1.0";

    final constant Real small=1.e-60
    "Smallest number such that small and -small are representable on the machine";

    final constant Real inf=1.e+60
    "Biggest Real number such that inf and -inf are representable on the machine";

    final constant SI.Acceleration g_n=9.80665
    "Standard acceleration of gravity on earth";

    final constant Real R(final unit="J/(mol.K)") = 8.314472
    "Molar gas constant";

    final constant Real sigma(final unit="W/(m2.K4)") = 5.670400e-8
    "Stefan-Boltzmann constant";

    final constant NonSI.Temperature_degC T_zero=-273.15
    "Absolute zero temperature";
    annotation (
      Documentation(info="<html>
<p>
This package provides often needed constants from mathematics, machine
dependent constants and constants from nature. The latter constants
(name, value, description) are from the following source:
</p>

<dl>
<dt>Peter J. Mohr and Barry N. Taylor (1999):</dt>
<dd><b>CODATA Recommended Values of the Fundamental Physical Constants: 1998</b>.
    Journal of Physical and Chemical Reference Data, Vol. 28, No. 6, 1999 and
    Reviews of Modern Physics, Vol. 72, No. 2, 2000. See also <a href=
\"http://physics.nist.gov/cuu/Constants/\">http://physics.nist.gov/cuu/Constants/</a></dd>
</dl>

<p>CODATA is the Committee on Data for Science and Technology.</p>

<dl>
<dt><b>Main Author:</b></dt>
<dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a><br>
    Deutsches Zentrum f&uuml;r Luft und Raumfahrt e. V. (DLR)<br>
    Oberpfaffenhofen<br>
    Postfach 11 16<br>
    D-82230 We&szlig;ling<br>
    email: <a href=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</a></dd>
</dl>

<p>
Copyright &copy; 1998-2010, Modelica Association and DLR.
</p>
<p>
<i>This Modelica package is <u>free</u> software and the use is completely at <u>your own risk</u>; it can be redistributed and/or modified under the terms of the Modelica License 2. For license conditions (including the disclaimer of warranty) see <a href=\"modelica://Modelica.UsersGuide.ModelicaLicense2\">Modelica.UsersGuide.ModelicaLicense2</a> or visit <a href=\"http://www.modelica.org/licenses/ModelicaLicense2\"> http://www.modelica.org/licenses/ModelicaLicense2</a>.</i>
</p>
</html>
",   revisions="<html>
<ul>
<li><i>Nov 8, 2004</i>
       by <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br>
       Constants updated according to 2002 CODATA values.</li>
<li><i>Dec 9, 1999</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Constants updated according to 1998 CODATA values. Using names, values
       and description text from this source. Included magnetic and
       electric constant.</li>
<li><i>Sep 18, 1999</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Constants eps, inf, small introduced.</li>
<li><i>Nov 15, 1997</i>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Realized.</li>
</ul>
</html>"),
      Invisible=true,
      Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
              100}}), graphics={
          Line(
            points={{-34,-38},{12,-38}},
            color={0,0,0},
            thickness=0.5),
          Line(
            points={{-20,-38},{-24,-48},{-28,-56},{-34,-64}},
            color={0,0,0},
            thickness=0.5),
          Line(
            points={{-2,-38},{2,-46},{8,-56},{14,-64}},
            color={0,0,0},
            thickness=0.5)}),
      Diagram(graphics={
          Rectangle(
            extent={{200,162},{380,312}},
            fillColor={235,235,235},
            fillPattern=FillPattern.Solid,
            lineColor={0,0,255}),
          Polygon(
            points={{200,312},{220,332},{400,332},{380,312},{200,312}},
            fillColor={235,235,235},
            fillPattern=FillPattern.Solid,
            lineColor={0,0,255}),
          Polygon(
            points={{400,332},{400,182},{380,162},{380,312},{400,332}},
            fillColor={235,235,235},
            fillPattern=FillPattern.Solid,
            lineColor={0,0,255}),
          Text(
            extent={{210,302},{370,272}},
            lineColor={160,160,164},
            textString="Library"),
          Line(
            points={{266,224},{312,224}},
            color={0,0,0},
            thickness=1),
          Line(
            points={{280,224},{276,214},{272,206},{266,198}},
            color={0,0,0},
            thickness=1),
          Line(
            points={{298,224},{302,216},{308,206},{314,198}},
            color={0,0,0},
            thickness=1),
          Text(
            extent={{152,412},{458,334}},
            lineColor={255,0,0},
            textString="Modelica.Constants")}));
  end Constants;

  package Icons "Library of icons"
    extends Icons.Package;

    partial package ExamplesPackage
    "Icon for packages containing runnable examples"
    //extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={Rectangle(
              extent={{-80,100},{100,-80}},
              lineColor={0,0,0},
              fillColor={215,230,240},
              fillPattern=FillPattern.Solid), Rectangle(
              extent={{-100,80},{80,-100}},
              lineColor={0,0,0},
              fillColor={240,240,240},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{-58,46},{42,-14},{-58,-74},{-58,46}},
              lineColor={0,0,255},
              pattern=LinePattern.None,
              fillColor={95,95,95},
              fillPattern=FillPattern.Solid)}), Documentation(info="<html>
<p>This icon indicates a package that contains executable examples.</p>
</html>"));
    end ExamplesPackage;

    partial model Example "Icon for runnable examples"

      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={Ellipse(extent={{-100,100},{100,-100}},
                lineColor={95,95,95},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
                                       Polygon(
              points={{-36,60},{64,0},{-36,-60},{-36,60}},
              lineColor={0,0,255},
              pattern=LinePattern.None,
              fillColor={95,95,95},
              fillPattern=FillPattern.Solid)}), Documentation(info="<html>
<p>This icon indicates an example. The play button suggests that the example can be executed.</p>
</html>"));
    end Example;

    partial package Package "Icon for standard packages"

      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={Rectangle(
              extent={{-80,100},{100,-80}},
              lineColor={0,0,0},
              fillColor={215,230,240},
              fillPattern=FillPattern.Solid), Rectangle(
              extent={{-100,80},{80,-100}},
              lineColor={0,0,0},
              fillColor={240,240,240},
              fillPattern=FillPattern.Solid)}),
                                Documentation(info="<html>
<p>Standard package icon.</p>
</html>"));
    end Package;

    partial package BasesPackage "Icon for packages containing base classes"
    //extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={Rectangle(
              extent={{-80,100},{100,-80}},
              lineColor={0,0,0},
              fillColor={215,230,240},
              fillPattern=FillPattern.Solid), Rectangle(
              extent={{-100,80},{80,-100}},
              lineColor={0,0,0},
              fillColor={240,240,240},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{-30,10},{10,-30}},
              lineColor={0,0,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid)}),
                                Documentation(info="<html>
<p>This icon shall be used for a package/library that contains base models and classes, respectively.</p>
</html>"));
    end BasesPackage;

    partial package VariantsPackage "Icon for package containing variants"
    //extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},
                {100,100}}),       graphics={Rectangle(
              extent={{-80,100},{100,-80}},
              lineColor={0,0,0},
              fillColor={215,230,240},
              fillPattern=FillPattern.Solid), Rectangle(
              extent={{-100,80},{80,-100}},
              lineColor={0,0,0},
              fillColor={240,240,240},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{-80,-20},{-20,-80}},
              lineColor={0,0,0},
              fillColor={135,135,135},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{0,-20},{60,-80}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{0,60},{60,0}},
              lineColor={0,0,0},
              fillColor={175,175,175},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{-80,60},{-20,0}},
              lineColor={0,0,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid)}),
                                Documentation(info="<html>
<p>This icon shall be used for a package/library that contains several variants of one components.</p>
</html>"));
    end VariantsPackage;

    partial package InterfacesPackage "Icon for packages containing interfaces"
    //extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={Rectangle(
              extent={{-80,100},{100,-80}},
              lineColor={0,0,0},
              fillColor={215,230,240},
              fillPattern=FillPattern.Solid), Rectangle(
              extent={{-100,80},{80,-100}},
              lineColor={0,0,0},
              fillColor={240,240,240},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{0,50},{20,50},{50,10},{80,10},{80,-30},{50,-30},{20,-70},{
                  0,-70},{0,50}},
              lineColor={0,0,0},
              smooth=Smooth.None,
              fillColor={215,215,215},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{-100,10},{-70,10},{-40,50},{-20,50},{-20,-70},{-40,-70},{
                  -70,-30},{-100,-30},{-100,10}},
              lineColor={0,0,0},
              smooth=Smooth.None,
              fillColor={215,230,240},
              fillPattern=FillPattern.Solid)}),
                                Documentation(info="<html>
<p>This icon indicates packages containing interfaces.</p>
</html>"));
    end InterfacesPackage;

    partial package SourcesPackage "Icon for packages containing sources"
    //extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={Rectangle(
              extent={{-80,100},{100,-80}},
              lineColor={0,0,0},
              fillColor={215,230,240},
              fillPattern=FillPattern.Solid), Rectangle(
              extent={{-100,80},{80,-100}},
              lineColor={0,0,0},
              fillColor={240,240,240},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{-28,12},{-28,-40},{36,-14},{-28,12}},
              lineColor={0,0,0},
              smooth=Smooth.None,
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Line(
              points={{-28,-14},{-68,-14}},
              color={0,0,0},
              smooth=Smooth.None)}),
                                Documentation(info="<html>
<p>This icon indicates a package which contains sources.</p>
</html>"));
    end SourcesPackage;

    partial package SensorsPackage "Icon for packages containing sensors"
    //extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={Rectangle(
              extent={{-80,100},{100,-80}},
              lineColor={0,0,0},
              fillColor={215,230,240},
              fillPattern=FillPattern.Solid), Rectangle(
              extent={{-100,80},{80,-100}},
              lineColor={0,0,0},
              fillColor={240,240,240},
              fillPattern=FillPattern.Solid),
            Line(
              points={{-70,20},{50,20}},
              color={0,0,0},
              smooth=Smooth.None),
            Line(points={{-10,-70},{38,54}}, color={0,0,0}),
            Ellipse(
              extent={{-15,-65},{-5,-75}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Line(
              points={{-70,20},{-70,-8}},
              color={0,0,0},
              smooth=Smooth.None),
            Line(
              points={{50,20},{50,-8}},
              color={0,0,0},
              smooth=Smooth.None),
            Line(
              points={{-10,20},{-10,-8}},
              color={0,0,0},
              smooth=Smooth.None)}),
                                Documentation(info="<html>
<p>This icon indicates a package containing sensors.</p>
</html>"));
    end SensorsPackage;

    partial class RotationalSensor
    "Icon representing a round measurement device"

      annotation (
        Icon(coordinateSystem(
            preserveAspectRatio=false,
            extent={{-100,-100},{100,100}},
            grid={1,1}), graphics={
            Ellipse(
              extent={{-70,70},{70,-70}},
              lineColor={0,0,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Line(points={{0,70},{0,40}}, color={0,0,0}),
            Line(points={{22.9,32.8},{40.2,57.3}}, color={0,0,0}),
            Line(points={{-22.9,32.8},{-40.2,57.3}}, color={0,0,0}),
            Line(points={{37.6,13.7},{65.8,23.9}}, color={0,0,0}),
            Line(points={{-37.6,13.7},{-65.8,23.9}}, color={0,0,0}),
            Line(points={{0,0},{9.02,28.6}}, color={0,0,0}),
            Polygon(
              points={{-0.48,31.6},{18,26},{18,57.2},{-0.48,31.6}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{-5,5},{5,-5}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid)}),
        Diagram(coordinateSystem(
            preserveAspectRatio=false,
            extent={{-100,-100},{100,100}},
            grid={1,1}), graphics),
        Documentation(info="<html>
<p>
This icon is designed for a <b>rotational sensor</b> model.
</p>
</html>"));
    end RotationalSensor;

    partial class TranslationalSensor
    "Icon representing a linear measurement device"

      annotation (
        Icon(coordinateSystem(
            preserveAspectRatio=false,
            extent={{-100,-100},{100,100}},
            grid={1,1}), graphics={
            Rectangle(
              extent={{-70,-60},{70,20}},
              lineColor={0,0,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{0,-40},{-10,-16},{10,-16},{0,-40}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Line(points={{0,0},{0,-16}}, color={0,0,0}),
            Line(points={{-70,0},{0,0}}, color={0,0,0}),
            Line(points={{-50,-40},{-50,-60}}, color={0,0,0}),
            Line(points={{-30,-40},{-30,-60}}, color={0,0,0}),
            Line(points={{-10,-40},{-10,-60}}, color={0,0,0}),
            Line(points={{10,-40},{10,-60}}, color={0,0,0}),
            Line(points={{30,-40},{30,-60}}, color={0,0,0}),
            Line(points={{50,-40},{50,-60}}, color={0,0,0})}),
        Diagram(coordinateSystem(
            preserveAspectRatio=false,
            extent={{-100,-100},{100,100}},
            grid={1,1}), graphics),
        Documentation(Error, info="<html>
<p>
This icon is designed for a <b>translational sensor</b> model.
</p></html>"));
    end TranslationalSensor;

    partial package MaterialPropertiesPackage
    "Icon for package containing property classes"
    //extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={Rectangle(
              extent={{-80,100},{100,-80}},
              lineColor={0,0,0},
              fillColor={215,230,240},
              fillPattern=FillPattern.Solid), Rectangle(
              extent={{-100,80},{80,-100}},
              lineColor={0,0,0},
              fillColor={240,240,240},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{-68,50},{52,-70}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={215,230,240})}),
                                Documentation(info="<html>
<p>This icon indicates a package that contains properties</p>
</html>"));
    end MaterialPropertiesPackage;

    partial function Function "Icon for functions"

      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={
            Text(extent={{-140,162},{136,102}}, textString=
                                                   "%name"),
            Ellipse(
              extent={{-100,100},{100,-100}},
              lineColor={255,127,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-100,100},{100,-100}},
              lineColor={255,127,0},
              textString=
                   "f")}),Documentation(Error, info="<html>
<p>This icon indicates Modelica functions.</p>
</html>"));
    end Function;

    partial record Record "Icon for records"

      annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                -100},{100,100}}), graphics={
            Rectangle(
              extent={{-100,50},{100,-100}},
              fillColor={255,255,127},
              fillPattern=FillPattern.Solid,
              lineColor={0,0,255}),
            Text(
              extent={{-127,115},{127,55}},
              textString="%name",
              lineColor={0,0,255}),
            Line(points={{-100,-50},{100,-50}}, color={0,0,0}),
            Line(points={{-100,0},{100,0}}, color={0,0,0}),
            Line(points={{0,50},{0,-100}}, color={0,0,0})}),
                                                          Documentation(info="<html>
<p>
This icon is indicates a record.
</p>
</html>"));
    end Record;

    connector SignalBus "Icon for signal bus"

      annotation (
        Icon(coordinateSystem(
            preserveAspectRatio=false,
            extent={{-100,-100},{100,100}},
            grid={2,2},
            initialScale=0.2), graphics={
            Rectangle(
              extent={{-20,2},{20,-2}},
              lineColor={255,204,51},
              lineThickness=0.5),
            Polygon(
              points={{-80,50},{80,50},{100,30},{80,-40},{60,-50},{-60,-50},{-80,
                  -40},{-100,30},{-80,50}},
              lineColor={0,0,0},
              fillColor={255,204,51},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{-65,25},{-55,15}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{-5,25},{5,15}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{55,25},{65,15}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{-35,-15},{-25,-25}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{25,-15},{35,-25}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid)}),
        Diagram(coordinateSystem(
            preserveAspectRatio=false,
            extent={{-100,-100},{100,100}},
            grid={2,2},
            initialScale=0.2), graphics={
            Polygon(
              points={{-40,25},{40,25},{50,15},{40,-20},{30,-25},{-30,-25},{-40,
                  -20},{-50,15},{-40,25}},
              lineColor={0,0,0},
              fillColor={255,204,51},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{-32.5,7.5},{-27.5,12.5}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{-2.5,12.5},{2.5,7.5}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{27.5,12.5},{32.5,7.5}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{-17.5,-7.5},{-12.5,-12.5}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{12.5,-7.5},{17.5,-12.5}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-150,70},{150,40}},
              lineColor={0,0,0},
              textString=
                   "%name")}),
        Documentation(Error, info="<html>
This icon is designed for a <b>signal bus</b> connector.
</html>"));
    end SignalBus;
    annotation(Documentation(__Dymola_DocumentationClass=true, info="<html>
<p>This package contains definitions for the graphical layout of components which may be used in different libraries. The icons can be utilized by inheriting them in the desired class using &quot;extends&quot; or by directly copying the &quot;icon&quot; layer. </p>
<dl>
<dt><b>Main Authors:</b> </dt>
    <dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a></dd><dd>Deutsches Zentrum fuer Luft und Raumfahrt e.V. (DLR)</dd><dd>Oberpfaffenhofen</dd><dd>Postfach 1116</dd><dd>D-82230 Wessling</dd><dd>email: <a href=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</a></dd><br>
    <dd>Christian Kral</dd><dd><a href=\"http://www.ait.ac.at/\">Austrian Institute of Technology, AIT</a></dd><dd>Mobility Department</dd><dd>Giefinggasse 2</dd><dd>1210 Vienna, Austria</dd><dd>email: <a href=\"mailto:christian.kral@ait.ac.at\">christian.kral@ait.ac.at</a></dd><br>
    <dd align=\"justify\">Johan Andreasson</dd><dd align=\"justify\"><a href=\"http://www.modelon.se/\">Modelon AB</a></dd><dd align=\"justify\">Ideon Science Park</dd><dd align=\"justify\">22370 Lund, Sweden</dd><dd align=\"justify\">email: <a href=\"mailto:johan.andreasson@modelon.se\">johan.andreasson@modelon.se</a></dd>
</dl>
<p>Copyright &copy; 1998-2010, Modelica Association, DLR, AIT, and Modelon AB. </p>
<p><i>This Modelica package is <b>free</b> software; it can be redistributed and/or modified under the terms of the <b>Modelica license</b>, see the license conditions and the accompanying <b>disclaimer</b> in <a href=\"modelica://Modelica.UsersGuide.ModelicaLicense2\">Modelica.UsersGuide.ModelicaLicense2</a>.</i> </p>
</html>"));
  end Icons;

  package SIunits
  "Library of type and unit definitions based on SI units according to ISO 31-1992"
    extends Modelica.Icons.Package;

    package Conversions
    "Conversion functions to/from non SI units and type definitions of non SI units"
      extends Modelica.Icons.Package;

      package NonSIunits "Type definitions of non SI units"
        extends Modelica.Icons.Package;

        type Temperature_degC = Real (final quantity="ThermodynamicTemperature",
              final unit="degC")
        "Absolute temperature in degree Celsius (for relative temperature use SIunits.TemperatureDifference)"
                                                                                                            annotation(__Dymola_absoluteValue=true);

        type Angle_deg = Real (final quantity="Angle", final unit="deg")
        "Angle in degree";

        type AngularVelocity_rpm = Real (final quantity="AngularVelocity", final unit=
                   "1/min")
        "Angular velocity in revolutions per minute. Alias unit names that are outside of the SI system: rpm, r/min, rev/min"
          annotation (Documentation(info="<html>
<p>

</html>"));

        type Time_hour = Real (final quantity="Time", final unit="h")
        "Time in hours";

        type Pressure_bar = Real (final quantity="Pressure", final unit="bar")
        "Absolute pressure in bar";
        annotation (Documentation(info="<HTML>
<p>
This package provides predefined types, such as <b>Angle_deg</b> (angle in
degree), <b>AngularVelocity_rpm</b> (angular velocity in revolutions per
minute) or <b>Temperature_degF</b> (temperature in degree Fahrenheit),
which are in common use but are not part of the international standard on
units according to ISO 31-1992 \"General principles concerning quantities,
units and symbols\" and ISO 1000-1992 \"SI units and recommendations for
the use of their multiples and of certain other units\".</p>
<p>If possible, the types in this package should not be used. Use instead
types of package Modelica.SIunits. For more information on units, see also
the book of Francois Cardarelli <b>Scientific Unit Conversion - A
Practical Guide to Metrication</b> (Springer 1997).</p>
<p>Some units, such as <b>Temperature_degC/Temp_C</b> are both defined in
Modelica.SIunits and in Modelica.Conversions.NonSIunits. The reason is that these
definitions have been placed erroneously in Modelica.SIunits although they
are not SIunits. For backward compatibility, these type definitions are
still kept in Modelica.SIunits.</p>
</HTML>
"),   Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={Text(
                extent={{-66,-13},{52,-67}},
                lineColor={0,0,0},
                textString="[km/h]")}));
      end NonSIunits;

      function to_degC "Convert from Kelvin to degCelsius"
        extends ConversionIcon;
        input Temperature Kelvin "Kelvin value";
        output NonSIunits.Temperature_degC Celsius "Celsius value";
      algorithm
        Celsius := Kelvin + Modelica.Constants.T_zero;
        annotation (Inline=true,Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Text(
                extent={{-20,100},{-100,20}},
                lineColor={0,0,0},
                textString="K"), Text(
                extent={{100,-20},{20,-100}},
                lineColor={0,0,0},
                textString="degC")}));
      end to_degC;

      function from_degC "Convert from degCelsius to Kelvin"
        extends ConversionIcon;
        input NonSIunits.Temperature_degC Celsius "Celsius value";
        output Temperature Kelvin "Kelvin value";
      algorithm
        Kelvin := Celsius - Modelica.Constants.T_zero;
        annotation (Inline=true,Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Text(
                extent={{-20,100},{-100,20}},
                lineColor={0,0,0},
                textString="degC"),  Text(
                extent={{100,-20},{20,-100}},
                lineColor={0,0,0},
                textString="K")}));
      end from_degC;

      function from_deg "Convert from degree to radian"
        extends ConversionIcon;
        input NonSIunits.Angle_deg degree "degree value";
        output Angle radian "radian value";
      algorithm
        radian := (Modelica.Constants.pi/180.0)*degree;
        annotation (Inline=true,Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Text(
                extent={{4,100},{-102,46}},
                lineColor={0,0,0},
                textString="deg"), Text(
                extent={{100,-32},{-18,-100}},
                lineColor={0,0,0},
                textString="rad")}));
      end from_deg;

      function to_hour "Convert from second to hour"
        extends ConversionIcon;
        input Time s "second value";
        output NonSIunits.Time_hour hour "hour value";
      algorithm
        hour := s/3600;
        annotation (Inline=true,Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Text(
                extent={{12,100},{-100,50}},
                lineColor={0,0,0},
                textString="s"), Text(
                extent={{100,-56},{-20,-100}},
                lineColor={0,0,0},
                textString="hour")}));
      end to_hour;

      function to_bar "Convert from Pascal to bar"
        extends ConversionIcon;
        input Pressure Pa "Pascal value";
        output NonSIunits.Pressure_bar bar "bar value";
      algorithm
        bar := Pa/1e5;
        annotation (Inline=true,Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Text(
                extent={{-12,100},{-100,56}},
                lineColor={0,0,0},
                textString="Pa"),     Text(
                extent={{98,-52},{-4,-100}},
                lineColor={0,0,0},
                textString="bar")}));
      end to_bar;

      partial function ConversionIcon "Base icon for conversion functions"

        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={
              Rectangle(
                extent={{-100,100},{100,-100}},
                lineColor={191,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(points={{-90,0},{30,0}}, color={191,0,0}),
              Polygon(
                points={{90,0},{30,20},{30,-20},{90,0}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-115,155},{115,105}},
                textString="%name",
                lineColor={0,0,255})}));
      end ConversionIcon;
      annotation (Icon(coordinateSystem(preserveAspectRatio=true,
                       extent={{-100,-100},{100,100}}), graphics),
                                Documentation(info="<HTML>
<p>This package provides conversion functions from the non SI Units
defined in package Modelica.SIunits.Conversions.NonSIunits to the
corresponding SI Units defined in package Modelica.SIunits and vice
versa. It is recommended to use these functions in the following
way (note, that all functions have one Real input and one Real output
argument):</p>
<pre>
  <b>import</b> SI = Modelica.SIunits;
  <b>import</b> Modelica.SIunits.Conversions.*;
     ...
  <b>parameter</b> SI.Temperature     T   = from_degC(25);   // convert 25 degree Celsius to Kelvin
  <b>parameter</b> SI.Angle           phi = from_deg(180);   // convert 180 degree to radian
  <b>parameter</b> SI.AngularVelocity w   = from_rpm(3600);  // convert 3600 revolutions per minutes
                                                      // to radian per seconds
</pre>

</HTML>
"));
    end Conversions;

    type Angle = Real (
        final quantity="Angle",
        final unit="rad",
        displayUnit="deg");

    type Length = Real (final quantity="Length", final unit="m");

    type Height = Length(min=0);

    type Area = Real (final quantity="Area", final unit="m2");

    type Volume = Real (final quantity="Volume", final unit="m3");

    type Time = Real (final quantity="Time", final unit="s");

    type Velocity = Real (final quantity="Velocity", final unit="m/s");

    type Acceleration = Real (final quantity="Acceleration", final unit="m/s2");

    type Mass = Real (
        quantity="Mass",
        final unit="kg",
        min=0);

    type Density = Real (
        final quantity="Density",
        final unit="kg/m3",
        displayUnit="g/cm3",
        min=0);

    type Pressure = Real (
        final quantity="Pressure",
        final unit="Pa",
        displayUnit="bar");

    type AbsolutePressure = Pressure (min=0);

    type DynamicViscosity = Real (
        final quantity="DynamicViscosity",
        final unit="Pa.s",
        min=0);

    type SurfaceTension = Real (final quantity="SurfaceTension", final unit="N/m");

    type Energy = Real (final quantity="Energy", final unit="J");

    type Power = Real (final quantity="Power", final unit="W");

    type EnthalpyFlowRate = Real (final quantity="EnthalpyFlowRate", final unit=
            "W");

    type MassFlowRate = Real (quantity="MassFlowRate", final unit="kg/s");

    type VolumeFlowRate = Real (final quantity="VolumeFlowRate", final unit=
            "m3/s");

    type ThermodynamicTemperature = Real (
        final quantity="ThermodynamicTemperature",
        final unit="K",
        min = 0,
        start = 288.15,
        displayUnit="degC")
    "Absolute temperature (use type TemperatureDifference for relative temperatures)"
                                                                                                        annotation(__Dymola_absoluteValue=true);

    type Temp_K = ThermodynamicTemperature;

    type Temperature = ThermodynamicTemperature;

    type TemperatureDifference = Real (
        final quantity="ThermodynamicTemperature",
        final unit="K") annotation(__Dymola_absoluteValue=false);

    type TemperatureSlope = Real (final quantity="TemperatureSlope",
        final unit="K/s");

    type Compressibility = Real (final quantity="Compressibility", final unit=
            "1/Pa");

    type IsothermalCompressibility = Compressibility;

    type HeatFlowRate = Real (final quantity="Power", final unit="W");

    type HeatFlux = Real (final quantity="HeatFlux", final unit="W/m2");

    type ThermalConductivity = Real (final quantity="ThermalConductivity", final unit=
               "W/(m.K)");

    type CoefficientOfHeatTransfer = Real (final quantity=
            "CoefficientOfHeatTransfer", final unit="W/(m2.K)");

    type ThermalResistance = Real (final quantity="ThermalResistance", final unit=
           "K/W");

    type ThermalConductance = Real (final quantity="ThermalConductance", final unit=
               "W/K");

    type HeatCapacity = Real (final quantity="HeatCapacity", final unit="J/K");

    type SpecificHeatCapacity = Real (final quantity="SpecificHeatCapacity",
          final unit="J/(kg.K)");

    type RatioOfSpecificHeatCapacities = Real (final quantity=
            "RatioOfSpecificHeatCapacities", final unit="1");

    type SpecificEntropy = Real (final quantity="SpecificEntropy", final unit=
            "J/(kg.K)");

    type SpecificEnergy = Real (final quantity="SpecificEnergy", final unit=
            "J/kg");

    type SpecificInternalEnergy = SpecificEnergy;

    type SpecificEnthalpy = SpecificEnergy;

    type DerDensityByEnthalpy = Real (final unit="kg.s2/m5");

    type DerDensityByPressure = Real (final unit="s2/m2");

    type DerDensityByTemperature = Real (final unit="kg/(m3.K)");

    type DerEnthalpyByPressure = Real (final unit="J.m.s2/kg2");

    type RadiantPower = Real (final quantity="Power", final unit="W");

    type RadiantEnergyFluenceRate = Real (final quantity=
            "RadiantEnergyFluenceRate", final unit="W/m2");

    type Emissivity = Real (final quantity="Emissivity", final unit="1");

    type ReflectionCoefficient = Real (final quantity="ReflectionCoefficient",
          final unit="1");

    type TransmissionCoefficient = Real (final quantity="TransmissionCoefficient",
            final unit="1");

    type MolarMass = Real (final quantity="MolarMass", final unit="kg/mol",min=0);

    type MolarVolume = Real (final quantity="MolarVolume", final unit="m3/mol", min=0);

    type MassFraction = Real (final quantity="MassFraction", final unit="1");

    type MoleFraction = Real (final quantity="MoleFraction", final unit="1");

    type PrandtlNumber = Real (final quantity="PrandtlNumber", final unit="1");
    annotation (
      Invisible=true,
      Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
              100}}), graphics={Text(
            extent={{-63,-13},{45,-67}},
            lineColor={0,0,0},
            textString="[kg.m2]")}),
      Documentation(info="<html>
<p>This package provides predefined types, such as <i>Mass</i>,
<i>Angle</i>, <i>Time</i>, based on the international standard
on units, e.g.,
</p>

<pre>   <b>type</b> Angle = Real(<b>final</b> quantity = \"Angle\",
                     <b>final</b> unit     = \"rad\",
                     displayUnit    = \"deg\");
</pre>

<p>
as well as conversion functions from non SI-units to SI-units
and vice versa in subpackage
<a href=\"modelica://Modelica.SIunits.Conversions\">Conversions</a>.
</p>

<p>
For an introduction how units are used in the Modelica standard library
with package SIunits, have a look at:
<a href=\"modelica://Modelica.SIunits.UsersGuide.HowToUseSIunits\">How to use SIunits</a>.
</p>

<p>
Copyright &copy; 1998-2010, Modelica Association and DLR.
</p>
<p>
<i>This Modelica package is <u>free</u> software and the use is completely at <u>your own risk</u>; it can be redistributed and/or modified under the terms of the Modelica License 2. For license conditions (including the disclaimer of warranty) see <a href=\"modelica://Modelica.UsersGuide.ModelicaLicense2\">Modelica.UsersGuide.ModelicaLicense2</a> or visit <a href=\"http://www.modelica.org/licenses/ModelicaLicense2\"> http://www.modelica.org/licenses/ModelicaLicense2</a>.</i>
</p>
</html>",   revisions="<html>
<ul>
<li><i>Jan. 27, 2010</i> by Christian Kral:<br/>Added complex units.</li>
<li><i>Dec. 14, 2005</i> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br/>Add User&#39;;s Guide and removed &quot;min&quot; values for Resistance and Conductance.</li>
<li><i>October 21, 2002</i> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a> and <a href=\"http://www.robotic.dlr.de/Christian.Schweiger/\">Christian Schweiger</a>:<br/>Added new package <b>Conversions</b>. Corrected typo <i>Wavelenght</i>.</li>
<li><i>June 6, 2000</i> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br/>Introduced the following new types<br/>type Temperature = ThermodynamicTemperature;<br/>types DerDensityByEnthalpy, DerDensityByPressure, DerDensityByTemperature, DerEnthalpyByPressure, DerEnergyByDensity, DerEnergyByPressure<br/>Attribute &quot;final&quot; removed from min and max values in order that these values can still be changed to narrow the allowed range of values.<br/>Quantity=&quot;Stress&quot; removed from type &quot;Stress&quot;, in order that a type &quot;Stress&quot; can be connected to a type &quot;Pressure&quot;.</li>
<li><i>Oct. 27, 1999</i> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br/>New types due to electrical library: Transconductance, InversePotential, Damping.</li>
<li><i>Sept. 18, 1999</i> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br/>Renamed from SIunit to SIunits. Subpackages expanded, i.e., the SIunits package, does no longer contain subpackages.</li>
<li><i>Aug 12, 1999</i> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br/>Type &quot;Pressure&quot; renamed to &quot;AbsolutePressure&quot; and introduced a new type &quot;Pressure&quot; which does not contain a minimum of zero in order to allow convenient handling of relative pressure. Redefined BulkModulus as an alias to AbsolutePressure instead of Stress, since needed in hydraulics.</li>
<li><i>June 29, 1999</i> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br/>Bug-fix: Double definition of &quot;Compressibility&quot; removed and appropriate &quot;extends Heat&quot; clause introduced in package SolidStatePhysics to incorporate ThermodynamicTemperature.</li>
<li><i>April 8, 1998</i> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a> and Astrid Jaschinski:<br/>Complete ISO 31 chapters realized.</li>
<li><i>Nov. 15, 1997</i> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a> and <a href=\"http://www.control.lth.se/~hubertus/\">Hubertus Tummescheit</a>:<br/>Some chapters realized.</li>
</ul>
</html>"),
      Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
              100}}), graphics={
          Rectangle(
            extent={{169,86},{349,236}},
            fillColor={235,235,235},
            fillPattern=FillPattern.Solid,
            lineColor={0,0,255}),
          Polygon(
            points={{169,236},{189,256},{369,256},{349,236},{169,236}},
            fillColor={235,235,235},
            fillPattern=FillPattern.Solid,
            lineColor={0,0,255}),
          Polygon(
            points={{369,256},{369,106},{349,86},{349,236},{369,256}},
            fillColor={235,235,235},
            fillPattern=FillPattern.Solid,
            lineColor={0,0,255}),
          Text(
            extent={{179,226},{339,196}},
            lineColor={160,160,164},
            textString="Library"),
          Text(
            extent={{206,173},{314,119}},
            lineColor={0,0,0},
            textString="[kg.m2]"),
          Text(
            extent={{163,320},{406,264}},
            lineColor={255,0,0},
            textString="Modelica.SIunits")}));
  end SIunits;
annotation (
preferredView="info",
version="3.2",
versionBuild=8,
versionDate="2010-10-25",
dateModified = "2011-09-05 15:20:00Z",
revisionId="",
uses(Complex(version="1.0"), ModelicaServices(version="1.2")),
conversion(
 noneFromVersion="3.1",
 noneFromVersion="3.0.1",
 noneFromVersion="3.0",
 from(version="2.1", script="modelica://Modelica/Resources/Scripts/Dymola/ConvertModelica_from_2.2.2_to_3.0.mos"),
 from(version="2.2", script="modelica://Modelica/Resources/Scripts/Dymola/ConvertModelica_from_2.2.2_to_3.0.mos"),
 from(version="2.2.1", script="modelica://Modelica/Resources/Scripts/Dymola/ConvertModelica_from_2.2.2_to_3.0.mos"),
 from(version="2.2.2", script="modelica://Modelica/Resources/Scripts/Dymola/ConvertModelica_from_2.2.2_to_3.0.mos")),
__Dymola_classOrder={"UsersGuide","Blocks","StateGraph","Electrical","Magnetic","Mechanics","Fluid","Media","Thermal",
      "Math","Utilities","Constants", "Icons", "SIunits"},
Settings(NewStateSelection=true),
Documentation(info="<HTML>
<p>
Package <b>Modelica&reg;</b> is a <b>standardized</b> and <b>free</b> package
that is developed together with the Modelica&reg; language from the
Modelica Association, see
<a href=\"http://www.Modelica.org\">http://www.Modelica.org</a>.
It is also called <b>Modelica Standard Library</b>.
It provides model components in many domains that are based on
standardized interface definitions. Some typical examples are shown
in the next figure:
</p>

<img src=\"modelica://Modelica/Resources/Images/UsersGuide/ModelicaLibraries.png\">

<p>
For an introduction, have especially a look at:
</p>
<ul>
<li> <a href=\"modelica://Modelica.UsersGuide.Overview\">Overview</a>
  provides an overview of the Modelica Standard Library
  inside the <a href=\"modelica://Modelica.UsersGuide\">User's Guide</a>.</li>
<li><a href=\"modelica://Modelica.UsersGuide.ReleaseNotes\">Release Notes</a>
 summarizes the changes of new versions of this package.</li>
<li> <a href=\"modelica://Modelica.UsersGuide.Contact\">Contact</a>
  lists the contributors of the Modelica Standard Library.</li>
<li> The <b>Examples</b> packages in the various libraries, demonstrate
  how to use the components of the corresponding sublibrary.</li>
</ul>

<p>
This version of the Modelica Standard Library consists of
</p>
<ul>
<li> <b>1280</b> models and blocks, and</li>
<li> <b>910</b> functions
</ul>
<p>
that are directly usable (= number of public, non-partial classes).
</p>

<p>
<b>Licensed by the Modelica Association under the Modelica License 2</b><br>
Copyright &copy; 1998-2010, ABB, AIT, T.&nbsp;B&ouml;drich, DLR, Dassault Syst&egrave;mes AB, Fraunhofer, A.Haumer, Modelon,
TU Hamburg-Harburg, Politecnico di Milano.
</p>

<p>
<i>This Modelica package is <u>free</u> software and the use is completely at <u>your own risk</u>; it can be redistributed and/or modified under the terms of the Modelica License 2. For license conditions (including the disclaimer of warranty) see <a href=\"modelica://Modelica.UsersGuide.ModelicaLicense2\">Modelica.UsersGuide.ModelicaLicense2</a> or visit <a href=\"http://www.modelica.org/licenses/ModelicaLicense2\"> http://www.modelica.org/licenses/ModelicaLicense2</a>.</i>
</p>
</HTML>
"));
end Modelica;

package LearnGB

  package VAVReheat
  "Variable air volume flow system with terminal reheat and five thermal zones"
    extends Modelica.Icons.ExamplesPackage;

    model ClosedLoop
    "Variable air volume flow system with terminal reheat and five thermal zones"
      extends Modelica.Icons.Example;
      replaceable package MediumA =
          Buildings.Media.GasesPTDecoupled.MoistAirUnsaturated;
      package MediumW = Buildings.Media.ConstantPropertyLiquidWater
      "Medium model for water";
      constant Real conv=1.2 "Conversion factor for nominal mass flow rate";
      constant Modelica.SIunits.Volume VSou = 556.24
      "Room volume for south perimeter zone and so on";
      constant Modelica.SIunits.Volume VNor = 556.24;
      constant Modelica.SIunits.Volume VCor = 2698;
      constant Modelica.SIunits.Volume VWes = 347.55;
      constant Modelica.SIunits.Volume VEas = 347.55;
      constant Modelica.SIunits.Volume VSouEas = 12.53;
      constant Modelica.SIunits.Volume VSouWes = 12.53;
      constant Modelica.SIunits.Volume VNorEas = 12.53;
      constant Modelica.SIunits.Volume VNorWes = 12.53;
      parameter Modelica.SIunits.MassFlowRate m0_flow_cor=3.493*conv
      "Design mass flow rate core";
      parameter Modelica.SIunits.MassFlowRate m0_flow_sou=0.859*conv
      "Design mass flow rate south perimeter zone";
      parameter Modelica.SIunits.MassFlowRate m0_flow_eas=0.957*conv
      "Design mass flow rate east perimeter zone";
      parameter Modelica.SIunits.MassFlowRate m0_flow_nor=0.743*conv*1.4
      "Design mass flow rate north perimeter zone";
      parameter Modelica.SIunits.MassFlowRate m0_flow_wes=1.121*conv
      "Design mass flow rate west perimeter zone";
      parameter Modelica.SIunits.MassFlowRate m0_flow_souWes=0.03*conv*10
      "Design mass flow rate southwest perimeter zone";
      parameter Modelica.SIunits.MassFlowRate m0_flow_norWes=0.029*conv*10
      "Design mass flow rate northwest perimeter zone";
      parameter Modelica.SIunits.MassFlowRate m0_flow_souEas=0.027*conv*10
      "Design mass flow rate southeast perimeter zone";
      parameter Modelica.SIunits.MassFlowRate m0_flow_norEas=0.026*conv*10
      "Design mass flow rate northeast perimeter zone";
      parameter Modelica.SIunits.MassFlowRate m_flow_nominal=m0_flow_cor +
          m0_flow_sou + m0_flow_eas + m0_flow_nor + m0_flow_wes + m0_flow_souWes +
          m0_flow_souEas + m0_flow_norWes + m0_flow_norEas
      "Nominal mass flow rate";
      parameter Modelica.SIunits.Angle lat=41.98*3.14159/180 "Latitude";
      Buildings.Fluid.Sources.Outside amb(redeclare package Medium = MediumA,
          nPorts=2) "Ambient conditions"
        annotation (Placement(transformation(extent={{-132,12},{-112,32}})));
      Buildings.Fluid.FixedResistances.FixedResistanceDpM fil(
        m_flow_nominal=m_flow_nominal,
        redeclare package Medium = MediumA,
        dp_nominal=200 + 200 + 100,
        from_dp=false,
        linearized=false) "Filter"
        annotation (Placement(transformation(extent={{60,-50},{80,-30}})));
      Buildings.Fluid.HeatExchangers.DryEffectivenessNTU heaCoi(
        redeclare package Medium1 = MediumA,
        redeclare package Medium2 = MediumW,
        m1_flow_nominal=m_flow_nominal,
        allowFlowReversal2=false,
        dp2_nominal=6000,
        m2_flow_nominal=m_flow_nominal*1000*(10 - (-20))/4200/10,
        configuration=Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow,
        Q_flow_nominal=m_flow_nominal*1006*(16.7 - 8.5),
        dp1_nominal=0,
        T_a1_nominal=281.65,
        T_a2_nominal=323.15) "Heating coil"
        annotation (Placement(transformation(extent={{98,-56},{118,-36}})));

      Buildings.Fluid.HeatExchangers.WetCoilCounterFlow cooCoi(
        UA_nominal=m_flow_nominal*1000*15/
            Buildings.Fluid.HeatExchangers.BaseClasses.lmtd(
            T_a1=26.2,
            T_b1=12.8,
            T_a2=6,
            T_b2=16),
        redeclare package Medium1 = MediumW,
        redeclare package Medium2 = MediumA,
        m1_flow_nominal=m_flow_nominal*1000*15/4200/10,
        m2_flow_nominal=m_flow_nominal,
        dp1_nominal=6000,
        dp2_nominal=0) "Cooling coil"
        annotation (Placement(transformation(extent={{210,-36},{190,-56}})));
      Buildings.Fluid.FixedResistances.FixedResistanceDpM dpSupDuc(
        m_flow_nominal=m_flow_nominal,
        dh=1,
        redeclare package Medium = MediumA,
        dp_nominal=20) "Pressure drop for supply duct"
        annotation (Placement(transformation(extent={{420,-50},{440,-30}})));
      Buildings.Fluid.FixedResistances.FixedResistanceDpM dpRetDuc(
        m_flow_nominal=m_flow_nominal,
        use_dh=false,
        dh=1,
        redeclare package Medium = MediumA,
        dp_nominal=20) "Pressure drop for return duct"
        annotation (Placement(transformation(extent={{440,110},{420,130}})));
      Buildings.Fluid.Movers.FlowMachine_y fanSup(
        redeclare package Medium = MediumA,
        tau=60,
        dynamicBalance=true,
        pressure(V_flow={0,m_flow_nominal/1.2*2}, dp={850,0})) "Supply air fan"
        annotation (Placement(transformation(extent={{300,-50},{320,-30}})));
      Buildings.Fluid.Movers.FlowMachine_y fanRet(
        redeclare package Medium = MediumA,
        tau=60,
        dynamicBalance=true,
        pressure(V_flow=m_flow_nominal/1.2*{0,2}, dp=1.5*110*{2,0}))
      "Return air fan"
        annotation (Placement(transformation(extent={{310,110},{290,130}})));
      Buildings.Fluid.Sources.FixedBoundary sinHea(
        redeclare package Medium = MediumW,
        p=300000,
        T=318.15,
        nPorts=1) "Sink for heating coil" annotation (Placement(transformation(
            extent={{-10,-10},{10,10}},
            rotation=90,
            origin={90,-120})));
      Buildings.Fluid.Sources.FixedBoundary sinCoo(
        redeclare package Medium = MediumW,
        p=300000,
        T=285.15,
        nPorts=1) "Sink for cooling coil" annotation (Placement(transformation(
            extent={{-10,-10},{10,10}},
            rotation=90,
            origin={190,-120})));
      Modelica.Blocks.Routing.RealPassThrough TOut(y(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          displayUnit="degC",
          min=0))
        annotation (Placement(transformation(extent={{-300,138},{-280,158}})));
      inner Modelica.Fluid.System system(
        p_ambient(displayUnit="Pa"),
        energyDynamics=Modelica.Fluid.Types.Dynamics.FixedInitial,
        m_flow_small=1E-4*m_flow_nominal)
        annotation (Placement(transformation(extent={{-284,102},{-264,122}})));
      Buildings.Fluid.Sensors.TemperatureTwoPort TSup(redeclare package Medium
        =   MediumA, m_flow_nominal=m_flow_nominal)
        annotation (Placement(transformation(extent={{330,-50},{350,-30}})));
      Modelica.Blocks.Sources.Constant TSupSetHea(y(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          displayUnit="degC",
          min=0), k=273.15 + 10) "Supply air temperature setpoint for heating"
        annotation (Placement(transformation(extent={{-100,-170},{-80,-150}})));
      Buildings.Controls.Continuous.LimPID heaCoiCon(
        yMax=1,
        yMin=0,
        Ti=60,
        Td=60,
        initType=Modelica.Blocks.Types.InitPID.InitialState,
        controllerType=Modelica.Blocks.Types.SimpleController.P)
      "Controller for heating coil"
        annotation (Placement(transformation(extent={{0,-170},{20,-150}})));
      Buildings.Controls.Continuous.LimPID cooCoiCon(
        Ti=60,
        reverseAction=true,
        Td=60,
        initType=Modelica.Blocks.Types.InitPID.InitialState,
        yMax=1,
        yMin=0,
        controllerType=Modelica.Blocks.Types.SimpleController.P)
      "Controller for cooling coil"
        annotation (Placement(transformation(extent={{0,-210},{20,-190}})));
      Buildings.Fluid.Sensors.RelativePressure dpRetFan(redeclare package
        Medium =
            MediumA) "Pressure difference over return fan" annotation (Placement(
            transformation(
            extent={{-10,10},{10,-10}},
            rotation=90,
            origin={320,50})));
      Controls.FanVFD conFanSup(xSet_nominal(displayUnit="Pa") = 410, r_N_min=0.0)
      "Controller for fan"
        annotation (Placement(transformation(extent={{240,0},{260,20}})));
      Buildings.Fluid.Sensors.VolumeFlowRate senSupFlo(redeclare package Medium
        =   MediumA, m_flow_nominal=m_flow_nominal)
      "Sensor for supply fan flow rate"
        annotation (Placement(transformation(extent={{360,-50},{380,-30}})));
      Buildings.Controls.SetPoints.OccupancySchedule occSch(occupancy=3600*{6,19})
      "Occupancy schedule"
        annotation (Placement(transformation(extent={{-318,-220},{-298,-200}})));
      Controls.ModeSelector modeSelector
        annotation (Placement(transformation(extent={{-100,-300},{-80,-280}})));
      Controls.ControlBus controlBus
        annotation (Placement(transformation(extent={{-250,-270},{-230,-250}})));
      Buildings.Fluid.Sensors.TemperatureTwoPort TCoiHeaOut(redeclare package
        Medium =   MediumA, m_flow_nominal=m_flow_nominal)
      "Heating coil outlet temperature"
        annotation (Placement(transformation(extent={{134,-50},{154,-30}})));
      Buildings.Utilities.Math.Min min(nin=9)
      "Computes lowest room temperature"
        annotation (Placement(transformation(extent={{1200,440},{1220,460}})));
      Buildings.Utilities.Math.Average ave(nin=9)
      "Compute average of room temperatures"
        annotation (Placement(transformation(extent={{1200,410},{1220,430}})));
      Buildings.Fluid.Actuators.Valves.TwoWayLinear valCoo(
        redeclare package Medium = MediumW,
        CvData=Buildings.Fluid.Types.CvTypes.OpPoint,
        m_flow_nominal=m_flow_nominal*1000*15/4200/10,
        dp_nominal=6000,
        from_dp=true) "Cooling coil valve" annotation (Placement(transformation(
            extent={{-10,-10},{10,10}},
            rotation=90,
            origin={230,-80})));
      Buildings.Fluid.Sources.FixedBoundary souCoo(
        nPorts=1,
        redeclare package Medium = MediumW,
        p=3E5 + 12000,
        T=285.15) "Source for cooling coil" annotation (Placement(transformation(
            extent={{-10,-10},{10,10}},
            rotation=90,
            origin={230,-120})));
      Controls.Economizer conEco(
        dT=1,
        k=1,
        Ti=60,
        VOut_flow_min=0.3*m_flow_nominal/1.2) "Controller for economizer"
        annotation (Placement(transformation(extent={{-80,140},{-60,160}})));
      Buildings.Fluid.Sensors.TemperatureTwoPort TRet(redeclare package Medium
        =   MediumA, m_flow_nominal=m_flow_nominal)
      "Return air temperature sensor"
        annotation (Placement(transformation(extent={{100,110},{80,130}})));
      Buildings.Fluid.Sensors.TemperatureTwoPort TMix(redeclare package Medium
        =   MediumA, m_flow_nominal=m_flow_nominal)
      "Mixed air temperature sensor"
        annotation (Placement(transformation(extent={{30,-50},{50,-30}})));
      Controls.RoomTemperatureSetpoint TSetRoo
        annotation (Placement(transformation(extent={{-300,-276},{-280,-256}})));
      Buildings.Fluid.Actuators.Valves.TwoWayLinear valHea(
        redeclare package Medium = MediumW,
        CvData=Buildings.Fluid.Types.CvTypes.OpPoint,
        dp_nominal=6000,
        m_flow_nominal=m_flow_nominal*1000*40/4200/10,
        from_dp=true) "Heating coil valve" annotation (Placement(transformation(
            extent={{-10,-10},{10,10}},
            rotation=90,
            origin={130,-80})));
      Buildings.Fluid.Sources.FixedBoundary souHea(
        nPorts=1,
        redeclare package Medium = MediumW,
        p(displayUnit="Pa") = 300000 + 12000,
        T=318.15) "Source for heating coil" annotation (Placement(transformation(
            extent={{-10,-10},{10,10}},
            rotation=90,
            origin={130,-120})));
      Buildings.Fluid.Actuators.Dampers.MixingBox eco(
        redeclare package Medium = MediumA,
        mOut_flow_nominal=m_flow_nominal,
        mRec_flow_nominal=m_flow_nominal,
        mExh_flow_nominal=m_flow_nominal,
        dpOut_nominal=10,
        dpRec_nominal=10,
        dpExh_nominal=10) "Economizer"
        annotation (Placement(transformation(extent={{-40,66},{14,12}})));
      Buildings.Fluid.Sensors.VolumeFlowRate VOut1(redeclare package Medium =
            MediumA, m_flow_nominal=m_flow_nominal)
      "Outside air volume flow rate"
        annotation (Placement(transformation(extent={{-80,12},{-60,32}})));
      Controls.DuctStaticPressureSetpoint pSetDuc(
        controllerType=Modelica.Blocks.Types.SimpleController.PI,
        pMin=50,
        nin=9) "Duct static pressure setpoint"
        annotation (Placement(transformation(extent={{160,0},{180,20}})));
      LearnGB.VAVReheat.ThermalZones.VAVBranch cor(
        redeclare package MediumA = MediumA,
        redeclare package MediumW = MediumW,
        m_flow_nominal=m0_flow_cor,
        VRoo=VCor) "Zone for core of buildings (azimuth will be neglected)"
        annotation (Placement(transformation(extent={{550,4},{618,72}})));
      LearnGB.VAVReheat.ThermalZones.VAVBranch sou(
        redeclare package MediumA = MediumA,
        redeclare package MediumW = MediumW,
        m_flow_nominal=m0_flow_sou,
        VRoo=VSou) "South-facing thermal zone"
        annotation (Placement(transformation(extent={{688,2},{760,74}})));
      LearnGB.VAVReheat.ThermalZones.VAVBranch eas(
        redeclare package MediumA = MediumA,
        redeclare package MediumW = MediumW,
        m_flow_nominal=m0_flow_eas,
        VRoo=VEas) "East-facing thermal zone"
        annotation (Placement(transformation(extent={{826,6},{894,74}})));
      LearnGB.VAVReheat.ThermalZones.VAVBranch nor(
        redeclare package MediumA = MediumA,
        redeclare package MediumW = MediumW,
        m_flow_nominal=m0_flow_nor,
        VRoo=VNor) "North-facing thermal zone"
        annotation (Placement(transformation(extent={{966,6},{1034,74}})));
      LearnGB.VAVReheat.ThermalZones.VAVBranch wes(
        redeclare package MediumA = MediumA,
        redeclare package MediumW = MediumW,
        m_flow_nominal=m0_flow_wes,
        VRoo=VWes) "West-facing thermal zone"
        annotation (Placement(transformation(extent={{1104,6},{1172,74}})));
      Controls.FanVFD conFanRet(xSet_nominal(displayUnit="m3/s") = m_flow_nominal/1.2,
          r_N_min=0.0) "Controller for fan"
        annotation (Placement(transformation(extent={{240,140},{260,160}})));
      Buildings.Fluid.Sensors.VolumeFlowRate senRetFlo(redeclare package Medium
        =   MediumA, m_flow_nominal=m_flow_nominal)
      "Sensor for return fan flow rate"
        annotation (Placement(transformation(extent={{380,110},{360,130}})));
      Buildings.Fluid.FixedResistances.SplitterFixedResistanceDpM splRetRoo1(
        redeclare package Medium = MediumA,
        m_flow_nominal={m_flow_nominal,m_flow_nominal - m0_flow_cor,m0_flow_cor},
        dp_nominal(displayUnit="Pa") = {10,10,10},
        from_dp=false,
        dynamicBalance=true,
        linearized=true) "Splitter for room return"
        annotation (Placement(transformation(extent={{600,130},{620,110}})));
      Buildings.Fluid.FixedResistances.SplitterFixedResistanceDpM splRetSou(
        redeclare package Medium = MediumA,
        dp_nominal(displayUnit="Pa") = {10,10,10},
        from_dp=false,
        dynamicBalance=true,
        linearized=true,
        m_flow_nominal={m0_flow_sou + m0_flow_eas + m0_flow_nor + m0_flow_wes +
            m0_flow_souWes + m0_flow_souEas + m0_flow_norWes + m0_flow_norEas,
            m0_flow_eas + m0_flow_nor + m0_flow_wes + m0_flow_souWes +
            m0_flow_souEas + m0_flow_norWes + m0_flow_norEas,m0_flow_sou})
      "Splitter for room return"
        annotation (Placement(transformation(extent={{738,130},{758,110}})));
      Buildings.Fluid.FixedResistances.SplitterFixedResistanceDpM splRetEas(
        redeclare package Medium = MediumA,
        dp_nominal(displayUnit="Pa") = {10,10,10},
        from_dp=false,
        dynamicBalance=true,
        linearized=true,
        m_flow_nominal={m0_flow_eas + m0_flow_nor + m0_flow_wes + m0_flow_souWes +
            m0_flow_souEas + m0_flow_norWes + m0_flow_norEas,m0_flow_nor +
            m0_flow_wes + m0_flow_souWes + m0_flow_souEas + m0_flow_norWes +
            m0_flow_norEas,m0_flow_eas}) "Splitter for room return"
        annotation (Placement(transformation(extent={{874,130},{894,110}})));
      Buildings.Fluid.FixedResistances.SplitterFixedResistanceDpM splRetNor(
        redeclare package Medium = MediumA,
        m_flow_nominal={m0_flow_nor + m0_flow_wes,m0_flow_wes,m0_flow_nor},
        dp_nominal(displayUnit="Pa") = {10,10,10},
        from_dp=false,
        dynamicBalance=true,
        linearized=true) "Splitter for room return"
        annotation (Placement(transformation(extent={{1014,130},{1034,110}})));
      Buildings.Fluid.FixedResistances.SplitterFixedResistanceDpM splSupRoo1(
        redeclare package Medium = MediumA,
        m_flow_nominal={m_flow_nominal,m_flow_nominal - m0_flow_cor,m0_flow_cor},
        dp_nominal(displayUnit="Pa") = {10,10,10},
        from_dp=true,
        linearized=true) "Splitter for room supply"
        annotation (Placement(transformation(extent={{574,-30},{594,-50}})));
      Buildings.Fluid.FixedResistances.SplitterFixedResistanceDpM splSupSou(
        redeclare package Medium = MediumA,
        dp_nominal(displayUnit="Pa") = {10,10,10},
        from_dp=true,
        linearized=true,
        m_flow_nominal={m_flow_nominal - m0_flow_cor,m0_flow_eas + m0_flow_nor +
            m0_flow_wes + m0_flow_souWes + m0_flow_souEas + m0_flow_norWes +
            m0_flow_norEas,m0_flow_sou}) "Splitter for room supply"
        annotation (Placement(transformation(extent={{714,-30},{734,-50}})));
      Buildings.Fluid.FixedResistances.SplitterFixedResistanceDpM splSupEas(
        redeclare package Medium = MediumA,
        dp_nominal(displayUnit="Pa") = {10,10,10},
        from_dp=true,
        linearized=true,
        m_flow_nominal={m0_flow_eas + m0_flow_nor + m0_flow_wes + m0_flow_souWes +
            m0_flow_souEas + m0_flow_norWes + m0_flow_norEas,m0_flow_nor +
            m0_flow_wes + m0_flow_souWes + m0_flow_souEas + m0_flow_norWes +
            m0_flow_norEas,m0_flow_eas}) "Splitter for room supply"
        annotation (Placement(transformation(extent={{850,-30},{870,-50}})));
      Buildings.Fluid.FixedResistances.SplitterFixedResistanceDpM splSupNor(
        redeclare package Medium = MediumA,
        dp_nominal(displayUnit="Pa") = {10,10,10},
        from_dp=true,
        linearized=true,
        m_flow_nominal={m0_flow_nor + m0_flow_wes + m0_flow_souWes + m0_flow_souEas +
            m0_flow_norWes + m0_flow_norEas,m0_flow_wes + m0_flow_souWes +
            m0_flow_souEas + m0_flow_norWes + m0_flow_norEas,m0_flow_nor})
      "Splitter for room supply"
        annotation (Placement(transformation(extent={{990,-30},{1010,-50}})));
      Controls.CoolingCoilTemperatureSetpoint TSetCoo
      "Setpoint for cooling coil"
        annotation (Placement(transformation(extent={{-50,-210},{-30,-190}})));
      Buildings.BoundaryConditions.WeatherData.ReaderTMY3 weaDat(
        TDryBulSou=Buildings.BoundaryConditions.Types.DataSource.Input,
        relHumSou=Buildings.BoundaryConditions.Types.DataSource.Input,
        pAtmSou=Buildings.BoundaryConditions.Types.DataSource.Parameter,
        winSpeSou=Buildings.BoundaryConditions.Types.DataSource.Parameter,
        winDirSou=Buildings.BoundaryConditions.Types.DataSource.Parameter,
        HGloHorSou=Buildings.BoundaryConditions.Types.DataSource.Parameter,
        HDifHorSou=Buildings.BoundaryConditions.Types.DataSource.Parameter,
        filNam=
            "Resources2/weatherdata/USA_IL_Chicago-OHare.Intl.AP.725300_TMY3.mos")
        annotation (Placement(transformation(extent={{-320,242},{-286,276}})));
      Buildings.BoundaryConditions.WeatherData.Bus weaBus "Weather Data Bus"
        annotation (Placement(transformation(extent={{-348,170},{-328,190}})));
      ThermalZones.Floor flo(
        redeclare package Medium = MediumA,
        VSou=VSou,VNor=VNor,VEas=VEas,VWes=VWes,VSouEas=VSouEas,VNorEas=VNorEas,VSouWes=VSouWes,VNorWes=VNorWes,
        lat=lat,
        VCor=VCor)
      "Model of a floor of the building that is served by this VAV system"
        annotation (Placement(transformation(extent={{804,280},{1132,674}})));
      LearnGB.VAVReheat.ThermalZones.VAVBranch norWes(
        redeclare package MediumA = MediumA,
        redeclare package MediumW = MediumW,
        VRoo=VNorWes,
        m_flow_nominal=m0_flow_norWes) "Northwest-facing thermal zone"
        annotation (Placement(transformation(extent={{566,400},{634,468}})));
      LearnGB.VAVReheat.ThermalZones.VAVBranch souWes(
        redeclare package MediumA = MediumA,
        redeclare package MediumW = MediumW,
        VRoo=VSouWes,
        m_flow_nominal=m0_flow_souWes) "southwest-facing thermal zone"
        annotation (Placement(transformation(extent={{568,290},{636,358}})));
      LearnGB.VAVReheat.ThermalZones.VAVBranch norEas(
        redeclare package MediumA = MediumA,
        redeclare package MediumW = MediumW,
        VRoo=VNorEas,
        m_flow_nominal=m0_flow_norEas) "Northeast-facing thermal zone"
        annotation (Placement(transformation(extent={{1346,332},{1278,400}})));
      LearnGB.VAVReheat.ThermalZones.VAVBranch souEas(
        redeclare package MediumA = MediumA,
        redeclare package MediumW = MediumW,
        VRoo=VSouEas,
        m_flow_nominal=m0_flow_souEas) "southeast-facing thermal zone"
        annotation (Placement(transformation(extent={{1348,204},{1280,272}})));
      Buildings.Fluid.FixedResistances.SplitterFixedResistanceDpM splSupWes(
        redeclare package Medium = MediumA,
        dp_nominal(displayUnit="Pa") = {10,10,10},
        from_dp=true,
        linearized=true,
        m_flow_nominal={m0_flow_wes + m0_flow_souWes + m0_flow_souEas +
            m0_flow_norWes + m0_flow_norEas,m0_flow_souWes + m0_flow_souEas +
            m0_flow_norWes + m0_flow_norEas,m0_flow_wes})
      "Splitter for room supply"
        annotation (Placement(transformation(extent={{1128,-30},{1148,-50}})));
      DeMultiplex9 deMultiplex9_1
        annotation (Placement(transformation(extent={{486,214},{532,260}})));
      Buildings.Fluid.FixedResistances.SplitterFixedResistanceDpM splSupSouEas(
        redeclare package Medium = MediumA,
        dp_nominal(displayUnit="Pa") = {10,10,10},
        from_dp=true,
        linearized=true,
        m_flow_nominal={m0_flow_nor + m0_flow_wes,m0_flow_souWes + m0_flow_norWes +
            m0_flow_souEas + m0_flow_norEas,m0_flow_wes})
      "Splitter for room supply"
        annotation (Placement(transformation(extent={{1176,-30},{1196,-50}})));
      Buildings.Fluid.FixedResistances.SplitterFixedResistanceDpM splSupNorEas(
        redeclare package Medium = MediumA,
        dp_nominal(displayUnit="Pa") = {10,10,10},
        from_dp=true,
        linearized=true,
        m_flow_nominal={m0_flow_souWes + m0_flow_norWes + m0_flow_norEas,
            m0_flow_souWes + m0_flow_norWes,m0_flow_norEas})
      "Splitter for room supply"
        annotation (Placement(transformation(extent={{1222,-30},{1242,-50}})));
      Buildings.Fluid.FixedResistances.SplitterFixedResistanceDpM splSupSouWes(
        redeclare package Medium = MediumA,
        dp_nominal(displayUnit="Pa") = {10,10,10},
        from_dp=true,
        linearized=true,
        m_flow_nominal={m0_flow_souWes + m0_flow_norWes,m0_flow_souWes,
            m0_flow_norWes}) "Splitter for room supply"
        annotation (Placement(transformation(extent={{1266,-30},{1286,-50}})));
      Buildings.Fluid.FixedResistances.SplitterFixedResistanceDpM splRetWes(
        redeclare package Medium = MediumA,
        dp_nominal(displayUnit="Pa") = {10,10,10},
        from_dp=false,
        dynamicBalance=true,
        linearized=true,
        m_flow_nominal={m0_flow_wes + m0_flow_souWes + m0_flow_souEas +
            m0_flow_norWes + m0_flow_norEas,m0_flow_souWes + m0_flow_souEas +
            m0_flow_norWes + m0_flow_norEas,m0_flow_wes})
      "Splitter for room return"
        annotation (Placement(transformation(extent={{1066,130},{1086,110}})));
      Buildings.Fluid.FixedResistances.SplitterFixedResistanceDpM splRetSouEas(
        redeclare package Medium = MediumA,
        dp_nominal(displayUnit="Pa") = {10,10,10},
        from_dp=false,
        dynamicBalance=true,
        linearized=true,
        m_flow_nominal={m0_flow_nor + m0_flow_wes,m0_flow_souWes + m0_flow_norWes +
            m0_flow_souEas + m0_flow_norEas,m0_flow_wes})
      "Splitter for room return"
        annotation (Placement(transformation(extent={{1110,130},{1130,110}})));
      Buildings.Fluid.FixedResistances.SplitterFixedResistanceDpM splRetNorEas(
        redeclare package Medium = MediumA,
        dp_nominal(displayUnit="Pa") = {10,10,10},
        from_dp=false,
        dynamicBalance=true,
        linearized=true,
        m_flow_nominal={m0_flow_souWes + m0_flow_norWes + m0_flow_norEas,
            m0_flow_souWes + m0_flow_norWes,m0_flow_norEas})
      "Splitter for room return"
        annotation (Placement(transformation(extent={{1148,130},{1168,110}})));
      Buildings.Fluid.FixedResistances.SplitterFixedResistanceDpM splRetNor4(
        redeclare package Medium = MediumA,
        dp_nominal(displayUnit="Pa") = {10,10,10},
        from_dp=false,
        dynamicBalance=true,
        linearized=true,
        m_flow_nominal={m0_flow_souWes + m0_flow_norWes,m0_flow_souWes,
            m0_flow_norWes}) "Splitter for room return"
        annotation (Placement(transformation(extent={{1194,130},{1214,110}})));

      Modelica.Blocks.Interfaces.RealOutput y[2]
        annotation (Placement(transformation(extent={{1398,160},{1418,180}})));
      Modelica.Blocks.Interfaces.RealInput u[2]
        annotation (Placement(transformation(extent={{-422,316},{-400,338}})));
    equation
      connect(fil.port_b, heaCoi.port_a1) annotation (Line(
          points={{80,-40},{98,-40}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(TSupSetHea.y, heaCoiCon.u_s) annotation (Line(
          points={{-79,-160},{-2,-160}},
          color={0,0,127},
          pattern=LinePattern.None,
          smooth=Smooth.None));
      connect(fanRet.port_a, dpRetFan.port_b) annotation (Line(
          points={{310,120},{320,120},{320,60}},
          color={0,127,255},
          pattern=LinePattern.None,
          smooth=Smooth.None));
      connect(fanSup.port_b, dpRetFan.port_a) annotation (Line(
          points={{320,-40},{320,40}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(senSupFlo.port_b, dpSupDuc.port_a) annotation (Line(
          points={{380,-40},{420,-40}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(controlBus, modeSelector.cb) annotation (Line(
          points={{-240,-260},{-104,-260},{-104,-286},{-96.8182,-286},{-96.8182,
            -283.182}},
          color={255,204,51},
          thickness=0.5,
          smooth=Smooth.None), Text(
          string="%first",
          index=-1,
          extent={{-6,3},{-6,3}}));

      connect(occSch.tNexOcc, controlBus.dTNexOcc) annotation (Line(
          points={{-297,-204},{-240,-204},{-240,-260}},
          color={0,0,127},
          smooth=Smooth.None), Text(
          string="%second",
          index=1,
          extent={{6,3},{6,3}}));
      connect(TOut.y, controlBus.TOut) annotation (Line(
          points={{-279,148},{-240,148},{-240,-260}},
          color={0,0,127},
          smooth=Smooth.None), Text(
          string="%second",
          index=1,
          extent={{6,3},{6,3}}));
      connect(occSch.occupied, controlBus.occupied) annotation (Line(
          points={{-297,-216},{-240,-216},{-240,-260}},
          color={255,0,255},
          smooth=Smooth.None), Text(
          string="%second",
          index=1,
          extent={{6,3},{6,3}}));
      connect(min.y, controlBus.TRooMin) annotation (Line(
          points={{1221,450},{1248,450},{1248,-260},{-240,-260}},
          color={0,0,127},
          smooth=Smooth.None), Text(
          string="%second",
          index=1,
          extent={{6,3},{6,3}}));
      connect(ave.y, controlBus.TRooAve) annotation (Line(
          points={{1221,420},{1248,420},{1248,-260},{-240,-260}},
          color={0,0,127},
          smooth=Smooth.None), Text(
          string="%second",
          index=1,
          extent={{6,3},{6,3}}));
      connect(controlBus, conFanSup.controlBus) annotation (Line(
          points={{-240,-260},{280,-260},{280,28},{243,28},{243,18}},
          color={255,204,51},
          thickness=0.5,
          smooth=Smooth.None), Text(
          string="%first",
          index=-1,
          extent={{-6,3},{-6,3}}));
      connect(valCoo.port_a, souCoo.ports[1]) annotation (Line(
          points={{230,-90},{230,-110}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(TRet.T, conEco.TRet) annotation (Line(
          points={{90,131},{90,172},{-92,172},{-92,157.333},{-81.3333,157.333}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(TMix.T, conEco.TMix) annotation (Line(
          points={{40,-29},{40,168},{-90,168},{-90,153.333},{-81.3333,153.333}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(conEco.TSupHeaSet, TSupSetHea.y) annotation (Line(
          points={{-81.3333,145.333},{-220,145.333},{-220,-120},{-10,-120},{-10,
            -160},{-79,-160}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(controlBus, conEco.controlBus) annotation (Line(
          points={{-240,-260},{-240,120},{-76,120},{-76,150.667}},
          color={255,204,51},
          thickness=0.5,
          smooth=Smooth.None), Text(
          string="%first",
          index=-1,
          extent={{-6,3},{-6,3}}));
      connect(TSetRoo.controlBus, controlBus) annotation (Line(
          points={{-288,-260},{-240,-260}},
          color={255,204,51},
          thickness=0.5,
          smooth=Smooth.None));
      connect(TSup.port_a, fanSup.port_b) annotation (Line(
          points={{330,-40},{320,-40}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(TSup.port_b, senSupFlo.port_a) annotation (Line(
          points={{350,-40},{360,-40}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(fil.port_a, TMix.port_b) annotation (Line(
          points={{60,-40},{50,-40}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(conFanSup.y, fanSup.y) annotation (Line(
          points={{261,10},{310,10},{310,-30}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(cor.controlBus, controlBus) annotation (Line(
          points={{550,20.32},{550,20},{540,20},{540,-160},{480,-160},{480,-260},
            {-240,-260}},
          color={255,204,51},
          thickness=0.5,
          smooth=Smooth.None), Text(
          string="%second",
          index=1,
          extent={{6,3},{6,3}}));
      connect(sou.controlBus, controlBus) annotation (Line(
          points={{688,19.28},{688,18},{674,18},{674,-160},{480,-160},{480,-260},{-240,
              -260}},
          color={255,204,51},
          thickness=0.5,
          smooth=Smooth.None), Text(
          string="%second",
          index=1,
          extent={{6,3},{6,3}}));
      connect(eas.controlBus, controlBus) annotation (Line(
          points={{826,22.32},{812,22.32},{812,-160},{480,-160},{480,-260},{
            -240,-260}},
          color={255,204,51},
          thickness=0.5,
          smooth=Smooth.None), Text(
          string="%second",
          index=1,
          extent={{6,3},{6,3}}));

      connect(nor.controlBus, controlBus) annotation (Line(
          points={{966,22.32},{950,22.32},{950,-160},{480,-160},{480,-260},{
            -240,-260}},
          color={255,204,51},
          thickness=0.5,
          smooth=Smooth.None), Text(
          string="%second",
          index=1,
          extent={{6,3},{6,3}}));

      connect(wes.controlBus, controlBus) annotation (Line(
          points={{1104,22.32},{1092,22.32},{1092,-160},{480,-160},{480,-260},{
            -240,-260}},
          color={255,204,51},
          thickness=0.5,
          smooth=Smooth.None), Text(
          string="%second",
          index=1,
          extent={{6,3},{6,3}}));
      connect(TCoiHeaOut.T, heaCoiCon.u_m) annotation (Line(
          points={{144,-29},{144,-20},{160,-20},{160,-180},{10,-180},{10,-172}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(souHea.ports[1], valHea.port_a) annotation (Line(
          points={{130,-110},{130,-90}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(heaCoiCon.y, valHea.y) annotation (Line(
          points={{21,-160},{108,-160},{108,-80},{122,-80}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(valHea.port_b, heaCoi.port_a2) annotation (Line(
          points={{130,-70},{130,-52},{118,-52}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(heaCoi.port_b2, sinHea.ports[1]) annotation (Line(
          points={{98,-52},{90,-52},{90,-110}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(cooCoiCon.y, valCoo.y) annotation (Line(
          points={{21,-200},{210,-200},{210,-80},{222,-80}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(conEco.yOA, eco.y) annotation (Line(
          points={{-59.3333,152},{-48,152},{-48,-8},{-13,-8},{-13,6.6}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(eco.port_Exh, amb.ports[1]) annotation (Line(
          points={{-40,55.2},{-100,55.2},{-100,24},{-112,24}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(amb.ports[2], VOut1.port_a) annotation (Line(
          points={{-112,20},{-96,20},{-96,22},{-80,22}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(VOut1.port_b, eco.port_Out) annotation (Line(
          points={{-60,22},{-50,22},{-50,22.8},{-40,22.8}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(dpRetFan.p_rel, conFanSup.u_m) annotation (Line(
          points={{311,50},{290,50},{290,-10},{250,-10},{250,-2}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(eco.port_Sup, TMix.port_a) annotation (Line(
          points={{14,22.8},{24,22.8},{24,-40},{30,-40}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(pSetDuc.y, conFanSup.u) annotation (Line(
          points={{181,10},{238,10}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(cor.yDam, pSetDuc.u[1]) annotation (Line(
          points={{620.267,26.6667},{624,26.6667},{624,190},{140,190},{140,
            8.22222},{158,8.22222}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(sou.yDam, pSetDuc.u[2]) annotation (Line(
          points={{762.4,26},{774,26},{774,190},{140,190},{140,8.66667},{158,
            8.66667}},
          color={0,0,127},
          smooth=Smooth.None));

      connect(eas.yDam, pSetDuc.u[3]) annotation (Line(
          points={{896.267,28.6667},{916,28.6667},{916,190},{140,190},{140,
            9.11111},{158,9.11111}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(nor.yDam, pSetDuc.u[4]) annotation (Line(
          points={{1036.27,28.6667},{1060,28.6667},{1060,190},{140,190},{140,
            9.55556},{158,9.55556}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(wes.yDam, pSetDuc.u[5]) annotation (Line(
          points={{1174.27,28.6667},{1196,28.6667},{1196,190},{140,190},{140,10},
            {158,10}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(heaCoi.port_b1, TCoiHeaOut.port_a) annotation (Line(
          points={{118,-40},{134,-40}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(controlBus, conFanRet.controlBus) annotation (Line(
          points={{-240,-260},{280,-260},{280,168},{243,168},{243,158}},
          color={255,204,51},
          thickness=0.5,
          smooth=Smooth.None), Text(
          string="%first",
          index=-1,
          extent={{-6,3},{-6,3}}));
      connect(senSupFlo.V_flow, conFanRet.u) annotation (Line(
          points={{370,-29},{370,90},{200,90},{200,150},{238,150}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(senRetFlo.port_b, fanRet.port_a) annotation (Line(
          points={{360,120},{310,120}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(senRetFlo.V_flow, conFanRet.u_m) annotation (Line(
          points={{370,131},{370,134},{250,134},{250,138}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(conFanRet.y, fanRet.y) annotation (Line(
          points={{261,150},{300,150},{300,130}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(dpRetDuc.port_b, senRetFlo.port_a) annotation (Line(
          points={{420,120},{380,120}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(TRet.port_b, eco.port_Ret) annotation (Line(
          points={{80,120},{24,120},{24,54},{14,54},{14,55.2}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(TRet.port_a, fanRet.port_b) annotation (Line(
          points={{100,120},{290,120}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(splRetRoo1.port_1, dpRetDuc.port_a) annotation (Line(
          points={{600,120},{440,120}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(splRetNor.port_1, splRetEas.port_2) annotation (Line(
          points={{1014,120},{894,120}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(splRetEas.port_1, splRetSou.port_2) annotation (Line(
          points={{874,120},{758,120}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(splRetSou.port_1, splRetRoo1.port_2) annotation (Line(
          points={{738,120},{620,120}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(splSupRoo1.port_3, cor.port_a) annotation (Line(
          points={{584,-30},{584,20.7733}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(splSupRoo1.port_2, splSupSou.port_1) annotation (Line(
          points={{594,-40},{714,-40}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(splSupSou.port_3, sou.port_a) annotation (Line(
          points={{724,-30},{724,19.76}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(splSupSou.port_2, splSupEas.port_1) annotation (Line(
          points={{734,-40},{850,-40}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(splSupEas.port_3, eas.port_a) annotation (Line(
          points={{860,-30},{860,22.7733}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(splSupEas.port_2, splSupNor.port_1) annotation (Line(
          points={{870,-40},{990,-40}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(TCoiHeaOut.port_b, cooCoi.port_a2) annotation (Line(
          points={{154,-40},{190,-40}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(valCoo.port_b, cooCoi.port_a1) annotation (Line(
          points={{230,-70},{230,-52},{210,-52}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(cooCoi.port_b1, sinCoo.ports[1]) annotation (Line(
          points={{190,-52},{188,-52},{188,-110},{190,-110}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(TSetCoo.TSet, cooCoiCon.u_s) annotation (Line(
          points={{-29,-200},{-2,-200}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(TSetCoo.TSet, conEco.TSupCooSet) annotation (Line(
          points={{-29,-200},{-20,-200},{-20,-140},{-200,-140},{-200,141.333},{
            -81.3333,141.333}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(TSupSetHea.y, TSetCoo.TSetHea) annotation (Line(
          points={{-79,-160},{-60,-160},{-60,-200},{-52,-200}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(modeSelector.cb, TSetCoo.controlBus) annotation (Line(
          points={{-96.8182,-283.182},{-104,-286},{-104,-208},{-41.8,-208}},
          color={255,204,51},
          thickness=0.5,
          smooth=Smooth.None));
      connect(conEco.VOut_flow, VOut1.V_flow) annotation (Line(
          points={{-81.3333,149.333},{-90,149.333},{-90,80},{-70,80},{-70,33}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(weaDat.weaBus, weaBus) annotation (Line(
          points={{-286,259},{-286,180},{-338,180}},
          color={255,204,51},
          thickness=0.5,
          smooth=Smooth.None));
      connect(weaBus.TDryBul, TOut.u) annotation (Line(
          points={{-338,180},{-326,180},{-326,148},{-302,148}},
          color={255,204,51},
          thickness=0.5,
          smooth=Smooth.None));
      connect(amb.weaBus, weaBus) annotation (Line(
          points={{-132,22.2},{-338,22.2},{-338,180}},
          color={255,204,51},
          thickness=0.5,
          smooth=Smooth.None));
      connect(weaBus.TDryBul, pSetDuc.TOut) annotation (Line(
          points={{-338,180},{150,180},{150,18},{158,18}},
          color={255,204,51},
          thickness=0.5,
          smooth=Smooth.None), Text(
          string="%first",
          index=-1,
          extent={{-6,3},{-6,3}}));
      connect(cor.port_b, flo.portsCor[1]) annotation (Line(
          points={{584,72},{586,72},{586,252},{784,252},{784,364},{954.88,364},
            {954.88,378.5}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(splRetRoo1.port_3, flo.portsCor[2]) annotation (Line(
          points={{610,130},{610,242},{792,242},{792,354},{928,354},{928,378.5},
            {968,378.5}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(sou.port_b, flo.portsSou[1]) annotation (Line(
          points={{724,74},{724,228},{954.88,228},{954.88,325.967}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(splRetSou.port_3, flo.portsSou[2]) annotation (Line(
          points={{748,130},{750,130},{750,224},{934,224},{934,325.967},{968,
            325.967}},
          color={0,127,255},
          smooth=Smooth.None));

      connect(eas.port_b, flo.portsEas[1]) annotation (Line(
          points={{860,74},{860,218},{1078,218},{1078,377.187},{1078.21,377.187}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(splRetEas.port_3, flo.portsEas[2]) annotation (Line(
          points={{884,130},{882,130},{882,212},{1091.33,212},{1091.33,377.187}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(nor.port_b, flo.portsNor[1]) annotation (Line(
          points={{1000,74},{1002,74},{1002,412},{954.88,412},{954.88,431.033}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(splRetNor.port_3, flo.portsNor[2]) annotation (Line(
          points={{1024,130},{1024,418},{968,418},{968,431.033}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(wes.port_b, flo.portsWes[1]) annotation (Line(
          points={{1138,74},{1140,74},{1140,254},{827.616,254},{827.616,375.873}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(weaBus, flo.weaBus) annotation (Line(
          points={{-338,180},{-338,477},{1007.36,477}},
          color={255,204,51},
          thickness=0.5,
          smooth=Smooth.None));
      connect(flo.TRooAir, min.u) annotation (Line(
          points={{1125.44,450.733},{1164.7,450.733},{1164.7,450},{1198,450}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(flo.TRooAir, ave.u) annotation (Line(
          points={{1125.44,450.733},{1164,450.733},{1164,420},{1198,420}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(TSup.T, cooCoiCon.u_m) annotation (Line(
          points={{340,-29},{340,-20},{354,-20},{354,-220},{10,-220},{10,-212}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(cooCoi.port_b2, fanSup.port_a) annotation (Line(
          points={{210,-40},{300,-40}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(nor.port_a, splSupNor.port_3) annotation (Line(
          points={{1000,22.7733},{1000,-30}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(wes.port_a, splSupWes.port_3) annotation (Line(
          points={{1138,22.7733},{1138,-30}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(splSupWes.port_1, splSupNor.port_2) annotation (Line(
          points={{1128,-40},{1010,-40}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(deMultiplex9_1.y5[1], cor.TRoo) annotation (Line(
          points={{534.3,236.31},{534.3,135.155},{545.467,135.155},{545.467,
            49.3333}},
          color={0,0,127},
          smooth=Smooth.None));

      connect(deMultiplex9_1.y1[1], sou.TRoo) annotation (Line(
          points={{534.3,257.7},{534.3,147.85},{683.2,147.85},{683.2,50}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(eas.TRoo, deMultiplex9_1.y1[1]) annotation (Line(
          points={{821.467,51.3333},{661.734,51.3333},{661.734,257.7},{534.3,
            257.7}},
          color={0,0,127},
          smooth=Smooth.None));

      connect(nor.TRoo, deMultiplex9_1.y3[1]) annotation (Line(
          points={{961.467,51.3333},{731.734,51.3333},{731.734,247.58},{534.3,
            247.58}},
          color={0,0,127},
          smooth=Smooth.None));

      connect(wes.TRoo, deMultiplex9_1.y4[1]) annotation (Line(
          points={{1099.47,51.3333},{800.735,51.3333},{800.735,242.06},{534.3,
            242.06}},
          color={0,0,127},
          smooth=Smooth.None));

      connect(norWes.TRoo, deMultiplex9_1.y6[1]) annotation (Line(
          points={{561.467,445.333},{561.467,331.667},{534.3,331.667},{534.3,
            230.56}},
          color={0,0,127},
          smooth=Smooth.None));

      connect(norEas.TRoo, deMultiplex9_1.y7[1]) annotation (Line(
          points={{1350.53,377.333},{1222.27,377.333},{1222.27,225.27},{534.3,
            225.27}},
          color={0,0,127},
          smooth=Smooth.None));

      connect(souEas.TRoo, deMultiplex9_1.y9[1]) annotation (Line(
          points={{1352.53,249.333},{927.265,249.333},{927.265,214.92},{534.3,
            214.92}},
          color={0,0,127},
          smooth=Smooth.None));

      connect(souWes.TRoo, deMultiplex9_1.y8[1]) annotation (Line(
          points={{563.467,335.333},{563.467,271.667},{534.3,271.667},{534.3,
            219.98}},
          color={0,0,127},
          smooth=Smooth.None));

      connect(deMultiplex9_1.u, flo.TRooAir) annotation (Line(
          points={{481.4,237},{481.4,506},{1164,506},{1164,450.733},{1125.44,
            450.733}},
          color={0,0,127},
          smooth=Smooth.None));

      connect(souWes.yDam, pSetDuc.u[6]) annotation (Line(
          points={{638.267,312.667},{656,312.667},{656,370},{128,370},{128,
            10.4444},{158,10.4444}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(norWes.yDam, pSetDuc.u[7]) annotation (Line(
          points={{636.267,422.667},{656,422.667},{656,390},{130,390},{130,
            10.8889},{158,10.8889}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(norEas.yDam, pSetDuc.u[8]) annotation (Line(
          points={{1275.73,354.667},{1264,354.667},{1264,280},{130,280},{130,
            11.3333},{158,11.3333}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(souEas.yDam, pSetDuc.u[9]) annotation (Line(
          points={{1277.73,226.667},{1268,226.667},{1268,280},{130,280},{130,
            11.7778},{158,11.7778}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(splSupWes.port_2, splSupSouEas.port_1) annotation (Line(
          points={{1148,-40},{1176,-40}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(splSupSouEas.port_3, souEas.port_a) annotation (Line(
          points={{1186,-30},{1186,2},{1314,2},{1314,220.773}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(splSupSouEas.port_2, splSupNorEas.port_1) annotation (Line(
          points={{1196,-40},{1222,-40}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(splSupNorEas.port_3, norEas.port_a) annotation (Line(
          points={{1232,-30},{1232,300},{1312,300},{1312,348.773}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(splSupNorEas.port_2, splSupSouWes.port_1) annotation (Line(
          points={{1242,-40},{1266,-40}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(splSupSouWes.port_3, souWes.port_a) annotation (Line(
          points={{1276,-30},{1276,192},{1190,192},{1190,272},{602,272},{602,
            306.773}},
          color={0,127,255},
          smooth=Smooth.None));

      connect(splSupSouWes.port_2, norWes.port_a) annotation (Line(
          points={{1286,-40},{1296,-40},{1296,182},{648,182},{648,380},{600,380},
            {600,416.773}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(souEas.port_b, flo.portsSouEas[1]) annotation (Line(
          points={{1314,272},{1314,284},{1078.21,284},{1078.21,324.653}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(norEas.port_b, flo.portsNorEas[1]) annotation (Line(
          points={{1312,400},{1312,406},{1078.21,406},{1078.21,428.407}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(souWes.port_b, flo.portsSouWes[1]) annotation (Line(
          points={{602,358},{602,368},{666,368},{666,312.833},{843.36,312.833}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(splRetNor.port_2, splRetWes.port_1) annotation (Line(
          points={{1034,120},{1066,120}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(splRetWes.port_2, splRetSouEas.port_1) annotation (Line(
          points={{1086,120},{1110,120}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(splRetSouEas.port_2, splRetNorEas.port_1) annotation (Line(
          points={{1130,120},{1148,120}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(splRetNorEas.port_2, splRetNor4.port_1) annotation (Line(
          points={{1168,120},{1194,120}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(splRetWes.port_3, flo.portsWes[2]) annotation (Line(
          points={{1076,130},{1076,202},{840.736,202},{840.736,375.873}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(splRetSouEas.port_3, flo.portsSouEas[2]) annotation (Line(
          points={{1120,130},{1120,154},{1091.33,154},{1091.33,324.653}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(splRetNorEas.port_3, flo.portsNorEas[2]) annotation (Line(
          points={{1158,130},{1158,414},{1091.33,414},{1091.33,428.407}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(splRetNor4.port_3, flo.portsSouWes[2]) annotation (Line(
          points={{1204,130},{1204,262},{856.48,262},{856.48,312.833}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(dpSupDuc.port_b, splSupRoo1.port_1) annotation (Line(
          points={{440,-40},{574,-40}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(splRetNor4.port_2, flo.portsNorWes[2]) annotation (Line(
          points={{1214,120},{1228,120},{1228,392},{838.112,392},{838.112,
            434.973}},
          color={0,127,255},
          smooth=Smooth.None));

      connect(norWes.port_b, flo.portsNorWes[1]) annotation (Line(
          points={{600,468},{600,490},{758,490},{758,434.973},{824.992,434.973}},
          color={0,127,255},
          smooth=Smooth.None));
      connect(souEas.controlBus, controlBus) annotation (Line(
          points={{1348,220.32},{1360,220.32},{1360,-160},{480,-160},{480,-260},{-240,
              -260}},
          color={255,204,51},
          thickness=0.5,
          smooth=Smooth.None), Text(
          string="%second",
          index=1,
          extent={{6,3},{6,3}}));
      connect(norEas.controlBus, controlBus) annotation (Line(
          points={{1346,348.32},{1362,348.32},{1362,-160},{480,-160},{480,-260},{-240,
              -260}},
          color={255,204,51},
          thickness=0.5,
          smooth=Smooth.None), Text(
          string="%second",
          index=1,
          extent={{6,3},{6,3}}));
      connect(souWes.controlBus, controlBus) annotation (Line(
          points={{568,306.32},{478,306.32},{478,-260},{-240,-260}},
          color={255,204,51},
          thickness=0.5,
          smooth=Smooth.None), Text(
          string="%second",
          index=1,
          extent={{6,3},{6,3}}));
      connect(norWes.controlBus, controlBus) annotation (Line(
          points={{566,416.32},{524,416.32},{524,416},{480,416},{480,-260},{-240,-260}},
          color={255,204,51},
          thickness=0.5,
          smooth=Smooth.None), Text(
          string="%second",
          index=1,
          extent={{6,3},{6,3}}));

      connect(flo.TRooAir[1], y[1]) annotation (Line(
          points={{1125.44,444.896},{1164,444.896},{1164,506},{1388,506},{1388,
            165},{1408,165}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(flo.TRooAir[6], y[2]) annotation (Line(
          points={{1125.44,452.193},{1164,452.193},{1164,506},{1388,506},{1388,
            175},{1408,175}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(u[1], weaDat.TDryBul_in) annotation (Line(
          points={{-411,321.5},{-366.5,321.5},{-366.5,270.9},{-321.7,270.9}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(u[2], weaDat.relHum_in) annotation (Line(
          points={{-411,332.5},{-366.5,332.5},{-366.5,265.8},{-321.7,265.8}},
          color={0,0,127},
          smooth=Smooth.None));
      annotation (
        Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-400,-400},
                {1400,600}}),
                        graphics),
        Documentation(info="<html>
<p>
This model consist of an HVAC system, a building envelope model and a model
for air flow through building leakage and through open doors based
on wind pressure and flow imbalance of the HVAC system.
</p>
<p>
The HVAC system is a variable air volume (VAV) flow system with economizer 
and a heating and cooling coil in the air handler unit. There is also a 
reheat coil and an air damper in each of the five zone inlet branches. 
The figure below shows the schematic diagram of the HVAC system
</p>
<p align=\"center\">
<img src=\"modelica://Buildings/Resources/Images/Examples/VAVReheat/vavSchematics.png\" border=\"1\">
</p>
<p>
The control is an implementation of the control sequence 
<i>VAV 2A2-21232</i> of the Sequences of Operation for 
Common HVAC Systems (ASHRAE, 2006). In this control sequence, the 
supply fan speed is regulated based on the duct static pressure. 
The return fan controller tracks the supply fan air flow rate 
reduced by a fixed offset. The duct static pressure is adjusted 
so that at least one VAV damper is 90% open. The economizer dampers 
are modulated to track the setpoint for the mixed air dry bulb temperature. 
Priority is given to maintain a minimum outside air volume flow rate. 
In each zone, the VAV damper is adjusted to meet the room temperature 
setpoint for cooling, or fully opened during heating. 
The room temperature setpoint for heating is tracked by varying 
the water flow rate through the reheat coil. There is also a 
finite state machine that transitions the mode of operation of 
the HVAC system between the modes 
<i>occupied</i>, <i>unoccupied off</i>, <i>unoccupied night set back</i>,
<i>unoccupied warm-up</i> and <i>unoccupied pre-cool</i>. 
In the VAV model, all air flows are computed based on the 
duct static pressure distribution and the performance curves of the fans. 
Local loop control is implemented using proportional and proportional-integral 
controllers, while the supervisory control is implemented 
using a finite state machine.
</p>
<p>
To model the heat transfer through the building envelope, 
a model of five interconnected rooms is used.
The five room model is representative of one floor of the 
new construction medium office building for Chicago, IL, 
as described in the set of DOE Commercial Building Benchmarks 
(Deru et al, 2009). There are four perimeter zones and one core zone. 
The envelope thermal properties meet ASHRAE Standard 90.1-2004.
The thermal room model computes transient heat conduction through
walls, floors and ceilings and long-wave radiative heat exchange between
surfaces. The convective heat transfer coefficient is computed based
on the temperature difference between the surface and the room air.
There is also a layer-by-layer short-wave radiation,
long-wave radiation, convection and conduction heat transfer model for the
windows. The model is similar to the 
Window 5 model and described in TARCOG 2006.
</p>
<p>
Each thermal zone can have air flow from the HVAC system, through leakages of the building envelope (except for the core zone) and through bi-directional air exchange through open doors that connect adjacent zones. The bi-directional air exchange is modeled based on the differences in static pressure between adjacent rooms at a reference height plus the difference in static pressure across the door height as a function of the difference in air density.
There is also wind pressure acting on each facade. The wind pressure is a function
of the wind speed and wind direction. Therefore, infiltration is a function of the
flow imbalance of the HVAC system and of the wind conditions.
</p>
<h4>References</h4>
<p>
ASHRAE.
<i>Sequences of Operation for Common HVAC Systems</i>.
ASHRAE, Atlanta, GA, 2006.
</p>
<p>
Deru M., K. Field, D. Studer, K. Benne, B. Griffith, P. Torcellini,
 M. Halverson, D. Winiarski, B. Liu, M. Rosenberg, J. Huang, M. Yazdanian, and D. Crawley.
<i>DOE commercial building research benchmarks for commercial buildings</i>.
Technical report, U.S. Department of Energy, Energy Efficiency and
Renewable Energy, Office of Building Technologies, Washington, DC, 2009.
</p>
<p>
TARCOG 2006: Carli, Inc., TARCOG: Mathematical models for calculation
of thermal performance of glazing systems with our without
shading devices, Technical Report, Oct. 17, 2006.
</p>
</html>"),
        __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Examples/VAVReheat/ClosedLoop.mos"
          "Simulate and plot"),
        experiment(
          StopTime=172800,
          Tolerance=1e-006,
          Algorithm="radau"));
    end ClosedLoop;

    package Controls "Package with controller models"
        extends Modelica.Icons.VariantsPackage;

      expandable connector ControlBus
      "Empty control bus that is adapted to the signals connected to it"
        extends Modelica.Icons.SignalBus;

        annotation (
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={Rectangle(
                extent={{-20,2},{22,-2}},
                lineColor={255,204,51},
                lineThickness=0.5)}),
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}),
                  graphics),
          Documentation(info="<html>
<p>
This connector defines the \"expandable connector\" ControlBus that
is used as bus in the
<a href=\"Modelica://Modelica.Blocks.Examples.BusUsage\">BusUsage</a> example.
Note, this connector is \"empty\". When using it, the actual content is
constructed by the signals connected to this bus.
</p>
</html>"));

      end ControlBus;

      block Economizer "Controller for economizer"
        import LearnGB.VAVReheat.Controls.OperationModes;
        parameter Modelica.SIunits.TemperatureDifference dT(min=0.1)= 1
        "Temperture offset to activate economizer";
        parameter Modelica.SIunits.VolumeFlowRate VOut_flow_min(min=0)
        "Minimum outside air volume flow rate";
        Modelica.Blocks.Interfaces.RealInput TSupHeaSet
        "Supply temperature setpoint for heating"
          annotation (Placement(transformation(extent={{-140,-40},{-100,0}},
              rotation=0), iconTransformation(extent={{-140,-40},{-100,0}})));
        Modelica.Blocks.Interfaces.RealInput TSupCooSet
        "Supply temperature setpoint for cooling"
          annotation (Placement(transformation(extent={{-140,-100},{-100,-60}},
              rotation=0)));
        Modelica.Blocks.Interfaces.RealInput TMix
        "Measured mixed air temperature"
          annotation (Placement(transformation(extent={{-140,80},{-100,120}},
              rotation=0), iconTransformation(extent={{-140,80},{-100,120}})));
        ControlBus controlBus
          annotation (Placement(transformation(extent={{-50,50},{-30,70}})));
        Modelica.Blocks.Interfaces.RealInput VOut_flow
        "Measured outside air flow rate"
          annotation (Placement(transformation(extent={{-140,20},{-100,60}},
              rotation=0), iconTransformation(extent={{-140,20},{-100,60}})));
        Modelica.Blocks.Interfaces.RealInput TRet "Return air temperature"
          annotation (Placement(transformation(extent={{-140,140},{-100,180}},
              rotation=0), iconTransformation(extent={{-140,140},{-100,180}})));
        Modelica.Blocks.Math.Gain gain(k=1/VOut_flow_min)
        "Normalize mass flow rate"
          annotation (Placement(transformation(extent={{-60,-60},{-40,-40}})));
        Buildings.Controls.Continuous.LimPID conV_flow(
          controllerType=Modelica.Blocks.Types.SimpleController.PI,
          k=k,
          Ti=Ti,
          yMax=0.995,
          yMin=0.005,
          Td=60) "Controller for outside air flow rate"
          annotation (Placement(transformation(extent={{-22,-20},{-2,0}})));
        Modelica.Blocks.Sources.Constant uni(k=1) "Unity signal"
          annotation (Placement(transformation(extent={{-60,-20},{-40,0}})));
        parameter Real k=1 "Gain of controller";
        parameter Modelica.SIunits.Time Ti "Time constant of Integrator block";
        Modelica.Blocks.Interfaces.RealOutput yOA
        "Control signal for outside air damper"
          annotation (Placement(transformation(extent={{200,70},{220,90}},
              rotation=0), iconTransformation(extent={{200,70},{220,90}})));
    public
        Modelica.Blocks.Continuous.FirstOrder firstOrder(
          initType=Modelica.Blocks.Types.Init.InitialState,
          y_start=0,
          T=5*60) annotation (Placement(transformation(extent={{160,-20},{180,0}})));
        Modelica.Blocks.Routing.Extractor extractor(nin=6)
          annotation (Placement(transformation(extent={{120,-20},{140,0}})));
        Modelica.Blocks.Sources.Constant closed(k=0)
        "Signal to close OA damper"
          annotation (Placement(transformation(extent={{60,-90},{80,-70}})));
        Modelica.Blocks.Math.Max max
        "Takes bigger signal (OA damper opens for temp. control or for minimum outside air)"
          annotation (Placement(transformation(extent={{80,-20},{100,0}})));
        MixedAirTemperatureSetpoint TSetMix "Mixed air temperature setpoint"
          annotation (Placement(transformation(extent={{-20,64},{0,84}})));
        EconomizerTemperatureControl yOATMix(Ti=Ti, k=k)
        "Control signal for outdoor damper to track mixed air temperature setpoint"
          annotation (Placement(transformation(extent={{20,160},{40,180}})));
        EconomizerTemperatureControl yOATFre(Ti=Ti, k=k)
        "Control signal for outdoor damper to track freeze temperature setpoint"
          annotation (Placement(transformation(extent={{20,120},{40,140}})));
        Modelica.Blocks.Math.Min min
        "Takes bigger signal (OA damper opens for temp. control or for minimum outside air)"
          annotation (Placement(transformation(extent={{20,-20},{40,0}})));
        Modelica.Blocks.Sources.Constant TFre(k=273.15 + 3)
        "Setpoint for freeze protection"
          annotation (Placement(transformation(extent={{-20,100},{0,120}})));
      equation
        connect(VOut_flow, gain.u) annotation (Line(
            points={{-120,40},{-92,40},{-92,-50},{-62,-50}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(gain.y, conV_flow.u_m) annotation (Line(
            points={{-39,-50},{-12,-50},{-12,-22}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(uni.y, conV_flow.u_s) annotation (Line(
            points={{-39,-10},{-24,-10}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(firstOrder.y, yOA) annotation (Line(
            points={{181,-10},{192,-10},{192,80},{210,80}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(extractor.y, firstOrder.u) annotation (Line(
            points={{141,-10},{158,-10}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(controlBus.controlMode, extractor.index) annotation (Line(
            points={{-40,60},{-40,20},{60,20},{60,-40},{130,-40},{130,-22}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(max.y, extractor.u[OperationModes.occupied]) annotation (Line(
            points={{101,-10},{118,-10}},
            color={0,0,127},
            smooth=Smooth.None));

        connect(closed.y, extractor.u[OperationModes.unoccupiedOff]) annotation (Line(
            points={{81,-80},{110,-80},{110,-10},{118,-10}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(closed.y, extractor.u[OperationModes.unoccupiedNightSetBack]) annotation (Line(
            points={{81,-80},{110,-80},{110,-10},{118,-10}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(max.y, extractor.u[OperationModes.unoccupiedWarmUp]) annotation (Line(
            points={{101,-10},{118,-10}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(max.y, extractor.u[OperationModes.unoccupiedPreCool]) annotation (Line(
            points={{101,-10},{118,-10}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(closed.y, extractor.u[OperationModes.safety]) annotation (Line(
            points={{81,-80},{110,-80},{110,-10},{118,-10}},
            color={0,0,127},
            smooth=Smooth.None));

        connect(TSupHeaSet, TSetMix.TSupHeaSet) annotation (Line(
            points={{-120,-20},{-80,-20},{-80,80},{-22,80}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(TSupCooSet, TSetMix.TSupCooSet) annotation (Line(
            points={{-120,-80},{-72,-80},{-72,68},{-22,68}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(controlBus, TSetMix.controlBus) annotation (Line(
            points={{-40,60},{-13,60},{-13,81}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(yOATMix.TRet, TRet) annotation (Line(
            points={{18,176},{-90,176},{-90,160},{-120,160}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(controlBus.TOut, yOATMix.TOut) annotation (Line(
            points={{-40,60},{-40,172},{18,172}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(yOATMix.TMix, TMix) annotation (Line(
            points={{18,168},{-80,168},{-80,100},{-120,100}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(yOATMix.TMixSet, TSetMix.TSet) annotation (Line(
            points={{18,164},{6,164},{6,75},{1,75}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(yOATMix.yOA, max.u1) annotation (Line(
            points={{41,170},{74,170},{74,-4},{78,-4}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(min.u2, conV_flow.y) annotation (Line(
            points={{18,-16},{10,-16},{10,-10},{-1,-10}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(min.y, max.u2) annotation (Line(
            points={{41,-10},{60,-10},{60,-16},{78,-16}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(min.u1, yOATFre.yOA) annotation (Line(
            points={{18,-4},{10,-4},{10,50},{50,50},{50,130},{41,130}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(yOATFre.TRet, TRet) annotation (Line(
            points={{18,136},{-60,136},{-60,160},{-120,160}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(controlBus.TOut, yOATFre.TOut) annotation (Line(
            points={{-40,60},{-40,132},{18,132}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(yOATFre.TMix, TMix) annotation (Line(
            points={{18,128},{-80,128},{-80,100},{-120,100}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(TFre.y, yOATFre.TMixSet) annotation (Line(
            points={{1,110},{10,110},{10,124},{18,124}},
            color={0,0,127},
            smooth=Smooth.None));
        annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{200,200}}), graphics), Icon(coordinateSystem(
                preserveAspectRatio=true, extent={{-100,-100},{200,200}}), graphics={
              Rectangle(
                extent={{-100,200},{200,-100}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-90,170},{-50,150}},
                lineColor={0,0,255},
                textString="TRet"),
              Text(
                extent={{-86,104},{-46,84}},
                lineColor={0,0,255},
                textString="TMix"),
              Text(
                extent={{-90,60},{-22,12}},
                lineColor={0,0,255},
                textString="VOut_flow"),
              Text(
                extent={{-90,-2},{-28,-40}},
                lineColor={0,0,255},
                textString="TSupHeaSet"),
              Text(
                extent={{-86,-58},{-24,-96}},
                lineColor={0,0,255},
                textString="TSupCooSet"),
              Text(
                extent={{138,96},{184,62}},
                lineColor={0,0,255},
                textString="yOA")}));
      end Economizer;

      block FanVFD "Controller for fan revolution"
        extends Modelica.Blocks.Interfaces.SISO;
        import LearnGB.VAVReheat.Controls.OperationModes;
        Buildings.Controls.Continuous.LimPID con(
          yMax=1,
          yMin=0,
          controllerType=Modelica.Blocks.Types.SimpleController.PI,
          Td=60,
          Ti=10) "Controller"
          annotation (Placement(transformation(extent={{-20,20},{0,40}})));
        Modelica.Blocks.Math.Gain gaiMea(k=1/xSet_nominal)
        "Gain to normalize measurement signal"
          annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));
        parameter Real xSet_nominal "Nominal setpoint (used for normalization)";
        ControlBus controlBus
          annotation (Placement(transformation(extent={{-80,70},{-60,90}})));
        Modelica.Blocks.Routing.Extractor extractor(nin=6)
          annotation (Placement(transformation(extent={{20,-40},{40,-20}})));
        Modelica.Blocks.Sources.Constant off(k=r_N_min) "Off signal"
          annotation (Placement(transformation(extent={{-60,-80},{-40,-60}})));
        Modelica.Blocks.Sources.Constant on(k=1) "On signal"
          annotation (Placement(transformation(extent={{-60,-40},{-40,-20}})));
        Modelica.Blocks.Math.Gain gaiSet(k=1/xSet_nominal)
        "Gain to normalize setpoint signal"
          annotation (Placement(transformation(extent={{-60,20},{-40,40}})));
        Modelica.Blocks.Interfaces.RealInput u_m
        "Connector of measurement input signal"   annotation (Placement(
              transformation(
              extent={{-20,-20},{20,20}},
              rotation=90,
              origin={0,-120})));
        parameter Real r_N_min=0.01 "Minimum normalized fan speed";
        Modelica.Blocks.Continuous.FirstOrder firstOrder(
          T=60,
          initType=initType,
          y_start=y_start)
          annotation (Placement(transformation(extent={{60,-40},{80,-20}})));
        parameter Modelica.Blocks.Types.Init initType=Modelica.Blocks.Types.Init.NoInit
        "Type of initialization (1: no init, 2: steady state, 3/4: initial output)";
        parameter Real y_start=0 "Initial or guess value of output (= state)";

      equation
        connect(gaiMea.y, con.u_m) annotation (Line(
            points={{-39,6.10623e-16},{-10,6.10623e-16},{-10,18}},
            color={0,0,127},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(con.y, extractor.u[OperationModes.occupied]) annotation (Line(
            points={{1,30},{20,30},{20,-8},{-20,-8},{-20,-30},{18,-30}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(con.y, extractor.u[OperationModes.unoccupiedWarmUp]) annotation (Line(
            points={{1,30},{20,30},{20,-8},{-20,-8},{-20,-30},{18,-30}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(con.y, extractor.u[OperationModes.unoccupiedPreCool]) annotation (Line(
            points={{1,30},{20,30},{20,-8},{-20,-8},{-20,-30},{18,-30}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(off.y, extractor.u[OperationModes.unoccupiedOff])  annotation (Line(
            points={{-39,-70},{-20,-70},{-20,-30},{18,-30}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(off.y, extractor.u[OperationModes.safety])  annotation (Line(
            points={{-39,-70},{-20,-70},{-20,-30},{18,-30}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(on.y, extractor.u[OperationModes.unoccupiedNightSetBack]) annotation (Line(
            points={{-39,-30},{18,-30}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(controlBus.controlMode, extractor.index) annotation (Line(
            points={{-70,80},{-70,-52},{30,-52},{30,-42}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(gaiSet.y, con.u_s) annotation (Line(
            points={{-39,30},{-22,30}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(u_m, gaiMea.u) annotation (Line(
            points={{1.11022e-15,-120},{1.11022e-15,-92},{-80,-92},{-80,0},{-62,0},{
                -62,6.66134e-16}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(gaiSet.u, u) annotation (Line(
            points={{-62,30},{-90,30},{-90,1.11022e-15},{-120,1.11022e-15}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(extractor.y, firstOrder.u) annotation (Line(
            points={{41,-30},{58,-30}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(firstOrder.y, y) annotation (Line(
            points={{81,-30},{88,-30},{88,5.55112e-16},{110,5.55112e-16}},
            color={0,0,127},
            smooth=Smooth.None));
        annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics), Icon(graphics={Text(
                extent={{-90,-50},{96,-96}},
                lineColor={0,0,255},
                textString="r_N_min=%r_N_min")}));
      end FanVFD;

      model ModeSelector "Finite State Machine for the operational modes"

        Modelica.StateGraph.InitialStep initialStep
          annotation (Placement(transformation(extent={{-80,20},{-60,40}})));
        Modelica.StateGraph.Transition start "Starts the system"
          annotation (Placement(transformation(extent={{-50,20},{-30,40}})));
        State unOccOff(
          mode=Buildings.Examples.VAVReheat.Controls.OperationModes.unoccupiedOff,
          nIn=3,
          nOut=4) "Unoccupied off mode, no coil protection"
          annotation (Placement(transformation(extent={{-20,20},{0,40}})));
        State unOccNigSetBac(
          nOut=2,
          mode=Buildings.Examples.VAVReheat.Controls.OperationModes.unoccupiedNightSetBack,
          nIn=1) "Unoccupied night set back"
          annotation (Placement(transformation(extent={{80,20},{100,40}})));
        Modelica.StateGraph.Transition t2(condition=TRooMinErrHea.y > 0, enableTimer=
              false)
          annotation (Placement(transformation(extent={{28,20},{48,40}})));
        parameter Modelica.SIunits.TemperatureDifference delTRooOnOff(min=0.1)=1
        "Deadband in room temperature between occupied on and occupied off";
        parameter Modelica.SIunits.Temperature TRooSetHeaOcc=293.15
        "Set point for room air temperature during heating mode";
        parameter Modelica.SIunits.Temperature TRooSetCooOcc=299.15
        "Set point for room air temperature during cooling mode";
        parameter Modelica.SIunits.Temperature TSetHeaCoiOut=303.15
        "Set point for air outlet temperature at central heating coil";
        Modelica.StateGraph.Transition t1(condition=delTRooOnOff < -TRooMinErrHea.y)
          annotation (Placement(transformation(extent={{50,70},{30,90}})));
        inner Modelica.StateGraph.StateGraphRoot stateGraphRoot
          annotation (Placement(transformation(extent={{160,160},{180,180}})));
        ControlBus cb
          annotation (Placement(transformation(extent={{-168,130},{-148,150}}),
              iconTransformation(extent={{-176,124},{-124,176}})));
        Modelica.Blocks.Routing.RealPassThrough TRooSetHea
        "Current heating setpoint temperature"
          annotation (Placement(transformation(extent={{-80,170},{-60,190}})));
        State morWarUp(mode=Buildings.Examples.VAVReheat.Controls.OperationModes.unoccupiedWarmUp,
                                                                                  nIn=2,
          nOut=1) "Morning warm up"
          annotation (Placement(transformation(extent={{-40,-100},{-20,-80}})));
        Modelica.StateGraph.TransitionWithSignal t6
          annotation (Placement(transformation(extent={{-76,-100},{-56,-80}})));
        Modelica.Blocks.Logical.LessEqualThreshold occThrSho(threshold=1800)
        "Signal to allow transition into morning warmup"
          annotation (Placement(transformation(extent={{-140,-190},{-120,-170}})));
        Modelica.StateGraph.TransitionWithSignal t5
          annotation (Placement(transformation(extent={{118,20},{138,40}})));
        State occ(       mode=Buildings.Examples.VAVReheat.Controls.OperationModes.occupied,
                                                                            nIn=3)
        "Occupied mode"
          annotation (Placement(transformation(extent={{60,-100},{80,-80}})));
        Modelica.Blocks.Routing.RealPassThrough TRooMin
          annotation (Placement(transformation(extent={{-80,140},{-60,160}})));
        Modelica.Blocks.Math.Feedback TRooMinErrHea
        "Room control error for heating"
          annotation (Placement(transformation(extent={{-40,170},{-20,190}})));
        Modelica.StateGraph.Transition t3(condition=TRooMin.y > TRooSetHeaOcc or
              occupied.y)
          annotation (Placement(transformation(extent={{10,-100},{30,-80}})));
        Modelica.Blocks.Routing.BooleanPassThrough occupied
        "outputs true if building is occupied"
          annotation (Placement(transformation(extent={{-80,80},{-60,100}})));
        Modelica.StateGraph.TransitionWithSignal t4(enableTimer=false)
          annotation (Placement(transformation(extent={{118,120},{98,140}})));
        State morPreCoo(                                                        nIn=2,
          mode=Buildings.Examples.VAVReheat.Controls.OperationModes.unoccupiedPreCool,
          nOut=1) "Pre-cooling mode"
          annotation (Placement(transformation(extent={{-40,-140},{-20,-120}})));
        Modelica.StateGraph.Transition t7(condition=TRooMin.y < TRooSetCooOcc or
              occupied.y)
          annotation (Placement(transformation(extent={{10,-140},{30,-120}})));
        Modelica.Blocks.Logical.And and1
          annotation (Placement(transformation(extent={{-100,-200},{-80,-180}})));
        Modelica.Blocks.Routing.RealPassThrough TRooAve
        "Average room temperature"
          annotation (Placement(transformation(extent={{-80,110},{-60,130}})));
        Modelica.Blocks.Sources.BooleanExpression booleanExpression(y=TRooAve.y <
              TRooSetCooOcc)
          annotation (Placement(transformation(extent={{-198,-224},{-122,-200}})));
        PreCoolingStarter preCooSta(TRooSetCooOcc=TRooSetCooOcc)
        "Model to start pre-cooling"
          annotation (Placement(transformation(extent={{-140,-160},{-120,-140}})));
        Modelica.StateGraph.TransitionWithSignal t9
          annotation (Placement(transformation(extent={{-90,-140},{-70,-120}})));
        Modelica.Blocks.Logical.Not not1
          annotation (Placement(transformation(extent={{-48,-180},{-28,-160}})));
        Modelica.Blocks.Logical.And and2
          annotation (Placement(transformation(extent={{80,100},{100,120}})));
        Modelica.Blocks.Logical.Not not2
          annotation (Placement(transformation(extent={{0,100},{20,120}})));
        Modelica.StateGraph.TransitionWithSignal t8
        "changes to occupied in case precooling is deactivated"
          annotation (Placement(transformation(extent={{30,-30},{50,-10}})));
        Modelica.Blocks.MathInteger.Sum sum(nu=5)
          annotation (Placement(transformation(extent={{-186,134},{-174,146}})));
      equation
        connect(start.outPort, unOccOff.inPort[1]) annotation (Line(
            points={{-38.5,30},{-29.75,30},{-29.75,30.6667},{-21,30.6667}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(initialStep.outPort[1], start.inPort) annotation (Line(
            points={{-59.5,30},{-44,30}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(unOccOff.outPort[1], t2.inPort)         annotation (Line(
            points={{0.5,30.375},{8.25,30.375},{8.25,30},{34,30}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(t2.outPort, unOccNigSetBac.inPort[1])  annotation (Line(
            points={{39.5,30},{79,30}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(unOccNigSetBac.outPort[1], t1.inPort)   annotation (Line(
            points={{100.5,30.25},{112,30.25},{112,80},{44,80}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(t1.outPort, unOccOff.inPort[2])          annotation (Line(
            points={{38.5,80},{-30,80},{-30,30},{-21,30}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(cb.dTNexOcc, occThrSho.u)             annotation (Line(
            points={{-158,140},{-150,140},{-150,-180},{-142,-180}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(t6.outPort, morWarUp.inPort[1]) annotation (Line(
            points={{-64.5,-90},{-41,-90},{-41,-89.5}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(t5.outPort, morWarUp.inPort[2]) annotation (Line(
            points={{129.5,30},{140,30},{140,-60},{-48,-60},{-48,-90.5},{-41,-90.5}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(unOccNigSetBac.outPort[2], t5.inPort)
                                               annotation (Line(
            points={{100.5,29.75},{113.25,29.75},{113.25,30},{124,30}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(cb.TRooMin, TRooMin.u) annotation (Line(
            points={{-158,140},{-92,140},{-92,150},{-82,150}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(TRooSetHea.y, TRooMinErrHea.u1)
                                          annotation (Line(
            points={{-59,180},{-38,180}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(TRooMin.y, TRooMinErrHea.u2)
                                          annotation (Line(
            points={{-59,150},{-30,150},{-30,172}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(unOccOff.outPort[2], t6.inPort) annotation (Line(
            points={{0.5,30.125},{12,30.125},{12,-48},{-80,-48},{-80,-90},{-70,-90}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(morWarUp.outPort[1], t3.inPort) annotation (Line(
            points={{-19.5,-90},{16,-90}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(cb.occupied, occupied.u) annotation (Line(
            points={{-158,140},{-120,140},{-120,90},{-82,90}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(occ.outPort[1], t4.inPort) annotation (Line(
            points={{80.5,-90},{172,-90},{172,130},{112,130}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(t4.outPort, unOccOff.inPort[3]) annotation (Line(
            points={{106.5,130},{-30,130},{-30,29.3333},{-21,29.3333}},
            color={0,0,0},
            smooth=Smooth.None));

        connect(occThrSho.y, and1.u1) annotation (Line(
            points={{-119,-180},{-110,-180},{-110,-190},{-102,-190}},
            color={255,0,255},
            smooth=Smooth.None));
        connect(and1.y, t6.condition) annotation (Line(
            points={{-79,-190},{-66,-190},{-66,-102}},
            color={255,0,255},
            smooth=Smooth.None));
        connect(and1.y, t5.condition) annotation (Line(
            points={{-79,-190},{128,-190},{128,18}},
            color={255,0,255},
            smooth=Smooth.None));
        connect(cb.TRooAve, TRooAve.u) annotation (Line(
            points={{-158,140},{-100,140},{-100,120},{-82,120}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(booleanExpression.y, and1.u2) annotation (Line(
            points={{-118.2,-212},{-110.1,-212},{-110.1,-198},{-102,-198}},
            color={255,0,255},
            smooth=Smooth.None));

        connect(preCooSta.y, t9.condition) annotation (Line(
            points={{-119,-150},{-80,-150},{-80,-142}},
            color={255,0,255},
            smooth=Smooth.None));
        connect(t9.outPort, morPreCoo.inPort[1]) annotation (Line(
            points={{-78.5,-130},{-59.75,-130},{-59.75,-129.5},{-41,-129.5}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(unOccOff.outPort[3], t9.inPort) annotation (Line(
            points={{0.5,29.875},{12,29.875},{12,0},{-100,0},{-100,-130},{-84,-130}},
            color={0,0,0},
            smooth=Smooth.None));

        connect(cb, preCooSta.controlBus) annotation (Line(
            points={{-158,140},{-150,140},{-150,-144},{-136.2,-144}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(morPreCoo.outPort[1], t7.inPort) annotation (Line(
            points={{-19.5,-130},{16,-130}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(t7.outPort, occ.inPort[2]) annotation (Line(
            points={{21.5,-130},{30,-130},{30,-128},{46,-128},{46,-90},{59,-90}},
            color={0,0,0},
            smooth=Smooth.None));

        connect(t3.outPort, occ.inPort[1]) annotation (Line(
            points={{21.5,-90},{42,-90},{42,-89.3333},{59,-89.3333}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(occThrSho.y, not1.u) annotation (Line(
            points={{-119,-180},{-110,-180},{-110,-170},{-50,-170}},
            color={255,0,255},
            smooth=Smooth.None));
        connect(not1.y, and2.u2) annotation (Line(
            points={{-27,-170},{200,-170},{200,90},{66,90},{66,102},{78,102}},
            color={255,0,255},
            smooth=Smooth.None));
        connect(and2.y, t4.condition) annotation (Line(
            points={{101,110},{108,110},{108,118}},
            color={255,0,255},
            smooth=Smooth.None));
        connect(occupied.y, not2.u) annotation (Line(
            points={{-59,90},{-20,90},{-20,110},{-2,110}},
            color={255,0,255},
            smooth=Smooth.None));
        connect(not2.y, and2.u1) annotation (Line(
            points={{21,110},{78,110}},
            color={255,0,255},
            smooth=Smooth.None));
        connect(cb.TRooSetHea, TRooSetHea.u) annotation (Line(
            points={{-158,140},{-92,140},{-92,180},{-82,180}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(t8.outPort, occ.inPort[3]) annotation (Line(
            points={{41.5,-20},{52,-20},{52,-90.6667},{59,-90.6667}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(unOccOff.outPort[4], t8.inPort) annotation (Line(
            points={{0.5,29.625},{12,29.625},{12,-20},{36,-20}},
            color={0,0,0},
            smooth=Smooth.None));
        connect(occupied.y, t8.condition) annotation (Line(
            points={{-59,90},{-50,90},{-50,-40},{40,-40},{40,-32}},
            color={255,0,255},
            smooth=Smooth.None));
        connect(morPreCoo.y, sum.u[1]) annotation (Line(
            points={{-19,-136},{-8,-136},{-8,-68},{-192,-68},{-192,143.36},{-186,
                143.36}},
            color={255,127,0},
            smooth=Smooth.None));
        connect(morWarUp.y, sum.u[2]) annotation (Line(
            points={{-19,-96},{-8,-96},{-8,-68},{-192,-68},{-192,141.68},{-186,141.68}},
            color={255,127,0},
            smooth=Smooth.None));

        connect(occ.y, sum.u[3]) annotation (Line(
            points={{81,-96},{100,-96},{100,-108},{-192,-108},{-192,140},{-186,140}},
            color={255,127,0},
            smooth=Smooth.None));

        connect(unOccOff.y, sum.u[4]) annotation (Line(
            points={{1,24},{6,24},{6,8},{-192,8},{-192,138.32},{-186,138.32}},
            color={255,127,0},
            smooth=Smooth.None));
        connect(unOccNigSetBac.y, sum.u[5]) annotation (Line(
            points={{101,24},{112,24},{112,8},{-192,8},{-192,136.64},{-186,136.64}},
            color={255,127,0},
            smooth=Smooth.None));
        connect(sum.y, cb.controlMode) annotation (Line(
            points={{-173.1,140},{-158,140}},
            color={255,127,0},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-220,
                  -220},{220,220}}), graphics), Icon(coordinateSystem(
                preserveAspectRatio=true, extent={{-220,-220},{220,220}}), graphics={
                Rectangle(
                extent={{-200,200},{200,-200}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Solid,
                fillColor={215,215,215}), Text(
                extent={{-176,80},{192,-84}},
                lineColor={0,0,255},
                textString="%name")}));
      end ModeSelector;

      type OperationModes = enumeration(
        occupied "Occupied",
        unoccupiedOff "Unoccupied off",
        unoccupiedNightSetBack "Unoccupied, night set back",
        unoccupiedWarmUp "Unoccupied, warm-up",
        unoccupiedPreCool "Unoccupied, pre-cool",
        safety "Safety (smoke, fire, etc.)")
      "Enumeration for modes of operation";

      block PreCoolingStarter "Outputs true when precooling should start"
        extends Modelica.Blocks.Interfaces.BooleanSignalSource;
        parameter Modelica.SIunits.Temperature TOutLim = 286.15
        "Limit for activating precooling";
        parameter Modelica.SIunits.Temperature TRooSetCooOcc
        "Set point for room air temperature during cooling mode";
        ControlBus controlBus
          annotation (Placement(transformation(extent={{-72,50},{-52,70}})));
        Modelica.Blocks.Logical.GreaterThreshold greater(threshold=TRooSetCooOcc)
          annotation (Placement(transformation(extent={{-40,0},{-20,20}})));
        Modelica.Blocks.Logical.LessThreshold greater2(threshold=1800)
          annotation (Placement(transformation(extent={{-40,-80},{-20,-60}})));
        Modelica.Blocks.Logical.LessThreshold greater1(threshold=TOutLim)
          annotation (Placement(transformation(extent={{-40,-40},{-20,-20}})));
        Modelica.Blocks.MathBoolean.And and3(nu=3)
          annotation (Placement(transformation(extent={{28,-6},{40,6}})));
      equation
        connect(controlBus.dTNexOcc, greater2.u) annotation (Line(
            points={{-62,60},{-54,60},{-54,-70},{-42,-70}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(controlBus.TRooAve, greater.u) annotation (Line(
            points={{-62,60},{-54,60},{-54,10},{-42,10}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(controlBus.TOut, greater1.u) annotation (Line(
            points={{-62,60},{-54,60},{-54,-30},{-42,-30}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(and3.y, y) annotation (Line(
            points={{40.9,0},{110,0}},
            color={255,0,255},
            smooth=Smooth.None));
        connect(greater.y, and3.u[1]) annotation (Line(
            points={{-19,10},{6,10},{6,2.8},{28,2.8}},
            color={255,0,255},
            smooth=Smooth.None));
        connect(greater1.y, and3.u[2]) annotation (Line(
            points={{-19,-30},{6,-30},{6,0},{28,0},{28,2.22045e-016}},
            color={255,0,255},
            smooth=Smooth.None));
        connect(greater2.y, and3.u[3]) annotation (Line(
            points={{-19,-70},{12,-70},{12,-2.8},{28,-2.8}},
            color={255,0,255},
            smooth=Smooth.None));
        annotation (Diagram(graphics));
      end PreCoolingStarter;

      block RoomTemperatureSetpoint "Set point scheduler for room temperature"
        extends Modelica.Blocks.Interfaces.BlockIcon;
        import LearnGB.VAVReheat.Controls.OperationModes;
        parameter Modelica.SIunits.Temperature THeaOn=293.15
        "Heating setpoint during on";
        parameter Modelica.SIunits.Temperature THeaOff=285.15
        "Heating setpoint during off";
        parameter Modelica.SIunits.Temperature TCooOn=297.15
        "Cooling setpoint during on";
        parameter Modelica.SIunits.Temperature TCooOff=303.15
        "Cooling setpoint during off";

        ControlBus controlBus
          annotation (Placement(transformation(extent={{10,50},{30,70}})));
        Modelica.Blocks.Routing.IntegerPassThrough mode
          annotation (Placement(transformation(extent={{60,50},{80,70}})));
        Modelica.Blocks.Sources.RealExpression setPoiHea(y=if (mode.y ==
              OperationModes.occupied or mode.y == OperationModes.unoccupiedWarmUp
               or mode.y == OperationModes.safety) then THeaOn else THeaOff)
          annotation (Placement(transformation(extent={{-80,70},{-60,90}})));
        Modelica.Blocks.Sources.RealExpression setPoiCoo(y=if (mode.y ==
              OperationModes.occupied or mode.y == OperationModes.unoccupiedPreCool
               or mode.y == OperationModes.safety) then TCooOn else TCooOff)
        "Cooling setpoint"
          annotation (Placement(transformation(extent={{-80,30},{-60,50}})));
        Modelica.Blocks.Continuous.FirstOrder firOrdHea(each T=10, each initType=
              Modelica.Blocks.Types.Init.SteadyState)
        "First order element, used since otherwise, Dymola 7.3 cannot reduce the index of the DAE"
          annotation (Placement(transformation(extent={{-40,70},{-20,90}})));
        Modelica.Blocks.Continuous.FirstOrder firOrdCoo(each T=10, each initType=
              Modelica.Blocks.Types.Init.SteadyState)
        "First order element, used since otherwise, Dymola 7.3 cannot reduce the index of the DAE"
          annotation (Placement(transformation(extent={{-40,30},{-20,50}})));
      equation
        connect(controlBus.controlMode,mode. u) annotation (Line(
            points={{20,60},{58,60}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(setPoiHea.y, firOrdHea.u) annotation (Line(
            points={{-59,80},{-42,80}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(firOrdHea.y, controlBus.TRooSetHea) annotation (Line(
            points={{-19,80},{20,80},{20,60}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(setPoiCoo.y, firOrdCoo.u) annotation (Line(
            points={{-59,40},{-42,40}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(firOrdCoo.y, controlBus.TRooSetCoo) annotation (Line(
            points={{-19,40},{20,40},{20,60}},
            color={0,0,127},
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics), Icon(graphics={
              Text(
                extent={{-92,90},{-52,70}},
                lineColor={0,0,255},
                textString="TRet"),
              Text(
                extent={{-96,50},{-56,30}},
                lineColor={0,0,255},
                textString="TMix"),
              Text(
                extent={{-94,22},{-26,-26}},
                lineColor={0,0,255},
                textString="VOut_flow"),
              Text(
                extent={{-88,-22},{-26,-60}},
                lineColor={0,0,255},
                textString="TSupHeaSet"),
              Text(
                extent={{-86,-58},{-24,-96}},
                lineColor={0,0,255},
                textString="TSupCooSet"),
              Text(
                extent={{42,16},{88,-18}},
                lineColor={0,0,255},
                textString="yOA")}));
      end RoomTemperatureSetpoint;

      block RoomVAV "Controller for room VAV box"
        extends Modelica.Blocks.Interfaces.BlockIcon;
        Buildings.Controls.Continuous.LimPID conHea(
          yMax=1,
          xi_start=0.1,
          initType=Modelica.Blocks.Types.InitPID.InitialState,
          Td=60,
          yMin=0,
          controllerType=Modelica.Blocks.Types.SimpleController.PI,
          k=0.01/10,
          Ti=10/2) "Controller for heating"
          annotation (Placement(transformation(extent={{-20,50},{0,70}})));

        Buildings.Controls.Continuous.LimPID conCoo(
          yMax=1,
          reverseAction=true,
          Td=60,
          controllerType=Modelica.Blocks.Types.SimpleController.PI,
          Ti=60/2,
          k=0.01/10) "Controller for cooling (acts on damper)"
          annotation (Placement(transformation(extent={{-20,-60},{0,-40}})));
        ControlBus controlBus
          annotation (Placement(transformation(extent={{-80,64},{-60,84}})));
        Modelica.Blocks.Interfaces.RealInput TRoo(final quantity="ThermodynamicTemperature",
                                                final unit = "K", displayUnit = "degC", min=0)
        "Measured room temperature"
          annotation (Placement(transformation(extent={{-140,20},{-100,60}})));
        Modelica.Blocks.Interfaces.RealOutput yHea
        "Signal for heating coil valve"
          annotation (Placement(transformation(extent={{100,30},{120,50}})));
        Modelica.Blocks.Interfaces.RealOutput yDam "Signal for VAV damper"
          annotation (Placement(transformation(extent={{100,-60},{120,-40}})));
        Modelica.Blocks.Interfaces.RealInput TSup(displayUnit="degC")
        "Measured supply air temperature after heating coil"
          annotation (Placement(transformation(extent={{-140,-60},{-100,-20}})));
        Buildings.Utilities.Math.SmoothMax smoothMax2(deltaX=0.1)
          annotation (Placement(transformation(extent={{12,-14},{32,6}})));
        Modelica.Blocks.Sources.Constant one(k=1)
          annotation (Placement(transformation(extent={{-60,-76},{-40,-56}})));
        Modelica.Blocks.Math.Add3 yDamHea(k3=-1)
        "Outputs (unlimited) damper signal for heating."
          annotation (Placement(transformation(extent={{-20,-20},{0,0}})));
        Modelica.Blocks.Math.Add add
          annotation (Placement(transformation(extent={{40,-40},{60,-20}})));
        Modelica.Blocks.Sources.Constant zero(k=0.1)
          annotation (Placement(transformation(extent={{-20,10},{0,30}})));
        Buildings.Utilities.Math.SmoothMin smoothMin(deltaX=0.1)
          annotation (Placement(transformation(extent={{76,-60},{96,-40}})));
      equation
        connect(controlBus.TRooSetHea, conHea.u_s) annotation (Line(
            points={{-70,74},{-70,60},{-22,60}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(controlBus.TRooSetCoo, conCoo.u_s) annotation (Line(
            points={{-70,74},{-70,-50},{-22,-50}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(conHea.u_m, TRoo) annotation (Line(
            points={{-10,48},{-10,40},{-120,40}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(conCoo.u_m, TRoo) annotation (Line(
            points={{-10,-62},{-10,-80},{-80,-80},{-80,40},{-120,40}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(TRoo, yDamHea.u3) annotation (Line(
            points={{-120,40},{-80,40},{-80,-18},{-22,-18}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(yDamHea.u2, TSup) annotation (Line(
            points={{-22,-10},{-90,-10},{-90,-40},{-120,-40}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(one.y, yDamHea.u1) annotation (Line(
            points={{-39,-66},{-32,-66},{-32,-2},{-22,-2}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(conCoo.y, add.u2) annotation (Line(
            points={{1,-50},{8,-50},{8,-36},{38,-36}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(yDamHea.y, smoothMax2.u2) annotation (Line(
            points={{1,-10},{10,-10}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(smoothMax2.y, add.u1) annotation (Line(
            points={{33,-4},{34,-4},{34,-24},{38,-24}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(zero.y, smoothMax2.u1) annotation (Line(
            points={{1,20},{4,20},{4,2},{10,2}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(smoothMin.u1, add.y) annotation (Line(
            points={{74,-44},{68,-44},{68,-30},{61,-30}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(one.y, smoothMin.u2) annotation (Line(
            points={{-39,-66},{48,-66},{48,-56},{74,-56}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(conHea.y, yHea) annotation (Line(
            points={{1,60},{80,60},{80,40},{110,40}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(smoothMin.y, yDam) annotation (Line(
            points={{97,-50},{110,-50}},
            color={0,0,127},
            smooth=Smooth.None));
        annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics), Icon(graphics={
              Text(
                extent={{-92,48},{-44,24}},
                lineColor={0,0,127},
                textString="TRoo"),
              Text(
                extent={{-92,-30},{-44,-54}},
                lineColor={0,0,127},
                textString="TSup"),
              Text(
                extent={{42,52},{90,28}},
                lineColor={0,0,127},
                textString="yHea"),
              Text(
                extent={{46,-36},{94,-60}},
                lineColor={0,0,127},
                textString="yCoo")}));
      end RoomVAV;

      model State
      "Block that outputs the mode if the state is active, or zero otherwise"
        extends Modelica.StateGraph.StepWithSignal;
       parameter OperationModes mode "Enter enumeration of mode";
        Modelica.Blocks.Interfaces.IntegerOutput y
        "Mode signal (=0 if not active)"
          annotation (Placement(transformation(extent={{100,-70},{120,-50}})));
      equation
         y = if localActive then mode else 0;
        annotation (Icon(graphics={Text(
                extent={{-82,96},{82,-84}},
                lineColor={0,0,255},
                textString="state")}),           Diagram(graphics));
      end State;

      model DuctStaticPressureSetpoint
      "Computes the duct static pressure setpoint"
        extends Modelica.Blocks.Interfaces.MISO;
        parameter Modelica.SIunits.AbsolutePressure pMin(displayUnit="Pa") = 100
        "Minimum duct static pressure setpoint";
        parameter Modelica.SIunits.AbsolutePressure pMax(displayUnit="Pa") = 410
        "Maximum duct static pressure setpoint";
        parameter Real k=0.1 "Gain of controller";
        parameter Modelica.SIunits.Time Ti=600
        "Time constant of Integrator block";
        parameter Modelica.SIunits.Time Td=60
        "Time constant of Derivative block";
        parameter Modelica.Blocks.Types.SimpleController controllerType=Modelica.Blocks.Types.SimpleController.PID
        "Type of controller";
                                 Buildings.Controls.Continuous.LimPID limPID(
          controllerType=controllerType,
          k=k,
          Ti=Ti,
          Td=Td,
          initType=Modelica.Blocks.Types.InitPID.InitialState,
          reverseAction=true)
          annotation (Placement(transformation(extent={{-20,40},{0,60}})));
    protected
        Buildings.Utilities.Math.Max max(final nin=nin)
          annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));
        Modelica.Blocks.Sources.Constant ySet(k=0.9)
        "Setpoint for maximum damper position"
          annotation (Placement(transformation(extent={{-60,40},{-40,60}})));

        Modelica.Blocks.Math.Add dp(final k2=-1) "Pressure difference"
          annotation (Placement(transformation(extent={{-20,-60},{0,-40}})));
        Modelica.Blocks.Sources.Constant pMaxSig(k=pMax)
          annotation (Placement(transformation(extent={{-60,-40},{-40,-20}})));
        Modelica.Blocks.Sources.Constant pMinSig(k=pMin)
          annotation (Placement(transformation(extent={{-60,-80},{-40,-60}})));
        Modelica.Blocks.Math.Add pSet "Pressure setpoint"
          annotation (Placement(transformation(extent={{60,-10},{80,10}})));
        Modelica.Blocks.Math.Product product
          annotation (Placement(transformation(extent={{20,10},{40,30}})));
    public
        Modelica.Blocks.Logical.Hysteresis hysteresis(uLow=283.15, uHigh=284.15)
        "Hysteresis to put fan on minimum revolution"
          annotation (Placement(transformation(extent={{-60,70},{-40,90}})));
        Modelica.Blocks.Interfaces.RealInput TOut "Outside air temperature"
          annotation (Placement(transformation(extent={{-140,60},{-100,100}})));
    protected
        Modelica.Blocks.Sources.Constant zero(k=0) "Zero output signal"
          annotation (Placement(transformation(extent={{20,42},{40,62}})));
    public
        Modelica.Blocks.Logical.Switch switch1
          annotation (Placement(transformation(extent={{60,50},{80,70}})));
      equation
        connect(max.u, u) annotation (Line(
            points={{-62,0},{-120,0}},
            color={0,0,127},
            smooth=Smooth.None));

        connect(ySet.y, limPID.u_s) annotation (Line(
            points={{-39,50},{-22,50}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(max.y, limPID.u_m) annotation (Line(
            points={{-39,0},{-10,0},{-10,38}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(limPID.y, product.u1) annotation (Line(
            points={{1,50},{10,50},{10,26},{18,26}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(pMaxSig.y, dp.u1) annotation (Line(
            points={{-39,-30},{-32,-30},{-32,-44},{-22,-44}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(pMinSig.y, dp.u2) annotation (Line(
            points={{-39,-70},{-30,-70},{-30,-56},{-22,-56}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(dp.y, product.u2) annotation (Line(
            points={{1,-50},{10,-50},{10,14},{18,14}},
            color={0,0,127},
            smooth=Smooth.None));

        connect(pMinSig.y, pSet.u2) annotation (Line(
            points={{-39,-70},{30,-70},{30,-6},{58,-6}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(pSet.y, y) annotation (Line(
            points={{81,0},{90.5,0},{90.5,0},{110,0}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(hysteresis.u, TOut) annotation (Line(
            points={{-62,80},{-120,80}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(product.y, switch1.u1) annotation (Line(
            points={{41,20},{50,20},{50,68},{58,68}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(zero.y, switch1.u3) annotation (Line(
            points={{41,52},{58,52}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(switch1.y, pSet.u1) annotation (Line(
            points={{81,60},{90,60},{90,20},{52,20},{52,6},{58,6}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(hysteresis.y, switch1.u2) annotation (Line(
            points={{-39,80},{46,80},{46,60},{58,60}},
            color={255,0,255},
            smooth=Smooth.None));
        annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}),
                               graphics), Icon(graphics={
              Text(
                extent={{-76,148},{50,-26}},
                textString="PSet",
                lineColor={0,0,127}),
              Text(
                extent={{-10,8},{44,-82}},
                lineColor={0,0,127},
                textString="%pMax"),
              Text(
                extent={{-16,-54},{48,-90}},
                lineColor={0,0,127},
                textString="%pMin")}));
      end DuctStaticPressureSetpoint;

      block CoolingCoilTemperatureSetpoint
      "Set point scheduler for cooling coil"
        extends Modelica.Blocks.Interfaces.BlockIcon;
        import LearnGB.VAVReheat.Controls.OperationModes;

        parameter Modelica.SIunits.Temperature TCooOn=273.15+12
        "Cooling setpoint during on";
        parameter Modelica.SIunits.Temperature TCooOff=273.15+30
        "Cooling setpoint during off";

        Modelica.Blocks.Sources.RealExpression TSupSetCoo(
         y=if (mode.y == OperationModes.occupied or mode.y == OperationModes.unoccupiedPreCool or mode.y == OperationModes.safety) then
                TCooOn else TCooOff)
        "Supply air temperature setpoint for cooling"
          annotation (Placement(transformation(extent={{-22,-50},{-2,-30}})));
        Modelica.Blocks.Interfaces.RealInput TSetHea
        "Set point for heating coil"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}},
              rotation=0)));
        Modelica.Blocks.Math.Add add
          annotation (Placement(transformation(extent={{20,-10},{40,10}})));
        Modelica.Blocks.Sources.Constant dTMin(k=1)
        "Minimum offset for cooling coil setpoint"
          annotation (Placement(transformation(extent={{-20,10},{0,30}})));
        Modelica.Blocks.Math.Max max1
          annotation (Placement(transformation(extent={{60,-30},{80,-10}})));
        ControlBus controlBus
          annotation (Placement(transformation(extent={{-28,-90},{-8,-70}})));
        Modelica.Blocks.Routing.IntegerPassThrough mode
          annotation (Placement(transformation(extent={{40,-90},{60,-70}})));
        Modelica.Blocks.Interfaces.RealOutput TSet "Temperature set point"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));
      equation
        connect(dTMin.y, add.u1) annotation (Line(
            points={{1,20},{10,20},{10,6},{18,6}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(add.y, max1.u1) annotation (Line(
            points={{41,0},{52,0},{52,-14},{58,-14}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(TSupSetCoo.y, max1.u2) annotation (Line(
            points={{-1,-40},{20,-40},{20,-26},{58,-26}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(controlBus.controlMode, mode.u) annotation (Line(
            points={{-18,-80},{38,-80}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(max1.y, TSet) annotation (Line(
            points={{81,-20},{86,-20},{86,0},{110,0},{110,0}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(TSetHea, add.u2) annotation (Line(
            points={{-120,0},{-52,0},{-52,-6},{18,-6}},
            color={0,0,127},
            smooth=Smooth.None));
        annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics), Icon(graphics={
              Text(
                extent={{44,16},{90,-18}},
                lineColor={0,0,255},
                textString="TSetCoo"),
              Text(
                extent={{-88,22},{-20,-26}},
                lineColor={0,0,255},
                textString="TSetHea")}));
      end CoolingCoilTemperatureSetpoint;

      model MixedAirTemperatureSetpoint
      "Mixed air temperature setpoint for economizer"
        extends Modelica.Blocks.Interfaces.BlockIcon;
        Modelica.Blocks.Routing.Extractor TSetMix(nin=6)
        "Mixed air setpoint temperature extractor"
          annotation (Placement(transformation(extent={{60,0},{80,20}})));
        Modelica.Blocks.Sources.Constant off(k=273.15 + 13)
        "Setpoint temperature to close damper"
          annotation (Placement(transformation(extent={{-80,20},{-60,40}})));
        Buildings.Utilities.Math.Average ave(nin=2)
          annotation (Placement(transformation(extent={{-20,-70},{0,-50}})));
        Modelica.Blocks.Interfaces.RealInput TSupHeaSet
        "Supply temperature setpoint for heating"
          annotation (Placement(transformation(extent={{-140,40},{-100,80}},
              rotation=0), iconTransformation(extent={{-140,40},{-100,80}})));
        Modelica.Blocks.Interfaces.RealInput TSupCooSet
        "Supply temperature setpoint for cooling"
          annotation (Placement(transformation(extent={{-140,-80},{-100,-40}},
              rotation=0)));
        Modelica.Blocks.Sources.Constant TPreCoo(k=273.15 + 13)
        "Setpoint during pre-cooling"
          annotation (Placement(transformation(extent={{-80,-20},{-60,0}})));
        ControlBus controlBus
          annotation (Placement(transformation(extent={{-40,60},{-20,80}})));
        Modelica.Blocks.Interfaces.RealOutput TSet
        "Mixed air temperature setpoint"
          annotation (Placement(transformation(extent={{100,0},{120,20}})));
        Modelica.Blocks.Routing.Multiplex2 multiplex2_1
          annotation (Placement(transformation(extent={{-60,-70},{-40,-50}})));
      equation

        connect(TSetMix.u[1], ave.y) annotation (Line(
            points={{58,8.33333},{14,8.33333},{14,-60},{1,-60}},
            color={0,0,127},
            smooth=Smooth.None));

        connect(ave.y, TSetMix.u[1])     annotation (Line(
            points={{1,-60},{42,-60},{42,8.33333},{58,8.33333}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(off.y, TSetMix.u[2]) annotation (Line(
            points={{-59,30},{40,30},{40,12},{58,12},{58,9}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(off.y, TSetMix.u[3]) annotation (Line(
            points={{-59,30},{40,30},{40,9.66667},{58,9.66667}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(off.y, TSetMix.u[4]) annotation (Line(
            points={{-59,30},{9.5,30},{9.5,10.3333},{58,10.3333}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(TPreCoo.y, TSetMix.u[5]) annotation (Line(
            points={{-59,-10},{0,-10},{0,11},{58,11}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(off.y, TSetMix.u[6]) annotation (Line(
            points={{-59,30},{40,30},{40,11.6667},{58,11.6667}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(controlBus.controlMode, TSetMix.index) annotation (Line(
            points={{-30,70},{-30,-14},{70,-14},{70,-2}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(TSetMix.y, TSet) annotation (Line(
            points={{81,10},{110,10}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(multiplex2_1.y, ave.u) annotation (Line(
            points={{-39,-60},{-22,-60}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(TSupCooSet, multiplex2_1.u2[1]) annotation (Line(
            points={{-120,-60},{-90,-60},{-90,-66},{-62,-66}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(TSupHeaSet, multiplex2_1.u1[1]) annotation (Line(
            points={{-120,60},{-90,60},{-90,-54},{-62,-54}},
            color={0,0,127},
            smooth=Smooth.None));
        annotation (Diagram(graphics));
      end MixedAirTemperatureSetpoint;

      block EconomizerTemperatureControl
      "Controller for economizer mixed air temperature"
        extends Modelica.Blocks.Interfaces.BlockIcon;
        import LearnGB.VAVReheat.Controls.OperationModes;
        Buildings.Controls.Continuous.LimPID con(
          k=k,
          Ti=Ti,
          yMax=0.995,
          yMin=0.005,
          Td=60,
          controllerType=Modelica.Blocks.Types.SimpleController.P)
        "Controller for mixed air temperature"
          annotation (Placement(transformation(extent={{60,-10},{80,10}})));
        parameter Real k=1 "Gain of controller";
        parameter Modelica.SIunits.Time Ti "Time constant of Integrator block";
        Modelica.Blocks.Logical.Greater signGain "Sign of control gain"
          annotation (Placement(transformation(extent={{-60,50},{-40,70}})));
        Modelica.Blocks.Logical.Switch swi1
          annotation (Placement(transformation(extent={{0,-10},{20,10}})));
        Modelica.Blocks.Logical.Switch swi2
          annotation (Placement(transformation(extent={{0,-50},{20,-30}})));
        Modelica.Blocks.Interfaces.RealOutput yOA
        "Control signal for outside air damper"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        Modelica.Blocks.Interfaces.RealInput TRet "Return air temperature"
          annotation (Placement(transformation(extent={{-140,40},{-100,80}})));
        Modelica.Blocks.Interfaces.RealInput TOut "Outside air temperature"
          annotation (Placement(transformation(extent={{-140,0},{-100,40}})));
        Modelica.Blocks.Interfaces.RealInput TMix "Mixed air temperature"
          annotation (Placement(transformation(extent={{-140,-40},{-100,0}})));
        Modelica.Blocks.Interfaces.RealInput TMixSet
        "Setpoint for mixed air temperature"
          annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));
      equation
        connect(signGain.y, swi1.u2)
                                    annotation (Line(
            points={{-39,60},{-12,60},{-12,6.66134e-16},{-2,6.66134e-16}},
            color={255,0,255},
            smooth=Smooth.None));

        connect(swi1.y, con.u_s)    annotation (Line(
            points={{21,6.10623e-16},{30,0},{40,1.27676e-15},{40,6.66134e-16},{58,
                6.66134e-16}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(swi2.y, con.u_m)    annotation (Line(
            points={{21,-40},{70,-40},{70,-12}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(signGain.y, swi2.u2) annotation (Line(
            points={{-39,60},{-12,60},{-12,-40},{-2,-40}},
            color={255,0,255},
            smooth=Smooth.None));
        connect(con.y, yOA)    annotation (Line(
            points={{81,6.10623e-16},{90.5,6.10623e-16},{90.5,5.55112e-16},{110,
                5.55112e-16}},
            color={0,0,127},
            smooth=Smooth.None));

        connect(signGain.u1, TRet) annotation (Line(
            points={{-62,60},{-120,60}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(signGain.u2, TOut) annotation (Line(
            points={{-62,52},{-80,52},{-80,20},{-120,20}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(swi1.u1, TMix) annotation (Line(
            points={{-2,8},{-80,8},{-80,-20},{-120,-20}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(swi2.u3, TMix) annotation (Line(
            points={{-2,-48},{-80,-48},{-80,-20},{-120,-20}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(swi1.u3, TMixSet) annotation (Line(
            points={{-2,-8},{-60,-8},{-60,-60},{-120,-60}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(swi2.u1, TMixSet) annotation (Line(
            points={{-2,-32},{-60,-32},{-60,-60},{-120,-60}},
            color={0,0,127},
            smooth=Smooth.None));
        annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                  {100,100}}),       graphics), Icon(coordinateSystem(
                preserveAspectRatio=true, extent={{-100,-100},{100,100}}), graphics={
              Text(
                extent={{-92,78},{-66,50}},
                lineColor={0,0,127},
                textString="TRet"),
              Text(
                extent={{-88,34},{-62,6}},
                lineColor={0,0,127},
                textString="TOut"),
              Text(
                extent={{-86,-6},{-60,-34}},
                lineColor={0,0,127},
                textString="TMix"),
              Text(
                extent={{-84,-46},{-58,-74}},
                lineColor={0,0,127},
                textString="TMixSet"),
              Text(
                extent={{64,14},{90,-14}},
                lineColor={0,0,127},
                textString="yOA")}));
      end EconomizerTemperatureControl;
    end Controls;

    package ThermalZones "Package with models for the thermal zones"
    extends Modelica.Icons.VariantsPackage;

      model VAVBranch "Supply branch of a VAV system"
        replaceable package MediumA = Modelica.Media.Interfaces.PartialMedium
        "Medium model for air"   annotation (choicesAllMatching=true);
        replaceable package MediumW = Modelica.Media.Interfaces.PartialMedium
        "Medium model for water"   annotation (choicesAllMatching=true);

        Buildings.Fluid.Actuators.Dampers.VAVBoxExponential vav(
          redeclare package Medium = MediumA,
          m_flow_nominal=m_flow_nominal,
          A=0.6,
          use_v_nominal=true,
          dp_nominal(displayUnit="Pa") = 220 + 20) "VAV box for room" annotation (
            Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={50,104})));
        Buildings.Fluid.HeatExchangers.DryEffectivenessNTU terHea(
          redeclare package Medium1 = MediumA,
          redeclare package Medium2 = MediumW,
          m1_flow_nominal=m_flow_nominal,
          dp2_nominal=6000,
          m2_flow_nominal=m_flow_nominal*1000*(50 - 17)/4200/10,
          Q_flow_nominal=m_flow_nominal*1006*(50 - 16.7),
          configuration=Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow,
          dp1_nominal=0,
          from_dp2=true,
          T_a1_nominal=289.85,
          T_a2_nominal=355.35) "Heat exchanger of terminal box" annotation (Placement(
              transformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={56,44})));

        Buildings.Fluid.Sources.FixedBoundary sinTer(
          redeclare package Medium = MediumW,
          p(displayUnit="Pa") = 3E5,
          nPorts=1) "Sink for terminal box " annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=180,
              origin={132,24})));
        Modelica.Fluid.Interfaces.FluidPort_a port_a(redeclare package Medium
          =   MediumA)
        "Fluid connector a1 (positive design flow direction is from port_a1 to port_b1)"
          annotation (Placement(transformation(extent={{40,-36},{60,-16}}),
              iconTransformation(extent={{40,-36},{60,-16}})));
        Modelica.Fluid.Interfaces.FluidPort_a port_b(redeclare package Medium
          =   MediumA)
        "Fluid connector b (positive design flow direction is from port_a1 to port_b1)"
          annotation (Placement(transformation(extent={{40,190},{60,210}}),
              iconTransformation(extent={{40,190},{60,210}})));
        parameter Modelica.SIunits.MassFlowRate m_flow_nominal
        "Mass flow rate of this thermal zone";

        parameter Modelica.SIunits.Volume VRoo "Room volume";
        Controls.RoomVAV con "Room temperature controller"
          annotation (Placement(transformation(extent={{0,-6},{20,14}})));
        Controls.ControlBus controlBus annotation (Placement(transformation(extent={{
                  -110,-50},{-90,-30}}), iconTransformation(extent={{-110,-38},{-90,-18}})));
        Buildings.Fluid.Sensors.MassFlowRate senMasFlo(redeclare package Medium
          =   MediumA) "Sensor for mass flow rate" annotation (Placement(
              transformation(
              extent={{-10,10},{10,-10}},
              rotation=90,
              origin={50,134})));
        Modelica.Blocks.Math.Gain fraMasFlo(k=1/m_flow_nominal)
        "Fraction of mass flow rate, relative to nominal flow"
          annotation (Placement(transformation(extent={{102,134},{122,154}})));
        Buildings.Fluid.Sensors.TemperatureTwoPort TSup(
          redeclare package Medium = MediumA,
          m_flow_nominal=m_flow_nominal,
          initType=Modelica.Blocks.Types.Init.InitialState)
        "Supply air temperature"
          annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={50,74})));
        Modelica.Blocks.Interfaces.RealOutput yDam "Signal for VAV damper"
          annotation (Placement(transformation(extent={{200,-10},{220,10}})));
        Modelica.Blocks.Math.Gain ACH(k=1/VRoo/1.2*3600) "Air change per hour"
          annotation (Placement(transformation(extent={{100,94},{120,114}})));
        Buildings.Fluid.Actuators.Valves.TwoWayLinear valHea(
          redeclare package Medium = MediumW,
          m_flow_nominal=m_flow_nominal*1000*15/4200/10,
          CvData=Buildings.Fluid.Types.CvTypes.OpPoint,
          from_dp=true) "Valve at reaheat coil"
          annotation (Placement(transformation(extent={{82,34},{102,14}})));
        Buildings.Fluid.Sources.FixedBoundary souTer(
          redeclare package Medium = MediumW,
          p(displayUnit="Pa") = 3E5 + 12000,
          nPorts=1,
          T=323.15) "Source for terminal box " annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=180,
              origin={132,64})));
        Modelica.Blocks.Interfaces.RealInput TRoo "Measured room temperature"
          annotation (Placement(transformation(extent={{-140,80},{-100,120}})));
      equation
        connect(con.controlBus, controlBus) annotation (Line(
            points={{3,11.4},{3,-40},{-100,-40}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(fraMasFlo.u, senMasFlo.m_flow) annotation (Line(
            points={{100,144},{80,144},{80,134},{61,134}},
            color={0,0,127},
            smooth=Smooth.None));

        connect(TSup.T, con.TSup) annotation (Line(
            points={{39,74},{-20,74},{-20,0},{-2,0}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(con.yDam, vav.y) annotation (Line(
            points={{21,-1},{32,-1},{32,104},{42,104}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(terHea.port_b1, TSup.port_a) annotation (Line(
            points={{50,54},{50,64}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(TSup.port_b, vav.port_a) annotation (Line(
            points={{50,84},{50,94}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(vav.port_b, senMasFlo.port_a) annotation (Line(
            points={{50,114},{50,124}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(con.yDam, yDam) annotation (Line(
            points={{21,-1},{188,-1},{188,0},{210,0}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(ACH.u, senMasFlo.m_flow) annotation (Line(
            points={{98,104},{80,104},{80,134},{61,134}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(con.yHea, valHea.y) annotation (Line(
            points={{21,8},{92,8},{92,16}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(souTer.ports[1], terHea.port_a2) annotation (Line(
            points={{122,64},{62,64},{62,54}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(terHea.port_b2, valHea.port_a) annotation (Line(
            points={{62,34},{62,24},{82,24}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(valHea.port_b, sinTer.ports[1]) annotation (Line(
            points={{102,24},{122,24}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(port_a, terHea.port_a1) annotation (Line(
            points={{50,-26},{50,34}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(senMasFlo.port_b, port_b) annotation (Line(
            points={{50,144},{50,200}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(con.TRoo, TRoo) annotation (Line(
            points={{-2,8},{-60,8},{-60,100},{-120,100}},
            color={0,0,127},
            smooth=Smooth.None));
        annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{200,200}}), graphics), Icon(coordinateSystem(
                preserveAspectRatio=true, extent={{-100,-100},{200,200}}), graphics={
              Rectangle(
                extent={{-100,200},{200,-100}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-160.5,-16.1286},{139.5,-20.1286}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={0,127,255},
                origin={31.8714,60.5},
                rotation=90),
              Rectangle(
                extent={{36,42},{66,16}},
                fillPattern=FillPattern.Solid,
                fillColor={175,175,175},
                pattern=LinePattern.None),
              Rectangle(
                extent={{72,-20},{92,-40}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192},
                origin={20,52},
                rotation=90),
              Rectangle(
                extent={{73,-10},{93,-22}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={0,127,255},
                origin={34,51},
                rotation=90),
              Polygon(
                points={{36,128},{64,144},{64,142},{36,126},{36,128}},
                pattern=LinePattern.None,
                smooth=Smooth.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,0}),
              Polygon(
                points={{36,36},{60,36},{60,34},{36,34},{36,36}},
                pattern=LinePattern.None,
                smooth=Smooth.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,0}),
              Polygon(
                points={{36,24},{60,24},{60,22},{36,22},{36,24}},
                pattern=LinePattern.None,
                smooth=Smooth.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,0}),
              Polygon(
                points={{46,30},{60,36},{60,34},{46,28},{46,30}},
                pattern=LinePattern.None,
                smooth=Smooth.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,0}),
              Polygon(
                points={{46,30},{60,24},{60,22},{46,28},{46,30}},
                pattern=LinePattern.None,
                smooth=Smooth.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,0}),
              Text(
                extent={{-78,198},{24,156}},
                lineColor={0,0,255},
                textString="%name"),
              Text(
                extent={{126,24},{194,-20}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                textString="yDam"),
              Text(
                extent={{144,194},{184,168}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                textString="p_rel"),
              Text(
                extent={{144,154},{192,122}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                textString="TRooAir")}));
      end VAVBranch;

      model Floor "Model of a floor of the building"
        replaceable package Medium = Modelica.Media.Interfaces.PartialMedium
        "Medium model for air"   annotation (choicesAllMatching=true);
        parameter Modelica.SIunits.Angle lat "Latitude";
        parameter Modelica.SIunits.Volume VSou
        "Room volume for sourth perimeter zone and so on";
        parameter Modelica.SIunits.Volume VNor;
        parameter Modelica.SIunits.Volume VEas;
        parameter Modelica.SIunits.Volume VWes;
        parameter Modelica.SIunits.Volume VCor;
        parameter Modelica.SIunits.Volume VNorEas;
        parameter Modelica.SIunits.Volume VNorWes;
        parameter Modelica.SIunits.Volume VSouEas;
        parameter Modelica.SIunits.Volume VSouWes;
        parameter Real winWalRat(
          min=0.01,
          max=0.99) = 0.33 "Window to wall ratio for exterior walls";
        Buildings.HeatTransfer.Data.Solids.Plywood matFur(x=0.15, nStaRef=5)
        "Material for furniture"
          annotation (Placement(transformation(extent={{140,460},{160,480}})));
        Buildings.HeatTransfer.Data.Resistances.Carpet matCar "Carpet"
          annotation (Placement(transformation(extent={{180,460},{200,480}})));
        Buildings.HeatTransfer.Data.Solids.Concrete matCon(
          x=0.1,
          k=1.311,
          c=836,
          nStaRef=5) "Concrete"
          annotation (Placement(transformation(extent={{140,430},{160,450}})));
        Buildings.HeatTransfer.Data.Solids.Plywood matWoo(
          x=0.01,
          k=0.11,
          d=544,
          nStaRef=1) "Wood for exterior construction"
          annotation (Placement(transformation(extent={{140,400},{160,420}})));
        Buildings.HeatTransfer.Data.Solids.Generic matIns(
          x=0.087,
          k=0.049,
          c=836.8,
          d=265,
          nStaRef=5) "Steelframe construction with insulation"
          annotation (Placement(transformation(extent={{180,400},{200,420}})));
        Buildings.HeatTransfer.Data.Solids.GypsumBoard matGyp(
          x=0.0127,
          k=0.16,
          c=830,
          d=784,
          nStaRef=2) "Gypsum board"
          annotation (Placement(transformation(extent={{138,372},{158,392}})));
        Buildings.HeatTransfer.Data.Solids.GypsumBoard matGyp2(
          x=0.025,
          k=0.16,
          c=830,
          d=784,
          nStaRef=2) "Gypsum board"
          annotation (Placement(transformation(extent={{178,372},{198,392}})));
        Buildings.HeatTransfer.Data.OpaqueConstructions.Generic conExtWal(final
            nLay=3, material={matWoo,matIns,matGyp}) "Exterior construction"
          annotation (Placement(transformation(extent={{280,460},{300,480}})));
        Buildings.HeatTransfer.Data.OpaqueConstructions.Generic conIntWal(final
            nLay=1, material={matGyp2}) "Interior wall construction"
          annotation (Placement(transformation(extent={{320,460},{340,480}})));
        Buildings.HeatTransfer.Data.OpaqueConstructions.Generic conFlo(final
            nLay=1, material={matCon}) "Floor construction (opa_a is carpet)"
          annotation (Placement(transformation(extent={{280,436},{300,456}})));
        Buildings.HeatTransfer.Data.OpaqueConstructions.Generic conFur(final
            nLay=1, material={matFur})
        "Construction for internal mass of furniture"
          annotation (Placement(transformation(extent={{320,438},{340,458}})));
        Buildings.HeatTransfer.Data.Solids.Plywood matCarTra(
          k=0.11,
          d=544,
          nStaRef=1,
          x=0.215/0.11) "Wood for floor"
          annotation (Placement(transformation(extent={{102,460},{122,480}})));
        Buildings.HeatTransfer.Data.GlazingSystems.DoubleClearAir13Clear glaSys(
          UFra=2,
          shade=Buildings.HeatTransfer.Data.Shades.Gray(),
          haveInteriorShade=false,
          haveExteriorShade=false) "Data record for the glazing system"
          annotation (Placement(transformation(extent={{240,460},{260,480}})));
        constant Modelica.SIunits.Height hRoo=2.74 "Room height";
        Buildings.Rooms.MixedAir sou(
          redeclare package Medium = Medium,
          lat=lat,
          AFlo=VSou/hRoo,
          hRoo=hRoo,
          nConExt=0,
          nConExtWin=1,
          nConPar=2,
          nConBou=3,
          nSurBou=0,
          nPorts=5,
          intConMod=intConMod,
          datConExtWin(
            layers={conExtWal},
            A={40.76*hRoo},
            glaSys={glaSys},
            AWin={winWalRat*40.76*hRoo},
            fFra={0.1},
            til={Buildings.HeatTransfer.Types.Tilt.Wall},
            azi={Buildings.HeatTransfer.Types.Azimuth.S}),
          datConPar(
            layers={conFlo,conFur},
            A={VSou/hRoo,405.54},
            til={Buildings.HeatTransfer.Types.Tilt.Floor,Buildings.HeatTransfer.Types.Tilt.Wall}),
          datConBou(
            layers={conIntWal,conIntWal,conIntWal},
            A={4.57,40.76,4.57}*hRoo,
            til={Buildings.HeatTransfer.Types.Tilt.Wall,Buildings.HeatTransfer.Types.Tilt.Wall,
                Buildings.HeatTransfer.Types.Tilt.Wall})) "South zone"
          annotation (Placement(transformation(extent={{144,-44},{184,-4}})));

        Buildings.Rooms.MixedAir eas(
          redeclare package Medium = Medium,
          lat=lat,
          AFlo=VEas/hRoo,
          hRoo=hRoo,
          nConExt=0,
          nConExtWin=1,
          nConPar=2,
          nConBou=1,
          datConBou(
            layers={conIntWal},
            A={24.13}*hRoo,
            til={Buildings.HeatTransfer.Types.Tilt.Wall}),
          nSurBou=2,
          nPorts=5,
          intConMod=intConMod,
          datConExtWin(
            layers={conExtWal},
            A={24.13*hRoo},
            glaSys={glaSys},
            AWin={winWalRat*24.13*hRoo},
            fFra={0.1},
            til={Buildings.HeatTransfer.Types.Tilt.Wall},
            azi={Buildings.HeatTransfer.Types.Azimuth.E}),
          datConPar(
            layers={conFlo,conFur},
            A={VEas/hRoo,253.38},
            til={Buildings.HeatTransfer.Types.Tilt.Floor,Buildings.HeatTransfer.Types.Tilt.Wall}),
          surBou(
            each A=4.57*hRoo,
            each absIR=0.9,
            each absSol=0.9,
            til={Buildings.HeatTransfer.Types.Tilt.Wall,Buildings.HeatTransfer.Types.Tilt.Wall}))
        "East zone"
          annotation (Placement(transformation(extent={{304,56},{344,96}})));

        Buildings.Rooms.MixedAir nor(
          redeclare package Medium = Medium,
          lat=lat,
          AFlo=VNor/hRoo,
          hRoo=hRoo,
          nConExt=0,
          nConExtWin=1,
          nConPar=2,
          nConBou=3,
          nSurBou=0,
          nPorts=5,
          intConMod=intConMod,
          datConExtWin(
            layers={conExtWal},
            A={40.76*hRoo},
            glaSys={glaSys},
            AWin={winWalRat*40.76*hRoo},
            fFra={0.1},
            til={Buildings.HeatTransfer.Types.Tilt.Wall},
            azi={Buildings.HeatTransfer.Types.Azimuth.N}),
          datConPar(
            layers={conFlo,conFur},
            A={VNor/hRoo,405.54},
            til={Buildings.HeatTransfer.Types.Tilt.Floor,Buildings.HeatTransfer.Types.Tilt.Wall}),
          datConBou(
            layers={conIntWal,conIntWal,conIntWal},
            A={4.57,40.76,4.57}*hRoo,
            til={Buildings.HeatTransfer.Types.Tilt.Wall,Buildings.HeatTransfer.Types.Tilt.Wall,
                Buildings.HeatTransfer.Types.Tilt.Wall})) "North zone"
          annotation (Placement(transformation(extent={{144,118},{184,158}})));

        Buildings.Rooms.MixedAir wes(
          redeclare package Medium = Medium,
          lat=lat,
          AFlo=VWes/hRoo,
          hRoo=hRoo,
          nConExt=0,
          nConExtWin=1,
          nConPar=2,
          nConBou=1,
          datConBou(
            layers={conIntWal},
            A={24.13}*hRoo,
            til={Buildings.HeatTransfer.Types.Tilt.Wall}),
          nSurBou=2,
          nPorts=5,
          intConMod=intConMod,
          datConExtWin(
            layers={conExtWal},
            A={24.13*hRoo},
            glaSys={glaSys},
            AWin={winWalRat*24.13*hRoo},
            fFra={0.1},
            til={Buildings.HeatTransfer.Types.Tilt.Wall},
            azi={Buildings.HeatTransfer.Types.Azimuth.W}),
          datConPar(
            layers={conFlo,conFur},
            A={VWes/hRoo,253.38},
            til={Buildings.HeatTransfer.Types.Tilt.Floor,Buildings.HeatTransfer.Types.Tilt.Wall}),
          surBou(
            each A=4.57*hRoo,
            each absIR=0.9,
            each absSol=0.9,
            til={Buildings.HeatTransfer.Types.Tilt.Wall,Buildings.HeatTransfer.Types.Tilt.Wall}))
        "West zone"
          annotation (Placement(transformation(extent={{12,36},{52,76}})));

        Buildings.Rooms.MixedAir cor(
          redeclare package Medium = Medium,
          lat=lat,
          AFlo=VCor/hRoo,
          hRoo=hRoo,
          nConExt=0,
          nConExtWin=0,
          nConPar=2,
          datConPar(
            layers={conFlo,conFur},
            A={360.0785/hRoo,262.52},
            til={Buildings.HeatTransfer.Types.Tilt.Floor,Buildings.HeatTransfer.Types.Tilt.Wall}),
          nConBou=0,
          nSurBou=4,
          surBou(
            A={40.76,24.13,40.76,24.13}*hRoo,
            each absIR=0.9,
            each absSol=0.9,
            til={Buildings.HeatTransfer.Types.Tilt.Wall,Buildings.HeatTransfer.Types.Tilt.Wall,
                Buildings.HeatTransfer.Types.Tilt.Wall,Buildings.HeatTransfer.Types.Tilt.Wall}),
          nPorts=15,
          intConMod=intConMod) "Core zone"
          annotation (Placement(transformation(extent={{144,36},{184,76}})));

        Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b portsSou[2](
            redeclare package Medium = Medium) "Fluid inlets and outlets"
          annotation (Placement(transformation(extent={{70,-42},{110,-26}}),
              iconTransformation(extent={{120,-38},{160,-22}})));
        Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b portsEas[2](
            redeclare package Medium = Medium) "Fluid inlets and outlets"
          annotation (Placement(transformation(extent={{348,42},{388,58}}),
              iconTransformation(extent={{308,40},{348,56}})));
        Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b portsNor[2](
            redeclare package Medium = Medium) "Fluid inlets and outlets"
          annotation (Placement(transformation(extent={{70,118},{110,134}}),
              iconTransformation(extent={{120,122},{160,138}})));
        Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b portsWes[2](
            redeclare package Medium = Medium) "Fluid inlets and outlets"
          annotation (Placement(transformation(extent={{-74,38},{-34,54}})));
        Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b portsCor[2](
            redeclare package Medium = Medium) "Fluid inlets and outlets"
          annotation (Placement(transformation(extent={{70,38},{110,54}}),
              iconTransformation(extent={{120,42},{160,58}})));
        Modelica.Blocks.Math.MatrixGain gai(K=20*[0.4; 0.4; 0.2])
        "Matrix gain to split up heat gain in radiant, convective and latent gain"
          annotation (Placement(transformation(extent={{-50,100},{-30,120}})));
        Modelica.Blocks.Sources.Constant uSha(k=0)
        "Control signal for the shading device"
          annotation (Placement(transformation(extent={{-96,170},{-76,190}})));
        Modelica.Blocks.Routing.Replicator replicator(nout=1)
          annotation (Placement(transformation(extent={{-58,170},{-38,190}})));
        Buildings.BoundaryConditions.WeatherData.Bus weaBus "Weather bus"
          annotation (Placement(transformation(extent={{200,190},{220,210}})));
        RoomLeakage leaSou(redeclare package Medium = Medium, VRoo=VSou,
          s=49.91/33.27,
          azi=Buildings.HeatTransfer.Types.Azimuth.S)
        "Model for air infiltration through the envelope"
          annotation (Placement(transformation(extent={{-58,336},{-22,376}})));
        RoomLeakage leaEas(redeclare package Medium = Medium, VRoo=VEas,
          s=33.27/49.91,
          azi=Buildings.HeatTransfer.Types.Azimuth.E)
        "Model for air infiltration through the envelope"
          annotation (Placement(transformation(extent={{-58,306},{-22,346}})));
        RoomLeakage leaNor(redeclare package Medium = Medium, VRoo=VNor,
          s=49.91/33.27,
          azi=Buildings.HeatTransfer.Types.Azimuth.N)
        "Model for air infiltration through the envelope"
          annotation (Placement(transformation(extent={{-58,274},{-22,314}})));
        RoomLeakage leaWes(redeclare package Medium = Medium, VRoo=VWes,
          s=33.27/49.91,
          azi=Buildings.HeatTransfer.Types.Azimuth.W)
        "Model for air infiltration through the envelope"
          annotation (Placement(transformation(extent={{-58,242},{-22,282}})));
        Modelica.Thermal.HeatTransfer.Sensors.TemperatureSensor temAirSou
        "Air temperature sensor"
          annotation (Placement(transformation(extent={{290,402},{310,422}})));
        Modelica.Thermal.HeatTransfer.Sensors.TemperatureSensor temAirEas
        "Air temperature sensor"
          annotation (Placement(transformation(extent={{290,374},{310,394}})));
        Modelica.Thermal.HeatTransfer.Sensors.TemperatureSensor temAirNor
        "Air temperature sensor"
          annotation (Placement(transformation(extent={{290,346},{310,366}})));
        Modelica.Thermal.HeatTransfer.Sensors.TemperatureSensor temAirWes
        "Air temperature sensor"
          annotation (Placement(transformation(extent={{292,318},{312,338}})));
        Modelica.Thermal.HeatTransfer.Sensors.TemperatureSensor temAirCor
        "Air temperature sensor"
          annotation (Placement(transformation(extent={{292,290},{312,310}})));
        Modelica.Blocks.Interfaces.RealOutput TRooAir[9]
        "Room air temperatures"
          annotation (Placement(transformation(extent={{380,150},{400,170}}),
              iconTransformation(extent={{380,150},{400,170}})));
        Buildings.Airflow.Multizone.DoorDiscretizedOpen opeSouCor(redeclare
          package Medium =   Medium, wOpe=10)
        "Opening between perimeter1 and core"
          annotation (Placement(transformation(extent={{84,0},{104,20}})));
        Buildings.Airflow.Multizone.DoorDiscretizedOpen opeEasCor(redeclare
          package Medium =   Medium, wOpe=10)
        "Opening between perimeter2 and core"
          annotation (Placement(transformation(extent={{250,38},{270,58}})));
        Buildings.Airflow.Multizone.DoorDiscretizedOpen opeNorCor(redeclare
          package Medium =   Medium, wOpe=10)
        "Opening between perimeter3 and core"
          annotation (Placement(transformation(extent={{80,74},{100,94}})));
        Buildings.Airflow.Multizone.DoorDiscretizedOpen opeWesCor(redeclare
          package Medium =   Medium, wOpe=10)
        "Opening between perimeter3 and core"
          annotation (Placement(transformation(extent={{20,2},{40,22}})));
        Modelica.Blocks.Sources.CombiTimeTable intGaiFra(table=[0,0.05; 3600*8,0.05; 3600*9,0.9;
              3600*12,0.9; 3600*12,0.8; 3600*13,0.8; 3600*13,1; 3600*17,1; 3600*19,0.1; 3600*24,0.05], extrapolation=
              Modelica.Blocks.Types.Extrapolation.Periodic)
        "Fraction of internal heat gain"
          annotation (Placement(transformation(extent={{-100,100},{-80,120}})));
        Buildings.Fluid.Sensors.RelativePressure senRelPre(redeclare package
          Medium =   Medium) "Building pressure measurement"
          annotation (Placement(transformation(extent={{40,224},{60,244}})));
        Buildings.Fluid.Sources.Outside out(nPorts=1, redeclare package Medium
          =   Medium)
          annotation (Placement(transformation(extent={{-58,220},{-38,240}})));
        Modelica.Blocks.Interfaces.RealOutput p_rel
        "Relative pressure signal of building static pressure"   annotation (
            Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=180,
              origin={-110,206})));
        parameter Buildings.HeatTransfer.Types.InteriorConvection intConMod=Buildings.HeatTransfer.Types.InteriorConvection.Temperature
        "Convective heat transfer model for room-facing surfaces of opaque constructions";
        Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b portsNorEas[2](
            redeclare package Medium = Medium) "Fluid inlets and outlets"
          annotation (Placement(transformation(extent={{348,122},{388,138}}),
              iconTransformation(extent={{308,118},{348,134}})));
        Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b portsSouEas[2](
            redeclare package Medium = Medium) "Fluid inlets and outlets"
          annotation (Placement(transformation(extent={{348,-40},{388,-24}}),
              iconTransformation(extent={{308,-40},{348,-24}})));
        Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b portsSouWes[2](
            redeclare package Medium = Medium) "Fluid inlets and outlets"
          annotation (Placement(transformation(extent={{-50,-58},{-10,-42}})));
        Buildings.Rooms.MixedAir norWes(
          redeclare package Medium = Medium,
          lat=lat,
          hRoo=hRoo,
          nConExt=0,
          nConPar=2,
          intConMod=intConMod,
          nConExtWin=2,
          nConBou=1,
          nSurBou=1,
          datConExtWin(
            layers={conExtWal,conExtWal},
            A={4.57*hRoo,4.57*hRoo},
            glaSys={glaSys,glaSys},
            AWin={winWalRat*4.57*hRoo,winWalRat*4.57*hRoo},
            fFra={0.1,0.1},
            til={Buildings.HeatTransfer.Types.Tilt.Wall,Buildings.HeatTransfer.Types.Tilt.Wall},
            azi={Buildings.HeatTransfer.Types.Azimuth.N,Buildings.HeatTransfer.Types.Azimuth.W}),
          datConPar(
            layers={conFlo,conFur},
            A={VNorWes/hRoo,9.14},
            til={Buildings.HeatTransfer.Types.Tilt.Floor,Buildings.HeatTransfer.Types.Tilt.Wall}),
          datConBou(
            layers={conIntWal},
            A={4.57}*hRoo,
            til={Buildings.HeatTransfer.Types.Tilt.Wall}),
          surBou(
            each A=4.57*hRoo,
            each absIR=0.9,
            each absSol=0.9,
            each til=Buildings.HeatTransfer.Types.Tilt.Wall),
          nPorts=5,
          AFlo=VNorWes/hRoo) "Northwest zone"
          annotation (Placement(transformation(extent={{30,116},{70,156}})));

        Buildings.Rooms.MixedAir norEas(
          redeclare package Medium = Medium,
          lat=lat,
          AFlo=VNorEas/hRoo,
          hRoo=hRoo,
          nConExt=0,
          nConPar=2,
          nPorts=5,
          intConMod=intConMod,
          nConExtWin=2,
          nConBou=1,
          nSurBou=1,
          datConExtWin(
            layers={conExtWal,conExtWal},
            A={4.57,4.57}*hRoo,
            glaSys={glaSys,glaSys},
            AWin={winWalRat*4.57*hRoo,winWalRat*4.57*hRoo},
            fFra={0.1,0.1},
            til={Buildings.HeatTransfer.Types.Tilt.Wall,Buildings.HeatTransfer.Types.Tilt.Wall},
            azi={Buildings.HeatTransfer.Types.Azimuth.N,Buildings.HeatTransfer.Types.Azimuth.E}),
          datConPar(
            layers={conFlo,conFur},
            A={VNorEas/hRoo,9.14},
            til={Buildings.HeatTransfer.Types.Tilt.Floor,Buildings.HeatTransfer.Types.Tilt.Wall}),
          datConBou(
            layers={conIntWal},
            A={4.57}*hRoo,
            til={Buildings.HeatTransfer.Types.Tilt.Wall}),
          surBou(
            each A=4.57*hRoo,
            each absIR=0.9,
            each absSol=0.9,
            each til=Buildings.HeatTransfer.Types.Tilt.Wall)) "Northeast zone"
          annotation (Placement(transformation(extent={{304,120},{344,160}})));

        Buildings.Rooms.MixedAir souEas(
          redeclare package Medium = Medium,
          lat=lat,
          AFlo=VSouEas/hRoo,
          hRoo=hRoo,
          nConExt=0,
          nConPar=2,
          nPorts=5,
          intConMod=intConMod,
          nConExtWin=2,
          nConBou=1,
          nSurBou=1,
          datConExtWin(
            layers={conExtWal,conExtWal},
            A={4.57,4.57}*hRoo,
            glaSys={glaSys,glaSys},
            AWin={winWalRat*4.57*hRoo,winWalRat*4.57*hRoo},
            fFra={0.1,0.1},
            til={Buildings.HeatTransfer.Types.Tilt.Wall,Buildings.HeatTransfer.Types.Tilt.Wall},
            azi={Buildings.HeatTransfer.Types.Azimuth.S,Buildings.HeatTransfer.Types.Azimuth.E}),
          datConBou(
            layers={conIntWal},
            A={4.57}*hRoo,
            til={Buildings.HeatTransfer.Types.Tilt.Wall}),
          surBou(
            each A=4.57*hRoo,
            each absIR=0.9,
            each absSol=0.9,
            each til=Buildings.HeatTransfer.Types.Tilt.Wall),
          datConPar(
            layers={conFlo,conFur},
            A={VSouEas/hRoo,9.14},
            til={Buildings.HeatTransfer.Types.Tilt.Floor,Buildings.HeatTransfer.Types.Tilt.Wall}))
        "Southeast zone"
          annotation (Placement(transformation(extent={{308,-42},{348,-2}})));

        Buildings.Rooms.MixedAir souWes(
          redeclare package Medium = Medium,
          lat=lat,
          AFlo=VSouWes/hRoo,
          hRoo=hRoo,
          nConExt=0,
          nConPar=2,
          nPorts=5,
          intConMod=intConMod,
          nConExtWin=2,
          nConBou=1,
          nSurBou=1,
          datConExtWin(
            layers={conExtWal,conExtWal},
            A={4.57,4.57}*hRoo,
            glaSys={glaSys,glaSys},
            AWin={winWalRat*4.57*hRoo,winWalRat*4.57*hRoo},
            fFra={0.1,0.1},
            til={Buildings.HeatTransfer.Types.Tilt.Wall,Buildings.HeatTransfer.Types.Tilt.Wall},
            azi={Buildings.HeatTransfer.Types.Azimuth.S,Buildings.HeatTransfer.Types.Azimuth.W}),
          datConPar(
            layers={conFlo,conFur},
            A={VSouWes/hRoo,9.14},
            til={Buildings.HeatTransfer.Types.Tilt.Floor,Buildings.HeatTransfer.Types.Tilt.Wall}),
          datConBou(
            layers={conIntWal},
            A={4.57}*hRoo,
            til={Buildings.HeatTransfer.Types.Tilt.Wall}),
          surBou(
            each A=4.57*hRoo,
            each absIR=0.9,
            each absSol=0.9,
            each til=Buildings.HeatTransfer.Types.Tilt.Wall)) "Southwest zone"
          annotation (Placement(transformation(extent={{14,-52},{54,-12}})));

        Multiplex9 multiplex9_1
          annotation (Placement(transformation(extent={{346,280},{372,306}})));
        Modelica.Thermal.HeatTransfer.Sensors.TemperatureSensor temAirNorWes
        "Air temperature sensor"
          annotation (Placement(transformation(extent={{292,260},{312,280}})));
        Modelica.Thermal.HeatTransfer.Sensors.TemperatureSensor temAirNorEas
        "Air temperature sensor"
          annotation (Placement(transformation(extent={{292,232},{312,252}})));
        Modelica.Thermal.HeatTransfer.Sensors.TemperatureSensor temAirSouWes
        "Air temperature sensor"
          annotation (Placement(transformation(extent={{292,204},{312,224}})));
        Modelica.Thermal.HeatTransfer.Sensors.TemperatureSensor temAirSouEas
        "Air temperature sensor"
          annotation (Placement(transformation(extent={{292,176},{312,196}})));
        Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b portsNorWes[2](
            redeclare package Medium = Medium) "Fluid inlets and outlets"
          annotation (Placement(transformation(extent={{-78,128},{-38,144}})));
        Buildings.Airflow.Multizone.Orifice oriNorWes(redeclare package Medium
          =   Medium, A=0.2)
          annotation (Placement(transformation(extent={{92,138},{102,148}})));
        Buildings.Airflow.Multizone.Orifice oriSouWes(redeclare package Medium
          =   Medium, A=0.2)
          annotation (Placement(transformation(extent={{86,-86},{96,-76}})));
        Buildings.Airflow.Multizone.Orifice oriSouEas(redeclare package Medium
          =   Medium, A=0.2)
          annotation (Placement(transformation(extent={{282,-70},{272,-60}})));
        Buildings.Airflow.Multizone.Orifice oriNorEas(redeclare package Medium
          =   Medium, A=0.2)
          annotation (Placement(transformation(extent={{276,126},{266,136}})));
        RoomLeakage leaNorWes(
          redeclare package Medium = Medium,
          s=49.91/33.27,
          azi=Buildings.HeatTransfer.Types.Azimuth.N,
          VRoo=VNorWes) "Model for air infiltration through the envelope"
          annotation (Placement(transformation(extent={{-58,404},{-22,444}})));
        RoomLeakage leaNorWesW(
          redeclare package Medium = Medium,
          s=33.27/49.91,
          azi=Buildings.HeatTransfer.Types.Azimuth.W,
          VRoo=VNorWes) "Model for air infiltration through the envelope"
          annotation (Placement(transformation(extent={{-58,372},{-22,412}})));
        RoomLeakage leaSouWesW(
          redeclare package Medium = Medium,
          s=33.27/49.91,
          azi=Buildings.HeatTransfer.Types.Azimuth.W,
          VRoo=VSouWes) "Model for air infiltration through the envelope"
          annotation (Placement(transformation(extent={{-58,440},{-22,480}})));
        RoomLeakage leaSouWesS(
          redeclare package Medium = Medium,
          s=49.91/33.27,
          azi=Buildings.HeatTransfer.Types.Azimuth.S,
          VRoo=VSouWes) "Model for air infiltration through the envelope"
          annotation (Placement(transformation(extent={{2,440},{38,480}})));
        RoomLeakage leaNorEasN(
          redeclare package Medium = Medium,
          s=49.91/33.27,
          azi=Buildings.HeatTransfer.Types.Azimuth.N,
          VRoo=VNorEas) "Model for air infiltration through the envelope"
          annotation (Placement(transformation(extent={{2,404},{38,444}})));
        RoomLeakage leaNorEasE(
          redeclare package Medium = Medium,
          s=33.27/49.91,
          azi=Buildings.HeatTransfer.Types.Azimuth.E,
          VRoo=VNorEas) "Model for air infiltration through the envelope"
          annotation (Placement(transformation(extent={{2,372},{38,412}})));
        RoomLeakage leaSouEasS(
          redeclare package Medium = Medium,
          s=49.91/33.27,
          azi=Buildings.HeatTransfer.Types.Azimuth.S,
          VRoo=VSouEas) "Model for air infiltration through the envelope"
          annotation (Placement(transformation(extent={{2,336},{38,376}})));
        RoomLeakage leaSouEasE(
          redeclare package Medium = Medium,
          s=33.27/49.91,
          azi=Buildings.HeatTransfer.Types.Azimuth.E,
          VRoo=VSouEas) "Model for air infiltration through the envelope"
          annotation (Placement(transformation(extent={{2,296},{38,336}})));
      equation
        connect(uSha.y, replicator.u) annotation (Line(
            points={{-75,180},{-60,180}},
            color={0,0,127},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(replicator.y, nor.uSha) annotation (Line(
            points={{-37,180},{130,180},{130,154},{142,154}},
            color={0,0,127},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(replicator.y, wes.uSha) annotation (Line(
            points={{-37,180},{-6,180},{-6,72},{10,72}},
            color={0,0,127},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(replicator.y, eas.uSha) annotation (Line(
            points={{-37,180},{232,180},{232,92},{302,92}},
            color={0,0,127},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(replicator.y, sou.uSha) annotation (Line(
            points={{-37,180},{130,180},{130,-8},{142,-8}},
            color={0,0,127},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(replicator.y, cor.uSha) annotation (Line(
            points={{-37,180},{130,180},{130,72},{142,72}},
            color={0,0,127},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(gai.y, nor.qGai_flow)          annotation (Line(
            points={{-29,110},{120,110},{120,148},{142,148}},
            color={0,0,127},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(gai.y, cor.qGai_flow)          annotation (Line(
            points={{-29,110},{120,110},{120,66},{142,66}},
            color={0,0,127},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(gai.y, sou.qGai_flow)          annotation (Line(
            points={{-29,110},{120,110},{120,-14},{142,-14}},
            color={0,0,127},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(gai.y, eas.qGai_flow)          annotation (Line(
            points={{-29,110},{226,110},{226,86},{302,86}},
            color={0,0,127},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(gai.y, wes.qGai_flow)          annotation (Line(
            points={{-29,110},{-14,110},{-14,66},{10,66}},
            color={0,0,127},
            pattern=LinePattern.None,
            smooth=Smooth.None));
        connect(sou.weaBus, weaBus) annotation (Line(
            points={{181.9,-6.1},{181.9,8},{210,8},{210,200}},
            color={255,204,51},
            pattern=LinePattern.None,
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(eas.weaBus, weaBus) annotation (Line(
            points={{341.9,93.9},{341.9,120},{210,120},{210,200}},
            color={255,204,51},
            pattern=LinePattern.None,
            thickness=0.5,
            smooth=Smooth.None));
        connect(nor.weaBus, weaBus) annotation (Line(
            points={{181.9,155.9},{182,160},{182,168},{210,168},{210,200}},
            color={255,204,51},
            pattern=LinePattern.None,
            thickness=0.5,
            smooth=Smooth.None));
        connect(wes.weaBus, weaBus) annotation (Line(
            points={{49.9,73.9},{49.9,168},{210,168},{210,200}},
            color={255,204,51},
            pattern=LinePattern.None,
            thickness=0.5,
            smooth=Smooth.None));
        connect(cor.weaBus, weaBus) annotation (Line(
            points={{181.9,73.9},{181.9,90},{210,90},{210,200}},
            color={255,204,51},
            pattern=LinePattern.None,
            thickness=0.5,
            smooth=Smooth.None));
        connect(weaBus, leaSou.weaBus) annotation (Line(
            points={{210,200},{-80,200},{-80,356},{-58,356}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None));
        connect(weaBus, leaEas.weaBus) annotation (Line(
            points={{210,200},{-80,200},{-80,326},{-58,326}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None));
        connect(weaBus, leaNor.weaBus) annotation (Line(
            points={{210,200},{-80,200},{-80,294},{-58,294}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None));
        connect(weaBus, leaWes.weaBus) annotation (Line(
            points={{210,200},{-80,200},{-80,262},{-58,262}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None));
        connect(sou.heaPorAir, temAirSou.port) annotation (Line(
            points={{163,-24},{224,-24},{224,100},{264,100},{264,412},{290,412}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(eas.heaPorAir, temAirEas.port) annotation (Line(
            points={{323,76},{286,76},{286,384},{290,384}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(nor.heaPorAir, temAirNor.port) annotation (Line(
            points={{163,138},{164,138},{164,356},{290,356}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(wes.heaPorAir, temAirWes.port) annotation (Line(
            points={{31,56},{70,56},{70,114},{186,114},{186,328},{292,328}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(cor.heaPorAir, temAirCor.port)  annotation (Line(
            points={{163,56},{162,56},{162,300},{292,300}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(sou.ports[1], portsSou[1]) annotation (Line(
            points={{145.8,-34},{80,-34}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(sou.ports[2], portsSou[2]) annotation (Line(
            points={{147.4,-34},{100,-34}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(eas.ports[1], portsEas[1]) annotation (Line(
            points={{305.8,66},{300,66},{300,50},{358,50}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(eas.ports[2], portsEas[2]) annotation (Line(
            points={{307.4,66},{300,66},{300,50},{378,50}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(nor.ports[1], portsNor[1]) annotation (Line(
            points={{145.8,128},{112,128},{112,126},{80,126}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(nor.ports[2], portsNor[2]) annotation (Line(
            points={{147.4,128},{124,128},{124,126},{100,126}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(wes.ports[1], portsWes[1]) annotation (Line(
            points={{13.8,46},{-6,46},{-6,52},{-26,52},{-26,46},{-64,46}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(wes.ports[2], portsWes[2]) annotation (Line(
            points={{15.4,46},{0,46},{0,56},{-16,56},{-16,46},{-44,46}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(cor.ports[1], portsCor[1]) annotation (Line(
            points={{145.267,46},{80,46}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(cor.ports[2], portsCor[2]) annotation (Line(
            points={{145.8,46},{136,46},{136,48},{124,48},{124,46},{100,46}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(leaSou.port_b, sou.ports[3]) annotation (Line(
            points={{-22,356},{-2,356},{-2,-72},{134,-72},{134,-34},{149,-34}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(leaEas.port_b, eas.ports[3]) annotation (Line(
            points={{-22,326},{246,326},{246,66},{309,66}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(leaNor.port_b, nor.ports[3]) annotation (Line(
            points={{-22,294},{138,294},{138,128},{149,128}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(leaWes.port_b, wes.ports[3]) annotation (Line(
            points={{-22,262},{2,262},{2,46},{17,46}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(opeSouCor.port_b1, cor.ports[3]) annotation (Line(
            points={{104,16},{116,16},{116,46},{146.333,46}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(opeSouCor.port_a2, cor.ports[4]) annotation (Line(
            points={{104,4},{116,4},{116,46},{146.867,46}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(opeSouCor.port_a1, sou.ports[4]) annotation (Line(
            points={{84,16},{74,16},{74,-20},{134,-20},{134,-34},{150.6,-34}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(opeSouCor.port_b2, sou.ports[5]) annotation (Line(
            points={{84,4},{74,4},{74,-20},{134,-20},{134,-34},{152.2,-34}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(opeEasCor.port_b1, eas.ports[4]) annotation (Line(
            points={{270,54},{290,54},{290,66},{310.6,66}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(opeEasCor.port_a2, eas.ports[5]) annotation (Line(
            points={{270,42},{290,42},{290,66},{312.2,66}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(opeEasCor.port_a1, cor.ports[5]) annotation (Line(
            points={{250,54},{190,54},{190,34},{142,34},{142,46},{147.4,46}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(opeEasCor.port_b2, cor.ports[6]) annotation (Line(
            points={{250,42},{190,42},{190,34},{142,34},{142,46},{147.933,46}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(opeNorCor.port_b1, nor.ports[4]) annotation (Line(
            points={{100,90},{124,90},{124,128},{150.6,128}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(opeNorCor.port_a2, nor.ports[5]) annotation (Line(
            points={{100,78},{124,78},{124,128},{152.2,128}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(opeNorCor.port_a1, cor.ports[7]) annotation (Line(
            points={{80,90},{76,90},{76,60},{142,60},{142,46},{148.467,46}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(opeNorCor.port_b2, cor.ports[8]) annotation (Line(
            points={{80,78},{76,78},{76,60},{142,60},{142,46},{149,46}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(opeWesCor.port_b1, cor.ports[9]) annotation (Line(
            points={{40,18},{56,18},{56,34},{116,34},{116,46},{149.533,46}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(opeWesCor.port_a2, cor.ports[10]) annotation (Line(
            points={{40,6},{56,6},{56,34},{116,34},{116,46},{150.067,46}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(opeWesCor.port_a1, wes.ports[4]) annotation (Line(
            points={{20,18},{2,18},{2,46},{18.6,46}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(opeWesCor.port_b2, wes.ports[5]) annotation (Line(
            points={{20,6},{2,6},{2,46},{20.2,46}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(intGaiFra.y, gai.u) annotation (Line(
            points={{-79,110},{-52,110}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(cor.ports[11], senRelPre.port_b) annotation (Line(
            points={{150.6,46},{110,46},{110,234},{60,234}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(out.weaBus, weaBus) annotation (Line(
            points={{-58,230.2},{-70,230.2},{-70,230},{-80,230},{-80,200},{210,
                200}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(out.ports[1], senRelPre.port_a) annotation (Line(
            points={{-38,230},{2,230},{2,234},{40,234}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(senRelPre.p_rel, p_rel) annotation (Line(
            points={{50,225},{50,206},{-110,206}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(portsSouWes[1], souWes.ports[1]) annotation (Line(
            points={{-40,-50},{-6,-50},{-6,-42},{15.8,-42}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(portsSouWes[2], souWes.ports[2]) annotation (Line(
            points={{-20,-50},{-12,-50},{-12,-42},{17.4,-42}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(portsNorEas[1], norEas.ports[1]) annotation (Line(
            points={{358,130},{305.8,130}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(portsNorEas[2], norEas.ports[2]);
        connect(portsSouEas[1], souEas.ports[1]) annotation (Line(
            points={{358,-32},{309.8,-32}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(portsSouEas[2], souEas.ports[2]);
        connect(norWes.uSha, replicator.y) annotation (Line(
            points={{28,152},{6,152},{6,180},{-37,180}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(norEas.uSha, replicator.y) annotation (Line(
            points={{302,156},{262,156},{262,180},{-37,180}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(norWes.qGai_flow, gai.y) annotation (Line(
            points={{28,146},{0,146},{0,110},{-29,110}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(norEas.qGai_flow, gai.y) annotation (Line(
            points={{302,150},{226,150},{226,110},{-29,110}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(multiplex9_1.y, TRooAir) annotation (Line(
            points={{373.3,293},{390,293},{390,190},{374,190},{374,160},{390,160}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(temAirSou.T, multiplex9_1.u1[1]) annotation (Line(
            points={{310,412},{320,412},{320,306},{344.44,306}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(temAirEas.T, multiplex9_1.u2[1]) annotation (Line(
            points={{310,384},{322,384},{322,302.75},{344.44,302.75}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(temAirNor.T, multiplex9_1.u3[1]) annotation (Line(
            points={{310,356},{322,356},{322,299.5},{344.44,299.5}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(temAirWes.T, multiplex9_1.u4[1]) annotation (Line(
            points={{312,328},{322,328},{322,296.25},{344.44,296.25}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(temAirCor.T, multiplex9_1.u5[1]) annotation (Line(
            points={{312,300},{322,300},{322,293},{344.44,293}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(temAirNorWes.T, multiplex9_1.u6[1]) annotation (Line(
            points={{312,270},{322,270},{322,289.75},{344.44,289.75}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(temAirNorEas.T, multiplex9_1.u7[1]) annotation (Line(
            points={{312,242},{322,242},{322,286.5},{344.44,286.5}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(temAirSouWes.T, multiplex9_1.u8[1]) annotation (Line(
            points={{312,214},{322,214},{322,283.12},{344.44,283.12}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(temAirSouEas.T, multiplex9_1.u9[1]) annotation (Line(
            points={{312,186},{322,186},{322,280},{344.44,280}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(temAirNorWes.port, norWes.heaPorAir) annotation (Line(
            points={{292,270},{70,270},{70,212},{49,212},{49,136}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(temAirNorEas.port, norEas.heaPorAir) annotation (Line(
            points={{292,242},{276,242},{276,140},{323,140}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(temAirSouWes.port, souWes.heaPorAir) annotation (Line(
            points={{292,214},{292,-58},{33,-58},{33,-32}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(temAirSouEas.port, souEas.heaPorAir) annotation (Line(
            points={{292,186},{280,186},{280,-22},{327,-22}},
            color={191,0,0},
            smooth=Smooth.None));

        connect(norWes.weaBus, weaBus) annotation (Line(
            points={{67.9,153.9},{67.9,168},{210,168},{210,200}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None));
        connect(souWes.weaBus, weaBus) annotation (Line(
            points={{51.9,-14.1},{68,-14.1},{68,168},{210,168},{210,200}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None));
        connect(norEas.weaBus, weaBus) annotation (Line(
            points={{341.9,157.9},{341.9,168},{210,168},{210,200}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None));
        connect(souEas.weaBus, weaBus) annotation (Line(
            points={{345.9,-4.1},{345.9,8},{210,8},{210,200}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None));
        connect(souWes.uSha, replicator.y) annotation (Line(
            points={{12,-16},{-6,-16},{-6,180},{-37,180}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(souEas.uSha, replicator.y) annotation (Line(
            points={{306,-6},{232,-6},{232,180},{-37,180}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(souEas.qGai_flow, gai.y) annotation (Line(
            points={{306,-12},{226,-12},{226,110},{-29,110}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(souWes.qGai_flow, gai.y) annotation (Line(
            points={{12,-22},{-14,-22},{-14,110},{-29,110}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(nor.surf_conBou[1], norWes.surf_surBou[1]) annotation (Line(
            points={{170,121.333},{170,114},{46.2,114},{46.2,122}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(nor.surf_conBou[2], cor.surf_surBou[1]) annotation (Line(
            points={{170,122},{170,114},{186,114},{186,30},{160.2,30},{160.2,
                41.25}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(nor.surf_conBou[3], norEas.surf_surBou[1]) annotation (Line(
            points={{170,122.667},{170,114},{320.2,114},{320.2,126}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(eas.surf_conBou[1], cor.surf_surBou[2]) annotation (Line(
            points={{330,60},{330,30},{160.2,30},{160.2,41.75}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(norEas.surf_conBou[1], eas.surf_surBou[1]) annotation (Line(
            points={{330,124},{330,118},{350,118},{350,46},{320.2,46},{320.2,
                61.5}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(souEas.surf_conBou[1], eas.surf_surBou[2]) annotation (Line(
            points={{334,-38},{334,-44},{352,-44},{352,20},{320.2,20},{320.2,
                62.5}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(sou.surf_conBou[1], souEas.surf_surBou[1]) annotation (Line(
            points={{170,-40.6667},{170,-50},{324.2,-50},{324.2,-36}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(sou.surf_conBou[2], cor.surf_surBou[3]) annotation (Line(
            points={{170,-40},{170,-50},{186,-50},{186,30},{160.2,30},{160.2,
                42.25}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(souWes.surf_surBou[1], sou.surf_conBou[3]) annotation (Line(
            points={{30.2,-46},{30,-46},{30,-58},{170,-58},{170,-39.3333}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(wes.surf_conBou[1], cor.surf_surBou[4]) annotation (Line(
            points={{38,40},{38,30},{160.2,30},{160.2,42.75}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(souWes.surf_conBou[1], wes.surf_surBou[2]) annotation (Line(
            points={{40,-48},{40,-58},{62,-58},{62,30},{28.2,30},{28.2,42.5}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(norWes.surf_conBou[1], wes.surf_surBou[1]) annotation (Line(
            points={{56,120},{56,30},{28.2,30},{28.2,41.5}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(portsNorWes[1], norWes.ports[1]) annotation (Line(
            points={{-68,136},{-12,136},{-12,126},{31.8,126}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(portsNorWes[2], norWes.ports[2]);
        connect(oriNorWes.port_a, norWes.ports[3]) annotation (Line(
            points={{92,143},{90,143},{90,164},{16,164},{16,126},{35,126}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(oriNorWes.port_b, cor.ports[12]) annotation (Line(
            points={{102,143},{114,143},{114,46},{151.133,46}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(oriSouWes.port_a, souWes.ports[3]) annotation (Line(
            points={{86,-81},{26,-81},{26,-64},{-2,-64},{-2,-42},{19,-42}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(oriSouWes.port_b, cor.ports[13]) annotation (Line(
            points={{96,-81},{124,-81},{124,46},{151.667,46}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(oriSouEas.port_a, souEas.ports[3]) annotation (Line(
            points={{282,-65},{298,-65},{298,-32},{313,-32}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(oriSouEas.port_b, cor.ports[14]) annotation (Line(
            points={{272,-65},{248,-65},{248,20},{132,20},{132,46},{152.2,46}},
            color={0,127,255},
            smooth=Smooth.None));

        connect(oriNorEas.port_a, norEas.ports[3]) annotation (Line(
            points={{276,131},{294,131},{294,130},{309,130}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(oriNorEas.port_b, cor.ports[15]) annotation (Line(
            points={{266,131},{234,131},{234,128},{196,128},{196,92},{132,92},{
                132,46},{152.733,46}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(leaNorWesW.weaBus, weaBus) annotation (Line(
            points={{-58,392},{-80,392},{-80,200},{210,200}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None));
        connect(leaNorWes.weaBus, weaBus) annotation (Line(
            points={{-58,424},{-80,424},{-80,200},{210,200}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None));
        connect(leaNorWesW.port_b, norWes.ports[4]) annotation (Line(
            points={{-22,392},{-12,392},{-12,126},{36.6,126}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(leaNorWes.port_b, norWes.ports[5]) annotation (Line(
            points={{-22,424},{-16,424},{-16,126},{38.2,126}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(leaSouWesW.weaBus, weaBus) annotation (Line(
            points={{-58,460},{-80,460},{-80,200},{210,200}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None));
        connect(leaSouWesW.port_b, souWes.ports[4]) annotation (Line(
            points={{-22,460},{-12,460},{-12,-42},{20.6,-42}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(leaSouWesS.port_b, souWes.ports[5]) annotation (Line(
            points={{38,460},{46,460},{46,430},{-12,430},{-12,-42},{22.2,-42}},
            color={0,127,255},
            smooth=Smooth.None));

        connect(leaSouWesS.weaBus, weaBus) annotation (Line(
            points={{2,460},{-10,460},{-10,200},{210,200}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None));
        connect(leaNorEasN.weaBus, weaBus) annotation (Line(
            points={{2,424},{-10,424},{-10,200},{210,200}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None));
        connect(leaNorEasE.weaBus, weaBus) annotation (Line(
            points={{2,392},{-10,392},{-10,200},{210,200}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None));
        connect(leaNorEasN.port_b, norEas.ports[4]) annotation (Line(
            points={{38,424},{270,424},{270,142},{286,142},{286,130},{310.6,130}},
            color={0,127,255},
            smooth=Smooth.None));

        connect(leaNorEasE.port_b, norEas.ports[5]) annotation (Line(
            points={{38,392},{54,392},{54,424},{270,424},{270,142},{286,142},{
                286,130},{312.2,130}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(leaSouEasS.weaBus, weaBus) annotation (Line(
            points={{2,356},{-10,356},{-10,200},{210,200}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None));
        connect(leaSouEasE.weaBus, weaBus) annotation (Line(
            points={{2,316},{-10,316},{-10,200},{210,200}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None));
        connect(leaSouEasS.port_b, souEas.ports[4]) annotation (Line(
            points={{38,356},{272,356},{272,-32},{314.6,-32}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(leaSouEasE.port_b, souEas.ports[5]) annotation (Line(
            points={{38,316},{58,316},{58,356},{272,356},{272,-32},{316.2,-32}},
            color={0,127,255},
            smooth=Smooth.None));

        annotation (Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{400,500}}), graphics), Icon(coordinateSystem(
                preserveAspectRatio=true, extent={{-100,-100},{400,500}}), graphics={
              Rectangle(
                extent={{-80,-80},{380,180}},
                lineColor={95,95,95},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-60,160},{360,-60}},
                pattern=LinePattern.None,
                lineColor={117,148,176},
                fillColor={170,213,255},
                fillPattern=FillPattern.Sphere),
              Rectangle(
                extent={{0,-80},{294,-60}},
                lineColor={95,95,95},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{0,-74},{294,-66}},
                lineColor={95,95,95},
                fillColor={170,213,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{8,8},{294,100}},
                lineColor={95,95,95},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{20,88},{280,22}},
                pattern=LinePattern.None,
                lineColor={117,148,176},
                fillColor={170,213,255},
                fillPattern=FillPattern.Sphere),
              Rectangle(
                extent={{-80,120},{-60,-20}},
                lineColor={95,95,95},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-74,120},{-66,-20}},
                lineColor={95,95,95},
                fillColor={170,213,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{360,122},{380,-18}},
                lineColor={95,95,95},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{366,122},{374,-18}},
                lineColor={95,95,95},
                fillColor={170,213,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{2,170},{296,178}},
                lineColor={95,95,95},
                fillColor={170,213,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{2,160},{296,180}},
                lineColor={95,95,95},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{2,166},{296,174}},
                lineColor={95,95,95},
                fillColor={170,213,255},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-84,234},{-62,200}},
                lineColor={0,0,255},
                textString="dP"),
              Rectangle(
                extent={{8,160},{18,94}},
                lineColor={95,95,95},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-5,35},{5,-35}},
                lineColor={95,95,95},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid,
                origin={-25,93},
                rotation=90),
              Rectangle(
                extent={{8,10},{18,-60}},
                lineColor={95,95,95},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-5,35},{5,-35}},
                lineColor={95,95,95},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid,
                origin={-25,13},
                rotation=90),
              Rectangle(
                extent={{-5,35},{5,-35}},
                lineColor={95,95,95},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid,
                origin={325,95},
                rotation=90),
              Rectangle(
                extent={{282,160},{292,94}},
                lineColor={95,95,95},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{284,8},{294,-60}},
                lineColor={95,95,95},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-5,35},{5,-35}},
                lineColor={95,95,95},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid,
                origin={325,15},
                rotation=90)}));
      end Floor;

      model RoomLeakage "Room leakage model"
        extends Buildings.BaseClasses.BaseIcon;
        replaceable package Medium = Modelica.Media.Interfaces.PartialMedium
        "Medium in the component"   annotation (choicesAllMatching=true);
        parameter Modelica.SIunits.Volume VRoo "Room volume";
        Buildings.Fluid.FixedResistances.FixedResistanceDpM res(
          redeclare package Medium = Medium,
          dp_nominal=50,
          m_flow_nominal=VRoo*1.2/3600) "Resistance model" annotation (Placement(
              transformation(extent={{20,-10},{40,10}}, rotation=0)));
        Modelica.Fluid.Interfaces.FluidPort_b port_b(redeclare package Medium
          =   Medium) annotation (Placement(transformation(extent={{90,-10},{110,10}},
                rotation=0)));
        Buildings.Fluid.Sources.Outside_CpLowRise amb(
          redeclare package Medium = Medium,
          nPorts=1,
          s=s,
          azi=azi)
          annotation (Placement(transformation(extent={{-60,-10},{-40,10}}, rotation=
                  0)));
        Buildings.BoundaryConditions.WeatherData.Bus weaBus
        "Bus with weather data"
          annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
        Buildings.Fluid.Sensors.MassFlowRate senMasFlo1(redeclare package
          Medium =   Medium, allowFlowReversal=true)
        "Sensor for mass flow rate"                             annotation (Placement(
              transformation(
              extent={{10,10},{-10,-10}},
              rotation=180,
              origin={-10,0})));
        Modelica.Blocks.Math.Gain ACHInf(k=1/VRoo/1.2*3600, y(unit="1/h"))
        "Air change per hour due to infiltration"
          annotation (Placement(transformation(extent={{12,30},{32,50}})));
        parameter Real s
        "Side ratio, s=length of this wall/length of adjacent wall";
        parameter Modelica.SIunits.Angle azi
        "Surface azimuth (South:0, West:pi/2)";
      equation
        connect(res.port_b, port_b) annotation (Line(points={{40,0},{55,0},{55,
                1.16573e-015},{70,1.16573e-015},{70,0},{100,0}}, color={0,127,255}));
        connect(amb.weaBus, weaBus) annotation (Line(
            points={{-60,0.2},{-80,0.2},{-80,0},{-100,0}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None));
        connect(amb.ports[1], senMasFlo1.port_a) annotation (Line(
            points={{-40,0},{-20,0},{-20,1.22465e-015}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(senMasFlo1.port_b, res.port_a) annotation (Line(
            points={{0,-1.22465e-015},{10,-1.22465e-015},{10,0},{20,0}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(senMasFlo1.m_flow, ACHInf.u) annotation (Line(
            points={{-10,11},{-10,40},{10,40}},
            color={0,0,127},
            smooth=Smooth.None));
        annotation (
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics),
          Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                  100}}), graphics={
              Ellipse(
                extent={{-80,40},{0,-40}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Sphere,
                fillColor={0,127,255}),
              Rectangle(
                extent={{20,12},{80,-12}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Rectangle(
                extent={{20,6},{80,-6}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={0,127,255}),
              Line(points={{-100,0},{-80,0}}, color={0,0,255}),
              Line(points={{0,0},{20,0}}, color={0,0,255}),
              Line(points={{80,0},{90,0}}, color={0,0,255})}),
          Documentation(info="<html>
<p>
Room leakage.
</p></html>",       revisions="<html>
<ul>
<li>
July 20, 2007 by Michael Wetter:<br>
First implementation.
</li>
</ul>
</html>"));
      end RoomLeakage;
    end ThermalZones;
  end VAVReheat;

  block DeMultiplex9 "DeMultiplexer block for six output connectors"
    extends Modelica.Blocks.Interfaces.BlockIcon;
    parameter Integer n1=1 "dimension of output signal connector 1";
    parameter Integer n2=1 "dimension of output signal connector 2";
    parameter Integer n3=1 "dimension of output signal connector 3";
    parameter Integer n4=1 "dimension of output signal connector 4";
    parameter Integer n5=1 "dimension of output signal connector 5";
    parameter Integer n6=1 "dimension of output signal connector 6";
    parameter Integer n7=1 "dimension of output signal connector 7";
    parameter Integer n8=1 "dimension of output signal connector 8";
    parameter Integer n9=1 "dimension of output signal connector 9";

    Modelica.Blocks.Interfaces.RealInput u[n1 + n2 + n3 + n4 + n5 + n6 + n7 + n8 + n9]
    "Connector of Real input signals"   annotation (Placement(transformation(
            extent={{-140,-20},{-100,20}}, rotation=0)));
    Modelica.Blocks.Interfaces.RealOutput y1[n1]
    "Connector of Real output signals 1"   annotation (Placement(transformation(
            extent={{100,80},{120,100}}, rotation=0)));
    Modelica.Blocks.Interfaces.RealOutput y2[n2]
    "Connector of Real output signals 2"   annotation (Placement(transformation(
            extent={{100,60},{120,80}}, rotation=0)));
    Modelica.Blocks.Interfaces.RealOutput y3[n3]
    "Connector of Real output signals 3"   annotation (Placement(transformation(
            extent={{100,36},{120,56}},rotation=0)));
    Modelica.Blocks.Interfaces.RealOutput y4[n4]
    "Connector of Real output signals 4"   annotation (Placement(transformation(
            extent={{100,12},{120,32}},  rotation=0)));
    Modelica.Blocks.Interfaces.RealOutput y5[n5]
    "Connector of Real output signals 5"   annotation (Placement(transformation(
            extent={{100,-13},{120,7}},   rotation=0)));
    Modelica.Blocks.Interfaces.RealOutput y6[n6]
    "Connector of Real output signals 6"   annotation (Placement(transformation(
            extent={{100,-38},{120,-18}},  rotation=0)));
    Modelica.Blocks.Interfaces.RealOutput y7[n7]
    "Connector of Real output signals 6"   annotation (Placement(transformation(
            extent={{100,-61},{120,-41}},  rotation=0)));
    Modelica.Blocks.Interfaces.RealOutput y8[n8]
    "Connector of Real output signals 6"   annotation (Placement(transformation(
            extent={{100,-84},{120,-64}},  rotation=0)));
    Modelica.Blocks.Interfaces.RealOutput y9[n9]
    "Connector of Real output signals 6"   annotation (Placement(transformation(
            extent={{100,-106},{120,-86}}, rotation=0)));

  equation
    [u] = [y1; y2; y3; y4; y5; y6; y7; y8; y9];
    annotation (
      Documentation(info="<HTML>
<p>
The input connector is <b>splitted</b> up into six output connectors.
Note, that the dimensions of the output connector signals have to be
explicitly defined via parameters n1, n2, n3, n4, n5 and n6.
</HTML>
"),   Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}},
          grid={1,1}), graphics={
          Ellipse(
            extent={{-14,16},{16,-14}},
            fillColor={0,0,127},
            fillPattern=FillPattern.Solid,
            lineColor={0,0,127}),
          Line(points={{-100,0},{-6,0}}, color={0,0,127}),
          Line(points={{99,90},{60,90},{5,10}}, color={0,0,127}),
          Line(points={{100,53},{60,53},{8,6}}, color={0,0,127}),
          Line(points={{100,18},{59,18},{7,2}}, color={0,0,127}),
          Line(points={{100,-19},{60,-19},{13,-2}}, color={0,0,127}),
          Line(points={{99,-54},{60,-54},{9,-1}}, color={0,0,127}),
          Line(points={{100,-91},{60,-91},{3,-7}}, color={0,0,127})}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}},
          grid={1,1}), graphics={
          Line(points={{99,90},{60,90},{5,10}}, color={0,0,255}),
          Line(points={{100,-28},{60,-28},{10,-2}},color={0,0,255}),
          Line(points={{-100,0},{-6,0}}, color={0,0,255}),
          Ellipse(
            extent={{-14,15},{16,-15}},
            fillColor={0,0,255},
            fillPattern=FillPattern.Solid,
            lineColor={0,0,255}),
          Line(points={{100,70},{60,70},{6,10}},color={0,0,255}),
          Line(points={{100,-4},{61,-4},{11,2}},  color={0,0,255}),
          Line(points={{100,46},{59,46},{9,10}},color={0,0,255}),
          Line(points={{100,22},{60,22},{8,7}},     color={0,0,255}),
          Line(points={{100,-52},{60,-52},{9,-4}}, color={0,0,255}),
          Line(points={{100,-75},{60,-75},{6,-6}}, color={0,0,255}),
          Line(points={{100,-96},{60,-96},{5,-6}}, color={0,0,255})}));
  end DeMultiplex9;

  block Multiplex9 "Multiplexer block for nine input connectors"
    extends Modelica.Blocks.Interfaces.BlockIcon;
    parameter Integer n1=1 "dimension of input signal connector 1";
    parameter Integer n2=1 "dimension of input signal connector 2";
    parameter Integer n3=1 "dimension of input signal connector 3";
    parameter Integer n4=1 "dimension of input signal connector 4";
    parameter Integer n5=1 "dimension of input signal connector 5";
    parameter Integer n6=1 "dimension of input signal connector 6";
    parameter Integer n7=1 "dimension of input signal connector 7";
    parameter Integer n8=1 "dimension of input signal connector 8";
    parameter Integer n9=1 "dimension of input signal connector 9";
    Modelica.Blocks.Interfaces.RealInput u1[n1]
    "Connector of Real input signals 1"   annotation (Placement(transformation(
            extent={{-124,88},{-100,112}},rotation=0)));
    Modelica.Blocks.Interfaces.RealInput u2[n2]
    "Connector of Real input signals 2"   annotation (Placement(transformation(
            extent={{-124,63},{-100,87}}, rotation=0)));
    Modelica.Blocks.Interfaces.RealInput u3[n3]
    "Connector of Real input signals 3"   annotation (Placement(transformation(
            extent={{-124,38},{-100,62}},rotation=0)));
    Modelica.Blocks.Interfaces.RealInput u4[n4]
    "Connector of Real input signals 4"   annotation (Placement(transformation(
            extent={{-124,13},{-100,37}},  rotation=0)));
    Modelica.Blocks.Interfaces.RealInput u5[n5]
    "Connector of Real input signals 5"   annotation (Placement(transformation(
            extent={{-124,-12},{-100,12}},  rotation=0)));
    Modelica.Blocks.Interfaces.RealInput u6[n6]
    "Connector of Real input signals 6"   annotation (Placement(transformation(
            extent={{-124,-37},{-100,-13}}, rotation=0)));

    Modelica.Blocks.Interfaces.RealOutput y[n1 + n2 + n3 + n4 + n5 + n6 + n7 + n8 + n9]
    "Connector of Real output signals"   annotation (Placement(transformation(
            extent={{100,-10},{120,10}}, rotation=0)));

    Modelica.Blocks.Interfaces.RealInput u7[n7]
    "Connector of Real input signals 7"   annotation (Placement(transformation(
            extent={{-124,-62},{-100,-38}}, rotation=0)));
    Modelica.Blocks.Interfaces.RealInput u8[n8]
    "Connector of Real input signals 8"   annotation (Placement(transformation(
            extent={{-124,-88},{-100,-64}}, rotation=0)));
    Modelica.Blocks.Interfaces.RealInput u9[n9]
    "Connector of Real input signals 9"   annotation (Placement(transformation(
            extent={{-124,-112},{-100,-88}},rotation=0)));
  equation
    [y] = [u1; u2; u3; u4; u5; u6; u7; u8; u9];
    annotation (
      Documentation(info="<HTML>
<p>
The output connector is the <b>concatenation</b> of the six input connectors.
Note, that the dimensions of the input connector signals have to be
explicitly defined via parameters n1, n2, n3, n4, n5 and n6.
</p>
</HTML>
"),   Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}},
          grid={1,1}), graphics={
          Line(points={{8,0},{102,0}}, color={0,0,127}),
          Ellipse(
            extent={{-15,15},{15,-15}},
            fillColor={0,0,127},
            fillPattern=FillPattern.Solid,
            lineColor={0,0,127}),
          Line(points={{-99,85},{-61,85},{-3,11}}, color={0,0,127}),
          Line(points={{-100,51},{-61,51},{-7,6}}, color={0,0,127}),
          Line(points={{-101,17},{-60,17},{-9,2}}, color={0,0,127}),
          Line(points={{-100,-18},{-60,-18},{-11,-4}}, color={0,0,127}),
          Line(points={{-99,-50},{-60,-50},{-9,-6}}, color={0,0,127}),
          Line(points={{-100,-85},{-60,-85},{-3,-10}}, color={0,0,255})}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}},
          grid={1,1}), graphics={
          Line(points={{-99,85},{-61,85},{-3,11}}, color={0,0,255}),
          Line(points={{-100,-85},{-60,-85},{-3,-10}}, color={0,0,255}),
          Line(points={{8,0},{102,0}}, color={0,0,255}),
          Ellipse(
            extent={{-15,15},{15,-15}},
            fillColor={0,0,255},
            fillPattern=FillPattern.Solid,
            lineColor={0,0,255}),
          Line(points={{-100,51},{-61,51},{-7,6}}, color={0,0,255}),
          Line(points={{-99,-50},{-60,-50},{-9,-6}}, color={0,0,255}),
          Line(points={{-101,17},{-60,17},{-9,2}}, color={0,0,255}),
          Line(points={{-100,-18},{-60,-18},{-11,-4}}, color={0,0,255})}));
  end Multiplex9;
  annotation (uses(Modelica(version="3.2"), Buildings(version="1.0")));
end LearnGB;
model LearnGB_VAVReheat_ClosedLoop
 extends LearnGB.VAVReheat.ClosedLoop;
  annotation(experiment(
  StopTime=172800,
  Tolerance=1e-006,
  Algorithm="radau"));
end LearnGB_VAVReheat_ClosedLoop;
