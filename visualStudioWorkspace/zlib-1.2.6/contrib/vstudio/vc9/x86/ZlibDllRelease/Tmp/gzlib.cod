; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	E:\SRI\straylight_repo\visualStudioWorkspace\zlib-1.2.6\gzlib.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@		; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@		; `string'
PUBLIC	??_C@_02LMMGGCAJ@?3?5?$AA@			; `string'
EXTRN	_sprintf:PROC
EXTRN	_open:PROC
EXTRN	__lseeki64:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
;	COMDAT ??_C@_02LMMGGCAJ@?3?5?$AA@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5?$AA@ DB ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
CONST	SEGMENT
??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@ DB 'out of memory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@
CONST	SEGMENT
??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@ DB '<fd:%d>', 00H ; `string'
PUBLIC	_gz_error
; Function compile flags: /Ogtp
; File e:\sri\straylight_repo\visualstudioworkspace\zlib-1.2.6\gzlib.c
;	COMDAT _gz_error
_TEXT	SEGMENT
_msg$ = 8						; size = 4
_gz_error PROC						; COMDAT
; _state$ = ecx
; _err$ = eax

; 512  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx
  00007	8b f0		 mov	 esi, eax

; 513  :     /* free previously allocated message and clear */
; 514  :     if (state->msg != NULL) {

  00009	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  0000c	85 c0		 test	 eax, eax
  0000e	74 16		 je	 SHORT $LN16@gz_error

; 515  :         if (state->err != Z_MEM_ERROR)

  00010	83 7f 5c fc	 cmp	 DWORD PTR [edi+92], -4	; fffffffcH
  00014	74 09		 je	 SHORT $LN5@gz_error

; 516  :             free(state->msg);

  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 _free
  0001c	83 c4 04	 add	 esp, 4
$LN5@gz_error:

; 517  :         state->msg = NULL;

  0001f	c7 47 60 00 00
	00 00		 mov	 DWORD PTR [edi+96], 0
$LN16@gz_error:

; 518  :     }
; 519  : 
; 520  :     /* if fatal, set state->x.have to 0 so that the gzgetc() macro fails */
; 521  :     if (err != Z_OK && err != Z_BUF_ERROR)

  00026	85 f6		 test	 esi, esi
  00028	74 0b		 je	 SHORT $LN4@gz_error
  0002a	83 fe fb	 cmp	 esi, -5			; fffffffbH
  0002d	74 06		 je	 SHORT $LN4@gz_error

; 522  :         state->x.have = 0;

  0002f	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN4@gz_error:

; 523  : 
; 524  :     /* set error code, and if no message, then done */
; 525  :     state->err = err;
; 526  :     if (msg == NULL)

  00035	8b 45 08	 mov	 eax, DWORD PTR _msg$[ebp]
  00038	89 77 5c	 mov	 DWORD PTR [edi+92], esi
  0003b	85 c0		 test	 eax, eax
  0003d	0f 84 b5 00 00
	00		 je	 $LN7@gz_error

; 527  :         return;
; 528  : 
; 529  :     /* for an out of memory error, save as static string */
; 530  :     if (err == Z_MEM_ERROR) {

  00043	83 fe fc	 cmp	 esi, -4			; fffffffcH
  00046	75 07		 jne	 SHORT $LN2@gz_error

; 531  :         state->msg = (char *)msg;

  00048	89 47 60	 mov	 DWORD PTR [edi+96], eax
  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi

; 544  :     return;
; 545  : }

  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
$LN2@gz_error:
  0004f	53		 push	 ebx

; 532  :         return;
; 533  :     }
; 534  : 
; 535  :     /* construct error message with path */
; 536  :     if ((state->msg = malloc(strlen(state->path) + strlen(msg) + 3)) == NULL) {

  00050	8b 5f 18	 mov	 ebx, DWORD PTR [edi+24]
  00053	8b c3		 mov	 eax, ebx
  00055	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL11@gz_error:
  00058	8a 08		 mov	 cl, BYTE PTR [eax]
  0005a	40		 inc	 eax
  0005b	84 c9		 test	 cl, cl
  0005d	75 f9		 jne	 SHORT $LL11@gz_error
  0005f	2b c2		 sub	 eax, edx
  00061	8b d0		 mov	 edx, eax
  00063	8b 45 08	 mov	 eax, DWORD PTR _msg$[ebp]
  00066	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  00069	8d a4 24 00 00
	00 00		 npad	 7
$LL12@gz_error:
  00070	8a 08		 mov	 cl, BYTE PTR [eax]
  00072	40		 inc	 eax
  00073	84 c9		 test	 cl, cl
  00075	75 f9		 jne	 SHORT $LL12@gz_error
  00077	2b c6		 sub	 eax, esi
  00079	8d 44 10 03	 lea	 eax, DWORD PTR [eax+edx+3]
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 _malloc
  00083	83 c4 04	 add	 esp, 4
  00086	89 47 60	 mov	 DWORD PTR [edi+96], eax
  00089	85 c0		 test	 eax, eax
  0008b	75 13		 jne	 SHORT $LN1@gz_error

; 537  :         state->err = Z_MEM_ERROR;

  0008d	5b		 pop	 ebx
  0008e	c7 47 5c fc ff
	ff ff		 mov	 DWORD PTR [edi+92], -4	; fffffffcH

; 538  :         state->msg = (char *)"out of memory";

  00095	c7 47 60 00 00
	00 00		 mov	 DWORD PTR [edi+96], OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  0009c	5f		 pop	 edi
  0009d	5e		 pop	 esi

; 544  :     return;
; 545  : }

  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
$LN1@gz_error:

; 539  :         return;
; 540  :     }
; 541  :     strcpy(state->msg, state->path);

  000a0	8b cb		 mov	 ecx, ebx
  000a2	8b d0		 mov	 edx, eax
$LL9@gz_error:
  000a4	8a 01		 mov	 al, BYTE PTR [ecx]
  000a6	88 02		 mov	 BYTE PTR [edx], al
  000a8	41		 inc	 ecx
  000a9	42		 inc	 edx
  000aa	84 c0		 test	 al, al
  000ac	75 f6		 jne	 SHORT $LL9@gz_error

; 542  :     strcat(state->msg, ": ");

  000ae	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  000b1	48		 dec	 eax
$LL13@gz_error:
  000b2	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  000b5	40		 inc	 eax
  000b6	84 c9		 test	 cl, cl
  000b8	75 f8		 jne	 SHORT $LL13@gz_error
  000ba	66 8b 0d 00 00
	00 00		 mov	 cx, WORD PTR ??_C@_02LMMGGCAJ@?3?5?$AA@
  000c1	66 89 08	 mov	 WORD PTR [eax], cx
  000c4	8a 15 02 00 00
	00		 mov	 dl, BYTE PTR ??_C@_02LMMGGCAJ@?3?5?$AA@+2
  000ca	88 50 02	 mov	 BYTE PTR [eax+2], dl

; 543  :     strcat(state->msg, msg);

  000cd	8b 45 08	 mov	 eax, DWORD PTR _msg$[ebp]
  000d0	8b c8		 mov	 ecx, eax
$LL14@gz_error:
  000d2	8a 10		 mov	 dl, BYTE PTR [eax]
  000d4	40		 inc	 eax
  000d5	84 d2		 test	 dl, dl
  000d7	75 f9		 jne	 SHORT $LL14@gz_error
  000d9	8b 7f 60	 mov	 edi, DWORD PTR [edi+96]
  000dc	2b c1		 sub	 eax, ecx
  000de	8b f1		 mov	 esi, ecx
  000e0	4f		 dec	 edi
$LL15@gz_error:
  000e1	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  000e4	47		 inc	 edi
  000e5	84 c9		 test	 cl, cl
  000e7	75 f8		 jne	 SHORT $LL15@gz_error
  000e9	8b c8		 mov	 ecx, eax
  000eb	c1 e9 02	 shr	 ecx, 2
  000ee	f3 a5		 rep movsd
  000f0	8b c8		 mov	 ecx, eax
  000f2	83 e1 03	 and	 ecx, 3
  000f5	f3 a4		 rep movsb
  000f7	5b		 pop	 ebx
$LN7@gz_error:
  000f8	5f		 pop	 edi
  000f9	5e		 pop	 esi

; 544  :     return;
; 545  : }

  000fa	5d		 pop	 ebp
  000fb	c3		 ret	 0
_gz_error ENDP
_TEXT	ENDS
PUBLIC	_gzclearerr@4
; Function compile flags: /Ogtp
;	COMDAT _gzclearerr@4
_TEXT	SEGMENT
_file$ = 8						; size = 4
_gzclearerr@4 PROC					; COMDAT

; 484  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 485  :     gz_statep state;
; 486  : 
; 487  :     /* get internal structure and check integrity */
; 488  :     if (file == NULL)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  00006	33 d2		 xor	 edx, edx
  00008	3b ca		 cmp	 ecx, edx
  0000a	74 29		 je	 SHORT $LN4@gzclearerr

; 489  :         return;
; 490  :     state = (gz_statep)file;
; 491  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  0000c	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0000f	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  00014	74 0e		 je	 SHORT $LN7@gzclearerr
  00016	3d b1 79 00 00	 cmp	 eax, 31153		; 000079b1H
  0001b	75 18		 jne	 SHORT $LN4@gzclearerr

; 492  :         return;
; 493  : 
; 494  :     /* clear error and end-of-file */
; 495  :     if (state->mode == GZ_READ) {

  0001d	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  00022	75 06		 jne	 SHORT $LN1@gzclearerr
$LN7@gzclearerr:

; 496  :         state->eof = 0;

  00024	89 51 40	 mov	 DWORD PTR [ecx+64], edx

; 497  :         state->past = 0;

  00027	89 51 44	 mov	 DWORD PTR [ecx+68], edx
$LN1@gzclearerr:

; 498  :     }
; 499  :     gz_error(state, Z_OK, NULL);

  0002a	52		 push	 edx
  0002b	33 c0		 xor	 eax, eax
  0002d	e8 00 00 00 00	 call	 _gz_error
  00032	83 c4 04	 add	 esp, 4
$LN4@gzclearerr:

; 500  : }

  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
_gzclearerr@4 ENDP
_TEXT	ENDS
PUBLIC	_gzerror@8
; Function compile flags: /Ogtp
;	COMDAT _gzerror@8
_TEXT	SEGMENT
_file$ = 8						; size = 4
_errnum$ = 12						; size = 4
_gzerror@8 PROC						; COMDAT

; 465  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 466  :     gz_statep state;
; 467  : 
; 468  :     /* get internal structure and check integrity */
; 469  :     if (file == NULL)

  00003	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 06		 jne	 SHORT $LN3@gzerror
$LN8@gzerror:

; 470  :         return NULL;

  0000a	33 c0		 xor	 eax, eax

; 479  : }

  0000c	5d		 pop	 ebp
  0000d	c2 08 00	 ret	 8
$LN3@gzerror:

; 471  :     state = (gz_statep)file;
; 472  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00010	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00013	81 f9 4f 1c 00
	00		 cmp	 ecx, 7247		; 00001c4fH
  00019	74 08		 je	 SHORT $LN2@gzerror
  0001b	81 f9 b1 79 00
	00		 cmp	 ecx, 31153		; 000079b1H

; 473  :         return NULL;

  00021	75 e7		 jne	 SHORT $LN8@gzerror
$LN2@gzerror:

; 474  : 
; 475  :     /* return error information */
; 476  :     if (errnum != NULL)

  00023	8b 4d 0c	 mov	 ecx, DWORD PTR _errnum$[ebp]
  00026	85 c9		 test	 ecx, ecx
  00028	74 05		 je	 SHORT $LN1@gzerror

; 477  :         *errnum = state->err;

  0002a	8b 50 5c	 mov	 edx, DWORD PTR [eax+92]
  0002d	89 11		 mov	 DWORD PTR [ecx], edx
$LN1@gzerror:

; 478  :     return state->msg == NULL ? "" : state->msg;

  0002f	8b 40 60	 mov	 eax, DWORD PTR [eax+96]
  00032	85 c0		 test	 eax, eax
  00034	75 05		 jne	 SHORT $LN4@gzerror
  00036	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN4@gzerror:

; 479  : }

  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
_gzerror@8 ENDP
_TEXT	ENDS
PUBLIC	_gzeof@4
; Function compile flags: /Ogtp
;	COMDAT _gzeof@4
_TEXT	SEGMENT
_file$ = 8						; size = 4
_gzeof@4 PROC						; COMDAT

; 447  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 448  :     gz_statep state;
; 449  : 
; 450  :     /* get internal structure and check integrity */
; 451  :     if (file == NULL)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  00006	85 c9		 test	 ecx, ecx

; 452  :         return 0;

  00008	74 1f		 je	 SHORT $LN5@gzeof

; 453  :     state = (gz_statep)file;
; 454  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  0000a	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0000d	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  00012	74 0e		 je	 SHORT $LN8@gzeof
  00014	3d b1 79 00 00	 cmp	 eax, 31153		; 000079b1H

; 455  :         return 0;

  00019	75 0e		 jne	 SHORT $LN5@gzeof

; 456  : 
; 457  :     /* return end-of-file state */
; 458  :     return state->mode == GZ_READ ? state->past : 0;

  0001b	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  00020	75 07		 jne	 SHORT $LN5@gzeof
$LN8@gzeof:
  00022	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]

; 459  : }

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
$LN5@gzeof:

; 456  : 
; 457  :     /* return end-of-file state */
; 458  :     return state->mode == GZ_READ ? state->past : 0;

  00029	33 c0		 xor	 eax, eax

; 459  : }

  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
_gzeof@4 ENDP
_TEXT	ENDS
PUBLIC	_gzoffset64@4
; Function compile flags: /Ogtp
;	COMDAT _gzoffset64@4
_TEXT	SEGMENT
_gzoffset64@4 PROC					; COMDAT
; _file$ = esi

; 415  :     z_off64_t offset;
; 416  :     gz_statep state;
; 417  : 
; 418  :     /* get internal structure and check integrity */
; 419  :     if (file == NULL)

  00000	85 f6		 test	 esi, esi
  00002	75 06		 jne	 SHORT $LN4@gzoffset64
$LN7@gzoffset64:

; 420  :         return -1;

  00004	83 c8 ff	 or	 eax, -1
  00007	0b d0		 or	 edx, eax

; 431  :     return offset;
; 432  : }

  00009	c3		 ret	 0
$LN4@gzoffset64:

; 421  :     state = (gz_statep)file;
; 422  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  0000a	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000d	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  00012	74 07		 je	 SHORT $LN3@gzoffset64
  00014	3d b1 79 00 00	 cmp	 eax, 31153		; 000079b1H

; 423  :         return -1;

  00019	75 e9		 jne	 SHORT $LN7@gzoffset64
$LN3@gzoffset64:

; 424  : 
; 425  :     /* compute and return effective offset in file */
; 426  :     offset = LSEEK(state->fd, 0, SEEK_CUR);

  0001b	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0001e	6a 01		 push	 1
  00020	6a 00		 push	 0
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 __lseeki64
  00028	99		 cdq

; 427  :     if (offset == -1)

  00029	8b c8		 mov	 ecx, eax
  0002b	23 ca		 and	 ecx, edx
  0002d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00030	83 f9 ff	 cmp	 ecx, -1

; 428  :         return -1;

  00033	74 cf		 je	 SHORT $LN7@gzoffset64

; 429  :     if (state->mode == GZ_READ)             /* reading */

  00035	81 7e 10 4f 1c
	00 00		 cmp	 DWORD PTR [esi+16], 7247 ; 00001c4fH
  0003c	75 06		 jne	 SHORT $LN5@gzoffset64

; 430  :         offset -= state->strm.avail_in;     /* don't count buffered input */

  0003e	2b 46 68	 sub	 eax, DWORD PTR [esi+104]
  00041	83 da 00	 sbb	 edx, 0
$LN5@gzoffset64:

; 431  :     return offset;
; 432  : }

  00044	c3		 ret	 0
_gzoffset64@4 ENDP
_TEXT	ENDS
PUBLIC	_gztell64@4
; Function compile flags: /Ogtp
;	COMDAT _gztell64@4
_TEXT	SEGMENT
_gztell64@4 PROC					; COMDAT
; _file$ = ecx

; 388  :     gz_statep state;
; 389  : 
; 390  :     /* get internal structure and check integrity */
; 391  :     if (file == NULL)

  00000	85 c9		 test	 ecx, ecx
  00002	75 06		 jne	 SHORT $LN2@gztell64
$LN7@gztell64:

; 392  :         return -1;

  00004	83 c8 ff	 or	 eax, -1
  00007	0b d0		 or	 edx, eax

; 399  : }

  00009	c3		 ret	 0
$LN2@gztell64:

; 393  :     state = (gz_statep)file;
; 394  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  0000a	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0000d	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  00012	74 07		 je	 SHORT $LN1@gztell64
  00014	3d b1 79 00 00	 cmp	 eax, 31153		; 000079b1H

; 395  :         return -1;

  00019	75 e9		 jne	 SHORT $LN7@gztell64
$LN1@gztell64:

; 396  : 
; 397  :     /* return position */
; 398  :     return state->x.pos + (state->seek ? state->skip : 0);

  0001b	83 79 58 00	 cmp	 DWORD PTR [ecx+88], 0
  0001f	56		 push	 esi
  00020	74 12		 je	 SHORT $LN5@gztell64
  00022	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  00025	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00028	8b 71 54	 mov	 esi, DWORD PTR [ecx+84]
  0002b	03 c2		 add	 eax, edx
  0002d	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00030	13 d6		 adc	 edx, esi
  00032	5e		 pop	 esi

; 399  : }

  00033	c3		 ret	 0
$LN5@gztell64:

; 396  : 
; 397  :     /* return position */
; 398  :     return state->x.pos + (state->seek ? state->skip : 0);

  00034	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00037	33 d2		 xor	 edx, edx
  00039	33 f6		 xor	 esi, esi
  0003b	03 c2		 add	 eax, edx
  0003d	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00040	13 d6		 adc	 edx, esi
  00042	5e		 pop	 esi

; 399  : }

  00043	c3		 ret	 0
_gztell64@4 ENDP
_TEXT	ENDS
PUBLIC	_gzbuffer@8
; Function compile flags: /Ogtp
;	COMDAT _gzbuffer@8
_TEXT	SEGMENT
_file$ = 8						; size = 4
_size$ = 12						; size = 4
_gzbuffer@8 PROC					; COMDAT

; 251  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 252  :     gz_statep state;
; 253  : 
; 254  :     /* get internal structure and check integrity */
; 255  :     if (file == NULL)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	75 07		 jne	 SHORT $LN4@gzbuffer
$LN7@gzbuffer:

; 256  :         return -1;

  0000a	83 c8 ff	 or	 eax, -1

; 270  : }

  0000d	5d		 pop	 ebp
  0000e	c2 08 00	 ret	 8
$LN4@gzbuffer:

; 257  :     state = (gz_statep)file;
; 258  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00011	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00014	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  00019	74 07		 je	 SHORT $LN3@gzbuffer
  0001b	3d b1 79 00 00	 cmp	 eax, 31153		; 000079b1H

; 259  :         return -1;

  00020	75 e8		 jne	 SHORT $LN7@gzbuffer
$LN3@gzbuffer:

; 260  : 
; 261  :     /* make sure we haven't already allocated memory */
; 262  :     if (state->size != 0)

  00022	83 79 1c 00	 cmp	 DWORD PTR [ecx+28], 0

; 263  :         return -1;

  00026	75 e2		 jne	 SHORT $LN7@gzbuffer

; 264  : 
; 265  :     /* check and set requested size */
; 266  :     if (size < 2)

  00028	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  0002b	83 f8 02	 cmp	 eax, 2
  0002e	73 05		 jae	 SHORT $LN1@gzbuffer

; 267  :         size = 2;               /* need two bytes to check magic header */

  00030	b8 02 00 00 00	 mov	 eax, 2
$LN1@gzbuffer:

; 268  :     state->want = size;

  00035	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 269  :     return 0;

  00038	33 c0		 xor	 eax, eax

; 270  : }

  0003a	5d		 pop	 ebp
  0003b	c2 08 00	 ret	 8
_gzbuffer@8 ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _gz_reset
_TEXT	SEGMENT
_gz_reset PROC						; COMDAT
; _state$ = esi

; 77   : {

  00000	57		 push	 edi

; 78   :     state->x.have = 0;              /* no output data available */

  00001	33 ff		 xor	 edi, edi

; 79   :     if (state->mode == GZ_READ) {   /* for reading ... */

  00003	81 7e 10 4f 1c
	00 00		 cmp	 DWORD PTR [esi+16], 7247 ; 00001c4fH
  0000a	89 3e		 mov	 DWORD PTR [esi], edi
  0000c	75 09		 jne	 SHORT $LN1@gz_reset

; 80   :         state->eof = 0;             /* not at end of file */

  0000e	89 7e 40	 mov	 DWORD PTR [esi+64], edi

; 81   :         state->past = 0;            /* have not read past end yet */

  00011	89 7e 44	 mov	 DWORD PTR [esi+68], edi

; 82   :         state->how = LOOK;          /* look for gzip header */

  00014	89 7e 30	 mov	 DWORD PTR [esi+48], edi
$LN1@gz_reset:

; 83   :     }
; 84   :     state->seek = 0;                /* no seek request pending */
; 85   :     gz_error(state, Z_OK, NULL);    /* clear error */

  00017	57		 push	 edi
  00018	33 c0		 xor	 eax, eax
  0001a	8b ce		 mov	 ecx, esi
  0001c	89 7e 58	 mov	 DWORD PTR [esi+88], edi
  0001f	e8 00 00 00 00	 call	 _gz_error
  00024	83 c4 04	 add	 esp, 4

; 86   :     state->x.pos = 0;               /* no uncompressed data yet */

  00027	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0002a	89 7e 0c	 mov	 DWORD PTR [esi+12], edi

; 87   :     state->strm.avail_in = 0;       /* no input data yet */

  0002d	89 7e 68	 mov	 DWORD PTR [esi+104], edi
  00030	5f		 pop	 edi

; 88   : }

  00031	c3		 ret	 0
_gz_reset ENDP
PUBLIC	_gzoffset@4
; Function compile flags: /Ogtp
;	COMDAT _gzoffset@4
_TEXT	SEGMENT
_file$ = 8						; size = 4
_gzoffset@4 PROC					; COMDAT

; 437  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	51		 push	 ecx
  00007	56		 push	 esi

; 438  :     z_off64_t ret;
; 439  : 
; 440  :     ret = gzoffset64(file);

  00008	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  0000b	e8 00 00 00 00	 call	 _gzoffset64@4
  00010	8b c8		 mov	 ecx, eax
  00012	8b f2		 mov	 esi, edx

; 441  :     return ret == (z_off_t)ret ? (z_off_t)ret : -1;

  00014	99		 cdq
  00015	3b c8		 cmp	 ecx, eax
  00017	75 0d		 jne	 SHORT $LN3@gzoffset
  00019	3b f2		 cmp	 esi, edx
  0001b	75 09		 jne	 SHORT $LN3@gzoffset
  0001d	8b c1		 mov	 eax, ecx

; 442  : }

  0001f	5e		 pop	 esi
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN3@gzoffset:

; 441  :     return ret == (z_off_t)ret ? (z_off_t)ret : -1;

  00026	83 c8 ff	 or	 eax, -1

; 442  : }

  00029	5e		 pop	 esi
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
_gzoffset@4 ENDP
_TEXT	ENDS
PUBLIC	_gztell@4
; Function compile flags: /Ogtp
;	COMDAT _gztell@4
_TEXT	SEGMENT
_file$ = 8						; size = 4
_gztell@4 PROC						; COMDAT

; 404  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 405  :     z_off64_t ret;
; 406  : 
; 407  :     ret = gztell64(file);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  00006	56		 push	 esi
  00007	e8 00 00 00 00	 call	 _gztell64@4
  0000c	8b c8		 mov	 ecx, eax
  0000e	8b f2		 mov	 esi, edx

; 408  :     return ret == (z_off_t)ret ? (z_off_t)ret : -1;

  00010	99		 cdq
  00011	3b c8		 cmp	 ecx, eax
  00013	75 0b		 jne	 SHORT $LN3@gztell
  00015	3b f2		 cmp	 esi, edx
  00017	75 07		 jne	 SHORT $LN3@gztell
  00019	8b c1		 mov	 eax, ecx
  0001b	5e		 pop	 esi

; 409  : }

  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
$LN3@gztell:

; 408  :     return ret == (z_off_t)ret ? (z_off_t)ret : -1;

  00020	83 c8 ff	 or	 eax, -1
  00023	5e		 pop	 esi

; 409  : }

  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
_gztell@4 ENDP
_TEXT	ENDS
PUBLIC	_gzrewind@4
; Function compile flags: /Ogtp
;	COMDAT _gzrewind@4
_TEXT	SEGMENT
_file$ = 8						; size = 4
_gzrewind@4 PROC					; COMDAT

; 275  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	51		 push	 ecx
  00007	56		 push	 esi

; 276  :     gz_statep state;
; 277  : 
; 278  :     /* get internal structure */
; 279  :     if (file == NULL)

  00008	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  0000b	85 f6		 test	 esi, esi

; 280  :         return -1;

  0000d	74 3e		 je	 SHORT $LN2@gzrewind

; 281  :     state = (gz_statep)file;
; 282  : 
; 283  :     /* check that we're reading and that there's no error */
; 284  :     if (state->mode != GZ_READ ||
; 285  :             (state->err != Z_OK && state->err != Z_BUF_ERROR))

  0000f	81 7e 10 4f 1c
	00 00		 cmp	 DWORD PTR [esi+16], 7247 ; 00001c4fH
  00016	75 35		 jne	 SHORT $LN2@gzrewind
  00018	8b 46 5c	 mov	 eax, DWORD PTR [esi+92]
  0001b	85 c0		 test	 eax, eax
  0001d	74 05		 je	 SHORT $LN3@gzrewind
  0001f	83 f8 fb	 cmp	 eax, -5			; fffffffbH
  00022	75 29		 jne	 SHORT $LN2@gzrewind
$LN3@gzrewind:

; 287  : 
; 288  :     /* back up and start over */
; 289  :     if (LSEEK(state->fd, state->start, SEEK_SET) == -1)

  00024	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  00027	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  0002a	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  0002d	6a 00		 push	 0
  0002f	50		 push	 eax
  00030	51		 push	 ecx
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 __lseeki64
  00037	83 c4 10	 add	 esp, 16			; 00000010H
  0003a	83 f8 ff	 cmp	 eax, -1

; 290  :         return -1;

  0003d	74 0e		 je	 SHORT $LN2@gzrewind

; 291  :     gz_reset(state);

  0003f	e8 00 00 00 00	 call	 _gz_reset

; 292  :     return 0;

  00044	33 c0		 xor	 eax, eax

; 293  : }

  00046	5e		 pop	 esi
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
$LN2@gzrewind:

; 286  :         return -1;

  0004d	83 c8 ff	 or	 eax, -1

; 293  : }

  00050	5e		 pop	 esi
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
_gzrewind@4 ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _gz_open
_TEXT	SEGMENT
_path$ = 8						; size = 4
_fd$ = 12						; size = 4
_gz_open PROC						; COMDAT
; _mode$ = eax

; 95   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	57		 push	 edi

; 96   :     gz_statep state;
; 97   : 
; 98   :     /* check input */
; 99   :     if (path == NULL)

  00005	33 ff		 xor	 edi, edi
  00007	8b d8		 mov	 ebx, eax
  00009	39 7d 08	 cmp	 DWORD PTR _path$[ebp], edi
  0000c	75 06		 jne	 SHORT $LN27@gz_open

; 100  :         return NULL;

  0000e	5f		 pop	 edi
  0000f	33 c0		 xor	 eax, eax
  00011	5b		 pop	 ebx

; 213  : }

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
$LN27@gz_open:
  00014	56		 push	 esi

; 101  : 
; 102  :     /* allocate gzFile structure to return */
; 103  :     state = malloc(sizeof(gz_state));

  00015	68 a0 00 00 00	 push	 160			; 000000a0H
  0001a	e8 00 00 00 00	 call	 _malloc
  0001f	8b f0		 mov	 esi, eax
  00021	83 c4 04	 add	 esp, 4

; 104  :     if (state == NULL)

  00024	3b f7		 cmp	 esi, edi

; 105  :         return NULL;

  00026	0f 84 59 01 00
	00		 je	 $LN42@gz_open

; 106  :     state->size = 0;            /* no buffers allocated yet */
; 107  :     state->want = GZBUFSIZE;    /* requested buffer size */
; 108  :     state->msg = NULL;          /* no error message yet */
; 109  : 
; 110  :     /* interpret mode */
; 111  :     state->mode = GZ_NONE;
; 112  :     state->level = Z_DEFAULT_COMPRESSION;
; 113  :     state->strategy = Z_DEFAULT_STRATEGY;
; 114  :     state->direct = 0;
; 115  :     while (*mode) {

  0002c	8a 03		 mov	 al, BYTE PTR [ebx]
  0002e	89 7e 1c	 mov	 DWORD PTR [esi+28], edi
  00031	c7 46 20 00 20
	00 00		 mov	 DWORD PTR [esi+32], 8192 ; 00002000H
  00038	89 7e 60	 mov	 DWORD PTR [esi+96], edi
  0003b	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  0003e	c7 46 48 ff ff
	ff ff		 mov	 DWORD PTR [esi+72], -1
  00045	89 7e 4c	 mov	 DWORD PTR [esi+76], edi
  00048	89 7e 2c	 mov	 DWORD PTR [esi+44], edi
  0004b	84 c0		 test	 al, al
  0004d	74 78		 je	 SHORT $LN24@gz_open
  0004f	ba 03 00 00 00	 mov	 edx, 3
  00054	8d 4a 01	 lea	 ecx, DWORD PTR [edx+1]
$LL25@gz_open:

; 116  :         if (*mode >= '0' && *mode <= '9')

  00057	3c 30		 cmp	 al, 48			; 00000030H
  00059	7c 0f		 jl	 SHORT $LN23@gz_open
  0005b	3c 39		 cmp	 al, 57			; 00000039H
  0005d	7f 0b		 jg	 SHORT $LN23@gz_open

; 117  :             state->level = *mode - '0';

  0005f	0f be c0	 movsx	 eax, al
  00062	83 e8 30	 sub	 eax, 48			; 00000030H
  00065	89 46 48	 mov	 DWORD PTR [esi+72], eax

; 118  :         else

  00068	eb 55		 jmp	 SHORT $LN40@gz_open
$LN23@gz_open:

; 119  :             switch (*mode) {

  0006a	0f be c0	 movsx	 eax, al
  0006d	83 c0 d5	 add	 eax, -43		; ffffffd5H
  00070	83 f8 4c	 cmp	 eax, 76			; 0000004cH
  00073	77 4a		 ja	 SHORT $LN40@gz_open
  00075	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN38@gz_open[eax]
  0007c	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN44@gz_open[eax*4]
$LN19@gz_open:

; 120  :             case 'r':
; 121  :                 state->mode = GZ_READ;

  00083	c7 46 10 4f 1c
	00 00		 mov	 DWORD PTR [esi+16], 7247 ; 00001c4fH

; 122  :                 break;

  0008a	eb 33		 jmp	 SHORT $LN40@gz_open
$LN18@gz_open:

; 123  : #ifndef NO_GZCOMPRESS
; 124  :             case 'w':
; 125  :                 state->mode = GZ_WRITE;

  0008c	c7 46 10 b1 79
	00 00		 mov	 DWORD PTR [esi+16], 31153 ; 000079b1H

; 126  :                 break;

  00093	eb 2a		 jmp	 SHORT $LN40@gz_open
$LN17@gz_open:

; 127  :             case 'a':
; 128  :                 state->mode = GZ_APPEND;

  00095	c7 46 10 01 00
	00 00		 mov	 DWORD PTR [esi+16], 1

; 129  :                 break;

  0009c	eb 21		 jmp	 SHORT $LN40@gz_open
$LN14@gz_open:

; 130  : #endif
; 131  :             case '+':       /* can't read and write at the same time */
; 132  :                 free(state);
; 133  :                 return NULL;
; 134  :             case 'b':       /* ignore -- will request binary anyway */
; 135  :                 break;
; 136  :             case 'f':
; 137  :                 state->strategy = Z_FILTERED;

  0009e	c7 46 4c 01 00
	00 00		 mov	 DWORD PTR [esi+76], 1

; 138  :                 break;

  000a5	eb 18		 jmp	 SHORT $LN40@gz_open
$LN13@gz_open:

; 139  :             case 'h':
; 140  :                 state->strategy = Z_HUFFMAN_ONLY;

  000a7	c7 46 4c 02 00
	00 00		 mov	 DWORD PTR [esi+76], 2

; 141  :                 break;

  000ae	eb 0f		 jmp	 SHORT $LN40@gz_open
$LN12@gz_open:

; 142  :             case 'R':
; 143  :                 state->strategy = Z_RLE;

  000b0	89 56 4c	 mov	 DWORD PTR [esi+76], edx

; 144  :                 break;

  000b3	eb 0a		 jmp	 SHORT $LN40@gz_open
$LN11@gz_open:

; 145  :             case 'F':
; 146  :                 state->strategy = Z_FIXED;

  000b5	89 4e 4c	 mov	 DWORD PTR [esi+76], ecx
$LN10@gz_open:

; 147  :             case 'T':
; 148  :                 state->direct = 1;

  000b8	c7 46 2c 01 00
	00 00		 mov	 DWORD PTR [esi+44], 1
$LN40@gz_open:

; 106  :     state->size = 0;            /* no buffers allocated yet */
; 107  :     state->want = GZBUFSIZE;    /* requested buffer size */
; 108  :     state->msg = NULL;          /* no error message yet */
; 109  : 
; 110  :     /* interpret mode */
; 111  :     state->mode = GZ_NONE;
; 112  :     state->level = Z_DEFAULT_COMPRESSION;
; 113  :     state->strategy = Z_DEFAULT_STRATEGY;
; 114  :     state->direct = 0;
; 115  :     while (*mode) {

  000bf	8a 43 01	 mov	 al, BYTE PTR [ebx+1]

; 149  :             default:        /* could consider as an error, but just ignore */
; 150  :                 ;
; 151  :             }
; 152  :         mode++;

  000c2	43		 inc	 ebx
  000c3	84 c0		 test	 al, al
  000c5	75 90		 jne	 SHORT $LL25@gz_open
$LN24@gz_open:

; 153  :     }
; 154  : 
; 155  :     /* must provide an "r", "w", or "a" */
; 156  :     if (state->mode == GZ_NONE) {

  000c7	8b 5e 10	 mov	 ebx, DWORD PTR [esi+16]
  000ca	3b df		 cmp	 ebx, edi

; 157  :         free(state);
; 158  :         return NULL;

  000cc	74 36		 je	 SHORT $LN43@gz_open

; 159  :     }
; 160  : 
; 161  :     /* can't force transparent read */
; 162  :     if (state->mode == GZ_READ) {

  000ce	81 fb 4f 1c 00
	00		 cmp	 ebx, 7247		; 00001c4fH
  000d4	75 0c		 jne	 SHORT $LN7@gz_open

; 163  :         if (state->direct) {

  000d6	39 7e 2c	 cmp	 DWORD PTR [esi+44], edi

; 164  :             free(state);
; 165  :             return NULL;

  000d9	75 29		 jne	 SHORT $LN43@gz_open

; 166  :         }
; 167  :         state->direct = 1;      /* for empty file */

  000db	c7 46 2c 01 00
	00 00		 mov	 DWORD PTR [esi+44], 1
$LN7@gz_open:

; 168  :     }
; 169  : 
; 170  :     /* save the path name for error messages */
; 171  :     state->path = malloc(strlen(path) + 1);

  000e2	8b 45 08	 mov	 eax, DWORD PTR _path$[ebp]
  000e5	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL39@gz_open:
  000e8	8a 08		 mov	 cl, BYTE PTR [eax]
  000ea	40		 inc	 eax
  000eb	84 c9		 test	 cl, cl
  000ed	75 f9		 jne	 SHORT $LL39@gz_open
  000ef	2b c2		 sub	 eax, edx
  000f1	40		 inc	 eax
  000f2	50		 push	 eax
  000f3	e8 00 00 00 00	 call	 _malloc
  000f8	8b f8		 mov	 edi, eax
  000fa	83 c4 04	 add	 esp, 4
  000fd	89 7e 18	 mov	 DWORD PTR [esi+24], edi

; 172  :     if (state->path == NULL) {

  00100	85 ff		 test	 edi, edi
  00102	75 10		 jne	 SHORT $LN5@gz_open
$LN43@gz_open:

; 173  :         free(state);

  00104	56		 push	 esi
  00105	e8 00 00 00 00	 call	 _free
  0010a	83 c4 04	 add	 esp, 4
  0010d	5e		 pop	 esi
  0010e	5f		 pop	 edi

; 174  :         return NULL;

  0010f	33 c0		 xor	 eax, eax
  00111	5b		 pop	 ebx

; 213  : }

  00112	5d		 pop	 ebp
  00113	c3		 ret	 0
$LN5@gz_open:

; 175  :     }
; 176  :     strcpy(state->path, path);

  00114	8b 4d 08	 mov	 ecx, DWORD PTR _path$[ebp]
  00117	8b d7		 mov	 edx, edi
  00119	8d a4 24 00 00
	00 00		 npad	 7
$LL30@gz_open:
  00120	8a 01		 mov	 al, BYTE PTR [ecx]
  00122	88 02		 mov	 BYTE PTR [edx], al
  00124	41		 inc	 ecx
  00125	42		 inc	 edx
  00126	84 c0		 test	 al, al
  00128	75 f6		 jne	 SHORT $LL30@gz_open

; 177  : 
; 178  :     /* open the file with the appropriate mode (or just use fd) */
; 179  :     state->fd = fd != -1 ? fd :
; 180  :         open(path,
; 181  : #ifdef O_LARGEFILE
; 182  :             O_LARGEFILE |
; 183  : #endif
; 184  : #ifdef O_BINARY
; 185  :             O_BINARY |
; 186  : #endif
; 187  :             (state->mode == GZ_READ ?
; 188  :                 O_RDONLY :
; 189  :                 (O_WRONLY | O_CREAT | (
; 190  :                     state->mode == GZ_WRITE ?
; 191  :                         O_TRUNC :
; 192  :                         O_APPEND))),
; 193  :             0666);

  0012a	8b 45 0c	 mov	 eax, DWORD PTR _fd$[ebp]
  0012d	83 f8 ff	 cmp	 eax, -1
  00130	75 3c		 jne	 SHORT $LN34@gz_open
  00132	81 fb 4f 1c 00
	00		 cmp	 ebx, 7247		; 00001c4fH
  00138	75 04		 jne	 SHORT $LN31@gz_open
  0013a	33 c0		 xor	 eax, eax
  0013c	eb 19		 jmp	 SHORT $LN32@gz_open
$LN31@gz_open:
  0013e	8d 83 4f 86 ff
	ff		 lea	 eax, DWORD PTR [ebx-31153]
  00144	f7 d8		 neg	 eax
  00146	1b c0		 sbb	 eax, eax
  00148	25 08 fe ff ff	 and	 eax, -504		; fffffe08H
  0014d	05 00 02 00 00	 add	 eax, 512		; 00000200H
  00152	0d 01 01 00 00	 or	 eax, 257		; 00000101H
$LN32@gz_open:
  00157	8b 4d 08	 mov	 ecx, DWORD PTR _path$[ebp]
  0015a	68 b6 01 00 00	 push	 438			; 000001b6H
  0015f	0d 00 80 00 00	 or	 eax, 32768		; 00008000H
  00164	50		 push	 eax
  00165	51		 push	 ecx
  00166	e8 00 00 00 00	 call	 _open
  0016b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN34@gz_open:
  0016e	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 194  :     if (state->fd == -1) {

  00171	83 f8 ff	 cmp	 eax, -1
  00174	75 16		 jne	 SHORT $LN4@gz_open

; 195  :         free(state->path);

  00176	57		 push	 edi
  00177	e8 00 00 00 00	 call	 _free

; 196  :         free(state);

  0017c	56		 push	 esi
  0017d	e8 00 00 00 00	 call	 _free
  00182	83 c4 08	 add	 esp, 8
$LN42@gz_open:

; 197  :         return NULL;

  00185	5e		 pop	 esi
  00186	5f		 pop	 edi
  00187	33 c0		 xor	 eax, eax
  00189	5b		 pop	 ebx

; 213  : }

  0018a	5d		 pop	 ebp
  0018b	c3		 ret	 0
$LN4@gz_open:

; 198  :     }
; 199  :     if (state->mode == GZ_APPEND)

  0018c	83 fb 01	 cmp	 ebx, 1
  0018f	75 07		 jne	 SHORT $LN3@gz_open

; 200  :         state->mode = GZ_WRITE;         /* simplify later checks */

  00191	c7 46 10 b1 79
	00 00		 mov	 DWORD PTR [esi+16], 31153 ; 000079b1H
$LN3@gz_open:

; 201  : 
; 202  :     /* save the current position for rewinding (only if reading) */
; 203  :     if (state->mode == GZ_READ) {

  00198	81 7e 10 4f 1c
	00 00		 cmp	 DWORD PTR [esi+16], 7247 ; 00001c4fH
  0019f	75 25		 jne	 SHORT $LN1@gz_open

; 204  :         state->start = LSEEK(state->fd, 0, SEEK_CUR);

  001a1	6a 01		 push	 1
  001a3	33 ff		 xor	 edi, edi
  001a5	57		 push	 edi
  001a6	50		 push	 eax
  001a7	e8 00 00 00 00	 call	 __lseeki64
  001ac	99		 cdq
  001ad	89 56 3c	 mov	 DWORD PTR [esi+60], edx

; 205  :         if (state->start == -1) state->start = 0;

  001b0	8b d0		 mov	 edx, eax
  001b2	23 56 3c	 and	 edx, DWORD PTR [esi+60]
  001b5	83 c4 0c	 add	 esp, 12			; 0000000cH
  001b8	89 46 38	 mov	 DWORD PTR [esi+56], eax
  001bb	83 fa ff	 cmp	 edx, -1
  001be	75 06		 jne	 SHORT $LN1@gz_open
  001c0	89 7e 38	 mov	 DWORD PTR [esi+56], edi
  001c3	89 7e 3c	 mov	 DWORD PTR [esi+60], edi
$LN1@gz_open:

; 206  :     }
; 207  : 
; 208  :     /* initialize stream */
; 209  :     gz_reset(state);

  001c6	e8 00 00 00 00	 call	 _gz_reset

; 210  : 
; 211  :     /* return stream */
; 212  :     return (gzFile)state;

  001cb	8b c6		 mov	 eax, esi
  001cd	5e		 pop	 esi
  001ce	5f		 pop	 edi
  001cf	5b		 pop	 ebx

; 213  : }

  001d0	5d		 pop	 ebp
  001d1	c3		 ret	 0
  001d2	8b ff		 npad	 2
$LN44@gz_open:
  001d4	00 00 00 00	 DD	 $LN43@gz_open
  001d8	00 00 00 00	 DD	 $LN11@gz_open
  001dc	00 00 00 00	 DD	 $LN12@gz_open
  001e0	00 00 00 00	 DD	 $LN10@gz_open
  001e4	00 00 00 00	 DD	 $LN17@gz_open
  001e8	00 00 00 00	 DD	 $LN14@gz_open
  001ec	00 00 00 00	 DD	 $LN13@gz_open
  001f0	00 00 00 00	 DD	 $LN19@gz_open
  001f4	00 00 00 00	 DD	 $LN18@gz_open
  001f8	00 00 00 00	 DD	 $LN40@gz_open
$LN38@gz_open:
  001fc	00		 DB	 0
  001fd	09		 DB	 9
  001fe	09		 DB	 9
  001ff	09		 DB	 9
  00200	09		 DB	 9
  00201	09		 DB	 9
  00202	09		 DB	 9
  00203	09		 DB	 9
  00204	09		 DB	 9
  00205	09		 DB	 9
  00206	09		 DB	 9
  00207	09		 DB	 9
  00208	09		 DB	 9
  00209	09		 DB	 9
  0020a	09		 DB	 9
  0020b	09		 DB	 9
  0020c	09		 DB	 9
  0020d	09		 DB	 9
  0020e	09		 DB	 9
  0020f	09		 DB	 9
  00210	09		 DB	 9
  00211	09		 DB	 9
  00212	09		 DB	 9
  00213	09		 DB	 9
  00214	09		 DB	 9
  00215	09		 DB	 9
  00216	09		 DB	 9
  00217	01		 DB	 1
  00218	09		 DB	 9
  00219	09		 DB	 9
  0021a	09		 DB	 9
  0021b	09		 DB	 9
  0021c	09		 DB	 9
  0021d	09		 DB	 9
  0021e	09		 DB	 9
  0021f	09		 DB	 9
  00220	09		 DB	 9
  00221	09		 DB	 9
  00222	09		 DB	 9
  00223	02		 DB	 2
  00224	09		 DB	 9
  00225	03		 DB	 3
  00226	09		 DB	 9
  00227	09		 DB	 9
  00228	09		 DB	 9
  00229	09		 DB	 9
  0022a	09		 DB	 9
  0022b	09		 DB	 9
  0022c	09		 DB	 9
  0022d	09		 DB	 9
  0022e	09		 DB	 9
  0022f	09		 DB	 9
  00230	09		 DB	 9
  00231	09		 DB	 9
  00232	04		 DB	 4
  00233	09		 DB	 9
  00234	09		 DB	 9
  00235	09		 DB	 9
  00236	09		 DB	 9
  00237	05		 DB	 5
  00238	09		 DB	 9
  00239	06		 DB	 6
  0023a	09		 DB	 9
  0023b	09		 DB	 9
  0023c	09		 DB	 9
  0023d	09		 DB	 9
  0023e	09		 DB	 9
  0023f	09		 DB	 9
  00240	09		 DB	 9
  00241	09		 DB	 9
  00242	09		 DB	 9
  00243	07		 DB	 7
  00244	09		 DB	 9
  00245	09		 DB	 9
  00246	09		 DB	 9
  00247	09		 DB	 9
  00248	08		 DB	 8
_gz_open ENDP
PUBLIC	_gzseek64@16
; Function compile flags: /Ogtp
;	COMDAT _gzseek64@16
_TEXT	SEGMENT
tv405 = 8						; size = 8
_offset$ = 8						; size = 8
_gzseek64@16 PROC					; COMDAT
; _file$ = esi
; _whence$ = ecx

; 300  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	57		 push	 edi

; 301  :     unsigned n;
; 302  :     z_off64_t ret;
; 303  :     gz_statep state;
; 304  : 
; 305  :     /* get internal structure and check integrity */
; 306  :     if (file == NULL)

  00005	85 f6		 test	 esi, esi

; 307  :         return -1;

  00007	74 28		 je	 SHORT $LN28@gzseek64

; 308  :     state = (gz_statep)file;
; 309  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00009	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0000c	81 fa 4f 1c 00
	00		 cmp	 edx, 7247		; 00001c4fH
  00012	74 08		 je	 SHORT $LN14@gzseek64
  00014	81 fa b1 79 00
	00		 cmp	 edx, 31153		; 000079b1H

; 310  :         return -1;

  0001a	75 15		 jne	 SHORT $LN28@gzseek64
$LN14@gzseek64:

; 311  : 
; 312  :     /* check that there's no error */
; 313  :     if (state->err != Z_OK && state->err != Z_BUF_ERROR)

  0001c	8b 46 5c	 mov	 eax, DWORD PTR [esi+92]
  0001f	85 c0		 test	 eax, eax
  00021	74 05		 je	 SHORT $LN13@gzseek64
  00023	83 f8 fb	 cmp	 eax, -5			; fffffffbH

; 314  :         return -1;

  00026	75 09		 jne	 SHORT $LN28@gzseek64
$LN13@gzseek64:

; 315  : 
; 316  :     /* can only seek from start or relative to current position */
; 317  :     if (whence != SEEK_SET && whence != SEEK_CUR)

  00028	85 c9		 test	 ecx, ecx
  0002a	74 10		 je	 SHORT $LN20@gzseek64
  0002c	83 f9 01	 cmp	 ecx, 1
  0002f	74 19		 je	 SHORT $LN11@gzseek64
$LN28@gzseek64:

; 318  :         return -1;

  00031	83 c8 ff	 or	 eax, -1
  00034	0b d0		 or	 edx, eax

; 370  : }

  00036	5f		 pop	 edi
  00037	5b		 pop	 ebx
  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
$LN20@gzseek64:

; 319  : 
; 320  :     /* normalize offset to a SEEK_CUR specification */
; 321  :     if (whence == SEEK_SET)
; 322  :         offset -= state->x.pos;

  0003c	8b 5d 08	 mov	 ebx, DWORD PTR _offset$[ebp]
  0003f	2b 5e 08	 sub	 ebx, DWORD PTR [esi+8]
  00042	8b 7d 0c	 mov	 edi, DWORD PTR _offset$[ebp+4]
  00045	1b 7e 0c	 sbb	 edi, DWORD PTR [esi+12]
  00048	eb 12		 jmp	 SHORT $LN9@gzseek64
$LN11@gzseek64:

; 323  :     else if (state->seek)

  0004a	83 7e 58 00	 cmp	 DWORD PTR [esi+88], 0

; 324  :         offset += state->skip;

  0004e	8b 5d 08	 mov	 ebx, DWORD PTR _offset$[ebp]
  00051	8b 7d 0c	 mov	 edi, DWORD PTR _offset$[ebp+4]
  00054	74 06		 je	 SHORT $LN9@gzseek64
  00056	03 5e 50	 add	 ebx, DWORD PTR [esi+80]
  00059	13 7e 54	 adc	 edi, DWORD PTR [esi+84]
$LN9@gzseek64:

; 325  :     state->seek = 0;

  0005c	c7 46 58 00 00
	00 00		 mov	 DWORD PTR [esi+88], 0

; 326  : 
; 327  :     /* if within raw area while reading, just go there */
; 328  :     if (state->mode == GZ_READ && state->how == COPY &&
; 329  :             state->x.pos + offset >= 0) {

  00063	81 fa 4f 1c 00
	00		 cmp	 edx, 7247		; 00001c4fH
  00069	75 6b		 jne	 SHORT $LN8@gzseek64
  0006b	83 7e 30 01	 cmp	 DWORD PTR [esi+48], 1
  0006f	75 65		 jne	 SHORT $LN8@gzseek64
  00071	8b c3		 mov	 eax, ebx
  00073	03 46 08	 add	 eax, DWORD PTR [esi+8]
  00076	8b cf		 mov	 ecx, edi
  00078	13 4e 0c	 adc	 ecx, DWORD PTR [esi+12]
  0007b	89 4d 0c	 mov	 DWORD PTR tv405[ebp+4], ecx
  0007e	78 56		 js	 SHORT $LN8@gzseek64
  00080	7f 04		 jg	 SHORT $LN21@gzseek64
  00082	85 c0		 test	 eax, eax
  00084	72 50		 jb	 SHORT $LN8@gzseek64
$LN21@gzseek64:

; 330  :         ret = LSEEK(state->fd, offset - state->x.have, SEEK_CUR);
; 331  :         if (ret == -1)

  00086	33 c0		 xor	 eax, eax
  00088	8b cb		 mov	 ecx, ebx
  0008a	2b 0e		 sub	 ecx, DWORD PTR [esi]
  0008c	6a 01		 push	 1
  0008e	8b d7		 mov	 edx, edi
  00090	1b d0		 sbb	 edx, eax
  00092	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00095	52		 push	 edx
  00096	51		 push	 ecx
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 __lseeki64
  0009d	83 c4 10	 add	 esp, 16			; 00000010H
  000a0	83 f8 ff	 cmp	 eax, -1

; 332  :             return -1;

  000a3	74 8c		 je	 SHORT $LN28@gzseek64

; 333  :         state->x.have = 0;

  000a5	33 c0		 xor	 eax, eax

; 334  :         state->eof = 0;
; 335  :         state->past = 0;
; 336  :         state->seek = 0;
; 337  :         gz_error(state, Z_OK, NULL);

  000a7	50		 push	 eax
  000a8	8b ce		 mov	 ecx, esi
  000aa	89 06		 mov	 DWORD PTR [esi], eax
  000ac	89 46 40	 mov	 DWORD PTR [esi+64], eax
  000af	89 46 44	 mov	 DWORD PTR [esi+68], eax
  000b2	89 46 58	 mov	 DWORD PTR [esi+88], eax
  000b5	e8 00 00 00 00	 call	 _gz_error
  000ba	83 c4 04	 add	 esp, 4

; 338  :         state->strm.avail_in = 0;
; 339  :         state->x.pos += offset;

  000bd	01 5e 08	 add	 DWORD PTR [esi+8], ebx

; 340  :         return state->x.pos;

  000c0	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000c3	c7 46 68 00 00
	00 00		 mov	 DWORD PTR [esi+104], 0
  000ca	11 7e 0c	 adc	 DWORD PTR [esi+12], edi
  000cd	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]

; 370  : }

  000d0	5f		 pop	 edi
  000d1	5b		 pop	 ebx
  000d2	5d		 pop	 ebp
  000d3	c2 08 00	 ret	 8
$LN8@gzseek64:

; 341  :     }
; 342  : 
; 343  :     /* calculate skip amount, rewinding if needed for back seek when reading */
; 344  :     if (offset < 0) {

  000d6	85 ff		 test	 edi, edi
  000d8	7f 39		 jg	 SHORT $LN3@gzseek64
  000da	7c 04		 jl	 SHORT $LN22@gzseek64
  000dc	85 db		 test	 ebx, ebx
  000de	73 33		 jae	 SHORT $LN3@gzseek64
$LN22@gzseek64:

; 345  :         if (state->mode != GZ_READ)         /* writing -- can't go backwards */

  000e0	81 fa 4f 1c 00
	00		 cmp	 edx, 7247		; 00001c4fH

; 346  :             return -1;

  000e6	0f 85 45 ff ff
	ff		 jne	 $LN28@gzseek64

; 347  :         offset += state->x.pos;

  000ec	03 5e 08	 add	 ebx, DWORD PTR [esi+8]
  000ef	13 7e 0c	 adc	 edi, DWORD PTR [esi+12]

; 348  :         if (offset < 0)                     /* before start of file! */

  000f2	85 ff		 test	 edi, edi
  000f4	7f 0e		 jg	 SHORT $LN4@gzseek64
  000f6	0f 8c 35 ff ff
	ff		 jl	 $LN28@gzseek64
  000fc	85 db		 test	 ebx, ebx

; 349  :             return -1;

  000fe	0f 82 2d ff ff
	ff		 jb	 $LN28@gzseek64
$LN4@gzseek64:

; 350  :         if (gzrewind(file) == -1)           /* rewind, then skip to offset */

  00104	56		 push	 esi
  00105	e8 00 00 00 00	 call	 _gzrewind@4
  0010a	83 f8 ff	 cmp	 eax, -1

; 351  :             return -1;

  0010d	0f 84 1e ff ff
	ff		 je	 $LN28@gzseek64
$LN3@gzseek64:

; 352  :     }
; 353  : 
; 354  :     /* if reading, skip what's in output buffer (one less gzgetc() check) */
; 355  :     if (state->mode == GZ_READ) {

  00113	81 7e 10 4f 1c
	00 00		 cmp	 DWORD PTR [esi+16], 7247 ; 00001c4fH
  0011a	75 27		 jne	 SHORT $LN2@gzseek64

; 356  :         n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > offset ?
; 357  :             (unsigned)offset : state->x.have;

  0011c	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0011e	33 c0		 xor	 eax, eax
  00120	3b c7		 cmp	 eax, edi
  00122	7f 0a		 jg	 SHORT $LN18@gzseek64
  00124	7c 04		 jl	 SHORT $LN24@gzseek64
  00126	3b cb		 cmp	 ecx, ebx
  00128	77 04		 ja	 SHORT $LN18@gzseek64
$LN24@gzseek64:
  0012a	8b c1		 mov	 eax, ecx
  0012c	eb 02		 jmp	 SHORT $LN19@gzseek64
$LN18@gzseek64:
  0012e	8b c3		 mov	 eax, ebx
$LN19@gzseek64:

; 358  :         state->x.have -= n;
; 359  :         state->x.next += n;

  00130	01 46 04	 add	 DWORD PTR [esi+4], eax
  00133	2b c8		 sub	 ecx, eax
  00135	89 0e		 mov	 DWORD PTR [esi], ecx

; 360  :         state->x.pos += n;

  00137	33 c9		 xor	 ecx, ecx
  00139	01 46 08	 add	 DWORD PTR [esi+8], eax
  0013c	11 4e 0c	 adc	 DWORD PTR [esi+12], ecx

; 361  :         offset -= n;

  0013f	2b d8		 sub	 ebx, eax
  00141	1b f9		 sbb	 edi, ecx
$LN2@gzseek64:

; 362  :     }
; 363  : 
; 364  :     /* request skip (if not zero) */
; 365  :     if (offset) {

  00143	8b c3		 mov	 eax, ebx
  00145	0b c7		 or	 eax, edi
  00147	74 0d		 je	 SHORT $LN1@gzseek64

; 366  :         state->seek = 1;

  00149	c7 46 58 01 00
	00 00		 mov	 DWORD PTR [esi+88], 1

; 367  :         state->skip = offset;

  00150	89 5e 50	 mov	 DWORD PTR [esi+80], ebx
  00153	89 7e 54	 mov	 DWORD PTR [esi+84], edi
$LN1@gzseek64:

; 368  :     }
; 369  :     return state->x.pos + offset;

  00156	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00159	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0015c	03 c3		 add	 eax, ebx
  0015e	13 d7		 adc	 edx, edi

; 370  : }

  00160	5f		 pop	 edi
  00161	5b		 pop	 ebx
  00162	5d		 pop	 ebp
  00163	c2 08 00	 ret	 8
_gzseek64@16 ENDP
_TEXT	ENDS
PUBLIC	_gzdopen@8
; Function compile flags: /Ogtp
;	COMDAT _gzdopen@8
_TEXT	SEGMENT
_fd$ = 8						; size = 4
_mode$ = 12						; size = 4
_gzdopen@8 PROC						; COMDAT

; 235  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 236  :     char *path;         /* identifier for error messages */
; 237  :     gzFile gz;
; 238  : 
; 239  :     if (fd == -1 || (path = malloc(7 + 3 * sizeof(int))) == NULL)

  00005	8b 7d 08	 mov	 edi, DWORD PTR _fd$[ebp]
  00008	83 ff ff	 cmp	 edi, -1
  0000b	74 39		 je	 SHORT $LN1@gzdopen
  0000d	6a 13		 push	 19			; 00000013H
  0000f	e8 00 00 00 00	 call	 _malloc
  00014	8b f0		 mov	 esi, eax
  00016	83 c4 04	 add	 esp, 4
  00019	85 f6		 test	 esi, esi
  0001b	74 29		 je	 SHORT $LN1@gzdopen

; 241  :     sprintf(path, "<fd:%d>", fd);   /* for debugging */

  0001d	57		 push	 edi
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@
  00023	56		 push	 esi
  00024	e8 00 00 00 00	 call	 _sprintf

; 242  :     gz = gz_open(path, fd, mode);

  00029	8b 45 0c	 mov	 eax, DWORD PTR _mode$[ebp]
  0002c	57		 push	 edi
  0002d	56		 push	 esi
  0002e	e8 00 00 00 00	 call	 _gz_open

; 243  :     free(path);

  00033	56		 push	 esi
  00034	8b f8		 mov	 edi, eax
  00036	e8 00 00 00 00	 call	 _free
  0003b	83 c4 18	 add	 esp, 24			; 00000018H

; 244  :     return gz;

  0003e	8b c7		 mov	 eax, edi
  00040	5f		 pop	 edi
  00041	5e		 pop	 esi

; 245  : }

  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8
$LN1@gzdopen:
  00046	5f		 pop	 edi

; 240  :         return NULL;

  00047	33 c0		 xor	 eax, eax
  00049	5e		 pop	 esi

; 245  : }

  0004a	5d		 pop	 ebp
  0004b	c2 08 00	 ret	 8
_gzdopen@8 ENDP
_TEXT	ENDS
PUBLIC	_gzopen@8
; Function compile flags: /Ogtp
;	COMDAT _gzopen@8
_TEXT	SEGMENT
_path$ = 8						; size = 4
_mode$ = 12						; size = 4
_gzopen@8 PROC						; COMDAT

; 219  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 220  :     return gz_open(path, -1, mode);

  00003	8b 45 08	 mov	 eax, DWORD PTR _path$[ebp]
  00006	6a ff		 push	 -1
  00008	50		 push	 eax
  00009	8b 45 0c	 mov	 eax, DWORD PTR _mode$[ebp]
  0000c	e8 00 00 00 00	 call	 _gz_open
  00011	83 c4 08	 add	 esp, 8

; 221  : }

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
_gzopen@8 ENDP
PUBLIC	_gzseek@12
; Function compile flags: /Ogtp
;	COMDAT _gzseek@12
_TEXT	SEGMENT
_file$ = 8						; size = 4
_offset$ = 12						; size = 4
_whence$ = 16						; size = 4
_gzseek@12 PROC						; COMDAT

; 377  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	51		 push	 ecx

; 378  :     z_off64_t ret;
; 379  : 
; 380  :     ret = gzseek64(file, (z_off64_t)offset, whence);

  00007	8b 45 0c	 mov	 eax, DWORD PTR _offset$[ebp]
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR _whence$[ebp]
  0000d	56		 push	 esi
  0000e	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  00011	99		 cdq
  00012	52		 push	 edx
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 _gzseek64@16
  00019	8b c8		 mov	 ecx, eax
  0001b	8b f2		 mov	 esi, edx

; 381  :     return ret == (z_off_t)ret ? (z_off_t)ret : -1;

  0001d	99		 cdq
  0001e	3b c8		 cmp	 ecx, eax
  00020	75 0d		 jne	 SHORT $LN3@gzseek
  00022	3b f2		 cmp	 esi, edx
  00024	75 09		 jne	 SHORT $LN3@gzseek
  00026	8b c1		 mov	 eax, ecx

; 382  : }

  00028	5e		 pop	 esi
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 0c 00	 ret	 12			; 0000000cH
$LN3@gzseek:

; 381  :     return ret == (z_off_t)ret ? (z_off_t)ret : -1;

  0002f	83 c8 ff	 or	 eax, -1

; 382  : }

  00032	5e		 pop	 esi
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 0c 00	 ret	 12			; 0000000cH
_gzseek@12 ENDP
END
